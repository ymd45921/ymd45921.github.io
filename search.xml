<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>对于 npm 中 Dependencies 以及一些杂项的小结</title>
      <link href="/2022/simple-summary-of-dependencies-and-misc-in-npm/"/>
      <url>/2022/simple-summary-of-dependencies-and-misc-in-npm/</url>
      
        <content type="html"><![CDATA[<p>一些关于 <code>npm</code> 中依赖和版本号的小结。知识盲区实在是太多了！</p><h2 id="npm-中的依赖"><code>npm</code> 中的依赖</h2><p><code>npm</code> 中的依赖主要有 <code>dependencies</code>、<code>devDependencies</code> 和 <code>peerDependencies</code>。</p><h3 id="dependencies-vs.-devdependencies"><code>dependencies</code> vs. <code>devDependencies</code></h3><p>顾名思义，前者是在生产环境和开发环境中都使用的包，而后者是仅在开发环境中使用的包。</p><p>比如 <code>gulp</code>、<code>webpack</code> 就是典型的只在开发环境中使用的包，无需打包到产品中。</p><p>开发环境和生产环境，可以通过 <code>NODE_ENV=production|development</code> 来指定。</p><p>对于 <code>npm</code> 而言，安装两种不同的依赖需要指定的完整标志分别是 <code>--save</code> 和 <code>--save-dev</code>。</p><h3 id="peerdependencies"><code>peerDependencies</code></h3><p>对于一般的 <code>dependencies</code> 的场合：如果我们有包 A 引用包 B 作为依赖，而我们在我们的项目中安装了包 A 作为依赖，那么实际上只有包 A 被安装到了我们的项目的 <code>node_modules</code> 中，包 B 实际上被安装到了包 A 安装目录下的 <code>node_modules</code> 中。这带来的结果是，虽然包 A 和包 B 都安装过了，我们可以使用 <code>require</code> 引用包 A，但是却不可以直接在我们的项目中引用包 B。</p><p>但是如果在包 A 中，包 B 是作为 <code>peerDependencies</code> 引入的，那么安装包 A 时，包 B 会被同样安装到我们项目的 <code>node_modules</code> 目录下；此时就可以直接在我们的项目中引用包 B。</p><p>综上所述，<code>peerDepenedencies</code> 的含义可以理解为对包管理器的要求：如果你安装了某个包，那么我建议你也安装我的 <code>peerDependencies</code>。</p><p><code>npm2</code> 在安装包时会强制安装包的 <code>peerDependencies</code>，不需要再宿主环境中指定对于这些包的依赖；而 <code>npm3</code> 不再强制安装这些依赖，而是在安装结束后检查本次安装是否正确；如果发现安装不正确则打印 WARN。不正确包括未安装和版本不匹配两种情况。</p><p>而如果出现了这种不正确的问题，只能手动解决：比如手动将这些依赖增加到 <code>package.json</code> 或者修改它们的版本使得这些依赖可以符合要求，然后 <code>npm install --force</code>…… 太蠢了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> WARN  using --force I sure hope you know what you are doing</span><br></pre></td></tr></table></figure><h2 id="npm-版本号规则"><code>npm</code> 版本号规则</h2><p>整体来说，<code>npm</code> 的版本号的格式是 <code>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code> 的形式。</p><h3 id="版本号匹配规则">版本号匹配规则</h3><p>出现在 <code>package.json</code> 中的各种依赖包的版本实际上是匹配规则，又被称为 <code>npm</code> 语义化版本。一般来说有以下常用的匹配规则：</p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>写法</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><code>version</code></td><td>精确匹配某个特定版本</td></tr><tr class="even"><td><code>&gt;version</code><br /><code>&lt;version</code><br /><code>&gt;=version</code> <br /><code>&lt;=version</code></td><td>大于、小于、大于等于、小于等于某个特定版本；表示了一个范围<br />将两个规则连写也可以表示一个范围；如：<code>&gt;=version1 &lt;version2</code></td></tr><tr class="odd"><td><code>~version</code></td><td>大致匹配某个版本。具体来说规则如下：<br />1）指定到 <code>&lt;patch&gt;</code>：形如 <code>~a.b.c</code>；指大于当前指定的版本，但是小于下一个次版本号的所有版本<br />2）指定到 <code>&lt;minor&gt;</code>：形如 <code>~a.b</code>；指固定主版本号和次版本号，补丁版本号任意<br />3）指定到 <code>&lt;major&gt;</code>：形如 <code>~a</code>；指固定主版本号，次版本号和补丁任意</td></tr><tr class="even"><td><code>^version</code></td><td>兼容某个版本，其含义是版本号中最左的非 0 版本号的右侧版本可以任意；<br />如 <code>^a.b.c</code> 实际上等价于 <code>&gt;=a.b.c</code> 和 <code>&lt;a+1.0.0</code> 同时成立；<br />而 <code>^0.a.b</code> 则等价于 <code>&gt;=0.a.b</code> 和 <code>&lt;0.a+1.0</code> 同时成立；<br />如果缺省了某个低权重的版本号，那么缺失的位置可以任意（此时类似 <code>~version</code>）</td></tr><tr class="odd"><td>标识符 <code>x</code></td><td>标识符 <code>x</code> 的位置可以填入任何数字</td></tr><tr class="even"><td>标识符 <code>*</code></td><td>表示任意版本；等价于留空规则；严格的来说等价于 <code>&gt;=0.0.0</code></td></tr><tr class="odd"><td><code>version1 - version2</code></td><td>匹配了 <code>[version1, version2]</code> 双闭区间的版本</td></tr><tr class="even"><td><code>range1 || range2</code></td><td>操作符 <code>||</code> 可以连接多个范围，表示匹配多个范围内的版本</td></tr></tbody></table><p>由此可以看出 <code>npm</code> 语义化版本中有各种各样的模糊和范围，这为前端的工程化引入了一些问题：当某些包升级过程中没有遵循语义化版本，可能会导致每次打包生成代码都不同；所以我们需要特定项目依赖的包的版本号，为此各大包管理器都引入了 <code>lockfile</code> 的机制来锁定项目依赖的版本号。</p><p>开源的包一般都不包含 <code>lockfile</code>，其原因可能是为了避免特定过多具体的包导致引用较多开源包重复打包某个包的不同版本使得工程体积膨胀，故只能信任其依赖的包遵循语义化版本的要求，某个小版本/大版本的功能不发生过大变化而可以兼容。</p><h3 id="包管理器的-install-和-update">包管理器的 <code>install</code> 和 <code>update</code></h3><p>以 <code>npm</code> 为例，安装有 <code>install</code> 和 <code>update</code> 两种命令；它们之间的区别主要体现在两个方面：</p><h4 id="对于已安装的模糊版本">对于已安装的模糊版本</h4><p><code>install</code> 会忽略模糊版本，而 <code>update</code> 会更新模糊版本至最新版。</p><p>对于未安装的包，两者都会直接安装</p><h4 id="对于-devdependencies">对于 <code>devDependencies</code></h4><p><code>install</code> 会安装/更新 <code>devDependencies</code>，除非指定 <code>--production</code> 标志。</p><p>而 <code>update</code> 会忽略 <code>devDependencies</code>，除非指定 <code>--dev</code> 标志。</p><h2 id="参考">参考</h2><ul><li><a href="https://www.cnblogs.com/wonyun/p/9692476.html">探讨npm依赖管理之peerDependencies</a></li><li><a href="https://blog.csdn.net/chenzhi5174/article/details/100718987">NPM版本号规则以及更新策略</a></li><li><a href="https://stackoverflow.com/questions/12478679/npm-install-vs-update-whats-the-difference">npm install vs. update - what's the difference?</a></li><li><a href="https://codingwithspike.wordpress.com/2016/01/21/dealing-with-the-deprecation-of-peerdependencies-in-npm-3/">Dealing with the deprecation of peerDependencies in NPM 3</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> Web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>考研中的伽马函数</title>
      <link href="/2021/gamma-function-in-kaoyan/"/>
      <url>/2021/gamma-function-in-kaoyan/</url>
      
        <content type="html"><![CDATA[<p>首先，在概率论里我们经常能遇到一个神秘的不可积的积分： <span class="math display">\[I = \int_0^{+\infty} e^{-t^2} \text dt\]</span> 这个积分既不能直接凑出来，也不能使用分部积分法消掉什么；一般，我们会使用升维的方法转化到极坐标来解决这个积分，就大概是下面这样： <span class="math display">\[I^2 = \int_0^{+\infty} e^{-x^2} \text dx \cdot \int_0^{+\infty} e^{-y^2} \text dy = \iint_D e^{-(x^2+y^2)}\text dx\text dy\]</span> 这样，使用极坐标变换可以得到： <span class="math display">\[I^2 = \int_0^\frac\pi2\text d\theta\int_0^{+\infty}re^{-r^2}\text dr = \frac\pi2\left(-\frac12e^{-r^2}\Bigg|_0^{+\infty}\right) = \frac\pi4\]</span> 显然被积函数恒大于 0，故 <span class="math inline">\(I &gt; 0\)</span>，综上所述可得：<span class="math inline">\(I = \int_0^{+\infty} e^{-t^2} \text dt = \frac{\sqrt{\pi}}2\)</span>。</p><p>每次遇到这种积分都要这样搞一遍实在是有些麻烦，有没有更系统化的方法呢？经过查阅 Wolfram Alpha，得知这种形式的积分可以使用 Gamma 函数表示。</p><h2 id="定义">定义</h2><p>伽马函数也叫欧拉第二积分，是阶乘函数在实数与复数上扩展的一类函数，是阶乘函数在复数域上的延拓。怎么理解这句话呢？首先我们知道阶乘函数定义在正整数离散点上，若对于任何一个非整数，无法使用其定义式求出它的值，因此我们需要对其进行延拓—— 最后得到了如下的定义式： <span class="math display">\[\Gamma(x) = \int_0^{+\infty}t^{x-1}e^{-t}\text dt\]</span> 现在我们只考虑其在实数域且 <span class="math inline">\(x &gt; 0\)</span> 上的情况，毕竟考研只需要这个。</p><p>Gamma 函数作为阶乘函数在更广的数域上的延拓，首先它当然满足阶乘函数本来的定义；它具有如下的性质：</p><ul><li>阶乘函数：<span class="math inline">\(\Gamma(x) = (x - 1)!\)</span></li><li>递推关系：<span class="math inline">\(\Gamma(x) = (x-1)\Gamma(x-1)\)</span></li></ul><p>那么如何证明这两个性质呢？一般有两种常见的做法：</p><h3 id="分部积分法">分部积分法</h3><p>对于 <span class="math inline">\(\Gamma(k)\)</span> 的定义式使用分部积分法： <span class="math display">\[\int_0^{+\infty}t^{k-1}e^{-t}\text dt = \frac1{k}\int_0^{+\infty}e^{-t}\text dt^{k} = \frac1{k}\left(e^{-t}t^{k}\Bigg|_0^{+\infty} + \int_0^{+\infty}e^{-t}t^{k}\text dt\right)\]</span> 显然，第一项为 0，第二项又是 <span class="math inline">\(\Gamma(k+1)\)</span> 的定义式，故： <span class="math display">\[\Gamma(k) = \frac1{k}\int_0^{+\infty}e^{-t}t^{k} = \frac{\Gamma(k + 1)}{k}\]</span> 就得到了上面性质中说到的递推关系；但是我们现在还缺乏一个初值；对于 <span class="math inline">\(\Gamma(1)\)</span>： <span class="math display">\[\Gamma(1) = \int_0^{+\infty}e^{-t}\text dt = -e^{-t}\Bigg|_0^{+\infty} = 1\]</span> 结合上面的到的递推公式，就可以得到它和阶乘函数的对应关系。</p><h3 id="展开法">展开法</h3><p>这种做法需要一定的技巧性；首先我们可以进行如下的展开： <span class="math display">\[\begin{align}&amp;\frac1{1-x} = \sum_{k=0}^\infty x^k    &amp;,\ |x| &lt; 1\\&amp;e^x = \sum_{k=0}^\infty \frac{x^k}{k!} &amp;,\ x \in \R\end{align}\]</span> 对于第一个展开式，又有： <span class="math display">\[\frac1{1-x} = \frac1{1-x}\int_0^{+\infty}e^{-t} \text dt = -\frac1{1-x}\int_0^{+\infty}e^{-(1-x)t} \text d[-(1-x)t]\]</span> 综上所述，可得： <span class="math display">\[\frac1{1-x} = \int_0^{+\infty}e^{-t}\cdot e^{xt} \text dt\]</span> 上式右侧的 <span class="math inline">\(e^{xt}\)</span> 也可以利用第二个展开式展开为无穷级数： <span class="math display">\[\frac1{1-x} = \sum_{k=0}^\infty x^k = \int_0^{+\infty}e^{-t}\cdot \sum_{k=0}^\infty \frac{(xt)^k}{k!} \text dt = \sum_{k=0}^\infty \frac{\int_0^{+\infty}e^{-t}\cdot t^k \text dt}{k!} x^k\]</span> 简单地说，就是在一致收敛域 <span class="math inline">\(|x|&lt;1\)</span> 上，有： <span class="math display">\[\sum_{k=0}^\infty x^k = \sum_{k=0}^\infty \frac{\int_0^{+\infty}e^{-t}\cdot t^k \text dt}{k!} x^k\]</span></p><p>对比系数可得 Gamma 函数的定义式： <span class="math display">\[\Gamma(k+1) = \int_0^{+\infty}e^{-t}\cdot t^k \text dt = k!\]</span> 虽然上述等式需要在一致收敛域上才成立，但是 <span class="math inline">\(k\)</span> 才是函数的参数，因此 <span class="math inline">\(k\in\R\)</span> 不受限制。</p><h2 id="应用">应用</h2><p>那么，已经知道了 Gamma 函数，我们应该怎么运用到上述的情况中呢？对于积分 <span class="math inline">\(I\)</span>，我们令 <span class="math inline">\(x = \sqrt t\)</span>： <span class="math display">\[I = \frac12\int_0^{+\infty} t^{-\frac12}e^{-t} \text dt = \frac12\Gamma(\frac12) = \Gamma(\frac32)\]</span> 因此，我们得到了关键值 <span class="math inline">\(\Gamma(\frac12) = \sqrt\pi\)</span>。其他的值都可以从这个关键值出发求出；</p><h3 id="举例">举例</h3><p>下面对于几种常见的变换进行示范：</p><h4 id="int_0infty-e-frac12x2text-dx"><span class="math inline">\(\int_0^{+\infty} e^{-\frac12x^2}\text dx\)</span></h4><p>令 <span class="math inline">\(x = \sqrt{2t}\)</span>，那么有： <span class="math display">\[\int_0^{+\infty} e^{-\frac12x^2}\text dx = \frac1{\sqrt2}\int_0^{+\infty} t^{-\frac12}e^{-t}\text dt = \frac1{\sqrt2}\Gamma(\frac12)\]</span> 我们就可以使用关键值快速求出这个积分值</p><h4 id="int_0infty-x2e-frac12x2text-dx"><span class="math inline">\(\int_0^{+\infty} x^2e^{-\frac12x^2}\text dx\)</span></h4><p>同理，令 <span class="math inline">\(x = \sqrt{2t}\)</span>，那么有： <span class="math display">\[\int_0^{+\infty} x^2e^{-\frac12x^2}\text dx = \frac2{\sqrt2}\int_0^{+\infty} t^\frac12e^{-t}\text dt = \sqrt2\Gamma(\frac32)\]</span> 关键在于使用换元法将原积分转化成 Gamma 函数定义式的形式。</p><h3 id="查表">查表</h3><p>常用的类似积分的查表。</p><table style="width:100%;"><colgroup><col style="width: 19%" /><col style="width: 30%" /><col style="width: 20%" /><col style="width: 19%" /><col style="width: 9%" /></colgroup><thead><tr class="header"><th style="text-align: center;">被积函数</th><th style="text-align: center;"><span class="math inline">\(\Gamma\)</span> 函数</th><th style="text-align: center;">在 <span class="math inline">\(\R^+\)</span> 上积分值</th><th style="text-align: center;">在 <span class="math inline">\(\R\)</span> 上的积分值</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(x^{-\frac12}e^{-x}\)</span></td><td style="text-align: center;"><span class="math inline">\(\Gamma(\frac12)\)</span></td><td style="text-align: center;"><span class="math inline">\(\sqrt\pi\)</span></td><td style="text-align: center;"><em>不存在</em></td><td style="text-align: center;"><strong>关键值</strong></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(e^{-x}\)</span></td><td style="text-align: center;"><span class="math inline">\(\Gamma(1)\)</span></td><td style="text-align: center;"><span class="math inline">\(1\)</span></td><td style="text-align: center;"><em>不存在</em></td><td style="text-align: center;">反常积分</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(x^{\frac12}e^{-x}\)</span></td><td style="text-align: center;"><span class="math inline">\(\Gamma(\frac32)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{\sqrt\pi}2\)</span></td><td style="text-align: center;"><em>不存在</em></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(xe^{-x}\)</span></td><td style="text-align: center;"><span class="math inline">\(\Gamma(2)\)</span></td><td style="text-align: center;"><span class="math inline">\(1\)</span></td><td style="text-align: center;"><em>不存在</em></td><td style="text-align: center;">可分部积分</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(e^{-x^2}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac12\Gamma(\frac12)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{\sqrt{\pi}}2\)</span></td><td style="text-align: center;"><span class="math inline">\(\sqrt\pi\)</span></td><td style="text-align: center;"><strong>关键值</strong></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(xe^{-x^2}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac12\Gamma(1)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac12\)</span></td><td style="text-align: center;"><em>不存在</em></td><td style="text-align: center;">可直接积分</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(x^2e^{-x^2}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac12\Gamma(\frac32)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{\sqrt{\pi}}4\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{\sqrt{\pi}}2\)</span></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(e^{-\frac12x^2}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac1{\sqrt2}\Gamma(\frac12)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{\sqrt{2\pi}}2\)</span></td><td style="text-align: center;"><span class="math inline">\(\sqrt{2\pi}\)</span></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(xe^{-\frac12x^2}\)</span></td><td style="text-align: center;"><span class="math inline">\(\Gamma(1)\)</span></td><td style="text-align: center;"><span class="math inline">\(1\)</span></td><td style="text-align: center;"><em>不存在</em></td><td style="text-align: center;">可直接积分</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(x^2e^{-\frac12x^2}\)</span></td><td style="text-align: center;"><span class="math inline">\(\sqrt2\Gamma(\frac32)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{\sqrt{2\pi}}2\)</span></td><td style="text-align: center;"><span class="math inline">\(\sqrt{2\pi}\)</span></td><td style="text-align: center;"></td></tr></tbody></table><p>部分积分在上面已经进行了推导。</p><h3 id="速记">速记</h3><p>说是速记，其实涉及到了 Gamma 函数的另一种形式；令 <span class="math inline">\(t = u^2\)</span>： <span class="math display">\[\Gamma(x) = \int_0^{+\infty}t^{x-1}e^{-t}\text dt = 2\int_0^{+\infty}u^{2x-1}e^{-u^2}\text du\]</span> 也就得到了 Gamma 函数的另一种表现形式： <span class="math display">\[\frac12\Gamma(x) = \int_0^{+\infty}u^{2x-1}e^{-u^2}\text du\]</span> 这种情况下和原定义不同；当 <span class="math inline">\(u\)</span> 的次数增加 2，对应的 Gamma 函数的参数增加 1.</p><p>虽然看起来很显然，但是在对于考研中各种类似这个的积分，使用这种形式可以快速建立积分和 Gamma 函数之间的关系，从而使用我们记忆的关键值和定义对积分求解。</p><h2 id="后记">后记</h2><p>原来这玩意不管是在汤家凤的高数讲义上还是在张宇概率论9讲上都有提到啊…… 我学的是个寄吧（）</p><h3 id="参考资料">参考资料</h3><ul><li><a href="https://blog.csdn.net/qq_43141726/article/details/104943994">伽马函数 - 959 - CSDN博客 - 伽马函数</a></li><li><a href="https://baike.baidu.com/item/伽玛函数/3540177?fromtitle=伽马函数&amp;fromid=11217190&amp;fr=aladdin">伽玛函数_百度百科 (baidu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/427673303?utm_source=qq&amp;utm_medium=social&amp;utm_oi=692365410040811520">世界上最美丽的函数——γ函数，一颗数学皇冠上的明珠，可以回答分数阶乘的问题 - 知乎 (zhihu.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 课业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 推导 </tag>
            
            <tag> 考研数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单数学：从约数个数和到莫比乌斯反演</title>
      <link href="/2021/sdoi-2015-the-summation-of-divisors/"/>
      <url>/2021/sdoi-2015-the-summation-of-divisors/</url>
      
        <content type="html"><![CDATA[<p>差不多算是基础的程度的知识的数论能力，就算已经不参加弹幕神乐的巫女想必也是应该要掌握的吧。</p><p>首先来点题目链接：<a href="https://www.luogu.com.cn/problem/P3327">P3327【SDOI2015】约数个数和 - 洛谷</a> | <a href="https://loj.ac/p/2185">2185. 「SDOI2015」约数个数和 - LibreOJ</a></p><blockquote><p><span class="math inline">\(\text d(x)\)</span> 是 <span class="math inline">\(x\)</span> 的约数个数，给定 <span class="math inline">\(N, M \le 50000\)</span>，求： <span class="math display">\[\sum_{i=1}^N\sum_{j=1}^M \text{d}(ij)\]</span></p></blockquote><h2 id="莫比乌斯反演">莫比乌斯反演</h2><p>这个题要用到它，但是我还不会。所以先随便学学吧！</p><h3 id="前置名词">前置名词</h3><h4 id="数论函数">数论函数</h4><p>定义域为正整数的函数称为数论函数。</p><h4 id="积性函数">积性函数</h4><p>若 <span class="math inline">\(f(x)\)</span> 是数论函数，且对于 <span class="math inline">\(\forall a,b \and (a,b)=1\)</span> 有 <span class="math inline">\(f(ab)=f(a)f(b)\)</span>，那么这样的数论函数称为积性函数。</p><p>常见的积性函数有欧拉函数（<span class="math inline">\(\varphi\)</span>）、莫比乌斯函数（<span class="math inline">\(\mu\)</span>）和除数函数（<span class="math inline">\(\sigma_k\)</span>）</p><h4 id="完全积性函数">完全积性函数</h4><p>若积性函数不需要 <span class="math inline">\((a,b)=1\)</span> 也能有 <span class="math inline">\(f(ab)=f(a)f(b)\)</span>，那样的 <span class="math inline">\(f\)</span> 就是完全积性函数。</p><p>常见的完全积性函数：<span class="math inline">\(f(x)=x\)</span>、<span class="math inline">\(1(x)=1\)</span></p><h4 id="dirichlet-卷积">Dirichlet 卷积</h4><p>两个数论函数 <span class="math inline">\(f,g\)</span> 的 Dirichlet 卷积的定义如下： <span class="math display">\[(f*g)(n)=\sum_{d\mid n}f(d)g(\frac nd)\]</span> 卷积运算符 <span class="math inline">\(*\)</span> 满足运算的交换律结合律以及对于 <span class="math inline">\(+\)</span> 的分配律；此外，对于满足 <span class="math inline">\(h(1)\ne0\)</span> 的数论函数 <span class="math inline">\(h\)</span>，卷积运算符还满足了等式的性质，即：<span class="math inline">\(f = g \Leftrightarrow f*h=g*h\)</span>。</p><p>Dirichlet 卷积具有<strong>单位元</strong>，其单位元 <span class="math inline">\(e\)</span> 定义如下： <span class="math display">\[\varepsilon:e(n)=\left\{\begin{matrix} 1\; (n=1)\\ 0\; (n\neq 1) \end{matrix}\right.=[n=1]\]</span></p><p>这个单位元也被称为单位函数，它是一个完全积性函数。</p><p><strong>结论 1</strong>：若 <span class="math inline">\(f, g\)</span> 是积性函数，那么 <span class="math inline">\(f*g\)</span> 也是积性函数。</p><p><strong>结论 2</strong>：积性函数的逆元（对于单位元）也是积性函数。</p><h3 id="莫比乌斯函数">莫比乌斯函数</h3><p>莫比乌斯函数是积性函数。</p><h4 id="定义">定义</h4><p>记作 <span class="math inline">\(\mu\)</span>；对于一个整数 <span class="math inline">\(n\)</span>，令其标准分解形式为 <span class="math inline">\(\prod p_i^{a_i},\ i\in[1, k]\)</span>，则莫比乌斯函数可以如下定义： <span class="math display">\[\mu(n)=\begin{cases}0 &amp;,\ \exists i: a_i &gt; 1 \\(-1)^k &amp;,\ \text{else}\end{cases}\]</span></p><p>简单地说：如果 <span class="math inline">\(n\)</span> 有平方因子，那么 <span class="math inline">\(\mu(n)=0\)</span>；否则是 <span class="math inline">\((-1)^k\)</span>，<span class="math inline">\(k\)</span> 是 <span class="math inline">\(n\)</span> 互不相同的质因子个数。</p><h4 id="性质">性质</h4><p>莫比乌斯函数最重要的性质是： <span class="math display">\[\sum_{d\mid n}\mu(d) = \begin{cases}1 &amp;,\ n=1 \\0 &amp;,\ n\ne1\end{cases} = e(n)\]</span> 用 Dirichlet 卷积的形式表示，就是 <span class="math inline">\(\mu * 1 = e\)</span>.</p><h5 id="这个性质的证明">这个性质的证明</h5><blockquote><p>令 <span class="math inline">\(n\)</span> 有标准分解形式为 <span class="math inline">\(\prod p_i^{a_i},\ i\in[1, k]\)</span>，定义 <span class="math inline">\(n&#39; = \prod p_i\)</span>；那么显然有： <span class="math display">\[\sum_{d\mid n}\mu(d) = 0 + \sum_{d\mid n&#39;}\mu(d)\]</span> 而 <span class="math inline">\(n&#39;\)</span> 中是没有重复的因子的，所以 <span class="math inline">\(d\)</span> 只需要在这 <span class="math inline">\(k\)</span> 个本质不同的因子中随意选取组合即可： <span class="math display">\[\sum_{d\mid n&#39;}\mu(d) = \sum_{i=0}^k \mathbf C_k^i\cdot(-1)^i\]</span> 为每一项增加一个 <span class="math inline">\(1^{k-i}\)</span>，由二项式定理可得： <span class="math display">\[\sum_{i=0}^k \mathbf C_k^i\cdot(-1)^i\cdot1^{k-i} = (-1 + 1)^k = 0^k\]</span> 显然，当且仅当 <span class="math inline">\(k=0\)</span> 时上式取值 <span class="math inline">\(1\)</span>；其他情况下均为 <span class="math inline">\(0\)</span>。而 <span class="math inline">\(k=0\)</span> 时，<span class="math inline">\(n\)</span> 没有任何素因子，故 <span class="math inline">\(n=1\)</span>.</p></blockquote><p>除此之外，我们还有一个结论可以帮助我们将莫比乌斯函数和欧拉函数联系起来： <span class="math display">\[\sum_{d\mid n}\frac{\mu(d)}d = \frac{\varphi(n)}n\]</span> 这个待会再想办法证（</p><h4 id="线性筛求解">线性筛求解</h4><p>根据定义，稍微修改一下线性筛，我们可以写出下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> n&gt; <span class="function"><span class="keyword">auto</span> &amp;<span class="title">mobius_sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">array</span>&lt;<span class="keyword">int</span>, n + 1&gt; mu;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;n + 1&gt; vis;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) prime.push_back(i), mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; pp : prime) &#123;</span><br><span class="line">            <span class="keyword">auto</span> ipp = (llong)i * pp;</span><br><span class="line">            <span class="keyword">if</span> (ipp &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            vis[ipp] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pp == <span class="number">0</span>) &#123; </span><br><span class="line">                mu[ipp] = <span class="number">0</span>; </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125; <span class="keyword">else</span> mu[ipp] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，线性筛基本可以求所有的积性函数。</p><h3 id="莫比乌斯反演-1">莫比乌斯反演</h3><p>对于一些函数 <span class="math inline">\(f(n)\)</span>，若它本身难求但其倍数/约数和好求，那么就可以用莫比乌斯反演来简化其运算。</p><h4 id="公式">公式</h4><p>设有数论函数 <span class="math inline">\(f,g\)</span>，那么有如下公式： <span class="math display">\[\begin{align}f(n)=\sum_{d\mid n}g(d) &amp;\iff g(n) = \sum_{d\mid n}\mu(d)f(\frac nd) \\f(n)=\sum_{n\mid d}g(d) &amp;\iff g(n) = \sum_{n\mid d}\mu(\frac dn)f(d)\end{align}\]</span> 形式一是标准形式。</p><h4 id="证明">证明</h4><p>我们先利用卷积知识简易证明上述的形式一：</p><blockquote><p>首先，将上式左边看作 <span class="math inline">\(f = g*1\)</span>；然后，有 Dirichlet 卷积的运算性质，我们在等式两侧卷积 <span class="math inline">\(\mu\)</span>，有： <span class="math display">\[f * \mu = g * 1 * \mu\]</span> 又因为莫比乌斯函数的性质有 <span class="math inline">\(e = 1 * \mu\)</span>，所以上式的右侧消去单位元，得：<span class="math inline">\(g = f * \mu\)</span>，即上式右侧。</p></blockquote><p>或者通过数论变换的方式证明形式一：</p><blockquote><p>数论变换就是反着推导的过程；对于上述关系右侧等式的右侧，代入关系左侧的条件可得： <span class="math display">\[\sum_{d\mid n}\mu(d)f(\frac nd) = \sum_{d\mid n}\mu(d)\sum_{k\mid \frac nd}g(k) = \sum_{k\mid n}g(k)\sum_{d\mid \frac nk}\mu(d)\]</span> 因为 <span class="math inline">\(dk\)</span> 是 <span class="math inline">\(n\)</span> 的因数，<span class="math inline">\(d\)</span> 和 <span class="math inline">\(k\)</span> 是对于 <span class="math inline">\(dk\)</span> 的进一步划分，这里交换求和顺序可以得到上式最右侧的形态；观察这个式子的右侧，利用莫比乌斯函数的主要性质，可以将其转化为单位函数的形式： <span class="math display">\[\sum_{k\mid n}g(k)\sum_{d\mid \frac nk}\mu(d) = \sum_{k\mid n}g(k)[\frac nk = 1] = g(n)\]</span> 也就是左侧的求和只有在 <span class="math inline">\(k = n\)</span> 时取值 <span class="math inline">\(g(n)\)</span>，结果也是 <span class="math inline">\(g(n)\)</span>，和形式一右侧等式的左侧一致。</p></blockquote><p>我们也可以如法炮制的证明形式二：</p><blockquote><p>将可被 <span class="math inline">\(n\)</span> 整除的 <span class="math inline">\(d\)</span> 表示成 <span class="math inline">\(kn\)</span>，将形式二的前提代入关系右侧的等式的右侧可得： <span class="math display">\[\begin{align}g(n) &amp;= \sum_{n\mid d}\mu(\frac dn)f(d) = \sum_{k=1}^{+\infty}\mu(k)f(kn)\\&amp;= \sum_{k=1}^{+\infty}\mu(k)\sum_{kn\mid q}g(q) = \sum_{n\mid q}g(q)\sum_{k\mid \frac qn}\mu(k)\end{align}\]</span> 然后再进行如法炮制的交换求和顺序：<span class="math inline">\(kn\)</span> 是无穷的 <span class="math inline">\(q\)</span> 的因数，再进一步划分 <span class="math inline">\(kn\)</span>；再次观察最右侧的式子，并转化为单位函数： <span class="math display">\[\sum_{n\mid q}g(q)\sum_{k\mid \frac qn}\mu(k) = \sum_{n\mid q}g(q)[\frac qn=1] = g(n)\]</span> 显然，整个求和式子只有在 <span class="math inline">\(q = n\)</span> 时才能取到值，且此时的值是 <span class="math inline">\(g(n)\)</span>，和形式二右侧等式的左侧一致。</p></blockquote><p>不知道看到这里，是否对于”莫比乌斯函数是一个和容斥系数相关的函数“这句话有了什么新的理解。</p><h4 id="应用">应用</h4><p>但是一般来说构造一个 <span class="math inline">\(f(n) = \sum_{d\mid n}g(d)\)</span> 颇有难度，那个公式很多时候都意义不明。所以通常的做法都是想办法整出一个 <span class="math inline">\([\gcd(i, j)=1]\)</span> 也就是 <span class="math inline">\(e(\gcd(i,j))\)</span>，然后通过 <span class="math inline">\(\sum_{d\mid \gcd(i,j)}\mu(d)\)</span> 来计算它；而这实际上就是莫比乌斯函数的性质——这样说也是十分意义不明，所以我们说一类相对比较常见的问题作为例子：</p><blockquote><p>给定 <span class="math inline">\(n\le m\)</span>，求解： <span class="math display">\[\sum_{i=1}^n\sum_{j=1}^m f(\gcd(i, j))\]</span></p></blockquote><p>我们考虑枚举 <span class="math inline">\(d = \gcd(i, j)\)</span> 的取值，于是有了： <span class="math display">\[\sum_{i=1}^n\sum_{j=1}^m f(\gcd(i, j)) = \sum_{d=1}^n \sum_{i=1}^{\lfloor\frac nd\rfloor}\sum_{j=1}^{\lfloor\frac md\rfloor} f(d)e(\gcd(i,j))\]</span> 那么我们可以对于单位函数的部分代入莫比乌斯函数的性质——有： <span class="math display">\[\sum_{d=1}^{\min(n,m)} \sum_{i=1}^{\lfloor\frac nd\rfloor}\sum_{j=1}^{\lfloor\frac md\rfloor} f(d)[\gcd(i,j)=1] = \sum_{d=1}^n \sum_{i=1}^{\lfloor\frac nd\rfloor}\sum_{j=1}^{\lfloor\frac md\rfloor} f(d)\sum_{r\mid\gcd(i,j)}\mu(r)\]</span> 对右侧式子进行反演——或者说调换求和顺序，去枚举 <span class="math inline">\(r\)</span> 的值并将其挪到外层，有： <span class="math display">\[\sum_{d=1}^n \sum_{i=1}^{\lfloor\frac nd\rfloor}\sum_{j=1}^{\lfloor\frac md\rfloor}f(d)\sum_{r\mid\gcd(i,j)}\mu(r) = \sum_{d=1}^n \sum_{r=1}^{\min(\lfloor\frac nd\rfloor,\lfloor\frac md\rfloor)}\mu(r)\sum_{i=1}^{\lfloor\frac n{dr}\rfloor}\sum_{j=1}^{\lfloor\frac m{dr}\rfloor}f(d)\]</span> 可以注意到这个时候右侧式子中的 <span class="math inline">\(i,j\)</span> 已经不会影响到所需要求和的东西了，相当于对 1 求和： <span class="math display">\[\sum_{d=1}^n \sum_{r=1}^{\lfloor\frac nd\rfloor}\mu(r)f(d)\sum_{i=1}^{\lfloor\frac n{dr}\rfloor}\sum_{j=1}^{\lfloor\frac m{dr}\rfloor}1 = \sum_{d=1}^n \sum_{r=1}^{\lfloor\frac nd\rfloor}\mu(r)f(d)\lfloor\frac n{dr}\rfloor\lfloor\frac m{dr}\rfloor\]</span> 此时，我们假设一个 <span class="math inline">\(g(t)\)</span>： <span class="math display">\[g(t) = \sum_{d\mid t}f(d)\mu(\frac td) = f * \mu\]</span> 观察题设的公式和我们的推到结果： <span class="math display">\[\sum_{i=1}^n\sum_{j=1}^m f(\gcd(i, j)) = \sum_{d=1}^n \sum_{r=1}^{\lfloor\frac nd\rfloor}\mu(r)f(d)\lfloor\frac n{dr}\rfloor\lfloor\frac m{dr}\rfloor\]</span> 我们把 <span class="math inline">\(dr\)</span> 看作一个整体，它是 <span class="math inline">\(n\)</span> 的因数，<span class="math inline">\(d,r\)</span> 是对其进一步的划分；那么令 <span class="math inline">\(t=dr\)</span>： <span class="math display">\[\sum_{i=1}^n\sum_{j=1}^m f(\gcd(i, j)) = \sum_{t=1}^ng(t)\lfloor\frac nt\rfloor\lfloor\frac mt\rfloor\]</span></p><p>至此，我们完成了题设公式的转换，即反演；<del>但是这样做的意义，是什么呢？</del>当然是推出来的这个式子相对比较好算了！一重求和不比二重求和容易？</p><h4 id="钢筋bushi"><del>钢筋（bushi</del></h4><p>上面的部分主要说的是对于含有 <span class="math inline">\(\gcd\)</span> 的式子的处理方法：弄出一个 <span class="math inline">\([\gcd(i,j)=1]\)</span> 然后再利用它的等价式子 <span class="math inline">\(\sum_{d\mid \gcd(i,j)}\mu(d)\)</span> 代换它，并求出了一个比较通用的“公式”；那么对于这种出现了 <span class="math inline">\(\gcd\)</span> 的式子，我就是想要使用反演公式设函数套怎么办呢？套路在此：</p><p>首先，我们再写一遍莫比乌斯反演公式的某种形态： <span class="math display">\[f(n)=\sum_{n\mid d}g(d) \iff g(n) = \sum_{n\mid d}\mu(\frac dn)f(d)\]</span> 一般来说，我们设 <span class="math inline">\(g(d)\)</span> 为范围内满足 <span class="math inline">\(\gcd(i, j) = d\)</span> 的数对个数，<span class="math inline">\(f(n)\)</span> 为满足 <span class="math inline">\(n \mid \gcd(i, j)\)</span> 的数对个数，那么它们就满足了： <span class="math display">\[\begin{align}g(d)&amp;=\sum_{i=1}^N\sum_{j=1}^M[\gcd(i, j)=d]\\ f(n)&amp;=\sum_{n\mid d}g(d)=\lfloor\frac Nn\rfloor\lfloor\frac Mn\rfloor\end{align}\]</span> 关于 <span class="math inline">\(f(n)\)</span> 的两种表达式：第一个表达式是利用我们定义的 <span class="math inline">\(g(d)\)</span> 来定义；第二个表达式是根据我们的定义直接得到的——当 <span class="math inline">\(i,j\)</span> 都有确定范围的时候，满足 <span class="math inline">\(\gcd(i, j) = kn\)</span> 的数对数量当然是这个。</p><p>这样，我们就可以利用前面写的那个莫比乌斯反演公式，得到： <span class="math display">\[g(n) = \sum_{n\mid d}\mu(\lfloor\frac dn\rfloor)f(d)\]</span> 当然，裸求 <span class="math inline">\(g(d)\)</span> 是不好求的；但是 <span class="math inline">\(\mu\)</span> 可以线性筛加维护前缀和，<span class="math inline">\(f(n)\)</span> 可以数论分块；于是我们就利用反演公式将不太好求的 <span class="math inline">\(g(d)\)</span> 简化的好求了一些。</p><h3 id="例题">例题</h3><p>上面的简介仍然是比较抽象，所以还是看几个题：</p><h4 id="haoi2011problem-b"><a href="https://www.luogu.com.cn/problem/P2522">【HAOI2011】Problem b</a></h4><blockquote><p>求 <span class="math inline">\(\sum_{i=a}^b \sum_{j=c}^d [\gcd(i,j)=k]\)</span></p></blockquote><p>首先原式的求和有区间，所以很显然地将他转化为一个二维差分的形式： <span class="math display">\[\begin{align}&amp;记\ A_{n,m}=\sum_{i=1}^n \sum_{j=1}^m [\gcd(i,j)=k]\\&amp;则\ 原式 = A_{b,d} - A_{b,c-1} - A_{a-1,d} + A_{a-1,c-1}\end{align}\]</span> 那么原来的问题转化成求 <span class="math inline">\(A_{n,m}\)</span>：</p><p>参考上面运用小节推的那个比较具有代表性的”公式“——这里 <span class="math inline">\(f(x)=[x=k]\)</span>；那么我们可以根据”公式“来套路的得到： <span class="math display">\[g(t) = \sum_{d\mid t}f(d)\mu(\frac td)\]</span> 然后，将它代回那个公式里，可以得到： <span class="math display">\[\begin{align}&amp;\sum_{i=1}^n \sum_{j=1}^m [\gcd(i,j)=k]\\=&amp;\sum_{t=1}^{\min(n,m)}\sum_{d\mid t}[d=k]\mu(\frac td)\lfloor\frac nt\rfloor\lfloor\frac mt\rfloor\\=&amp;\sum_{t=1,k\mid t}^{\min(n,m)}\mu(\frac tk)\lfloor\frac nt\rfloor\lfloor\frac mt\rfloor\\=&amp;\sum_{d=1}^{\lfloor\frac {\min(n,m)}k\rfloor}\mu(d)\lfloor\frac n{dk}\rfloor\lfloor\frac m{dk}\rfloor\end{align}\]</span> 现在这个公式已经可以通过 <span class="math inline">\(\mathcal O(n)\)</span> 来计算了；但是注意到这里待求和的式子还可以使用数论分块计算，所以实际上上式的时间复杂度是 <span class="math inline">\(\mathcal O(\sqrt n)\)</span> 的。<del>如果不会数论分块可以看这个：<a href="https://shiraha.cn/2021/The-concept-of-number-theory-partition/">数论分块入门 - 七海の参考書 (shiraha.cn)</a></del></p><p>然后，我们就能写出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> mu_sum[N + <span class="number">1</span>], a, b, c, d, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mu_seq</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mu_sum[r] - mu_sum[l - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> n&gt; <span class="function"><span class="keyword">auto</span> &amp;<span class="title">mobius_sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">array</span>&lt;<span class="keyword">int</span>, n + 1&gt; mu;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;n + 1&gt; vis;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) prime.push_back(i), mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; pp : prime) &#123;</span><br><span class="line">            <span class="keyword">auto</span> ipp = (llong)i * pp;</span><br><span class="line">            <span class="keyword">if</span> (ipp &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            vis[ipp] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pp == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[ipp] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> mu[ipp] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ybb</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) swap(n, m);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, nk = n / k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= nk; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> nlk = n / l / k, mlk = m / l / k;</span><br><span class="line">        r = min(&#123;nk, n / (n / l), m / (m / l)&#125;);</span><br><span class="line">        ret += mu_seq(l, r) * nlk * mlk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> mu = mobius_sieve&lt;N&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++ i)</span><br><span class="line">        mu_sum[i] = mu_sum[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> T = read(); T --;) &#123;</span><br><span class="line">        a = read(), b = read(), c = read();</span><br><span class="line">        d = read(), k = read();</span><br><span class="line">        <span class="keyword">auto</span> ans = ybb(b, d) - ybb(b, c - <span class="number">1</span>) - ybb(a - <span class="number">1</span>, d) + ybb(a - <span class="number">1</span>, c - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>遇事不决开 <code>long long</code> 是吧？<code>long long</code> 不是你的电子宠物（</del></p><h4 id="yy的gcd"><a href="https://www.luogu.com.cn/problem/P2257">YY的GCD</a></h4><blockquote><p>求 <span class="math inline">\(\sum_{i=1}^n \sum_{j=1}^m [\gcd(i,j)\ \text{is}\ \text{prime}]\)</span></p></blockquote><p>令 <span class="math inline">\(n\le m\)</span>，还是很套路地把上面的式子变成枚举 <span class="math inline">\(\gcd\)</span> 的值： <span class="math display">\[原式 = \sum_{k=1}^{\min(n,m)}\sum_{i=1}^n \sum_{j=1}^m [\gcd(i, j)=k] = \sum_{k=1}^{n}\sum_{i=1}^{\lfloor\frac nk\rfloor} \sum_{j=1}^{\lfloor\frac mk\rfloor} [\gcd(i, j)=1],\ k\ \text{is}\ \text{prime}\]</span> 还是运用“应用”部分得到的公式；我们轻而易举地发现 <span class="math inline">\(f=e\)</span>，那么套路地设 <span class="math inline">\(g\)</span>： <span class="math display">\[g(t) = f * \mu = \sum_{d\mid t}e(d)\mu(\frac td)\]</span> 然后还是代回原来的那个包含 <span class="math inline">\(f\)</span> 的表达式中，可以得到： <span class="math display">\[\begin{align}&amp;\sum_{k=1}^n\sum_{i=1}^{\lfloor\frac nk\rfloor} \sum_{j=1}^{\lfloor\frac mk\rfloor} e(\gcd(i, j)),\ \ k\ \text{is}\ \text{prime}.\\=&amp;\sum_{k=1}^n\sum_{t=1}^{\lfloor\frac nk\rfloor}\sum_{d\mid t}e(d)\mu(\frac td)\lfloor\frac n{tk}\rfloor\lfloor\frac m{tk}\rfloor\\=&amp;\sum_{k=1}^n\sum_{t=1}^{\lfloor\frac nk\rfloor}\mu(t)\lfloor\frac n{tk}\rfloor\lfloor\frac m{tk}\rfloor\end{align}\]</span> 令 <span class="math inline">\(x = tk\)</span>，那么： <span class="math display">\[上式 = \sum_{x=1}^n\sum_{k\mid x}\mu(\frac xk)\lfloor\frac nx\rfloor\lfloor\frac mx\rfloor = \sum_{x=1}^n\lfloor\frac nx\rfloor\lfloor\frac mx\rfloor\sum_{k\mid x}\mu(\frac xk),\ \ k\ \text{is}\ \text{prime}.\]</span> 那么式子就推到这里；上面的式子左边可以数论分块，右边那个东西虽然看起来玄乎但是总归还是可以预处理的：只需要对于所有的质数在范围内的倍数“对数筛”即可，复杂度不明<del>不会素数定理</del>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">1e7</span> + <span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> f[N + <span class="number">1</span>], f_sum[N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f_sec</span><span class="params">(llong l, llong r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f_sum[r] - f_sum[l - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> n&gt; <span class="function"><span class="keyword">auto</span> <span class="title">mobius_sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">array</span>&lt;<span class="keyword">int</span>, n + 1&gt; mu;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;n + 1&gt; vis;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) prime.push_back(i), mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; pp : prime) &#123;</span><br><span class="line">            <span class="keyword">auto</span> ipp = (llong)i * pp;</span><br><span class="line">            <span class="keyword">if</span> (ipp &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            vis[ipp] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pp == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[ipp] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> mu[ipp] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(ref(prime), ref(mu));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">llong <span class="title">fuck</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) swap(n, m);</span><br><span class="line">    llong ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (llong l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = min(&#123;n / (n / l), m / (m / l), (llong) n&#125;);</span><br><span class="line">        ret += (llong) f_sec(l, r) * (n / l) * (m / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> [prime, mu] = mobius_sieve&lt;N&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> pp : prime)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;; ++ i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> ipp = (llong)i * pp;</span><br><span class="line">            <span class="keyword">if</span> (ipp &gt; N) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> f[ipp] += mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++ i)</span><br><span class="line">        f_sum[i] = f_sum[i - <span class="number">1</span>] + f[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> T = read(); T --;) &#123;</span><br><span class="line">        <span class="keyword">auto</span> n = read(), m = read();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; fuck(n, m) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓条条大路通罗马<del>（罗马！）</del>，直接用莫比乌斯反演公式也能推出一样的式子，看各自喜好了（</p><h2 id="思路">思路</h2><p>那么，你已经学会了莫比乌斯反演了，快上！（指做开篇的那个题</p><h3 id="关于-dx">关于 d(x)</h3><p>首先关于这个都不太熟的 <span class="math inline">\(\text d(x)\)</span>，我们有一个结论： <span class="math display">\[\text d(NM) = \sum_{i\mid N}\sum_{j\mid M}[\gcd(i, j)=1]\]</span> 这个式子为什么是正确的？首先考虑对于一个整数 <span class="math inline">\(X\)</span> 的标准分解，即 <span class="math inline">\(X = \prod p_i^{a_i}\)</span>，约数的个数为 <span class="math inline">\(\text d(X) = \prod (a_i + 1)\)</span>；这非常的好理解，它的约数必定由它的质因子构成，每个质因子 <span class="math inline">\(p_i\)</span> 有 <span class="math inline">\(a_i + 1\)</span> 种不同的选法。合数因子本身就是对于这个数字所有的质因子进行这样的选择组合而成；对于 <span class="math inline">\(NM\)</span>，我们也可以从这个角度入手考虑：</p><p>对于一个素数 <span class="math inline">\(p\)</span>，有 <span class="math inline">\(N = n\times p^x\)</span> 和 <span class="math inline">\(M=m\times p^y\)</span>；那么显然 <span class="math inline">\(p\)</span> 在 <span class="math inline">\(NM\)</span> 中出现的次数是 <span class="math inline">\(x + y\)</span> 次，关于这个质因子有 <span class="math inline">\(x + y + 1\)</span> 种选法。那么怎么枚举选法呢？显然，若枚举 <span class="math inline">\(i\mid N\)</span> 和 <span class="math inline">\(j\mid M\)</span>，得到的 <span class="math inline">\(ij \mid NM\)</span>。那么问题就在于两次不同的枚举得到的 <span class="math inline">\(ij\)</span> 的乘积可能实际上是一样的；为了避免重复，我们定义下面的取法：</p><ul><li>令对于 <span class="math inline">\(NM\)</span> 和素因子 <span class="math inline">\(p\)</span>，我们要选取其中的 <span class="math inline">\(k\)</span> 次，那么这 <span class="math inline">\(k\)</span> 个 <span class="math inline">\(p\)</span> 就要由 <span class="math inline">\(N\)</span> 和 <span class="math inline">\(M\)</span> 来提供。</li><li>当 <span class="math inline">\(k \le x\)</span> 时，我们要求 <span class="math inline">\(p\)</span> 完全由 <span class="math inline">\(N\)</span> 提供；此时可以选出 <span class="math inline">\(k = x + 1\)</span> 种不同的有序数对 <span class="math inline">\((p^k, 1)\)</span></li><li>当 <span class="math inline">\(k &gt; x\)</span> 时，我们要求超过 <span class="math inline">\(x\)</span> 的部分由 <span class="math inline">\(M\)</span> 提供，但不再在 <span class="math inline">\(N\)</span> 中选择；此时有 <span class="math inline">\(y\)</span> 种有序数对 <span class="math inline">\((1,p^{k-x})\)</span></li></ul><p>因此对于每一个因子，在上述规则的限制下，在 <span class="math inline">\(NM\)</span> 中只会选出 <span class="math inline">\(x + y + 1\)</span> 种不同的选法，符合我们的要求；而实现这样的限制条件很显然可以通过 <span class="math inline">\(\gcd(i, j)=1\)</span> 来达成目的，因为我们从来没有在 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 中同时选择 <span class="math inline">\(p\)</span>.</p><h3 id="变换">变换</h3><p>综上所述，我们要求的式子可以写成下面的形式： <span class="math display">\[\sum_{n=1}^N\sum_{m=1}^M\text d(nm) = \sum_{n=1}^N\sum_{m=1}^M\sum_{i\mid n}\sum_{j\mid m}[\gcd(i, j)=1]\]</span> 改变四层求和的枚举顺序，先枚举 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span>，那么可以得到下面的形式： <span class="math display">\[\sum_{n=1}^N\sum_{m=1}^M\text d(nm) = \sum_{i=1}^N\sum_{j=1}^M\lfloor\frac Ni\rfloor\lfloor \frac Mj\rfloor[\gcd(i,j)=1]\]</span> 那么就转化了题设的公式，可以基于这个公式进行莫比乌斯反演了。</p><h3 id="反演">反演</h3><p>根据上面的讨论，我们已经得到了一个包含了 <span class="math inline">\(e(\gcd(i, j))\)</span> 形态的公式，现在对它进行操作：</p><p>根据 Dirichlet 卷积的单位元的性质，也就是 <span class="math inline">\(e = 1*\mu\)</span>，得： <span class="math display">\[\sum_{i=1}^N\sum_{j=1}^M\lfloor\frac Ni\rfloor\lfloor \frac Mj\rfloor[\gcd(i,j)=1] = \sum_{i=1}^N\sum_{j=1}^M\lfloor\frac Ni\rfloor\lfloor \frac Mj\rfloor\sum_{d\mid\gcd(i, j)}\mu(d)\]</span> 对于最右边这个子式，我们很自然地想到枚举 <span class="math inline">\(d\)</span>；令 <span class="math inline">\(\min(N,M)=N\)</span>，调换枚举顺序： <span class="math display">\[\sum_{i=1}^N\sum_{j=1}^M\lfloor\frac Ni\rfloor\lfloor \frac Mj\rfloor\sum_{d=1}^{\min(N,M)}[d\mid\gcd(i,j)]\mu(d) = \sum_{d=1}^{N}\mu(d)\sum_{i=1}^N\sum_{j=1}^M\lfloor\frac Ni\rfloor\lfloor \frac Mj\rfloor[d\mid\gcd(i,j)]\]</span> 右边的双层枚举子式又是典型的求 <span class="math inline">\(\gcd\)</span> 是倍数的类型，进行套路地转换： <span class="math display">\[\sum_{d=1}^{N}\mu(d)\sum_{i=1}^{\lfloor\frac Nd\rfloor}\sum_{j=1}^{\lfloor\frac Md\rfloor}\lfloor\frac N{id}\rfloor\lfloor \frac M{jd}\rfloor = \sum_{d=1}^{N}\mu(d)\sum_{i=1}^{\lfloor\frac Nd\rfloor}\lfloor\frac N{id}\rfloor\sum_{j=1}^{\lfloor\frac Md\rfloor}\lfloor\frac M{jd}\rfloor\]</span> 综上所述，我们通过反演将原式转化为了： <span class="math display">\[\sum_{n=1}^N\sum_{m=1}^M\text d(nm) = \sum_{d=1}^{\min(N,M)}\mu(d)(\sum_{i=1}^{\lfloor\frac Nd\rfloor}\lfloor\frac N{id}\rfloor\cdot\sum_{j=1}^{\lfloor\frac Md\rfloor}\lfloor\frac M{jd}\rfloor)\]</span> 那么这个化简后的式子要怎么去求呢？容易发现两个子求和是近乎一致的，可以预先处理；因此我们定义函数 <span class="math inline">\(h(n)=\sum_{i=1}^n\lfloor\frac ni\rfloor\)</span>，于是有： <span class="math display">\[\sum_{n=1}^N\sum_{m=1}^M\text d(nm) = \sum_{d=1}^{\min(N,M)}\mu(d)h(\lfloor\frac Nd\rfloor)h(\lfloor\frac Md\rfloor)\]</span> 而实际上，<span class="math inline">\(h(n)\)</span> 就是约数个数函数 <span class="math inline">\(\text d(x)\)</span> 的前缀和，这个也可以用线性筛求出来维护前缀和；当然如果不想使用线性筛来维护这个，也可以直接分块计算后加起来——复杂度是 <span class="math inline">\(\mathcal O(n\sqrt n)\)</span>；</p><h3 id="代码实现">代码实现</h3><p>综上所述，我们可以用分块和分块求解上面反演得到的式子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> h[N + <span class="number">1</span>], mu_sum[N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mu_sec</span><span class="params">(llong l, llong r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mu_sum[r] - mu_sum[l - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> n&gt; <span class="function"><span class="keyword">auto</span> <span class="title">mobius_sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">array</span>&lt;<span class="keyword">int</span>, n + 1&gt; mu;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;n + 1&gt; vis;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) prime.push_back(i), mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; pp : prime) &#123;</span><br><span class="line">            <span class="keyword">auto</span> ipp = (llong)i * pp;</span><br><span class="line">            <span class="keyword">if</span> (ipp &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            vis[ipp] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pp == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[ipp] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> mu[ipp] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(ref(prime), ref(mu));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">llong <span class="title">partition</span><span class="params">(llong n)</span> </span>&#123;</span><br><span class="line">    llong ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (llong l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = min(n / (n / l), n);</span><br><span class="line">        ret += (r - l + <span class="number">1</span>) * (n / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">llong <span class="title">fuck</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) swap(n, m);</span><br><span class="line">    llong ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (llong l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = min(&#123;n / (n / l), m / (m / l), (llong)n&#125;);</span><br><span class="line">        ret += (llong) mu_sec(l, r) * h[n / l] * h[m / l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> [prime, mu] = mobius_sieve&lt;N&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++ i)</span><br><span class="line">        mu_sum[i] = mu_sum[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++ i)</span><br><span class="line">        h[i] = (<span class="keyword">int</span>) partition(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> T = read(); T --;) &#123;</span><br><span class="line">        <span class="keyword">auto</span> n = read(), m = read();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; fuck(n, m) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用线性筛维护 <span class="math inline">\(\text d(x)\)</span> 再求其前缀和 <span class="math inline">\(h(x)\)</span>，则需要引入新的线性筛：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> h[N + <span class="number">1</span>], mu_sum[N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mu_sec</span><span class="params">(llong l, llong r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mu_sum[r] - mu_sum[l - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> n&gt; <span class="function"><span class="keyword">auto</span> <span class="title">mobius_sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">array</span>&lt;<span class="keyword">int</span>, n + 1&gt; mu;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;n + 1&gt; vis;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) prime.push_back(i), mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; pp : prime) &#123;</span><br><span class="line">            <span class="keyword">auto</span> ipp = (llong)i * pp;</span><br><span class="line">            <span class="keyword">if</span> (ipp &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            vis[ipp] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pp == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[ipp] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> mu[ipp] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(ref(prime), ref(mu));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> n&gt; <span class="function"><span class="keyword">auto</span> <span class="title">divisor_sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">array</span>&lt;<span class="keyword">int</span>, n + 1&gt; d, c;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;n + 1&gt; vis;</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">1</span>, c[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            prime.push_back(i);</span><br><span class="line">            d[i] = <span class="number">2</span>, c[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; pp : prime) &#123;</span><br><span class="line">            <span class="keyword">auto</span> ipp = (llong)i * pp;</span><br><span class="line">            <span class="keyword">if</span> (ipp &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> vis[ipp] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pp == <span class="number">0</span>) &#123;</span><br><span class="line">                c[ipp] = c[i] + <span class="number">1</span>;</span><br><span class="line">                d[ipp] = d[i] / c[ipp] * (c[ipp] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> c[ipp] = <span class="number">1</span>, d[ipp] = d[i] * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(ref(prime), ref(d));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">llong <span class="title">fuck</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) swap(n, m);</span><br><span class="line">    llong ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (llong l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = min(&#123;n / (n / l), m / (m / l), (llong)n&#125;);</span><br><span class="line">        ret += (llong) mu_sec(l, r) * h[n / l] * h[m / l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> [prime, mu] = mobius_sieve&lt;N&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++ i)</span><br><span class="line">        mu_sum[i] = mu_sum[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;d = divisor_sieve&lt;N&gt;().second;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++ i)</span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] + d[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> T = read(); T --;) &#123;</span><br><span class="line">        <span class="keyword">auto</span> n = read(), m = read();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; fuck(n, m) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，肯定是要把两个线性筛写在一起的；像上面那样写的人脑子多半是有点大病（</p><p>于是，这个问题就解决了！</p><h2 id="后记">后记</h2><p>莫比乌斯反演还是比较有趣的；这里列举的也仅仅是最基础最基础的板子题，用来加深对这个公式的推导以及这种方法的理解——也就是说有趣的题还有很多……之后有时间做了再整理一篇吧（</p><h3 id="参考资料">参考资料</h3><ul><li><a href="https://oi-wiki.org/math/mobius/">莫比乌斯反演 - OI Wiki (oi-wiki.org)</a></li><li><a href="https://zhuanlan.zhihu.com/p/106775790">数论小白入门-- 莫比乌斯反演 - 知乎 (zhihu.com)</a></li><li><a href="https://www.cnblogs.com/peng-ym/p/8647856.html">莫比乌斯反演 - pengym - 博客园 (cnblogs.com)</a></li><li><a href="https://blog.csdn.net/jjikkollp/article/details/75675590?spm=1001.2014.3001.5501">【bzoj3994】约数个数和_喵~-CSDN博客</a></li><li><a href="https://www.luogu.com.cn/blog/An-Amazing-Blog/mu-bi-wu-si-fan-yan-ji-ge-ji-miao-di-dong-xi">莫比乌斯反演-让我们从基础开始 - An_Account 的博客 - 洛谷博客 (luogu.com.cn)</a></li><li><a href="https://zhuanlan.zhihu.com/p/135211767">形形色色的素数 -- 质数定理 - 知乎 (zhihu.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
            <tag> 莫比乌斯反演 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NTT 简单入门</title>
      <link href="/2021/The-concept-of-ntt-introducing-edition/"/>
      <url>/2021/The-concept-of-ntt-introducing-edition/</url>
      
        <content type="html"><![CDATA[<p>《退役人的自我救赎系列》——其二，也就是差不多算是初等数论的知识。</p><p>一句话简介：NTT 即<strong>快速数论变换</strong>，是一种可以在 <span class="math inline">\(n\log n\)</span> 的时间内完成多项式乘法的算法——的一部分。</p><h2 id="前置知识">前置知识</h2><h3 id="fft">FFT</h3><p>可以看我之前写过的一篇文章：<a href="https://shiraha.cn/2021/The-concept-of-fft-introducing-edition/">基础知识：FFT - 简单入门 - 七海の参考書 (shiraha.cn)</a></p><p>FFT 需要使用复数——这样就无法回避大量的浮点运算，然后精度就会爆炸；但是由于已经证明了在复数域内，具有循环卷积特性的唯一变换是<strong>DFT</strong>，所以在复数域中不存在具有循环卷积性质的更简单的离散正交变换；因此，我们就提出了以数论为基础的具有循环卷积性质的<strong>快速数论变换</strong>（<strong>NTT</strong>）：它的特点在于用有限域上的单位根来取代复平面上的单位根。</p><p>上面这段话是上网抄的。虽然我现在还理解不了，但是有一件事情十分清楚——和 FFT 利用单位根的性质减少运算量一样，NTT 利用了原根的性质来减少运算量，达到了同样的复杂度。</p><h3 id="阶">阶</h3><h4 id="定义">定义</h4><p>若 <span class="math inline">\(a, p\in\N^+\)</span> 满足 <span class="math inline">\(\gcd(a, p)=1\)</span> 和 <span class="math inline">\(p&gt;1\)</span>，那么：</p><p>对于使得 <span class="math inline">\(a^n \equiv 1\ \text{mod}\ p\)</span> 成立的最小的 <span class="math inline">\(n\)</span>，我们称之为 <strong><span class="math inline">\(a\)</span> 模 <span class="math inline">\(p\)</span> 的阶</strong>，记作 <span class="math inline">\(\delta_p(a)\)</span> 或 <span class="math inline">\(\text{ord}_pa\)</span>。</p><h4 id="性质">性质</h4><h5 id="对于-iin0-delta_pa所有的-a_i-textmod-p-都互不相同">1. 对于 <span class="math inline">\(i\in[0, \delta_p(a))\)</span>，所有的 <span class="math inline">\(a_i\ \text{mod}\ p\)</span> 都互不相同</h5><p>反证法：令有 <span class="math inline">\(j\ne k\)</span> 在该范围内并且模意义下相同，那么显然有 <span class="math inline">\(a^{|j-k|}\equiv1\ \text{mod}\ p\)</span>，且 <span class="math inline">\(|j-k|\)</span> 也属于该范围内，和定义矛盾。</p><h5 id="对于任何-an-equiv-1-textmod-p有-delta_pa-mid-n">2. 对于任何 <span class="math inline">\(a^n \equiv 1\ \text{mod}\ p\)</span>，有 <span class="math inline">\(\delta_p(a) \mid n\)</span></h5><p>显然。否则，把 <span class="math inline">\(n\)</span> 表示为 <span class="math inline">\(k\delta_p(a) + m\)</span>，显然 <span class="math inline">\(m \in (0, \delta_p(a))\)</span> 且满足 <span class="math inline">\(a^m \equiv 1\ \text{mod}\ p\)</span>，和性质 1 冲突。</p><p><strong>推论 1</strong>：若有 <span class="math inline">\(\gcd(a, p)=1\)</span>，那么 <span class="math inline">\(\delta_p(a) \mid \phi(p)\)</span></p><p>由欧拉定理可知：若 <span class="math inline">\(\gcd(a, p) = 1\)</span>，则 <span class="math inline">\(a^{\phi(p)} \equiv 1 \ \text{mod} \ p\)</span>。那么由性质 2 可得 <span class="math inline">\(\delta_p(a) \mid \phi(p)\)</span>。</p><h5 id="若-qinzp-是素数那么-delta_pqidelta_pq-iff-gcddelta_pq-i1">3. 若 <span class="math inline">\(q\in\Z^+\)</span>，<span class="math inline">\(p\)</span> 是素数，那么 <span class="math inline">\(\delta_p(q^i)=\delta_p(q) \iff \gcd(\delta_p(q), i)=1\)</span></h5><p>首先，我们记 <span class="math inline">\(q^i = q^{\gcd(\delta_p(q), i)\cdot r}\)</span>，显然 <span class="math inline">\(r=\frac i{\gcd(\delta_p(q), i)} \in\Z^+\)</span></p><p><del>由性质 2 和题设条件欧拉函数的性质，可得：<span class="math inline">\(\delta_p(q) \mid \phi(p) = (p-1)\)</span> （好像没用）</del></p><p>那么，有：<span class="math inline">\((g^i)^{\frac{\delta_p(q)}{\gcd(\delta_p(q), i)}}=(g^{\delta_p(q)})^{\frac i{\gcd(\delta_p(q), i)}}=g^{r\cdot \delta_p(q)}\equiv1\ \text{mod}\ p\)</span></p><hr /><p>假设 <span class="math inline">\(\gcd(\delta_p(q), i)\ne1\)</span>，那么 <span class="math inline">\(\gcd(\delta_p(q), i)&gt;1\)</span>，那么 <span class="math inline">\(\frac{\delta_p(q)}{\gcd(\delta_p(q), i)}&lt;\delta_p(q)\)</span></p><p>因为 <span class="math inline">\((g^i)^{\frac{\delta_p(q)}{\gcd(\delta_p(q), i)}}\equiv1\ \text{mod}\ p\)</span>，由性质 2 可得 <span class="math inline">\(\delta_p(q^i)\mid\frac{\delta_p(q)}{\gcd(\delta_p(q), i)}\)</span>，因此 <span class="math inline">\(\delta_p(q^i)\le\frac{\delta_p(q)}{\gcd(\delta_p(q), i)}\)</span></p><p>综上所述，可得：<span class="math inline">\(\delta_p(q^i)\le\frac{\delta_p(q)}{\gcd(\delta_p(q), i)}&lt;\delta_p(q)\)</span></p><p>即 <span class="math inline">\(\gcd(\delta_p(q), i)\ne1\Rightarrow \delta_p(q^i)\ne\delta_p(q)\)</span>，<strong>必要条件</strong>得证。</p><hr /><p>继承上述的证明，若有 <span class="math inline">\(\gcd(\delta_p(q), i)=1\)</span>，那么 <span class="math inline">\(\frac{\delta_p(q)}{\gcd(\delta_p(q), i)}=\delta_p(q)\)</span></p><p>由上述证明就可以得到：<span class="math inline">\(\delta_p(q^i)\le\delta_p(q)\)</span></p><p>因为 <span class="math inline">\(g^{i\cdot\frac{\delta_p(q)}{\gcd(\delta_p(q), i)}}\equiv1\ \text{mod}\ p\)</span>，和性质 2 和 4 可知：<span class="math inline">\(\delta_p(q)\mid i\cdot\delta_p(q^i)\)</span></p><p>因为 <span class="math inline">\(\gcd(\delta_p(q), i)=1\)</span>，所以 <span class="math inline">\(上式\Rightarrow\delta_p(q)\mid \delta_p(q^i)\)</span>，也就是 <span class="math inline">\(\delta_p(q)\le\delta_p(q^i)\)</span></p><p>综上所述，<span class="math inline">\(\because \delta_p(q^i)\le\delta_p(q) \and \delta_p(q)\le\delta_p(q^i)\)</span>，<span class="math inline">\(\therefore \delta_p(q)=\delta_p(q^i)\)</span></p><p>即 <span class="math inline">\(\gcd(\delta_p(q), i)=1\Rightarrow \delta_p(q^i)=\delta_p(q)\)</span>，<strong>充分条件</strong>得证。</p><hr /><p>综上所述，<span class="math inline">\(\gcd(\delta_p(q), i)=1\)</span> 是 <span class="math inline">\(\delta_p(q)=\delta_p(q^i)\)</span> 的<strong>充分必要条件</strong>。</p><h5 id="delta_pab-fracdelta_pagcddelta_pa-b其中-a-p-b-in-z">4. <span class="math inline">\(\delta_p(a^b) = \frac{\delta_p(a)}{\gcd(\delta_p(a), b)}\)</span>，其中 <span class="math inline">\(a, p, b \in \Z^+\)</span></h5><p>由阶的定义可知：<span class="math inline">\((a^b)^{\delta_p(a^b)} \equiv a^{b\cdot\delta_p(a^b)}\equiv1\ \text{mod} \ p\)</span></p><p>又由性质 2，可以得到：<span class="math inline">\(\delta_p(a)\mid b\cdot\delta_p(a^b) \Rightarrow \frac{\delta_p(a)}{\gcd(\delta_p(a), b)}\mid \frac{b}{\gcd(\delta_p(a), b)}\cdot\delta_p(a^b)\)</span></p><p>显然，因为 <span class="math inline">\(\gcd(\frac{\delta_p(a)}{\gcd(\delta_p(a), b)}, \frac{b}{\gcd(\delta_p(a), b)})=1\)</span>，因此：<span class="math inline">\(上式\Rightarrow \frac{\delta_p(a)}{\gcd(\delta_p(a), b)}\mid\delta_p(a^b)\)</span></p><p>又因为定义：<span class="math inline">\(a^{b\cdot\frac{\delta_p(a)}{\gcd(\delta_p(a), b)}}\equiv a^{\delta_p(a)\cdot\frac{b}{\gcd(\delta_p(a), b)}} \equiv 1\ \text{mod}\ p\)</span>，<span class="math inline">\(\frac{b}{\gcd(\delta_p(a), b)}\)</span> 显然是整数。</p><p>所以由性质 2 可得：<span class="math inline">\(\delta_p(a^b)\mid\frac{\delta_p(a)}{\gcd(\delta_p(a), b)}\)</span></p><p>综上所述：<span class="math inline">\(\because \frac{\delta_p(a)}{\gcd(\delta_p(a), b)}\mid\delta_p(a^b)\ \and\ \delta_p(a^b)\mid\frac{\delta_p(a)}{\gcd(\delta_p(a), b)}\)</span>，<span class="math inline">\(\therefore \delta_p(a^b)=\frac{\delta_p(a)}{\gcd(\delta_p(a), b)}\)</span></p><h5 id="p-in-n-a-binzgcda-p-gcdb-p-1那么-gcddelta_padelta_pb1-iff-delta_pabdelta_padelta_pb">5. <span class="math inline">\(p \in \N^+,\ a, b\in\Z\)</span>，<span class="math inline">\(\gcd(a, p) = \gcd(b, p) = 1\)</span>，那么 <span class="math inline">\(\gcd(\delta_p(a),\delta_p(b))=1\)</span> <span class="math inline">\(\iff\)</span> <span class="math inline">\(\delta_p(ab)=\delta_p(a)\delta_p(b)\)</span></h5><p>由定义可得 <span class="math inline">\(a^{\delta_p(a)}\equiv1\ \text{mod}\ p\)</span> 和 <span class="math inline">\(b^{\delta_p(b)}\equiv1\ \text{mod}\ p\)</span>，那么：<span class="math inline">\((ab)^{\text{lcm}(\delta_p(a),\delta_p(b))}\equiv1\ \text{mod}\ p\)</span></p><p>由性质 2，可得：<span class="math inline">\(\delta_p(ab)\mid\text{lcm}(\delta_p(a),\delta_p(b))\)</span></p><p>设 <span class="math inline">\(\delta_p(ab)=\delta_p(a)\delta_p(b)\)</span> 成立，那么：<span class="math inline">\(上式 \Rightarrow \delta_p(a)\delta_p(b)\mid\text{lcm}(\delta_p(a),\delta_p(b))\)</span></p><p>又因为 <span class="math inline">\(\text{lcm}(\delta_p(a),\delta_p(b)) = \frac{\delta_p(a)\delta_p(b)}{\gcd(\delta_p(a),\delta_p(b))}\)</span>，可得 <span class="math inline">\(\gcd(\delta_p(a),\delta_p(b))=1\)</span></p><p>即 <span class="math inline">\(\delta_p(ab)=\delta_p(a)\delta_p(b)\)</span> <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\gcd(\delta_p(a),\delta_p(b))=1\)</span>，<strong>必要性</strong>得证。</p><hr /><p>又由阶的定义：<span class="math inline">\((ab)^{\delta_p(ab)}\equiv1\ \text{mod}\ p\)</span>，可以进行如下推导： <span class="math display">\[(ab)^{\delta_p(ab)}\equiv(ab)^{\delta_p(ab)\delta_p(b)}\equiv a^{\delta_p(ab)\delta_p(b)}\cdot b^{\delta_p(ab)\delta_p(b)}\equiv a^{\delta_p(ab)\delta_p(b)}\cdot 1\equiv1\ \text{mod}\ p\]</span> 由性质 2，可得：<span class="math inline">\(\delta_p(a)\mid\delta_p(ab)\delta_p(b)\)</span>；因为 <span class="math inline">\(\gcd(\delta_p(a),\delta_p(b))=1\)</span>，所以 <span class="math inline">\(\delta_p(a)\mid\delta_p(ab)\)</span></p><p>同理，可得：<span class="math inline">\(\delta_p(b)\mid\delta_p(ab)\)</span>；因为 <span class="math inline">\(\gcd(\delta_p(a),\delta_p(b))=1\)</span>，所以 <span class="math inline">\(\delta_p(a)\delta_p(b)\mid\delta_p(ab)\)</span></p><p>由定理可得：<span class="math inline">\(a^{\delta_p(a)}\equiv a^{\delta_p(a)\delta_p(b)}\equiv1\ \text{mod}\ p\)</span> 和 <span class="math inline">\(b^{\delta_p(b)}\equiv b^{\delta_p(a)\delta_p(b)}\equiv1\ \text{mod}\ p\)</span>，因此： <span class="math display">\[a^{\delta_p(a)\delta_p(b)} \cdot b^{\delta_p(a)\delta_p(b)} \equiv (ab)^{\delta_p(a)\delta_p(b)} \equiv1\ \text{mod}\ p\]</span> 由性质 2，可得 <span class="math inline">\(\delta_p(ab)\mid\delta_p(a)\delta_p(b)\)</span>；因此，可证 <span class="math inline">\(\delta_p(ab)=\delta_p(a)\delta_p(b)\)</span></p><p>即 <span class="math inline">\(\gcd(\delta_p(a),\delta_p(b))=1\)</span> <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\delta_p(ab)=\delta_p(a)\delta_p(b)\)</span>，<strong>充分性</strong>得证。</p><hr /><p>综上所述：<span class="math inline">\(\gcd(\delta_p(a),\delta_p(b))=1\)</span> 是 <span class="math inline">\(\delta_p(ab)=\delta_p(a)\delta_p(b)\)</span> 的<strong>充分必要条件</strong>。</p><h3 id="原根">原根</h3><h4 id="定义-1">定义</h4><p><span class="math inline">\(m \in \N^+,g\in\Z\)</span>，若有 <span class="math inline">\(\delta_m(g)=\phi(m)\)</span> 且 <span class="math inline">\(\gcd(m,g)=1\)</span>，那么称 <span class="math inline">\(g\)</span> 是模 <span class="math inline">\(m\)</span> 的一个原根。</p><p>若整数 <span class="math inline">\(g\)</span> 模正整数 <span class="math inline">\(m\)</span> 的阶（这要求它们互质）和 <span class="math inline">\(\phi(m)\)</span> 相等，那么 <span class="math inline">\(g\)</span> 是模 <span class="math inline">\(m\)</span> 的一个原根。</p><h4 id="性质-1">性质</h4><p>……我一定是哪里变得奇怪了才会想着抄录全部性质并键证它们== 哪天闲的没事干再补全吧（）</p><figure><img src="https://i.loli.net/2021/07/13/H9FqkSnMxPXpQr4.jpg" class="lazyload" data-srcset="https://i.loli.net/2021/07/13/H9FqkSnMxPXpQr4.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="7Q6A_S_AWQFY__Q5NEZI_E.jpg" /><figcaption aria-hidden="true">7Q6A_S_AWQFY__Q5NEZI_E.jpg</figcaption></figure><h4 id="定理">定理</h4><h5 id="原根的存在条件">原根的存在条件</h5><p>判断对于一个整数 <span class="math inline">\(p\)</span> 是否存在原根：</p><ul><li>对于整数 <span class="math inline">\(p=2,4\)</span>，它们的原根显然存在</li><li>奇素数 <span class="math inline">\(p\)</span> 的原根存在；对于 <span class="math inline">\(\alpha\in\N^+\)</span>，<span class="math inline">\(p^\alpha\)</span> 的原根存在</li><li>对于奇素数 <span class="math inline">\(p\)</span>，<span class="math inline">\(\alpha\in\N^+\)</span>，<span class="math inline">\(2p^\alpha\)</span> 的原根存在</li><li>若 <span class="math inline">\(p\)</span> 不符合上述的任何条件，则对于 <span class="math inline">\(\forall a\in\Z\)</span> 和 <span class="math inline">\(\gcd(a, p)=1\)</span>，都有 <span class="math inline">\(\delta_p(a) &lt; \phi(p)\)</span>，即 <span class="math inline">\(p\)</span> 不存在原根</li></ul><p>与之相关的一些定理：</p><ul><li>对于奇素数 <span class="math inline">\(p\)</span>，若 <span class="math inline">\(g\)</span> 是其原根，则 <span class="math inline">\(g\)</span> <strong>或者</strong> <span class="math inline">\(g+p\)</span> 是 <span class="math inline">\(p^2\)</span> 的原根</li><li>对于奇素数 <span class="math inline">\(p\)</span>，<span class="math inline">\(\alpha \in \N^+\)</span>，若 <span class="math inline">\(g\)</span> 是模 <span class="math inline">\(p^\alpha\)</span> 的原根，则 <span class="math inline">\(g\)</span> <strong>和</strong> <span class="math inline">\(g+p^\alpha\)</span> 中的奇数是 <span class="math inline">\(2p^\alpha\)</span> 的原根</li></ul><p>简单地说，对于奇素数 <span class="math inline">\(p\)</span>，<span class="math inline">\(\alpha\in\N^+\)</span>，有原根的数包括：<span class="math inline">\(\{2,4,p^\alpha,2p^\alpha\}\)</span></p><h5 id="求法">求法</h5><p>对于一个数 <span class="math inline">\(n\)</span>，如果它存在原根，那么首先找到它的最小原根并令其为 <span class="math inline">\(g\)</span>；那么，<span class="math inline">\(n\)</span> 的所有原根都可以表示为 <span class="math inline">\(g^k\)</span>，<span class="math inline">\(k\)</span> 是正整数并且满足 <span class="math inline">\(\gcd(\phi(n),k)=1\)</span>，共 <span class="math inline">\(\phi(\phi(n))\)</span> 个。</p><p>最小原根 <span class="math inline">\(g\)</span> 的大小已经证明是不会超过 <span class="math inline">\(\sqrt[4]{n}\)</span> 的，所以可以通过暴力枚举来确定，然后按照定义要求来验证某个数字是否是原根——但是定义要求 <span class="math inline">\(\delta_n(g)=\phi(n)\)</span>，我们无法对于每一个备选 <span class="math inline">\(g\)</span> 都枚举 <span class="math inline">\(i\in[1,\phi(n))\)</span> 来计算 <span class="math inline">\(g^i\)</span>，观察它不和 <span class="math inline">\(1\)</span> 同余来判定它是阶。</p><p>注意到阶的性质 2 的推论 1，我们可以知道 <span class="math inline">\(\delta_n(g)\mid\phi(n)\)</span>；也就是说，对于备选 <span class="math inline">\(g\)</span>，如果它模 <span class="math inline">\(n\)</span> 下的阶不满足原根的要求，而是另有 <span class="math inline">\(k &lt; \phi(n)\)</span> 存在，那么它满足 <span class="math inline">\(k\mid\phi(n)\)</span>；那么，我们只需要检查 <span class="math inline">\(\phi(n)\)</span> 的所有<strong>真</strong>因数就可以找到可能存在的 <span class="math inline">\(k\)</span> 了，而不需要枚举整个 <span class="math inline">\([1,\phi(n))\)</span>；具体地，若 <span class="math inline">\(\phi(n)\)</span> 的质因子被记为 <span class="math inline">\(p_1,\dots,p_r\)</span>，那么实际上我们只需要检查所有的 <span class="math inline">\(\frac{\phi(n)}{p_i}\)</span> 即可——它覆盖了所有的真因数的倍数，检查它们等同于检查了所有的真因数。</p><p>综上所述，找到最小原根 <span class="math inline">\(g\)</span> 所需要的时间是 <span class="math inline">\(\mathcal{O}(\sqrt[4]n\cdot\log n)\)</span> 的；利用最小原根 <span class="math inline">\(g\)</span> 求出所有原根所需要的时间是 <span class="math inline">\(\mathcal O (\phi(n)\cdot\log n^{\frac{\phi(n)}4})\)</span> 的。完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> n&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> &amp;<span class="title">linear_sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">array</span>&lt;<span class="keyword">int</span>, n + 1&gt; vis;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            prime.push_back(i), vis[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pp : prime) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((llong) i * pp &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            vis[i * pp] = pp;</span><br><span class="line">            <span class="keyword">if</span> (i % pp == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">auto</span> ret = <span class="built_in">make_pair</span>(ref(prime), ref(vis));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">llong <span class="title">fast_pow</span><span class="params">(llong a, llong b, llong mod)</span> </span>&#123;</span><br><span class="line">    llong ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1u</span>) ans = (ans * a) % mod;</span><br><span class="line">        a = (a * a) % mod, b &gt;&gt;= <span class="number">1u</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_primitive_root</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;de, llong g,</span></span></span><br><span class="line"><span class="function"><span class="params">        llong phi, llong n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fast_pow(g, phi, n) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> none_of(de.begin(), de.end(), [&amp;](<span class="keyword">int</span> p) &#123;</span><br><span class="line">            <span class="keyword">return</span> fast_pow(g, phi / p, n) == <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> [p, dc] = linear_sieve&lt;N&gt;();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> decompose = [&amp;dc = dc]</span><br><span class="line">            (llong x, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;de) &#123;</span><br><span class="line">        de.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ii = x; ii &gt; <span class="number">1</span>;) &#123;</span><br><span class="line">            de.insert(dc[ii]);</span><br><span class="line">            ii /= dc[ii];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;N&gt; has_primitive_root;</span><br><span class="line">    has_primitive_root.<span class="built_in">set</span>(<span class="number">1</span>).<span class="built_in">set</span>(<span class="number">2</span>).<span class="built_in">set</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (llong pp : p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pp == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> now = pp; now &lt; N; now *= pp) &#123;</span><br><span class="line">            has_primitive_root.<span class="built_in">set</span>(now);</span><br><span class="line">            <span class="keyword">if</span> (now * <span class="number">2</span> &lt; N) has_primitive_root.<span class="built_in">set</span>(now * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;llong&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> T = read(); T--;) &#123;</span><br><span class="line">        <span class="keyword">auto</span> n = read(), d = read(), phi = n;</span><br><span class="line">        <span class="keyword">if</span> (has_primitive_root[n]) &#123;</span><br><span class="line">            <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; de_n, de_phi;</span><br><span class="line">            decompose(n, de_n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> pi : de_n)</span><br><span class="line">                (phi /= pi) *= (pi - <span class="number">1</span>);</span><br><span class="line">            decompose(phi, de_phi);</span><br><span class="line">            llong g = <span class="number">0</span>, lim = n;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lim; ++ i)</span><br><span class="line">                <span class="keyword">if</span> (check_primitive_root(de_phi, i, phi, n))</span><br><span class="line">                &#123; g = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (!g) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> gi = g, i = <span class="number">1l</span>l;</span><br><span class="line">                 i &lt;= phi; ++ i, (gi *= g) %= n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (gcd(i, phi) == <span class="number">1</span>)</span><br><span class="line">                    ans.push_back(gi);</span><br><span class="line">            &#125;</span><br><span class="line">            sort(ans.begin(), ans.end());</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> id = d - <span class="number">1</span>; id &lt; ans.size(); id += d)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; ans[id] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先筛出质数，再筛出所有的可能有原根的数——这一步是 <span class="math inline">\(\mathcal O (n\log n)\)</span> 的；对于一个有原根的数 <span class="math inline">\(n\)</span>，首先利用筛的结果（当然也可以直接用线性筛直接算好了存起来）根据定义求出 <span class="math inline">\(\phi(n)\)</span>，然后再利用筛维护的数据（或者埃氏筛直接存起来）分解其质因数存好备用；暴力枚举，并且利用上面说的方法来检查其是否为原根，求出最小原根——这一步是理论 <span class="math inline">\(\mathcal O (\sqrt[4]n\log n)\)</span> 的；最后再利用最小原根生成所有的原根：这需要重复 <span class="math inline">\(\phi(n)\)</span> 次，每次使用 <span class="math inline">\(\gcd\)</span> 检查——这一步是 <span class="math inline">\(\mathcal O(\phi(n)\log n)\)</span> 的。</p><p>上面的代码可以通过 <a href="https://www.luogu.com.cn/problem/P6091">P6091 【模板】原根</a>。需要注意虽然最小原根有这个理论界限，但是求的时候只遍历到 <span class="math inline">\(\lceil n^\frac14\rceil\)</span> 似乎会暴毙……</p><h3 id="阶和原根">阶和原根</h3><p>那么如何理解这两个抽象的概念呢？</p><h2 id="后记">后记</h2><h3 id="参考资料">参考资料</h3><ul><li><a href="https://www.luogu.com.cn/blog/attack/solution-p38032">题解 P3803 【【模板】多项式乘法（NTT）】2 - attack 的博客 - 洛谷博客 (luogu.com.cn)</a></li><li><a href="https://zhuanlan.zhihu.com/p/347726949">快速数论变换（NTT）超详解 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/349128258">阶与原根 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/166043237">算法学习笔记(40): 原根 - 知乎 (zhihu.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
            <tag> FFT </tag>
            
            <tag> NTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数论分块入门</title>
      <link href="/2021/The-concept-of-number-theory-partition/"/>
      <url>/2021/The-concept-of-number-theory-partition/</url>
      
        <content type="html"><![CDATA[<p>《退役人的自我救赎系列》——其一，也就是基础的数论知识。</p><h2 id="整除分块">整除分块</h2><blockquote><p>求解 <span class="math inline">\(\sum_{i=1}^n \frac{n}i\)</span> 的值，<span class="math inline">\(n\)</span> 是 <span class="math inline">\(10^{10}\)</span> 级别。</p></blockquote><p>暴力是 <span class="math inline">\(\mathcal{O}(n)\)</span> 的，死了；但是 <span class="math inline">\(\lfloor \frac{n}i\rfloor\)</span> 的结果是根据块状分布的，且最多只会有 <span class="math inline">\(2\sqrt{n}\)</span> 种不同的值。因此，我们可以利用这个性质得到一个 <span class="math inline">\(\mathcal{O}(\sqrt{n})\)</span> 的算法。</p><p>直接地说，<span class="math inline">\(\lfloor \frac{n}i\rfloor\)</span> 的值在一段连续的区间内具有相同的值，且这个区间具有右端点 <span class="math inline">\(\lfloor \frac{n}{\lfloor\frac{n}i\rfloor}\rfloor\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">    r = min(n / (n / l), n);</span><br><span class="line">    procedure(l, r);<span class="comment">// [l, r] 的值是 n / l</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的写法需要注意的就是 <code>n / l</code> 可能为 0 导致除法除零，一般来说需要特判一下。</p><h3 id="cqoi2007余数求和"><a href="https://www.luogu.com.cn/problem/P2261">CQOI2007：余数求和</a></h3><p>那来点模板题。求的是模数和，看起来和上面的整除分块没有什么关系，但是： <span class="math display">\[\sum_{i=1}^n k\mod i = \sum_{i=1}^n k - \lfloor\frac{k}i\rfloor i = nk - \sum_{i=1}^n \lfloor\frac{k}i\rfloor i\]</span> 这样处理之后，右边的部分仍然不是我们熟悉的整出分块形式，所以还需要进一步处理；</p><p>我们已经知道了 <span class="math inline">\(\sum_{i=1}^n \lfloor\frac{k}i\rfloor\)</span> 在一定范围内具有相同的值，那么在块内我们令 <span class="math inline">\(T_j = \lfloor\frac{k}j\rfloor\)</span>，那么就可以进行如下形式的化简: <span class="math display">\[\sum_{i=1}^n \lfloor\frac{k}i\rfloor i = \sum_{i=1}^n T_i\cdot i = \sum_j\sum_{i=L}^R T_i\cdot \sum_{i=L}^R i\]</span> 这样，在每一个分块内，左边是整除分块，右边是一个公差为 1 的等差数列；块内只需要一个定值和一个很好求的和，就可以分块来做了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">auto</span> n = read(), k = read();</span><br><span class="line">    <span class="keyword">auto</span> ans = n * k;</span><br><span class="line">    <span class="keyword">for</span> (llong l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k / l) r = min(k / (k / l), n);</span><br><span class="line">        <span class="keyword">else</span> r = n;</span><br><span class="line">        ans -= (r - l + <span class="number">1</span>) * (l + r) / <span class="number">2</span> * (k / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，现在你已经学会了数论分块了！</p><h3 id="清华集训2012模积和"><a href="https://www.luogu.com.cn/problem/P2260">清华集训2012：模积和</a></h3><p>题目是要求了 <span class="math inline">\(i\ne j\)</span>，所以我们需要转化为下面的形式： <span class="math display">\[\sum_{i=1}^n\sum_{j=1}^m[i\ne j](n\ \text{mod}\ i)(m\ \text{mod}\ j) \\= \sum_{i=1}^n\sum_{j=1}^m(n\ \text{mod}\ i)(m\ \text{mod}\ j) - \sum_{i=1}^{\min(n, m)}(n\ \text{mod}\ i)(m\ \text{mod}\ i)\]</span> 然后，先处理上述式子的第一项；最直接的做法就是拆开化简： <span class="math display">\[ {align}\begin{align}原式 &amp;= \sum_{i=1}^n\sum_{j=1}^m (n-\lfloor\frac{n}i\rfloor i)(m - \lfloor\frac{m}j\rfloor j) \\&amp;= \sum_{i=1}^n\sum_{j=1}^m nm - \lfloor\frac{n}i\rfloor im - \lfloor\frac{m}j\rfloor jn + \lfloor\frac{m}j\rfloor\lfloor\frac{n}i\rfloor i j \\&amp;= n^2m^2 - nm^2\sum_{i=1}^n\lfloor\frac{n}i\rfloor i-n^2m\sum_{j=1}^m\lfloor\frac{m}j\rfloor j + nm\sum_{i=1}^n\lfloor\frac{n}i\rfloor i\cdot\sum_{j=1}^m\lfloor\frac{m}j\rfloor j\end{align}\]</span> 当然，也可以类似于上面求余数和的做法那样直接拆成： <span class="math display">\[\sum_{i=1}^n(n\ \text{mod}\ i) \cdot \sum_{j=1}^m(m\ \text{mod}\ j)\]</span> 也可以拆出相同的结果。</p><p>总而言之，上面的式子就被拆成了一些和上面模数求和一样的形式的组合，只需要分别求出两个互不相关的部分的和就可以算出题目种式子的左边部分；接下来处理右边部分，我们先约定 <span class="math inline">\(k = \min(n, m)\)</span>： <span class="math display">\[\begin{align}原式 &amp;= \sum_{i=1}^k (n-\lfloor\frac{n}i\rfloor i)(m - \lfloor\frac{m}i\rfloor i) \\&amp;= \sum_{i=1}^k(nm - m\lfloor\frac{n}i\rfloor i - n\lfloor\frac{m}i\rfloor i + \lfloor\frac{m}i\rfloor\lfloor\frac{n}i\rfloor i^2) \\&amp;= knm - m\sum_{i=1}^k\lfloor\frac{n}i\rfloor i - n\sum_{i=1}^k\lfloor\frac{m}i\rfloor i + \sum_{i=1}^k\lfloor\frac{n}i\rfloor \lfloor\frac{m}i\rfloor i^2\end{align}\]</span> 还是一样可以使用模数分块的方法求出。</p><p>此外，提一下考研常用公式：<span class="math inline">\(\sum_{i=1}^n i^2 = \frac16n(n+1)(2n+1)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> lll mod = <span class="number">19940417</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">lll <span class="title">fast_pow</span><span class="params">(lll a, lll b = mod - <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line">    lll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) (ret *= a) %= mod;</span><br><span class="line">        (a *= a) %= mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret %= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">llong <span class="title">euler_phi</span><span class="params">(llong n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span> (llong i = <span class="number">2</span>; i * i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!(n % i)) &#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (!(n % i)) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    lll n = read(), m = read(), k = min(n, m);</span><br><span class="line">    <span class="keyword">auto</span> nm = n * m % mod, n2m = nm * n % mod;</span><br><span class="line">    <span class="keyword">auto</span> n2m2 = nm * nm % mod, nm2 = nm * m % mod;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> calc = [](lll n, lll k) &#123;</span><br><span class="line">        lll ret = <span class="number">0</span>;</span><br><span class="line">        minimize(n, k);</span><br><span class="line">        <span class="keyword">for</span> (lll l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k / l) r = min(k / (k / l), n);</span><br><span class="line">            <span class="keyword">else</span> r = n;</span><br><span class="line">            <span class="keyword">auto</span> sum = (r - l + <span class="number">1</span>) * (l + r) / <span class="number">2</span> % mod;</span><br><span class="line">            (ret += sum * (k / l) % mod) %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret %= mod;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> sum_mod = [&amp;calc](lll n, lll k) &#123;</span><br><span class="line">        <span class="keyword">return</span> (n * k % mod - calc(n, k) + mod) % mod;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> phi_mod = euler_phi(mod) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> inv6 = fast_pow(<span class="number">6</span>, phi_mod);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> sum_i2 = [inv6](lll n) &#123;</span><br><span class="line">        <span class="keyword">return</span> n * (n + <span class="number">1</span>) % mod * (<span class="number">2</span> * n + <span class="number">1</span>) % mod * inv6 % mod;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> lp = sum_mod(n, n) * sum_mod(m, m) % mod;</span><br><span class="line">    <span class="keyword">auto</span> knm = k * nm % mod, rp = knm;</span><br><span class="line">    <span class="keyword">for</span> (lll l = <span class="number">1</span>, r; l &lt;= k; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n / l &amp;&amp; m / l)</span><br><span class="line">            r = min(&#123;n / (n / l), m / (m / l), k&#125;);</span><br><span class="line">        <span class="keyword">else</span> r = k;</span><br><span class="line">        <span class="keyword">auto</span> si2 = (sum_i2(r) - sum_i2(l - <span class="number">1</span>) + mod) % mod;</span><br><span class="line">        <span class="keyword">auto</span> inm = (n / l) * (m / l) % mod;</span><br><span class="line">        (rp += inm * si2 % mod) %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> ckn = calc(k, n), ckm = calc(k, m);</span><br><span class="line">    <span class="keyword">auto</span> tmp = (m * ckn % mod + n * ckm % mod) % mod;</span><br><span class="line">    rp = (rp + mod - tmp) % mod;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; llong((lp + mod - rp) % mod) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，<span class="math inline">\(19940417 = 7\times2848631\)</span>，并不是一个质数，所以不能用费马小定理求出模它意义下的逆元；但是 <span class="math inline">\(6\)</span> 和它互质，故应当使用<strong>欧拉定理</strong>：</p><blockquote><p><strong>欧拉定理</strong>：若 <span class="math inline">\(\gcd(a, m) = 1\)</span>，则 <span class="math inline">\(a^{\phi(m)} \equiv 1 \ (\text{mod} \ m)\)</span>。</p><p><strong>欧拉函数</strong>：<span class="math inline">\(\phi(n)\)</span>，表示了小于等于 <span class="math inline">\(n\)</span> 的正整数和 <span class="math inline">\(n\)</span> 互质的整数的个数。</p><p><strong>标准分解式</strong>：将质因数分解的结果按照大小，由小到大排列，并将相同质因数连乘以指数形式表示。</p><p>如果一个数字的标准分解式可以写成：<span class="math inline">\(n = p_1^{k_1}p_2^{k_2}\cdots p_r^{k_r}\)</span>，那么： <span class="math display">\[\phi(n) = \prod_{i=1}^rp_i^{k_i-1}(p_i-1)=\prod_{p|n}p^{\alpha_p-1}(p-1)=n\prod_{p|n}(1-\frac1p)\]</span> 可以使用上述公式计算欧拉函数。</p></blockquote><p>求解单个欧拉函数值，可以使用 Pollard Rho 算法优化后根据定义求解；多个欧拉函数值则可以使用线性筛求解。</p><h3 id="实战">实战（？）</h3><blockquote><p>给了 <span class="math inline">\(x_1, x_2, y_1, y_2\)</span>，求解： <span class="math display">\[\sum_{i=x_1}^{x_2}\sum_{j=y_1}^{y_2}(\lfloor\frac{i}{x_1}\rfloor+\lfloor\frac{x_2}i\rfloor+\lfloor\frac{j}{y_1}\rfloor+\lfloor\frac{y_2}j\rfloor)^2\]</span> 结果对 <span class="math inline">\(10^9+7\)</span> 取模。</p></blockquote><p>这是 CCPC 湘潭邀请赛 2021 的 C 题，无处补题。</p><figure><img src="https://i.loli.net/2021/07/08/ca4mpvGDIfHUPWn.jpg" class="lazyload" data-srcset="https://i.loli.net/2021/07/08/ca4mpvGDIfHUPWn.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="___MEL_9_R6YR3N0GK8937H.jpg" /><figcaption aria-hidden="true">___MEL_9_R6YR3N0GK8937H.jpg</figcaption></figure><p>首先还是直接把它们乘开： <span class="math display">\[\begin{align}原式 =&amp; (y_2-y_1+1)\sum_{i=x_1}^{x_2}(\lfloor\frac{i}{x_1}\rfloor+\lfloor\frac{x_2}i\rfloor)^2 + (x_2-x_1+1)\sum_{j=y_1}^{y_2}(\lfloor\frac{j}{y_1}\rfloor+\lfloor\frac{y_2}j\rfloor)^2 + \\ &amp;2\sum_{i=x_1}^{x_2}\sum_{j=y_1}^{y_2}(\lfloor\frac{i}{x_1}\rfloor+\lfloor\frac{x_2}i\rfloor)(\lfloor\frac{j}{y_1}\rfloor+\lfloor\frac{y_2}j\rfloor) \end{align}\]</span> 可以看出前两项是一类的，第三项是另一类的；其中，前两项又可以进行这样的拆分： <span class="math display">\[原式 = \sum_{i=x_1}^{x_2}\lfloor\frac{i}{x_1}\rfloor^2 + 2\sum_{i=x_1}^{x_2}\lfloor\frac{i}{x_1}\rfloor\lfloor\frac{x_2}i\rfloor + \sum_{i=x_1}^{x_2}\lfloor\frac{x_2}i\rfloor^2\]</span> 又可以分成三项；其中第三项是我们这里提到的整除分块问题，第一项是我们再熟悉不过的“分块”，可以直接计算；那么问题就变成了中间的一部分——在这里我想要说的是这并没有什么特殊的性质（或者是我没有发现），只需要分块再分块然后直接计算就可以了。</p><p>那么回到第一组式子的第三项；注意到 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 是互不相关的，所以直接分别计算然后乘起来就行： <span class="math display">\[原式 = \sum_{i=x_1}^{x_2}(\lfloor\frac{i}{x_1}\rfloor+\lfloor\frac{x_2}i\rfloor)\cdot\sum_{j=y_1}^{y_2}(\lfloor\frac{j}{y_1}\rfloor+\lfloor\frac{y_2}j\rfloor) \]</span> 只需要分别计算后求和，之后再在模意义下乘起来就得到了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> llong mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> lll <span class="title">fast_pow</span><span class="params">(lll a, lll b = mod - <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line">    lll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) (ret *= a) %= mod;</span><br><span class="line">        (a *= a) %= mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret %= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> lll inv6 = fast_pow(<span class="number">6</span>), inv2 = fast_pow(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">lll <span class="title">sum_i2</span><span class="params">(lll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n * (n + <span class="number">1</span>) % mod * (<span class="number">2</span> * n + <span class="number">1</span>) % mod * inv6 % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">lll <span class="title">sum_i</span><span class="params">(lll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n + <span class="number">1</span>) * n % mod * inv2 % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">lll <span class="title">xi2</span><span class="params">(lll l, lll n, lll k)</span> </span>&#123;</span><br><span class="line">    lll ret = <span class="number">0</span>;</span><br><span class="line">    minimize(n, k);</span><br><span class="line">    <span class="keyword">for</span> (lll r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k / l) r = min(k / (k / l), n);</span><br><span class="line">        <span class="keyword">else</span> r = n;</span><br><span class="line">        <span class="keyword">auto</span> val = (k / l) * (k / l) % mod;</span><br><span class="line">        (ret += (r - l + <span class="number">1</span>) * val % mod) %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">lll <span class="title">xi</span><span class="params">(lll l, lll n, lll k)</span> </span>&#123;</span><br><span class="line">    lll ret = <span class="number">0</span>;</span><br><span class="line">    minimize(n, k);</span><br><span class="line">    <span class="keyword">for</span> (lll r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k / l) r = min(k / (k / l), n);</span><br><span class="line">        <span class="keyword">else</span> r = n;</span><br><span class="line">        (ret += (r - l + <span class="number">1</span>) * (k / l) % mod) %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">lll <span class="title">sum_ix</span><span class="params">(lll n, lll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> m = n % x + <span class="number">1</span>, d = n / x;</span><br><span class="line">    <span class="keyword">if</span> (!d) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    lll ret = x * sum_i(d - <span class="number">1</span>) % mod;</span><br><span class="line">    (ret += m * d % mod) %= mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">lll <span class="title">sum_ix2</span><span class="params">(lll n, lll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> m = n % x + <span class="number">1</span>, d = n / x;</span><br><span class="line">    <span class="keyword">if</span> (!d) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    lll ret = x * sum_i2(d - <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">auto</span> d2 = d * d % mod;</span><br><span class="line">    (ret += m * d2 % mod) %= mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">lll <span class="title">ix</span><span class="params">(lll l, lll r, lll k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (sum_ix(r, k) + mod - sum_ix(l - <span class="number">1</span>, k)) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">lll <span class="title">ix2</span><span class="params">(lll l, lll r, lll k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (sum_ix2(r, k) + mod - sum_ix2(l - <span class="number">1</span>, k)) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">lll <span class="title">ix_xi</span><span class="params">(lll l, lll n, lll x1, lll x2)</span> </span>&#123;</span><br><span class="line">    lll ret = <span class="number">0</span>;</span><br><span class="line">    minimize(n, x2);</span><br><span class="line">    <span class="keyword">for</span> (lll r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x2 / l) r = min(x2 / (x2 / l), n);</span><br><span class="line">        <span class="keyword">else</span> r = n;</span><br><span class="line">        <span class="keyword">auto</span> tmp = ix(l, r, x1);</span><br><span class="line">        (ret += tmp * (x2 / l) % mod) %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> T = read(); T --;) &#123;</span><br><span class="line">        <span class="keyword">auto</span> x1 = read(), x2 = read(), y1 = read(), y2 = read();</span><br><span class="line">        <span class="keyword">auto</span> dy = y2 - y1 + <span class="number">1</span>, dx = x2 - x1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> part1 = ix2(x1, x2, x1) + xi2(x1, x2, x2) + ix_xi(x1, x2, x1, x2) * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> part2 = ix2(y1, y2, y1) + xi2(y1, y2, y2) + ix_xi(y1, y2, y1, y2) * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> part3L = (ix(x1, x2, x1) + xi(x1, x2, x2)) % mod;</span><br><span class="line">        <span class="keyword">auto</span> part3R = (ix(y1, y2, y1) + xi(y1, y2, y2)) % mod;</span><br><span class="line">        <span class="keyword">auto</span> part3 = part3L * part3R % mod * <span class="number">2</span> % mod;</span><br><span class="line">        <span class="keyword">auto</span> part12 = (part1 %= mod) * dy % mod + (part2 %= mod) * dx % mod;</span><br><span class="line">        <span class="keyword">auto</span> ans = (part12 + part3) % mod;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (llong)ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已通过五组测试样例。</p><h2 id="后记">后记</h2><h3 id="参考资料">参考资料</h3><ul><li><a href="https://www.cnblogs.com/GDOI2018/p/13541520.html#:~:text=什么是二维数论分块？%20举个例子，如果我们要在求%20⌊%20n%20i%20⌋%20的同时求出%20⌊,F%20(%20p%20i%20k%20i)%20。%20又称%22狄利克雷卷积%22。">学习总结-莫比乌斯反演 - __allenge - 博客园 (cnblogs.com)</a></li><li><a href="https://www.cnblogs.com/henry-1202/p/10121854.html">数论分块 - henry_y - 博客园 (cnblogs.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络实验报告（三合一）</title>
      <link href="/2021/computer-network-experiment-report-3-in-1/"/>
      <url>/2021/computer-network-experiment-report-3-in-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本报告涉及到的源代码的位置：<a href="https://github.com/ma-hunter/cn_exp" class="uri">https://github.com/ma-hunter/cn_exp</a></p></blockquote><table><thead><tr class="header"><th>班级</th><th>姓名</th><th>学号</th></tr></thead><tbody><tr class="odd"><td>软件工程 18XX 班</td><td>XXX</td><td>U2018XXXXX</td></tr></tbody></table><h2 id="实验一wireshark-抓包工具使用">实验一：Wireshark 抓包工具使用</h2><table><thead><tr class="header"><th>系统环境</th><th>软件版本</th></tr></thead><tbody><tr class="odd"><td>Windows 10 Pro 21H1</td><td>WIRE<strong>SHARK</strong> Version 3.4.6 (v3.4.6-0-g6357ac1405b8)</td></tr></tbody></table><h3 id="一实验目的">一、实验目的</h3><ol type="1"><li>学习 Wireshark 抓包工具的使用</li><li>了解 Wireshark 抓包工具的功能</li><li>通过学习，进一步理解协议及网络体系结构思想</li></ol><h3 id="二实验内容">二、实验内容</h3><p>使用 Wireshark，并学习使用它进行网络包分析。</p><h3 id="三实验原理">三、实验原理</h3><p>Wireshark 是网络包分析工具；网络包分析工具的主要作用是尝试捕获网络包，并尝试显示包的尽可能详细的情况。Wireshark 常见的应用如下：</p><ul><li>网络管理员用来解决网络问题</li><li>网络安全工程师用来检测安全隐患</li><li>开发人员用来测试协议执行情况</li></ul><p>这里，我们通过 Wireshark 来学习常见的网络协议。</p><h3 id="四实验过程">四、实验过程</h3><p>包含了从安装 Wireshark 开始到使用 Wireshark 观察一些现象的过程：</p><h4 id="下载-wireshark">4.1 下载 Wireshark</h4><p>Wireshark 的官方网站是：<a href="https://www.wireshark.org/" class="uri">https://www.wireshark.org/</a>，下载地址是<a href="https://2.na.dl.wireshark.org/win64/Wireshark-win64-3.4.6.exe" class="uri">https://2.na.dl.wireshark.org/win64/Wireshark-win64-3.4.6.exe</a></p><h4 id="准备工作">4.2 准备工作</h4><p>再 Powershell 中输入 <code>ipconfig</code> 查询本机的 IP 信息：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/查看IP地址.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/查看IP地址.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="查看IP地址" /><figcaption aria-hidden="true">查看IP地址</figcaption></figure><p>在同局域网下打开另一台设备，启动一个服务器：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/局域网内开启服务器.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/局域网内开启服务器.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="局域网内开启服务器" /><figcaption aria-hidden="true">局域网内开启服务器</figcaption></figure><p>查看局域网内的这台设备的 IP 地址：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/检查局域网内服务器IP.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/检查局域网内服务器IP.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="检查局域网内服务器IP" /><figcaption aria-hidden="true">检查局域网内服务器IP</figcaption></figure><p>可以得到的信息汇总如下：</p><table><thead><tr class="header"><th>机器</th><th>IP(v4) 地址</th><th>子网掩码</th><th>默认网关</th></tr></thead><tbody><tr class="odd"><td>主机</td><td>192.168.3.2</td><td>255.255.255.0</td><td>192.168.3.1</td></tr><tr class="even"><td>服务器</td><td>192.168.3.71</td><td>255.255.255.0</td><td>192.168.3.1</td></tr></tbody></table><p>因为只需要这些信息，所以直接在 Powershell 中获取；需要更详细的信息也可以通过网络适配器选项中来获得。接下来使用 Wireshark 捕获两者之间的通讯数据包，并且进行分析。</p><h4 id="启动-wireshark">4.3 启动 Wireshark</h4><p>首先需要先选择监听的网络设备：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/打开网络设备.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/打开网络设备.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="打开网络设备" /><figcaption aria-hidden="true">打开网络设备</figcaption></figure><p>然后，就可以开始捕获以太网的通信数据包：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/正在捕获以太网.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/正在捕获以太网.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="正在捕获以太网" /><figcaption aria-hidden="true">正在捕获以太网</figcaption></figure><p>接下来，可以进行捕获通过它的特定报文，并且分析内容。</p><h4 id="tcp握手">4.4 TCP握手</h4><p>浏览器访问上面查询到的服务器的地址 <code>http://192.168.3.71</code>，并且在 Wireshark 中设定限制条件（过滤器） <code>ip.src == 192.168.3.71 or ip.dst == 192.168.3.71</code> 来只捕获来自这两个 IP 地址之间的通信。</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/TCP握手.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/TCP握手.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="TCP握手" /><figcaption aria-hidden="true">TCP握手</figcaption></figure><p>高亮的部分就是 TCP 的三次握手。</p><h4 id="tcp报文分析示例">4.5 TCP报文分析示例</h4><p>这是上述三次握手过程中的第二次握手的报文的详细信息：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/报文详细分析.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/报文详细分析.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="报文详细分析" /><figcaption aria-hidden="true">报文详细分析</figcaption></figure><table><thead><tr class="header"><th>项目</th><th>信息</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>源端口</td><td>80</td><td>服务器的 HTTP 默认端口，服务确实开在 80 端口上</td></tr><tr class="even"><td>目的端口</td><td>61577</td><td>用户浏览器当前开启的用于和服务器通信的端口</td></tr><tr class="odd"><td>TCP 段长度</td><td>0</td><td>该报文不携带数据</td></tr><tr class="even"><td>Sequence 数字</td><td>0</td><td><code>Seq=0</code></td></tr><tr class="odd"><td>Acknowledge 数字</td><td>1</td><td>期望收到的下一个报文满足 <code>Seq=1</code></td></tr><tr class="even"><td>首部长度</td><td>32 bytes (8)</td><td>8 * 4B = 32 bytes</td></tr><tr class="odd"><td>标志</td><td>0x012</td><td>SYN 和 ACK 位为 1</td></tr><tr class="even"><td>校验和</td><td>0x5426</td><td>校验和为 0x5426，未验证</td></tr></tbody></table><h4 id="http报文分析">4.6 HTTP报文分析</h4><p>在 TCP 握手完成之后，服务器将使用 HTTP 协议传输数据到浏览器；我们在紧接着握手完成后面的位置找到了使用 HTTP 协议传输的数据包；可以打开查看其详细信息：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/HTTP报文.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/HTTP报文.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="HTTP报文" /><figcaption aria-hidden="true">HTTP报文</figcaption></figure><table><colgroup><col style="width: 28%" /><col style="width: 71%" /></colgroup><thead><tr class="header"><th>内容</th><th>信息</th></tr></thead><tbody><tr class="odd"><td><code>GET / HTTP/1.1</code></td><td>操作类型：GET；遵循了 HTTP 1.1 版本的协议</td></tr><tr class="even"><td><code>Host: 192.168.3.71</code></td><td>主机名：192.168.3.71；当绑定域名的场合下会是主机的域名</td></tr><tr class="odd"><td><code>Connection: keep-alive</code></td><td>连接类型是保持持久连接</td></tr><tr class="even"><td><code>User-Agent: ...</code></td><td>用户的客户端信息；这里有个 <code>Mozilla/5.0 (Windows NT 10.0 ...)</code> 说明是运行在 Windows 10 上的火狐浏览器</td></tr><tr class="odd"><td>……</td><td>……</td></tr></tbody></table><p>HTTP 头能塞的东西还挺多的，这里就不全部说明了；当然，这里所包含的项目也未必完整。</p><h3 id="五思考题">五、思考题</h3><p><strong>网络工程师能通过 Wireshark 做哪些工作？</strong></p><ul><li>检查网络协议的执行情况</li><li>排查网络故障，解决网络问题</li><li>网络攻防，检测网络安全隐患</li></ul><h2 id="实验二winpcap-编程">实验二：WinPcap 编程</h2><table><thead><tr class="header"><th>系统环境</th><th>开发环境</th></tr></thead><tbody><tr class="odd"><td>Windows 10 Pro 21H1</td><td>CLion 2021.1; CMake 3.19; tdm-gcc 9.3; NpCap SDK 1.07</td></tr></tbody></table><h3 id="一实验目的-1">一、实验目的</h3><ul><li>了解 NpCap 架构和运行逻辑</li><li>学习使用 NpCap SDK 进行编程</li></ul><h3 id="二实验内容-1">二、实验内容</h3><p>通过学习 NpCap SDK，编写一个网络抓包程序</p><h3 id="三实验原理-1">三、实验原理</h3><p>本实验主要基于 NpCap 完成，所以这里主要是关于 NpCap 的介绍：</p><h4 id="npcap概述">3.1 NpCap概述</h4><p>WinPcap 是一个基于Win32平台的，用于捕获网络数据包并进行分析的开源库；在 Linux 上也有对应的 LibPcap；目前 WinPcap 已经处于无人维护的状态，对于 Windows 10 有更新的且目前有人维护的开源项目 NpCap。</p><p>大多数网络应用程序通过被广泛使用的操作系统元件来访问网络，比如 sockets——这是一种简单的实现方式，因为操作系统已经妥善处理了底层具体实现细节（比如协议处理，封装数据包等等工作），并且提供了一个与读写文件类似的，令人熟悉的接口；但是有些时候，这种“简单的实现方式”并不能满足需求，因为有些应用程序需要直接访问网络中的数据包：也就是说原始数据包——即没有被操作系统利用网络协议处理过的数据包。而 WinPcap/NpCap 则为 Win32 应用程序提供了这样的接口：</p><ul><li>捕获原始数据包；无论它是发往某台机器的，还是在其他设备（共享媒介）上进行交换的</li><li>在数据包发送给某应用程序前，根据指定的规则过滤数据包</li><li>将原始数据包通过网络发送出去</li><li>收集并统计网络流量信息</li></ul><p>SDK 提供的这些功能需要借助运行在 Win32 内核中的网络设备驱动程序来实现；在安装完成驱动之后，SDK 将这些功能作为一个接口表现出来以供使用。</p><h4 id="要使用的接口">3.2 要使用的接口</h4><p>以下介绍了实现后文提到的 demo 所需要使用的 NpCap API 的简单介绍：</p><h5 id="pcap_findalldevs">3.2.1 <code>pcap_findalldevs</code></h5><p>NpCap 提供了 <code>pcap_findalldevs_ex</code> 和 <code>pcap_findalldevs</code> 函数来获取计算机上的网络接口设备的列表；此函数会为传入的 <code>pcap_if_t</code> 赋值——该类型是一个表示了设备列表的链表头；每一个这样的节点都包含了 <code>name</code> 和 <code>description</code> 域来描述设备。</p><p>除此之外，<code>pcap_if_t</code> 结构体还包含了一个 <code>pcap_addr</code> 结构体；后者包含了一个地址列表、一个掩码列表、一个广播地址列表和一个目的地址的列表；此外，<code>pcap_findalldevs_ex</code> 还能返回远程适配器信息和一个位于所给的本地文件夹的 pcap 文件列表。</p><h5 id="pcap_open">3.2.2 <code>pcap_open</code></h5><p>用来打开一个适配器，实际调用的是 <code>pcap_open_live</code>；它接受五个参数：</p><ul><li><code>name</code>：适配器的名称（GUID）</li><li><code>snaplen</code>：制定要捕获数据包中的哪些部分。在一些操作系统中 (比如 xBSD 和 Win32)，驱动可以被配置成只捕获数据包的初始化部分：这样可以减少应用程序间复制数据的量，从而提高捕获效率；本次实验中，将值定为 <code>65535</code>，比能遇到的最大的MTU还要大，因此总能收到完整的数据包。</li><li><code>flags</code>：主要的意义是其中包含的混杂模式开关；一般情况下，适配器只接收发给它自己的数据包， 而那些在其他机器之间通讯的数据包，将会被丢弃。但混杂模式将会捕获所有的数据包——因为我们需要捕获其他适配器的数据包，所以需要打开这个开关。</li><li><code>to_ms</code>：指定读取数据的超时时间，以毫秒计；在适配器上使用其他 API 进行读取操作的时候，这些函数会在这里设定的时间内响应——即使没有数据包或者捕获失败了；在统计模式下，<code>to_ms</code> 还可以用来定义统计的时间间隔：设置为 <code>0</code> 说明没有超时——如果没有数据包到达，则永远不返回；对应的还有 <code>-1</code>：读操作立刻返回。</li><li><code>errbuf</code>：用于存储错误信息字符串的缓冲区</li></ul><p>该函数返回一个 <code>pcap_t</code> 类型的 handle。</p><h5 id="pcap_loop">3.2.3 <code>pcap_loop</code></h5><p>API 函数 <code>pcap_loop</code> 和 <code>pcap_dispatch</code> 都用来在打开的适配器中捕获数据包；但是前者会已知捕获直到捕获到的数据包数量达到要求数量，而后者在到达了前面 API 设定的超时时间之后就会返回（尽管这得不到保证）；前者会在一小段时间内阻塞网络的应用，故一般项目都会使用后者作为读取数据包的函数；虽然在本次实验中，使用前者就够了。</p><p>这两个函数都有一个回调函数；这个回调函数会在这两个函数捕获到数据包的时候被调用，用来处理捕获到的数据包；这个回调函数需要遵顼特定的格式。但是需要注意的是我们无法发现 CRC 冗余校验码——因为帧到达适配器之后，会经过校验确认的过程；这个过程成功，则适配器会删除 CRC；否则，大多数适配器会删除整个包，因此无法被 NpCap 确认到。</p><h5 id="pcap_datalink">3.2.4 <code>pcap_datalink</code></h5><p>用于对 MAC 层进行了检测，以确保在处理一个以太网络，确保 MAC 首部是14位的。IP 数据包的首部就位于 MAC 首部的后面，将从 IP 数据包的首部解析到源 IP 地址和目的 IP 地址。</p><h5 id="pcap_compile-pcap_setfilter">3.2.5 <code>pcap_compile</code> &amp; <code>pcap_setfilter</code></h5><p>用来设置过滤器，以避免处理一些无用的包，提高包处理的效率。在本次实验中我们需要将过滤器字符串设置成 <code>ip and udp</code>，使得我们传入的回调只处理基于 IPv4 的 UDP 数据包；大大简化了解析过程和回调函数的调用次数。</p><h4 id="其他的补充">3.3 其他的补充</h4><p>处理 UDP 数据包的首部时存在一些困难：因为 IP 数据包的首部的长度并不是固定的，但是可以通过 IP 数据包的 <code>length</code> 域来得到它的长度；一旦知道了 UDP 首部的位置，就能解析到源端口和目的端口。</p><h3 id="四实验过程-1">四、实验过程</h3><p>从安装 NpCap 到运行 NpCap 示例程序的全部过程；</p><h4 id="安装-npcap">4.1 安装 NpCap</h4><p>NpCap 是 WinPcap for Windows 10；它的官方下载页面是 <a href="https://nmap.org/npcap/#download">Npcap: Windows Packet Capture Library &amp; Driver (nmap.org)</a>；在这里我们需要下载：</p><ul><li>NpCap 内核驱动：<a href="https://nmap.org/npcap/dist/npcap-1.31.exe">Npcap 1.31 installer</a></li><li>NpCap SDK 文件：<a href="https://nmap.org/npcap/dist/npcap-sdk-1.07.zip">Npcap SDK 1.07</a></li></ul><p>安装完成驱动后，再在 IDE 中为项目配置导入 NpCap SDK 文件。NpCap SDK 文件包中包括了使用 NpCap 实现的基本功能的 demo。</p><h4 id="使用-npcap-的功能">4.2 使用 NpCap 的功能</h4><p>项目的文件结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CMake target: if_list udp_dump basic_dump_ex</span><br><span class="line">(root)</span><br><span class="line">├ module</span><br><span class="line">│ └ (NpCap Library files)NpCap SDK 库文件</span><br><span class="line">├ src</span><br><span class="line">│ ├ basic_dump_ex.c目标 basic_dump_ex 的源文件</span><br><span class="line">│ ├ if_list.c目标 if_list 的源文件</span><br><span class="line">│ └ udp_dump.c目标 udp_dump 的源文件</span><br><span class="line">└ CMakeList.txtCMake 项目定义文件</span><br></pre></td></tr></table></figure><p>这些使用 NpCap 功能的 demo 的实现代码都位于：<a href="https://github.com/ma-hunter/cn_exp" class="uri">https://github.com/ma-hunter/cn_exp</a></p><h3 id="五实验结果">五、实验结果</h3><p>上述代码包括的，使用 NpCap 实现的几项基本功能的运行结果（非截图）。</p><h4 id="读取网络设备列表">5.1 读取网络设备列表</h4><p>使用 CMake，构建并运行上述项目中的目标 <code>if_list</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;D:\Program Files\JetBrains\Toolbox\apps\CLion\ch-0\211.6693.114\bin\cmake\win\bin\cmake.exe&quot; --build D:\Workspaces\CLion\cn_exp\cmake-build-debug --target if_list -- -j 4</span><br><span class="line">Scanning dependencies of target if_list</span><br><span class="line">[ 50%] Building C object CMakeFiles&#x2F;if_list.dir&#x2F;src&#x2F;if_list.c.obj</span><br><span class="line">[100%] Linking C executable if_list.exe</span><br><span class="line">[100%] Built target if_list</span><br><span class="line"></span><br><span class="line">构建已完成</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">D:\Workspaces\CLion\cn_exp\cmake-build-debug\if_list.exe \Device\NPF_&#123;5C8B26D4-9439-4304-B8FB-48A81CB33CF9&#125;</span><br><span class="line">        Description: WAN Miniport (Network Monitor)</span><br><span class="line">        Loopback: no</span><br><span class="line"></span><br><span class="line">\Device\NPF_&#123;C21F9683-BA8A-4AFE-827A-166030BB1466&#125;</span><br><span class="line">        Description: WAN Miniport (IPv6)</span><br><span class="line">        Loopback: no</span><br><span class="line"></span><br><span class="line">\Device\NPF_&#123;1C99E263-4855-4786-97ED-ECAC30A11761&#125;</span><br><span class="line">        Description: WAN Miniport (IP)</span><br><span class="line">        Loopback: no</span><br><span class="line"></span><br><span class="line">\Device\NPF_&#123;1A386F2B-3A3E-49A7-B899-2629C46C4FB3&#125;</span><br><span class="line">        Description: Hyper-V Virtual Ethernet Adapter #2</span><br><span class="line">        Loopback: no</span><br><span class="line">        Address Family: #23</span><br><span class="line">        Address Family Name: AF_INET6</span><br><span class="line">        Address Family: #2</span><br><span class="line">        Address Family Name: AF_INET</span><br><span class="line">        Address: 172.26.112.1</span><br><span class="line">        Netmask: 0.240.255.255</span><br><span class="line">        Broadcast Address: 255.31.112.1</span><br><span class="line"></span><br><span class="line">\Device\NPF_&#123;A30B9DA2-E755-4DF6-8BD4-010B6590B072&#125;</span><br><span class="line">        Description: Hyper-V Virtual Ethernet Adapter</span><br><span class="line">        Loopback: no</span><br><span class="line">        Address Family: #23</span><br><span class="line">        Address Family Name: AF_INET6</span><br><span class="line">        Address Family: #2</span><br><span class="line">        Address Family Name: AF_INET</span><br><span class="line">        Address: 172.26.0.1</span><br><span class="line">        Netmask: 0.240.255.255</span><br><span class="line">        Broadcast Address: 255.31.0.1</span><br><span class="line"></span><br><span class="line">\Device\NPF_&#123;21EAB23F-F3E5-48E0-B370-35B69F40B833&#125;</span><br><span class="line">        Description: Bluetooth Device (Personal Area Network) #3</span><br><span class="line">        Loopback: no</span><br><span class="line">        Address Family: #23</span><br><span class="line">        Address Family Name: AF_INET6</span><br><span class="line">        Address Family: #2</span><br><span class="line">        Address Family Name: AF_INET</span><br><span class="line">        Address: 169.254.62.143</span><br><span class="line">        Netmask: 0.0.255.255</span><br><span class="line">        Broadcast Address: 255.255.62.143</span><br><span class="line"></span><br><span class="line">\Device\NPF_&#123;5CCBE082-6FB3-4754-B27A-3659F98979BE&#125;</span><br><span class="line">        Description: Realtek RTL8188EU Wireless LAN 802.11n USB 2.0 Network Adapter</span><br><span class="line">        Loopback: no</span><br><span class="line">        Address Family: #23</span><br><span class="line">        Address Family Name: AF_INET6</span><br><span class="line">        Address Family: #2</span><br><span class="line">        Address Family Name: AF_INET</span><br><span class="line">        Address: 169.254.125.212</span><br><span class="line">        Netmask: 0.0.255.255</span><br><span class="line">        Broadcast Address: 255.255.125.212</span><br><span class="line"></span><br><span class="line">\Device\NPF_&#123;E919BE86-5601-4998-B187-2C629DE1F9B9&#125;</span><br><span class="line">        Description: Microsoft Wi-Fi Direct Virtual Adapter #2</span><br><span class="line">        Loopback: no</span><br><span class="line">        Address Family: #23</span><br><span class="line">        Address Family Name: AF_INET6</span><br><span class="line">        Address Family: #2</span><br><span class="line">        Address Family Name: AF_INET</span><br><span class="line">        Address: 169.254.194.126</span><br><span class="line">        Netmask: 0.0.255.255</span><br><span class="line">        Broadcast Address: 255.255.194.126</span><br><span class="line"></span><br><span class="line">\Device\NPF_&#123;FF7337C5-5DA3-4AF4-8C55-5A066C578D65&#125;</span><br><span class="line">        Description: Microsoft Wi-Fi Direct Virtual Adapter</span><br><span class="line">        Loopback: no</span><br><span class="line">        Address Family: #23</span><br><span class="line">        Address Family Name: AF_INET6</span><br><span class="line">        Address Family: #2</span><br><span class="line">        Address Family Name: AF_INET</span><br><span class="line">        Address: 169.254.180.74</span><br><span class="line">        Netmask: 0.0.255.255</span><br><span class="line">        Broadcast Address: 255.255.180.74</span><br><span class="line"></span><br><span class="line">\Device\NPF_&#123;43524049-AA60-4F6E-A89E-8AE5BA1EAA93&#125;</span><br><span class="line">        Description: Realtek PCIe GbE Family Controller</span><br><span class="line">        Loopback: no</span><br><span class="line">        Address Family: #23</span><br><span class="line">        Address Family Name: AF_INET6</span><br><span class="line">        Address Family: #2</span><br><span class="line">        Address Family Name: AF_INET</span><br><span class="line">        Address: 192.168.3.2</span><br><span class="line">        Netmask: 0.255.255.255</span><br><span class="line">        Broadcast Address: 255.168.3.2</span><br><span class="line"></span><br><span class="line">\Device\NPF_Loopback</span><br><span class="line">        Description: Adapter for loopback traffic capture</span><br><span class="line">        Loopback: yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 0</span><br></pre></td></tr></table></figure><p>于此同时可以看到控制面板下的网络适配器页面；可以看到基本的适配器信息是一致的：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/网络适配器.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/网络适配器.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="网络适配器.png" /><figcaption aria-hidden="true">网络适配器.png</figcaption></figure><p>我们的 demo 输出的更多是因为包含了一些被操作系统用户级别隐藏的接口。</p><h4 id="打开设别并抓包监听">5.2 打开设别并抓包监听</h4><p>使用 CMake，构建并运行上述项目中的目标 <code>basic_dump_ex</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;D:\Program Files\JetBrains\Toolbox\apps\CLion\ch-0\211.6693.114\bin\cmake\win\bin\cmake.exe&quot; --build D:\Workspaces\CLion\cn_exp\cmake-build-debug --target basic_dump_ex -- -j 4</span><br><span class="line">Scanning dependencies of target basic_dump_ex</span><br><span class="line">[ 50%] Building C object CMakeFiles&#x2F;basic_dump_ex.dir&#x2F;src&#x2F;basic_dump_ex.c.obj</span><br><span class="line">[100%] Linking C executable basic_dump_ex.exe</span><br><span class="line">[100%] Built target basic_dump_ex</span><br><span class="line"></span><br><span class="line">构建已完成</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">D:\Workspaces\CLion\cn_exp\cmake-build-debug\basic_dump_ex.exe</span><br><span class="line">1. \Device\NPF_&#123;5C8B26D4-9439-4304-B8FB-48A81CB33CF9&#125; (WAN Miniport (Network Monitor))</span><br><span class="line">2. \Device\NPF_&#123;C21F9683-BA8A-4AFE-827A-166030BB1466&#125; (WAN Miniport (IPv6))</span><br><span class="line">3. \Device\NPF_&#123;1C99E263-4855-4786-97ED-ECAC30A11761&#125; (WAN Miniport (IP))</span><br><span class="line">4. \Device\NPF_&#123;1A386F2B-3A3E-49A7-B899-2629C46C4FB3&#125; (Hyper-V Virtual Ethernet Adapter #2)</span><br><span class="line">5. \Device\NPF_&#123;A30B9DA2-E755-4DF6-8BD4-010B6590B072&#125; (Hyper-V Virtual Ethernet Adapter)</span><br><span class="line">6. \Device\NPF_&#123;21EAB23F-F3E5-48E0-B370-35B69F40B833&#125; (Bluetooth Device (Personal Area Network) #3)</span><br><span class="line">7. \Device\NPF_&#123;5CCBE082-6FB3-4754-B27A-3659F98979BE&#125; (Realtek RTL8188EU Wireless LAN 802.11n USB 2.0 Network Adapter)</span><br><span class="line">8. \Device\NPF_&#123;E919BE86-5601-4998-B187-2C629DE1F9B9&#125; (Microsoft Wi-Fi Direct Virtual Adapter #2)</span><br><span class="line">9. \Device\NPF_&#123;FF7337C5-5DA3-4AF4-8C55-5A066C578D65&#125; (Microsoft Wi-Fi Direct Virtual Adapter)</span><br><span class="line">10. \Device\NPF_&#123;43524049-AA60-4F6E-A89E-8AE5BA1EAA93&#125; (Realtek PCIe GbE Family Controller)</span><br><span class="line">11. \Device\NPF_Loopback (Adapter for loopback traffic capture)</span><br><span class="line">Enter the interface number (1-11):10</span><br><span class="line"></span><br><span class="line">listening on Realtek PCIe GbE Family Controller...</span><br><span class="line">13:36:31,027242 len:208</span><br><span class="line">13:36:31,068904 len:1071</span><br><span class="line">13:36:31,122063 len:54</span><br><span class="line">13:36:31,423026 len:60</span><br><span class="line">13:36:31,423094 len:54</span><br><span class="line">13:36:31,750427 len:336</span><br><span class="line">13:36:31,750466 len:320</span><br><span class="line">13:36:31,782177 len:66</span><br></pre></td></tr></table></figure><p>程序将会运行到被外部中断阻止后才会停止运行。</p><h4 id="捕获udp包并分析">5.3 捕获UDP包并分析</h4><p>使用 CMake，构建并运行上述项目中的目标 <code>basic_dump_ex</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;D:\Program Files\JetBrains\Toolbox\apps\CLion\ch-0\211.6693.114\bin\cmake\win\bin\cmake.exe&quot; --build D:\Workspaces\CLion\cn_exp\cmake-build-debug --target udp_dump -- -j 4</span><br><span class="line">[100%] Built target udp_dump</span><br><span class="line"></span><br><span class="line">构建已完成</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">D:\Workspaces\CLion\cn_exp\cmake-build-debug\udp_dump.exe</span><br><span class="line">1. \Device\NPF_&#123;5C8B26D4-9439-4304-B8FB-48A81CB33CF9&#125; (WAN Miniport (Network Monitor))</span><br><span class="line">2. \Device\NPF_&#123;C21F9683-BA8A-4AFE-827A-166030BB1466&#125; (WAN Miniport (IPv6))</span><br><span class="line">3. \Device\NPF_&#123;1C99E263-4855-4786-97ED-ECAC30A11761&#125; (WAN Miniport (IP))</span><br><span class="line">4. \Device\NPF_&#123;1A386F2B-3A3E-49A7-B899-2629C46C4FB3&#125; (Hyper-V Virtual Ethernet Adapter #2)</span><br><span class="line">5. \Device\NPF_&#123;A30B9DA2-E755-4DF6-8BD4-010B6590B072&#125; (Hyper-V Virtual Ethernet Adapter)</span><br><span class="line">6. \Device\NPF_&#123;21EAB23F-F3E5-48E0-B370-35B69F40B833&#125; (Bluetooth Device (Personal Area Network) #3)</span><br><span class="line">7. \Device\NPF_&#123;5CCBE082-6FB3-4754-B27A-3659F98979BE&#125; (Realtek RTL8188EU Wireless LAN 802.11n USB 2.0 Network Adapter)</span><br><span class="line">8. \Device\NPF_&#123;E919BE86-5601-4998-B187-2C629DE1F9B9&#125; (Microsoft Wi-Fi Direct Virtual Adapter #2)</span><br><span class="line">9. \Device\NPF_&#123;FF7337C5-5DA3-4AF4-8C55-5A066C578D65&#125; (Microsoft Wi-Fi Direct Virtual Adapter)</span><br><span class="line">10. \Device\NPF_&#123;43524049-AA60-4F6E-A89E-8AE5BA1EAA93&#125; (Realtek PCIe GbE Family Controller)</span><br><span class="line">11. \Device\NPF_Loopback (Adapter for loopback traffic capture)</span><br><span class="line">Enter the interface number (1-11):10</span><br><span class="line"></span><br><span class="line">listening on Realtek PCIe GbE Family Controller...</span><br><span class="line">13:38:26.314222 len:181 192.168.3.2.7726 -&gt; 180.97.33.12.8829</span><br><span class="line">13:38:26.339699 len:163 180.97.33.12.8829 -&gt; 192.168.3.2.7726</span><br><span class="line">13:38:28.517235 len:361 223.166.151.86.8000 -&gt; 192.168.3.2.4017</span><br><span class="line">13:38:28.517526 len:97 192.168.3.2.4017 -&gt; 223.166.151.86.8000</span><br><span class="line">13:38:29.100916 len:82 192.168.3.2.60173 -&gt; 192.168.3.1.53</span><br><span class="line">13:38:29.151404 len:149 192.168.3.1.53 -&gt; 192.168.3.2.60173</span><br><span class="line">13:38:30.577642 len:129 223.166.151.86.8000 -&gt; 192.168.3.2.4017</span><br></pre></td></tr></table></figure><p>程序将会运行到被外部中断阻止后才会停止运行。</p><h3 id="六思考题">六、思考题</h3><p><strong>WINPCAP是否能实现服务质量的控制？</strong></p><p>不能。WinPcap 可以独立地通过主机协议发送和接受数据，如同TCP/IP；这就意味着 WinPcap 不能阻止、过滤或操纵同一机器上的其他应用程序的通讯：它仅仅能简单地“监视”在网络上传输的数据包。所以，它不能提供类似网络流量控制、服务质量调度和个人防火墙之类的支持，因而不能实现服务质量的控制。</p><h2 id="实验三协议分析流量统计程序的编写">实验三：协议分析&amp;流量统计程序的编写</h2><table><thead><tr class="header"><th>系统环境</th><th>开发环境</th></tr></thead><tbody><tr class="odd"><td>Windows 10 Pro 21H1</td><td>CLion 2021.1; CMake 3.19; tdm-gcc 9.3; NpCap SDK 1.07</td></tr></tbody></table><h3 id="一实验目的-2">一、实验目的</h3><ul><li>理解协议在通信中的作用，掌握常见 IP 协议；</li><li>掌握基于 NpCap 的抓包软件的开发；</li><li>掌握协议解析和流量统计的编程方法；</li></ul><h3 id="二实验内容-2">二、实验内容</h3><p>利用 NpCap 编写协议分析工具；输出抓取的包和协议分析结构，并统计 IP 的流量（即包的数量）。</p><p>功能要求：</p><ol type="1"><li>利用 NpCap 捕获数据包，并可根据要求进行数据包过滤。</li><li>根据IP协议，解析每个数据包的PCI，展示其在不同网络层次所使用的协议结构和具体信息。</li><li>根据IP地址，统计源自该IP地址的流量，即捕获到的数据包的数量。</li></ol><p>运行程序后将捕获的信息输出到标准输出流中。</p><h3 id="三实验原理-2">三、实验原理</h3><p>实验的设计依据的原理，包括协议的概念和 NpCap 的接口使用逻辑。</p><h4 id="协议说明">3.1 协议说明</h4><p>下面的内容包含了本次实验所涉及到的协议类型的说明。</p><h5 id="协议栈分析">3.1.1 协议栈分析</h5><p>因为 TCP/IP 协议采用分层的结构，所以网络通信时，要传输的数据在发送端是一个逐层封装的过程；而相应地在接收端则是一个逐层分解的过程；如下图所示：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/协议栈分析.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/协议栈分析.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="协议栈分析" /><figcaption aria-hidden="true">协议栈分析</figcaption></figure><p>在接收端的逐层分解，就是上述封装的逆过程；</p><h5 id="以太网协议">3.1.2 以太网协议</h5><p>以太网 II 格式时一种帧格式，应用最为广泛，几乎成为了当前以太网的现行标准；它由 RFC894 定义，如下图所示：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/以太网协议.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/以太网协议.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="以太网协议.png" /><figcaption aria-hidden="true">以太网协议.png</figcaption></figure><h5 id="ip-协议">3.1.3 IP 协议</h5><p>IP 协议是 Internet 的核心协议，它工作在网络层，提供了不可靠无连接的数据传送服务；协议格式如图所示：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/IP协议.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/IP协议.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="IP协议" /><figcaption aria-hidden="true">IP协议</figcaption></figure><h5 id="icmp协议">3.1.4 ICMP协议</h5><p>ICMP 的全称是 Internet 控制信息协议 (Internet Control Message Protocol)。它提供了很多 Internet 的信息描述服务：例如能够检测网络的运行状况，通知协议有用的网络状态信息；ICMP 是基于 IP 协议的，ICMP 协议格式如图所示：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/ICMP协议.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/ICMP协议.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="ICMP协议.png" /><figcaption aria-hidden="true">ICMP协议.png</figcaption></figure><h5 id="tcp协议">3.1.5 TCP协议</h5><p>TCP协议是基于连接的可靠的协议：它负责发收端的协定，然后保持正确可靠的数据传输服务；它在 IP 协议上运行，而 IP 无连接的协议，所以TCP丰富了IP协议的功能，使它具有可靠的传输服务；TCP 协议格式如图所示：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/TCP协议.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/TCP协议.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="TCP协议.png" /><figcaption aria-hidden="true">TCP协议.png</figcaption></figure><p>可以看到 TCP 报文段结构由以下的部分组成：</p><ul><li>源端口：指定了发送端的端口</li><li>目的端口：指定了接受端的端口号</li><li>序号：指明了段在即将传输的段序列中的位置</li><li>确认号：规定成功收到段的序列号，确认序号包含发送确认的一端所期望收到的下一个序号</li><li>TCP 偏移量：指定了段头的长度。段头的长度取决与段头选项字段中设置的选项</li><li>保留：指定了一个保留字段，以备将来使用</li><li>标志：<code>SYN</code>、<code>ACK</code>、<code>PSH</code>、<code>RST</code>、<code>URG</code>、<code>FIN</code><ul><li><code>SYN</code>： 表示同步</li><li><code>ACK</code>： 表示确认</li><li><code>PSH</code>： 表示尽快的将数据送往接收进程</li><li><code>RST</code>： 表示复位连接</li><li><code>URG</code>： 表示紧急指针</li><li><code>FIN</code>： 表示发送方完成数据发送</li></ul></li><li>窗口：指定关于发送端能传输的下一段的大小的指令</li><li>校验和：校验和包含 TCP 段头和数据部分，用来校验段头和数据部分的可靠性</li><li>紧急指针：指明段中包含紧急信息，只有当 U R G 标志置1时紧急指针才有效</li><li>选项：指定了公认的段大小，时间戳，选项字段的末端，以及指定了选项字段的边界选项</li></ul><p>TCP 连接的建立和释放采用了三步握手法，如下图所示：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/TCP连接建立.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/TCP连接建立.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="TCP连接建立.jpg" /><figcaption aria-hidden="true">TCP连接建立.jpg</figcaption></figure><p>其过程可以描述如下步骤：</p><ol type="1"><li>主机一发出连接序号为 x（<code>seq=x</code>）</li><li>主机二应答接受主机一的连接请求，并声明自己的序号为 y（<code>sqe=y</code>，<code>ACK=x+1</code>）</li><li>主机一收到确认后，发送第一个数据 TPDU 并确认主机二的序号（<code>seq=x</code>，<code>ACK=y+1</code>）</li></ol><p>至此，整个连接建立过程正常结束，数据传输已经正式开始。</p><h5 id="udp-协议">3.1.6 UDP 协议</h5><p>用户数据报协议 UDP 是在 IP 协议上的传输层协议，它提供了无连接的协议服务；它在IP协议基础上提供了端口的功能，因此既可让应用程序之间进行通信了。UDP 协议格式如图3.7所示：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/UDP协议.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/UDP协议.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="UDP协议.png" /><figcaption aria-hidden="true">UDP协议.png</figcaption></figure><h4 id="协议处理">3.2 协议处理</h4><p>NpCap 按照一定的规则提供了 API，和本次实验相关的逻辑如下：</p><h5 id="npcap-处理流程">3.2.1 NpCap 处理流程</h5><p>NpCap 的工作周期可以被描述为如下序列：</p><ul><li><code>pcap_findalldevs</code> &amp; <code>pcap_findalldevs_ex</code>：获得网络接口设备的列表</li><li><code>pcap_open</code> &amp; <code>pcap_dump_open</code> &amp; <code>pcap_open_live</code>：打开设备/打开设备数据包</li><li><code>pcap_freealldevs</code>：释放获得的设备列表结构所占用的内存</li><li><code>pcap_compile</code> &amp; <code>pcap_setfilter</code>：编译并设置过滤器</li><li><code>pcap_loop</code>：根据设定的数量来循环捕获数据包，并调用指定的回调处理数据包</li><li><code>packet_handler</code>：传入 loop 的回调函数，用来处理被捕获的数据包</li><li><code>pcap_close</code>：关闭 NpCap 句柄（即打开的网络设备）</li></ul><p>简单地说，使用 NpCap 获得网络接口列表后，我们打开一个设备，并设定循环次数，传入指定类型的回调函数来处理被捕获的数据包，并在程序退出之前关闭设备。</p><h5 id="回调函数设计">3.2.2 回调函数设计</h5><p>因为上述协议栈分析中提到了，接收端分析包的内容就是一个逆封装的过程，所以我们可以采用逐层递归的方法来设计我们的回调函数；基本设计如下：</p><ul><li><code>(pkt)</code>：用来传入 NpCap 循环的，帧处理函数</li><li><code>(ethernet)</code>：用来处理以太网协议的部分</li><li><code>(ipv4)</code> &amp; <code>(ipv6)</code> &amp; <code>(arp)</code>：处理 IPv4、IPv6、ARP 协议的报头</li><li><code>(icmp)</code> &amp; <code>(tcp)</code> &amp; <code>(udp)</code>：处理 ICMP、TCP、UDP 的报文</li></ul><p>根据设计需求，在判断上一层的协议类型后，将待处理的报文递归给下一层的处理函数即可。</p><h3 id="四实验设计">四、实验设计</h3><p>关于代码实现方面的设计：</p><h4 id="项目组成">4.1 项目组成</h4><p>项目可以分为 <code>handlers</code>、<code>helpers</code> 和 <code>utils</code> 三个部分组成；</p><ul><li><code>utils</code> 包含了可复用的无后效逻辑的实现，尽量避免重复代码片段</li><li><code>handlers</code> 包含了传给 NpCap 的回调函数以及递归下降法实现的逆封装函数</li><li><code>helpers</code> 包含了要实现的额外功能，比如本次实验中的流量统计</li></ul><p>这三个部分分别使用独立的头文件和源文件组成，被 <code>main</code> 模块引用。</p><h4 id="预定义">4.2 预定义</h4><p>项目所需要的类型定义都包含在 <code>definitions.h</code> 中；包含了根据协议的组成而设计的报文和报头的类型定义；因为最后捕获的数据包是指向一片连续内存块的指针，这里的定义必须保证指定的内存块可以完全转化为对应的包类型才行；因此，需要保证顺序和使用的基本数据类型完全和定义符合。</p><h4 id="项目结构">4.3 项目结构</h4><p>最后，整个项目的文件结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CMake target: cn_exp</span><br><span class="line">(root)</span><br><span class="line">├ module</span><br><span class="line">│ └ (NpCap Library files)NpCap SDK 库文件</span><br><span class="line">├ include</span><br><span class="line">│ ├ definitions.h 预定义的类型声明</span><br><span class="line">│ ├ handlers.h递归下降法的包处理回调函数的声明</span><br><span class="line">│ ├ helpers.h流量统计相关方法的声明</span><br><span class="line">│ └ utils.h可复用模块的函数声明</span><br><span class="line">├ src</span><br><span class="line">│ ├ utils.cpp可复用模块的函数实现</span><br><span class="line">│ ├ helpers.cpp流量统计相关方法的实现</span><br><span class="line">│ └ handlers.cpp递归下降法的包处理回调函数的实现</span><br><span class="line">├ CMakeList.txtCMake 项目定义文件</span><br><span class="line">└ main.cpp主进程文件</span><br></pre></td></tr></table></figure><p>使用 CMake 加载项目，并构建运行 <code>cn_exp</code> 即可生成目标。</p><h3 id="五实现代码">五、实现代码</h3><p>Github 链接：<a href="https://github.com/ma-hunter/cn_exp" class="uri">https://github.com/ma-hunter/cn_exp</a></p><h3 id="六实验结果">六、实验结果</h3><p>完成实现上文所述的程序后，运行程序，可以得到下面的结果：</p><h4 id="运行结果">6.1 运行结果</h4><p>因为上传截图非常的麻烦，这里仅粘贴标准输出的文本。</p><h5 id="选择网络设备">6.1.1 选择网络设备</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Hello, World! Hello NpCap!</span><br><span class="line">1.\Device\NPF_&#123;5C8B26D4-9439-4304-B8FB-48A81CB33CF9&#125;WAN Miniport (Network Monitor)</span><br><span class="line">2.\Device\NPF_&#123;C21F9683-BA8A-4AFE-827A-166030BB1466&#125;WAN Miniport (IPv6)</span><br><span class="line">3.\Device\NPF_&#123;1C99E263-4855-4786-97ED-ECAC30A11761&#125;WAN Miniport (IP)</span><br><span class="line">4.\Device\NPF_&#123;1A386F2B-3A3E-49A7-B899-2629C46C4FB3&#125;Hyper-V Virtual Ethernet Adapter #2</span><br><span class="line">5.\Device\NPF_&#123;A30B9DA2-E755-4DF6-8BD4-010B6590B072&#125;Hyper-V Virtual Ethernet Adapter</span><br><span class="line">6.\Device\NPF_&#123;21EAB23F-F3E5-48E0-B370-35B69F40B833&#125;Bluetooth Device (Personal Area Network) #3</span><br><span class="line">7.\Device\NPF_&#123;5CCBE082-6FB3-4754-B27A-3659F98979BE&#125;Realtek RTL8188EU Wireless LAN 802.11n USB 2.0 Network Adapter</span><br><span class="line">8.\Device\NPF_&#123;E919BE86-5601-4998-B187-2C629DE1F9B9&#125;Microsoft Wi-Fi Direct Virtual Adapter #2</span><br><span class="line">9.\Device\NPF_&#123;FF7337C5-5DA3-4AF4-8C55-5A066C578D65&#125;Microsoft Wi-Fi Direct Virtual Adapter</span><br><span class="line">10.\Device\NPF_&#123;43524049-AA60-4F6E-A89E-8AE5BA1EAA93&#125;Realtek PCIe GbE Family Controller</span><br><span class="line">11.\Device\NPF_LoopbackAdapter for loopback traffic capture</span><br><span class="line">Enter the interface number (1-11):</span><br></pre></td></tr></table></figure><h5 id="设置监听循环的次数">6.1.2 设置监听循环的次数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Enter the interface number (1-11):10</span><br><span class="line"> listening on Realtek PCIe GbE Family Controller....</span><br><span class="line">Please input the num of packets you want to catch(0 for keeping catching):</span><br></pre></td></tr></table></figure><h5 id="tcp协议解析示例">6.1.3 TCP协议解析示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Time: 12:54:00, 129446Length: 60</span><br><span class="line">Type: 0x800 (IPv4)</span><br><span class="line">Destination address: c:c:b:6:c:e</span><br><span class="line">Source address: 8:a:0:c:6:c</span><br><span class="line">Version: 5</span><br><span class="line">Header length: 5 (20B)</span><br><span class="line">Type of service: 96</span><br><span class="line">Total length: 40</span><br><span class="line">Identification: 22603</span><br><span class="line">Flags: 0</span><br><span class="line">Fragment offset: 64 (512 B)</span><br><span class="line">Protocol: TCP</span><br><span class="line">Checksum: 32469</span><br><span class="line">Source IP address: 39.96.132.69</span><br><span class="line">Destination IP address: 192.168.3.2</span><br><span class="line">Source port: 443</span><br><span class="line">Destination port: 55308</span><br><span class="line">Sequence: 744910189</span><br><span class="line">Acknowledgement: 846425137</span><br><span class="line">Data offset: 0 (0 B)</span><br><span class="line">Flags: ACK</span><br><span class="line">Window: 28927</span><br><span class="line">Checksum: 54318</span><br><span class="line">Urgent pointer: 0</span><br></pre></td></tr></table></figure><h5 id="udp协议解析示例">6.1.4 UDP协议解析示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Time: 12:54:00, 148551Length: 106</span><br><span class="line">Type: 0x800 (IPv4)</span><br><span class="line">Destination address: 8:a:0:c:6:c</span><br><span class="line">Source address: c:c:b:6:c:e</span><br><span class="line">Version: 5</span><br><span class="line">Header length: 5 (20B)</span><br><span class="line">Type of service: 0</span><br><span class="line">Total length: 92</span><br><span class="line">Identification: 21792</span><br><span class="line">Flags: 0</span><br><span class="line">Fragment offset: 0 (0 B)</span><br><span class="line">Protocol: UDP</span><br><span class="line">Checksum: 0</span><br><span class="line">Source IP address: 192.168.3.2</span><br><span class="line">Destination IP address: 112.32.50.208</span><br><span class="line">Source port: 7726</span><br><span class="line">Destination port: 28078</span><br><span class="line">Length: 72</span><br><span class="line">Checksum: 26356</span><br></pre></td></tr></table></figure><h5 id="流量统计示例">6.1.5 流量统计示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flow counts: </span><br><span class="line">IP                                         Flow</span><br><span class="line">111.206.210.75                              3</span><br><span class="line">112.32.50.208                               2</span><br><span class="line">13.107.136.9                               53</span><br><span class="line">192.168.3.2                                34</span><br><span class="line">39.96.132.69                                8</span><br></pre></td></tr></table></figure><h4 id="构建记录">6.2 构建记录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;D:\Program Files\JetBrains\Toolbox\apps\CLion\ch-0\211.6693.114\bin\cmake\win\bin\cmake.exe&quot; -DCMAKE_BUILD_TYPE&#x3D;Debug -G &quot;CodeBlocks - MinGW Makefiles&quot; D:\Workspaces\CLion\cn_exp</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: D:&#x2F;Workspaces&#x2F;CLion&#x2F;cn_exp&#x2F;cmake-build-debug</span><br><span class="line"></span><br><span class="line">&quot;D:\Program Files\JetBrains\Toolbox\apps\CLion\ch-0\211.6693.114\bin\cmake\win\bin\cmake.exe&quot; --build D:\Workspaces\CLion\cn_exp\cmake-build-debug --target cn_exp -- -j 4</span><br><span class="line">Scanning dependencies of target cn_exp</span><br><span class="line">[ 20%] Building CXX object CMakeFiles&#x2F;cn_exp.dir&#x2F;src&#x2F;handlers.cpp.obj</span><br><span class="line">[ 40%] Linking CXX executable cn_exp.exe</span><br><span class="line">[100%] Built target cn_exp</span><br><span class="line"></span><br><span class="line">构建已完成</span><br></pre></td></tr></table></figure><h3 id="七思考题">七、思考题</h3><p><strong>应用WINPCAP能实现哪些网络应用?</strong></p><ul><li>捕获原始数据包。不管这个包是发往本地机，还是其他机器之间的交换包</li><li>在数据包被发送到应用程序之前，通过用户定义的规则过滤</li><li>向网络发送原始数据包</li><li>对网络通信量做出统计</li></ul><h2 id="参考资料">参考资料</h2><ul><li><a href="https://blog.csdn.net/lee1hong/article/details/106893706">计算机网络 | 实验一 wireshark抓包工具使用_哆啦一泓的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/lee1hong/article/details/106893772">计算机网络 | 实验二 WINPCWP编程_哆啦一泓的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/lee1hong/article/details/106893837">计算机网络 | 实验三 协议分析程序的编写_哆啦一泓的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/include_IT_dog/article/details/106813645">Winpcap进行抓包，分析数据包结构并统计IP流量_include的博客-CSDN博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 课业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课内作业 </tag>
            
            <tag> 实验报告 </tag>
            
            <tag> 计算机网络 </tag>
            
            <tag> Wireshark </tag>
            
            <tag> 抓包 </tag>
            
            <tag> NpCap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Nginx 和 Keepalived 部署一个高可用的负载均衡的 web 应用</title>
      <link href="/2021/use-nginx-and-keepalived-to-host-a-web-server/"/>
      <url>/2021/use-nginx-and-keepalived-to-host-a-web-server/</url>
      
        <content type="html"><![CDATA[<p>一般的 Web 应用是将写好的程序使用手段放在服务器上，然后在服务器上运行这些程序；这样其他计算机访问这台服务器的时候就可以使用这个应用。但是这样有一个明显的缺点就是一台主机的性能存在上限，当业务规模扩大，且业务要求提高的情况下，这种简单的部署形式就不能满足要求了。</p><p>实验环境：Ubuntu 20.04 电脑两台，处于同一局域网下。</p><p>首先，关于 Nginx 是什么和 Keepalived 是什么就不再赘述；这里仅简单说明实验操作过程：</p><h2 id="nginx-开启负载均衡">Nginx 开启负载均衡</h2><p>具体来说可以按照以下步骤进行；我的第一台主机作为常用机，其上已经运行了 <code>apache2</code> 的服务；那么此时如果要再使用 <code>nginx</code> 的负载均衡，就需要先关闭原有的 <code>apache2</code> 以释放 80 端口。之后设置 <code>nginx</code> 的转发规则就可以实现负载均衡了；</p><h3 id="安装基本的工具">安装基本的工具</h3><p>即使是像 Ubuntu 这样已经成熟的发行版，也需要安装相当多的工具才能进行服务器的搭建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install net-tools nginx vim</span><br></pre></td></tr></table></figure><p>最主要的是第一项的 <code>net-tools</code>，它包含了重要的工具 <code>ifconfig</code> 可以用来查看 Linux 网络接口的信息；再完成了安装之后，我们可以运行下面的命令，来启动防火墙和 <code>nginx</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw app list<span class="comment"># 列出所有可用的预设配置</span></span><br><span class="line">sudo ufw allow <span class="string">&#x27;Nginx Full&#x27;</span><span class="comment"># 允许 Nginx 的所有 HTTP/HTTPS 链接</span></span><br><span class="line">sudo ufw <span class="built_in">enable</span><span class="comment"># 根据设置的规则启用 UFW 防火墙</span></span><br><span class="line">sudo service nginx start</span><br></pre></td></tr></table></figure><p>但是因为我的主机上同时还运行了 <code>apache2</code> 占用了 80 端口，所以需要先处理它，才能重新运行 Nginx；</p><h3 id="关闭-apache2如果存在">关闭 Apache2（如果存在</h3><p>我在尝试关闭 <code>apache2</code> 的时候遇到了如何关闭都无法解放端口占用的问题；后来通过修改 <code>apache2</code> 的监听端口+重启主机才释放了 80 端口给 <code>nginx</code> 使用。</p><figure><img src="https://i.loli.net/2021/06/09/csNPLQkrnIaFW87.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/csNPLQkrnIaFW87.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="修改 apache2 的监听端口1.png" /><figcaption aria-hidden="true">修改 apache2 的监听端口1.png</figcaption></figure><figure><img src="https://i.loli.net/2021/06/09/5rtkXBwRGEpxZCN.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/5rtkXBwRGEpxZCN.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="修改 apache2 的监听端口2.png" /><figcaption aria-hidden="true">修改 apache2 的监听端口2.png</figcaption></figure><p>根据 Ubuntu apache 默认页面，可以知道 <code>apache2</code> 的配置文件位于 <code>/etc/apache2</code> 目录下；首先需要修改 <code>port.conf</code> 中的端口监听信息，然后再根据文件的提示修改 <code>sites-enabled/</code> 下的站点的监听信息。</p><p>做完这些重启 <code>apache2</code> 服务之后，就可以释放 <code>apache2</code> 对于端口 80 的占用了；此时运行 <code>nginx</code> 就可以正常启动服务了；</p><h3 id="检查-nginx-正常运行">检查 Nginx 正常运行</h3><p>使用 <code>service</code> 命令或者 <code>systemctl</code> 命令检查 <code>nginx</code> 的状态，可以看到如下页面：</p><figure><img src="https://i.loli.net/2021/06/09/RBXpqVuJFt23nmy.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/RBXpqVuJFt23nmy.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Nginx 已经正常运行.png" /><figcaption aria-hidden="true">Nginx 已经正常运行.png</figcaption></figure><p>此时，<code>apache2</code> 和 <code>nginx</code> 同时运行，分别监听 8080 和 80 端口；分别访问这两个端口，可以在响应头中看到它们的响应分别来自不同的服务器：</p><figure><img src="https://i.loli.net/2021/06/09/92ZrXejm6DQCfyN.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/92ZrXejm6DQCfyN.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="apache2 的服务器.png" /><figcaption aria-hidden="true">apache2 的服务器.png</figcaption></figure><center>Apache2 监听的 8080 端口</center><figure><img src="https://i.loli.net/2021/06/09/Ri482WgxvtEAZqa.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/Ri482WgxvtEAZqa.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="nginx 的服务器.png" /><figcaption aria-hidden="true">nginx 的服务器.png</figcaption></figure><center>Nginx 监听的 80 端口</center><p>至于为什么两个页面都是 “Apache2 Ubuntu Default Page”，是因为我先安装了 <code>apache2</code>，所以后安装的 <code>nginx</code> 创建的 <code>index.html</code> 被改名了；所以我们需要观察响应标头来判断相应的来源。</p><h3 id="启动两个服务器">启动两个服务器</h3><p>首先，我们需要写一个简单的页面，然后再把它们假设起来；这里也使用 Nginx 感觉有点麻烦了，所以使用了 <code>Node.js</code> 提供的简易 HTTP 服务器工具 <code>serve</code>；如果没有安装，需要先安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install npm</span><br><span class="line">sudo npm i -g serve</span><br></pre></td></tr></table></figure><p>之后，我们需要写一个简单的网页：</p><figure><img src="https://i.loli.net/2021/06/09/1JiLlRTbHt3xuBZ.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/1JiLlRTbHt3xuBZ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="写一个网页.png" /><figcaption aria-hidden="true">写一个网页.png</figcaption></figure><p>然后复制两份，分别修改端口的标记；</p><figure><img src="https://i.loli.net/2021/06/09/PhrU5E3nxGLDqFV.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/PhrU5E3nxGLDqFV.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="复制两份并且修改端口标记.png" /><figcaption aria-hidden="true">复制两份并且修改端口标记.png</figcaption></figure><p>修改完成后，使用 <code>serve</code> 分别将服务启动在对应的端口，终端最后如下：</p><figure><img src="https://i.loli.net/2021/06/09/I8dsOr2tnDBSaX5.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/I8dsOr2tnDBSaX5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="启动两个简易的 HTTP.png" /><figcaption aria-hidden="true">启动两个简易的 HTTP.png</figcaption></figure><p>在浏览器分别访问两个端口，以确认可以正常访问：</p><figure><img src="https://i.loli.net/2021/06/09/TzmOtCAsForKecU.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/TzmOtCAsForKecU.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="两个端口都可以正常运行.png" /><figcaption aria-hidden="true">两个端口都可以正常运行.png</figcaption></figure><p>这样，我们就将这个简单的网页部署到了“两个不同的服务器”上了，接下来需要通过 Nginx 来实现负载均衡。</p><h3 id="配置-nginx">配置 Nginx</h3><p>实现负载均衡需要先在配置文件中指定一个 <code>upstream</code>，其中包含了负载的服务器集群和它们的权重；Nginx 支持你选择特定的负载均衡的算法，如果不指定就是默认的轮询的方法；我们在 <code>/etc/nginx/conf.d/</code> 下创建 <code>nginx.conf</code>；配置文件如下：</p><figure><img src="https://i.loli.net/2021/06/09/fTMbPCWFIn87l5Z.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/fTMbPCWFIn87l5Z.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="nginx 配置文件.png" /><figcaption aria-hidden="true">nginx 配置文件.png</figcaption></figure><p>完成配置文件的编写之后，使用 <code>sudo nginx -t</code> 来检查配置文件是否有误或产生了冲突；如果没有意外，则重启 <code>nginx</code> 服务，就可以看到 80 端口会根据设置的权重自动转发到两个简易 HTTP 服务器上。</p><h4 id="需要注意的是">需要注意的是……</h4><p>Nginx 有一个默认的服务器配置，位于 <code>/etc/nginx/sites-enabled/</code> 目录下；这个服务器也是默认监听 80 端口的，会和我们已有的服务器产生冲突，所以要先移除；此外，<strong>不</strong>需要将我们创建的配置文件软链接到该目录，因为这样 Nginx 会扫描两次这个文件，从而继续得出端口冲突的结论。</p><figure><img src="https://i.loli.net/2021/06/09/E5ldTtz6PIw1k8o.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/E5ldTtz6PIw1k8o.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="移除多余的默认服务器，否则服务将无法启动.png" /><figcaption aria-hidden="true">移除多余的默认服务器，否则服务将无法启动.png</figcaption></figure><p>可以看到如果不删除这个配置文件，是无法通过 Nginx 的配置文件的测试的。同时，删除的只是链接到 <code>sites-available</code> 目录下的配置文件的软连接，并不会丢失这个配置；可以随时通过创建软连接的方式将这个配置文件拉回来。</p><h3 id="大功告成">大功告成！</h3><p>接下来，本机访问 <code>localhost</code> 或局域网内访问 <code>http://192.168.3.2/</code>（本机 IP），反复刷新，就可以看到端口标识根据配置文件中设置的权重反复横跳；</p><p>因为不好放视频，所以这里就不放了（</p><h2 id="keepalived-实现高可用">Keepalived 实现高可用</h2><p>keepalived 的高可用基于多台 Nginx 服务器共用一个虚拟网关，当其中的一台炸了的时候，会自动从这个虚拟的地址中退出，从而保证了对于这个虚拟地址的访问总是有效的（只要有一台服务器在正常运行）；因此，这要求至少将这样的 nginx 部署到多个服务器上形成 nginx 服务器集群；因此，首先我们要像上一部分所做的那样在另一个服务器上操作一遍；</p><h3 id="安装基本软件以远程操作">安装基本软件以远程操作</h3><p>比起上面的软件，还需要额外安装 SSH 服务器，以在第一台主机上访问第二台主机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vim nginx net-tools openssh-server</span><br></pre></td></tr></table></figure><p>安装完成后使用 <code>ifconfig</code> 获得第二台主机在局域网中的 IP，就可以在第一台主机上访问了：</p><figure><img src="https://i.loli.net/2021/06/09/GnUMIrhD1m5XCde.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/GnUMIrhD1m5XCde.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="连接 SSH 到第二台服务器.png" /><figcaption aria-hidden="true">连接 SSH 到第二台服务器.png</figcaption></figure><p>完成了基本软件安装后，启动 <code>nginx</code>，浏览器访问局域网 IP，可以看到 Nginx 欢迎页面，说明 Nginx 安装成功：</p><figure><img src="https://i.loli.net/2021/06/09/K3LaVm9yhYGFZ4q.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/K3LaVm9yhYGFZ4q.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="第二台服务器 Nginx 配置成功.png" /><figcaption aria-hidden="true">第二台服务器 Nginx 配置成功.png</figcaption></figure><p>因为这台主机上没有先装 <code>apache2</code>，所以 NginX 完成安装后就自动启动了；</p><h3 id="配置-nginx-的负载均衡并测试">配置 Nginx 的负载均衡并测试</h3><p>按照上一个部分部署完负载均衡之后，发现在第一台服务器上无法访问我们部署的页面：</p><figure><img src="https://i.loli.net/2021/06/09/HeS3Cita1dIoZPc.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/HeS3Cita1dIoZPc.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="发现第二台服务器无法访问.png" /><figcaption aria-hidden="true">发现第二台服务器无法访问.png</figcaption></figure><p>在第二台主机上尝试直接访问 <code>http://192.168.3.2:1919</code> 和 <code>http://192.168.3.2:9191</code> 会发现无法打开页面，再联想到安装 Nginx 之后自动配置的防火墙，判断 1919 和 9191 端口被 ufw 屏蔽；所以在第一台主机上手动开放这两个端口，第二台服务器上的负载均衡就可以正常使用了。</p><figure><img src="https://i.loli.net/2021/06/09/hO4F1lSHGY9oEC3.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/hO4F1lSHGY9oEC3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在第一台服务器上修改防火墙配置开放端口，成功.png" /><figcaption aria-hidden="true">在第一台服务器上修改防火墙配置开放端口，成功.png</figcaption></figure><p>使用 <code>ufw</code> 开放端口可以使用 <code>sudo ufw allow &lt;port&gt;</code> 来实现。</p><h3 id="安装-keepalived">安装 Keepalived</h3><p>在两台主机上安装 <code>keepalived</code> 并尝试运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install keepalived</span><br><span class="line">sudo service keepalived start</span><br></pre></td></tr></table></figure><p>会发现它们无法启动，因为缺少了配置文件：</p><figure><img src="https://i.loli.net/2021/06/09/z71fK6LDGYIJwsU.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/z71fK6LDGYIJwsU.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="无法启动keepalived，因为没有配置文件.png" /><figcaption aria-hidden="true">无法启动keepalived，因为没有配置文件.png</figcaption></figure><p>因此我们需要为它们添加配置文件；</p><h3 id="配置-keepalived">配置 Keepalived</h3><p>这一步主要是为第一台主机（主机）和第二台主机（从机）分别增加 Keepalived 配置文件和对于 Nginx 服务器的监控脚本；这使得它们在可以正常工作的状态下连接了同一个虚拟网关，且在检测到 Nginx 服务器出现异常时即使退出，保持虚拟地址的访问总是可用的。</p><h4 id="配置文件">配置文件</h4><p>配置文件主要需要指明本机 IP、检测脚本和虚拟网关三个部分，其他部分都可以照葫芦画瓢（）本机 IP 在进行前面的操作的时候我们已经都知道了，而检测脚本是可以直接 CV 的<del>（bushi</del>；虚拟网关需要在对应的主机上使用 <code>ifconfig</code> 查看你的 IP 是由哪一个名字的接口提供的；就像下面的图片中一样——<code>192.168.3.2</code> 这一局域网 IP 是由 <code>enp2s0</code> 提供的，所以虚拟网关的接口是该接口；</p><figure><img src="https://i.loli.net/2021/06/09/FNwJd73s6SYlHMQ.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/FNwJd73s6SYlHMQ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="编写 keepalived 配置文件，利用 ifconfig 查看网卡.png" /><figcaption aria-hidden="true">编写 keepalived 配置文件，利用 ifconfig 查看网卡.png</figcaption></figure><p>除此之外，还需要找到一个没有被占用的局域网 IP 地址作为对外暴露的虚拟地址，以隐藏背后的 Nginx 服务器集群；在这里，我选择的是没有被使用过的 <code>192.168.3.216</code>；最后的主从机配置文件分别如下：</p><figure><img src="https://i.loli.net/2021/06/09/fWlyPopSiM9YXBe.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/fWlyPopSiM9YXBe.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Master 的 keepalived.png" /><figcaption aria-hidden="true">Master 的 keepalived.png</figcaption></figure><center>主机的配置文件</center><p>注意 <code>virtual_ipaddress</code> 的值实际上是 <code>192.168.3.216</code> 这一没有被任何主机占用的局域网 IP，并且和下面从机配置的虚拟 IP 地址保持一致。这里的截图里是错误示范（</p><figure><img src="https://i.loli.net/2021/06/09/W8ReOfu9FtoKBIN.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/W8ReOfu9FtoKBIN.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Slave 的 keepalived.png" /><figcaption aria-hidden="true">Slave 的 keepalived.png</figcaption></figure><center>从机的配置文件</center><p>因为从机只有一个 USB 网卡，所以 <code>interface</code> 和一般的 Ubuntu 主机的默认网卡不一样。</p><h4 id="检测脚本">检测脚本</h4><p>用来检测 Nginx 服务器是否增长工作的脚本；我不懂，直接网上 CV 来的：</p><figure><img src="https://i.loli.net/2021/06/09/iKkIv2co9DO3FwS.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/iKkIv2co9DO3FwS.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="检查 Nginx 是否正常运行的脚本.png" /><figcaption aria-hidden="true">检查 Nginx 是否正常运行的脚本.png</figcaption></figure><p>遵循上面的配置文件，我们将这个脚本放在和配置文件同一个目录下，然后使用 <code>chmod</code> 赋予它可执行的权限，并运行一次——如果 Niginx 服务器当前正在正常运行，那么这个脚本会直接退出。</p><h3 id="大功告成-1">大功告成！</h3><p>完成这些操作之后，使用 <code>service</code> 或 <code>systemctl</code> 命令启动 <code>keepalived</code> 服务，就完成了部署：</p><figure><img src="https://i.loli.net/2021/06/09/Q3Vu1aPBnzZCwKt.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/Q3Vu1aPBnzZCwKt.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="增加权限并启动 keeplalived.png" /><figcaption aria-hidden="true">增加权限并启动 keeplalived.png</figcaption></figure><p>此时，我们使用 <code>ip a</code> 可以观察到在我们指定的网络接口下多了额外的虚拟 IP 地址：</p><figure><img src="https://i.loli.net/2021/06/09/SqNJPzsD9Vf5137.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/SqNJPzsD9Vf5137.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="观察到虚拟 IP.png" /><figcaption aria-hidden="true">观察到虚拟 IP.png</figcaption></figure><p>现在，将主机和从机中的任意一个的 Nginx 服务中止，访问虚拟网关还是可以打开这个页面（并且包含了负载均衡）；Web 应用的可用性提高了！</p><h2 id="总结">总结</h2><p>首先，我们使用多个服务器部署了我们的 Web 应用；然后使用多台安装了 Nginx 的服务器部署负载均衡——这个集群中的每一台服务器都可以根据设定的权重将来自外部的请求分配到部署了 Web 应用的服务器上；同时，这些 Nginx 服务器通过 Keepalived，通过一个公共的虚拟网关对外部开放；当这些服务器中的任何一个机能出现了故障时，Keepalived 都会通过预先编写的脚本察觉到问题并立即使该服务器断开和虚拟网关的连接直到恢复，保证了来自外部的请求都会通过这个虚拟网关到达正常工作的服务器上，从而实现了高可用。</p><h3 id="参考资料">参考资料</h3><p>历史记录丢失</p>]]></content>
      
      
      <categories>
          
          <category> 课业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课内作业 </tag>
            
            <tag> 实验报告 </tag>
            
            <tag> nginx </tag>
            
            <tag> Linux </tag>
            
            <tag> Web </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 NWERC 回顾</title>
      <link href="/2021/2020-nwerc/"/>
      <url>/2021/2020-nwerc/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://codeforces.com/gym/103049" class="uri">https://codeforces.com/gym/103049</a><br />习题册文档：<a href="https://2020.nwerc.eu/files/nwerc2020problems.pdf" class="uri">https://2020.nwerc.eu/files/nwerc2020problems.pdf</a><br />题解文档：<a href="https://2020.nwerc.eu/files/nwerc2020slides.pdf" class="uri">https://2020.nwerc.eu/files/nwerc2020slides.pdf</a></p></blockquote><p>唉，要是国内区域赛的网页也能像国外的这些这样就好了（）赛后关闭服务器不能说离谱，只能说非常离谱==</p><h2 id="前言">前言</h2><p>银川站你科表现喜人，但是相应地，对于我这种目前还没有什么奖项的队伍而言的压力也是非同一般。更何况沈阳也因为疫情原因延期了<del>我已经承受了太多</del>，队内总体士气低下，所以就以欢乐赛的形式进行这一次周周练，希望可以找找比赛的感觉——</p><p>也许是受了刺激<del>不能再碌碌无为了！</del>，在真机上装了 Ubuntu，这是第一次在较为接近现场赛的环境下作答（</p><p>虽然但是，接下来还有下个赛季的邀请赛，还要好好打才行！要加油了！</p><h2 id="反思">反思</h2><p>首先是这次 VP 的成绩：</p><table><thead><tr class="header"><th style="text-align: center;">Penalty</th><th style="text-align: center;">A</th><th style="text-align: center;">B</th><th style="text-align: center;">C</th><th style="text-align: center;">D</th><th style="text-align: center;">E</th><th style="text-align: center;">F</th><th style="text-align: center;">G</th><th style="text-align: center;">H</th><th style="text-align: center;">I</th><th style="text-align: center;">J</th><th style="text-align: center;">K</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">713</td><td style="text-align: center;"><font color="#999">-1</font></td><td style="text-align: center;"></td><td style="text-align: center;"><font color="#0a0">+</font></td><td style="text-align: center;"><font color="#0a0">+3</font></td><td style="text-align: center;"></td><td style="text-align: center;"><font color="#0a0">+1</font></td><td style="text-align: center;"></td><td style="text-align: center;"><font color="#0a0">+</font></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><font color="#0a0">+</font></td></tr></tbody></table><p>因为性质上是欢乐赛，所以打的挺懒散的——一直拖到三点半才开，中途甚至还有打了一半队友补了个觉的恶性事件以及打了一半队友泡方便面吃的鬼事情，所以总归是在意料之中；五个题也和最近 VP 这场的几个实力相近的队伍差不太多，所以倒也问题不大（</p><p>唯一感觉有点发寒的就是大量的低级错误……只能说是我太久没有写代码没有读英文了，唉，我自裁（</p><h2 id="题解">题解</h2><h3 id="k---keyboardd">K - <a href="https://codeforces.com/gym/103049/problem/K">Keyboardd</a></h3><blockquote><p>给了俩字符串，其中一个是另一个字符串中部分字符重复后得到的；得到所有重复了的字符（只输出一次）</p></blockquote><p>虽然是模拟，但是实现还是没有那么直接；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;/home/nanami/CLionProjects/untitled/input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">string</span> a, b, ans;</span><br><span class="line">    getline(<span class="built_in">cin</span>, a);</span><br><span class="line">    getline(<span class="built_in">cin</span>, b);</span><br><span class="line">    <span class="keyword">auto</span> al = a.length(), bl = b.length();</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; out;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k, l; i &lt; al;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (l = i; l &lt; al; ++ l)</span><br><span class="line">            <span class="keyword">if</span> (a[i] != a[l]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (k = j; k &lt; bl; ++ k)</span><br><span class="line">            <span class="keyword">if</span> (b[k] != a[i]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (k - j &gt; l - i) out.insert(a[i]);</span><br><span class="line">        j = k, i = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : out) <span class="built_in">putchar</span>(ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟的话就好好地用最正确的做法，不要无谓地浪费时间！当然，熟练度上来了就可以写出更漂亮的实现就是了。</p><h3 id="c---contest-struggles">C - <a href="https://codeforces.com/gym/103049/problem/C">Contest Struggles</a></h3><blockquote><p>给了 <span class="math inline">\(n\)</span> 个数字的平均值和其中大小为 <span class="math inline">\(k\)</span> 的子集的平均值，求剩余部分的平均值。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, k, d, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(); k = read(); d = read(); s = read();</span><br><span class="line">    <span class="keyword">if</span>(n == k) <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">double</span> ans = (<span class="keyword">long</span> <span class="keyword">double</span>) (n * d - s * k) / (<span class="keyword">long</span> <span class="keyword">double</span>) (n - k);</span><br><span class="line">        <span class="keyword">if</span>(ans &gt;= <span class="number">0</span> &amp;&amp; ans &lt;= <span class="number">100</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.7Lf\n&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没什么好说的。</p><h3 id="h---hot-springs">H - <a href="https://codeforces.com/gym/103049/problem/H">Hot Springs</a></h3><blockquote><p>重新排序长度为 <span class="math inline">\(n \leq 2\cdot10^5\)</span> 的数组，使得其差分数组的绝对值递增。</p></blockquote><p>排序之后找到中间一个位置，然后左右横跳就行了；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;/home/nanami/CLionProjects/untitled/input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        t[i] = read();</span><br><span class="line">    sort(t + <span class="number">1</span>, t + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">int</span> mid = n / <span class="number">2</span> + <span class="number">1</span>, l = mid - <span class="number">1</span>, r = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t[mid];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; t[l --];</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; t[r ++];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意别跳出边界了就行。</p><h3 id="d---dragon-balls">D - <a href="https://codeforces.com/gym/103049/problem/D">Dragon Balls</a></h3><blockquote><p>大小为 <span class="math inline">\(10^6\times10^6\)</span> 的平面上有不超过七个龙珠；每次你可以询问一个位置 <span class="math inline">\((x, y)\)</span>，交互器会回答其中与你给出的位置直线距离最近的龙珠和你给出的点的距离；如果你询问了一个龙珠的位置，那么视为你已经将它收集，它不再出现在平面上；要求在 <span class="math inline">\(1000\)</span> 次询问内收集所有龙珠。</p></blockquote><p>虽然但是，龙珠只能在整点上；而众所周知，一个圆上的整点数量是极其有限的；所以我们随便问一个点，得到半径之后就遍历所有的可行的整点就可以找到了。<del>更何况这个题时间限制足足给了 9s，还有和 7 一点关系都看不出来的 1000 次询问，我觉得这明摆着就是教我暴力（</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line">llong ii[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;/home/nanami/CLionProjects/untitled/input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++ i)</span><br><span class="line">        ii[i] = (llong)i * i;</span><br><span class="line">    <span class="keyword">auto</span> n = read();</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;llong, <span class="keyword">int</span>&gt; mem;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;0 0&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        llong d = read(), lim = d / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (!d) &#123; -- n; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mem[d]; ii[i] &lt;= lim; ++ i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> pos = lower_bound(ii, ii + N, d - ii[i]) - ii;</span><br><span class="line">            <span class="keyword">auto</span> res = ii[pos];</span><br><span class="line">            <span class="keyword">if</span> (res + ii[i] != d) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; pos &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span> (!read()) &#123; -- n; mem[d] = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (res == ii[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span> (!read()) &#123; -- n; mem[d] = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是非常不凑巧的是，我最开始的代码会在某些情况下处理完所有的龙珠之后继续询问，导致一开始 T 的飞起，我甚至一度怀疑我的判断是否合理（）只能说蠢到家了 == 实际上理性分析，每一次遍历一个圆，时间复杂度实际上是 <span class="math inline">\(\mathcal{O}(10^6\log10^6)\)</span> 的，最多只有 7 个圆但是却 9s 的时间；就算询问次数爆了，也不会超时而是 WA 才对；这样一来怎么想都不可能超时……所以一定是逻辑写错了（）看来还是因为最近训练的不够多，导致对于这种问题不太敏感了==</p><h4 id="一些思路">一些思路</h4><p>除了这种暴力的办法，我们当然可以想到一些更加“理智”的办法来求解；只是代码会难写许多：</p><ul><li><strong>随机取俩点，然后测试圆的交点</strong>：不难想象交点极可能是龙珠，不是的情况是引入了其他龙珠的干扰</li><li><strong>“伪四分树”</strong>：每次找到一个点，找到半径之后试探上下左右半径，这样半径总是在缩小；只是要注意不要测试的四个点都到平面外面去了，要规范一下它的最大值保证至少有一个边界出现在平面内</li><li><strong>平面上的二分、三分</strong>：这就给我整不会了……</li></ul><p>这些想法在比赛时 T 飞了的情况下都有考虑，但是最后几乎都因为代码不太好写而作罢……属实不是很行；实际上第二种思路也写了代码，只是也没有处理这个问题导致同样 T 飞了（）</p><h3 id="f---flight-collision">F - <a href="https://codeforces.com/gym/103049/problem/F">Flight Collision</a></h3><blockquote><p>有 <span class="math inline">\(n \leq 2\cdot10^5\)</span> 个点在一条直线上做匀速直线运动；第 <span class="math inline">\(i\)</span> 个点的 <span class="math inline">\(x\)</span>-<span class="math inline">\(t\)</span> 方程是 <span class="math inline">\(x_i = d_i + v_i\cdot t\)</span>；如果某个时刻，有两个点在同一个位置，那么这两个点就会湮灭；问最后可以存活的点的数量，并按照顺序输出。题目保证不会有任何时刻三个或更多的点出现在同一位置。</p></blockquote><p>首先要发现，相撞的点必须是初始位置相邻的点——不然中间那个点又没有撞，却变成小透明让它左右的两个点穿过它并相撞，岂不是很滑稽——题目也限定了不可能出现三个点相撞的情况，所以完全不考虑这个问题。</p><p><del>要是考虑三个或更多点同时相撞的话，这题可就给我整不会力</del></p><p>因此，我们就可以将所有相邻的两个点相撞的时间先算出来，然后塞到一个堆里；每次取出最先相撞的两个点，它们湮灭后，将新成为的邻居相撞的时间计算出来；维护的过程中，可能会出现两个点其中有一个死点的情况，此时要记得直接弹栈不做处理；</p><p>然后是最基础的：速度相等的话不可能相撞，直接不入堆；相撞时间是负数，说明它们相背而行，也不管。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> x[N], v[N], l[N], r[N];</span><br><span class="line"><span class="built_in">bitset</span>&lt;N&gt; dead;</span><br><span class="line"></span><br><span class="line"><span class="function">ldouble <span class="title">solve</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v[i] == v[j]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ldouble dx = x[j] - x[i], dv = v[i] - v[j];</span><br><span class="line">    <span class="keyword">return</span> dx / dv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;/home/nanami/CLionProjects/untitled/input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        x[i] = read(), v[i] = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++ i)</span><br><span class="line">        l[i] = i - <span class="number">1</span>, r[i] = i + <span class="number">1</span>;</span><br><span class="line">    l[<span class="number">1</span>] = r[n] = <span class="number">-1</span>, r[<span class="number">1</span>] = <span class="number">2</span>, l[n] = n - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;tuple&lt;ldouble, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i] != v[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = solve(i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; <span class="number">0</span>) heap.emplace(-t, i, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!heap.empty()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [<span class="keyword">_t</span>, ll, rr] = heap.top();</span><br><span class="line">        heap.pop();</span><br><span class="line">        <span class="keyword">if</span> (dead[ll] || dead[rr]) <span class="keyword">continue</span>;</span><br><span class="line">        dead.<span class="built_in">set</span>(ll), dead.<span class="built_in">set</span>(rr);</span><br><span class="line">        <span class="keyword">auto</span> nl = l[ll], nr = r[rr];</span><br><span class="line">        <span class="keyword">if</span> (nl &lt; <span class="number">0</span> || nr &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> r[nl] = nr, l[nr] = nl;</span><br><span class="line">        <span class="keyword">if</span> (v[nl] != v[nr]) &#123;</span><br><span class="line">            <span class="keyword">auto</span> nt = solve(nl, nr);</span><br><span class="line">            <span class="keyword">if</span> (nt &gt; <span class="number">0</span>) heap.emplace(-nt, nl, nr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> ans = n - dead.count();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!dead[i]) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察代码，大概能发现有一个名字怪异的变量 <code>_t</code>；因为这个题的一发罚时就交在它上——这个变量本没有什么用处，但是却屏蔽了全局空间里的 <code>t</code>，带来了错误…… <strong>写代码要养成好习惯！</strong>以后这种没有用处的变量都要用这种不容易输入的名字，相当于直接屏蔽了（（</p><h3 id="a---atomic-energy">A - <a href="https://codeforces.com/gym/103049/problem/A">Atomic Energy</a></h3><blockquote><p>假设原子内有 <span class="math inline">\(x\)</span> 个中子，那么它分解后释放的能量有如下关系： <span class="math display">\[\begin{cases}a_x &amp;, x \in [1, n] \\\min_{i + j = x}(a_i + a_j) &amp;, x &gt; n\end{cases}\]</span> 现在给定 <span class="math inline">\(n \leq 100\)</span> 以及对应的数组 <span class="math inline">\(a\)</span>，进行 <span class="math inline">\(q\)</span> 次询问：每次询问有 <span class="math inline">\(x \leq 10^9\)</span> 个中子的核释放能量。</p></blockquote><p>首先，如果这个 <span class="math inline">\(x\)</span> 没有那么大，那么可以使用 DP 维护出上界之内所有核释放的能量；但是因为题目里这个 <span class="math inline">\(x\)</span> 极端地大，所以这种做法 pass（</p><p>让我们贪心地考虑：如果存在某个 <span class="math inline">\(m \in [1, n]\)</span> 使得 <span class="math inline">\(\frac{a_m}m\)</span> 最小，那么为了使得最后的分解能量尽可能地小，我们要尽可能的选择分解得到 <span class="math inline">\(m\)</span>；但是这样存在一个问题：用 <span class="math inline">\(m\)</span> 并不能凑出所有的范围内的正整数；因此，我们需要选择其他的核，但这样就需要抉择优解了。</p><p>不难想象，当 <span class="math inline">\(x\)</span> 大到一定程度之后，它一定可以被表示为一些 <span class="math inline">\(m\)</span> 和一些其他的核的组成；相应地，在一定范围内，<span class="math inline">\(x\)</span> 可能存在不使用 <span class="math inline">\(m\)</span> 的分解方式，而这种方式最优。因此，一种比较理智的思路就是找到这样的一个范围，在这个范围（如果可以接受）内使用严谨的 DP；而在这个范围外，则贪心地使用 <span class="math inline">\(m\)</span> 直到剩余的中子数落到范围之内，再使用范围内存储的值拼出答案。</p><p>这里，首先给出结论：<font color="red">在不少于 <span class="math inline">\(m\)</span> 个正整数中，一定存在一个子集使得子集的和被 <span class="math inline">\(m\)</span> 整除；</font>对应到这个问题里来看，就是这个子集的所有核都可以换成 <span class="math inline">\(m\)</span>，从而使得单位能量更低；那么接下来来说明这个结论的正确性：</p><p>首先，我们将这 <span class="math inline">\(m\)</span> 个数字按照某种方式任意排序，然后对于得到的数组求前缀和；接下来，我们使用 <span class="math inline">\(pre_i\)</span> 表示对于这个数组长度为 <span class="math inline">\(i\)</span> 的前缀和，我们就得到了一个长度为 <span class="math inline">\(m\)</span> 的 <span class="math inline">\(pre\)</span> 数组；然后，我们在 <span class="math inline">\(\text{mod}\ m\)</span> 的意义下对于数组 <span class="math inline">\(pre\)</span> 分类：</p><ul><li>如果 <span class="math inline">\(\equiv 0\)</span> 类不为空，那么就说明存在某个前缀满足其和可以被 <span class="math inline">\(m\)</span> 整除，符合约束条件</li><li>否则，这就意味着 <span class="math inline">\(m\)</span> 个元素要被放在余数为 <span class="math inline">\([1, m - 1]\)</span> 共 <span class="math inline">\(m - 1\)</span> 个类中；由抽屉原理可知，一定有一个类中放了两个元素——也就是有两个不同的前缀和具有相同的余数</li><li>此时，我们只需要将这两个前缀做差，得到的就是一段连续区间的和，显然它的余数为 <span class="math inline">\(0\)</span></li></ul><p>至此，我们已经证明了给出的结论；对于这个题目而言，这意味着只要 <span class="math inline">\(x\)</span> 不可能被分解成少于 <span class="math inline">\(m\)</span> 个数字，那么就一定可以被 <span class="math inline">\(m\)</span> 代替；而 <span class="math inline">\(m - 1\)</span> 个数字可以组成的最大的数字是 <span class="math inline">\((m - 1)n\)</span>；</p><p>是不是做到这里，这个边界就找到了呢？我们先考虑一个很显然的情况：我们能否将 <span class="math inline">\(x\)</span> 分解成 <span class="math inline">\(x\)</span> 个 <span class="math inline">\(1\)</span> 呢？显然，除非 <span class="math inline">\(n = 1\)</span>，否则一定会分解出一个非 <span class="math inline">\(1\)</span> 的数字，因为最后一次分裂一定是 <span class="math inline">\(x&#39; &gt; n\)</span> 分解为 <span class="math inline">\(i,j &lt; n\)</span>；也就是说对于 <span class="math inline">\(x\)</span> 的分解序列，如果它满足本题要求，那么一定存在 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 使得 <span class="math inline">\(i + j &gt; n\)</span>；这一部分无关最小能量，是这个分解符合题意的基本条件。</p><p>那么，我们要怎么修正我们的严谨边界呢？因为这个要求也最多影响到两个基础分裂结果，所以只要在我们的边界上加上它就可以了；两个基础数最大是 <span class="math inline">\(2n\)</span>，我们现在的边界是 <span class="math inline">\((m + 1)n\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>, M = <span class="number">12315</span>;</span><br><span class="line">llong a[N], f[M], inf = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ii = a[i] * j, jj = a[j] * i;</span><br><span class="line">    <span class="keyword">if</span> (ii == jj) <span class="keyword">return</span> i &lt; j;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ii &lt; jj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = read(), q = read(), _[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = read();</span><br><span class="line">    iota(_, _ + n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> m = *min_element(_, _ + n, compare);</span><br><span class="line">    <span class="keyword">auto</span> lim = (m + <span class="number">1</span>) * n;</span><br><span class="line">    fill(f + <span class="number">1</span>, f + <span class="number">1</span> + lim, inf);</span><br><span class="line">    <span class="built_in">memcpy</span>(f + <span class="number">1</span>, a + <span class="number">1</span>, <span class="keyword">sizeof</span>(llong) * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= lim; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            f[i] = min(f[i], f[i - j] + a[j]);</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read();</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= lim) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[x]);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> t = (x - lim + m - <span class="number">1</span>) / m;</span><br><span class="line">            <span class="keyword">int</span> mt = m * t, res = x - mt;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[res] + a[m] * t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实完全没有必要想这么多；因为著名的 <span class="math inline">\(x \cdot y - x - y\)</span> 问题<del>（大概是这个式子吧，不排除我记错了的可能）</del>我们都有常识：使用一些正整数组成更大的正整数，在某个边界之后可以组成任何正整数；虽然不完全一样，但是这并不影响我们想到上面的猜想；至于这个边界，去取一个足够大但是又时间足够求出的范围就完全没问题（）就算再蠢想不到贪心 <span class="math inline">\(m\)</span>，检查所有的元素作为首要替代也可以通过此题…… 只能说确实拉了==</p><h3 id="e---endgame">E - <a href="https://codeforces.com/gym/103049/problem/E">Endgame</a></h3><blockquote><p>有一个 <span class="math inline">\(n\times n\)</span> 的棋盘，有 <span class="math inline">\(n\)</span> 个二维向量；现在 <code>Alice</code> 和 <code>Bob</code> 各有一个棋子，在不同的位置；接下来他们按顺序选择下面操作之一执行：</p><ul><li>从 <span class="math inline">\(n\)</span> 个向量中带放回地选择两个作为位移并顺次执行；吃掉经过位置的敌方棋子</li><li>瞬移到某个没有放置棋子的位置</li><li>什么也不做</li></ul><p><code>Alice</code> 现在想知道他是否可以吃到 <code>Bob</code> 的棋子，或者在吃不到的情况下是否能通过瞬移回避被 <code>Bob</code> 吃掉。</p></blockquote><p>首先考虑 <code>Bob</code> 是否能被 <code>Alice</code> 抓到；如果要暴力搜索那复杂度是 <span class="math inline">\(\mathcal{O}(n^2)\)</span> 的，大概是过不了的；但是对于这种搜索有一种很经典的做法就是两端搜索——这样复杂度就是 <span class="math inline">\(\mathcal{O}(n)\)</span> 的；对于两个点求出合法的 <span class="math inline">\(n\)</span> 个转移中点，然后进行匹配即可。</p><p>那么现在应该如何确定是否可以瞬移到 <code>Bob</code> 抓不到的地方呢？对于每一个位置都进行测试？未免也太蠢了一些；考虑以下从 <span class="math inline">\(n\)</span> 种操作中选出两个，可以有 <span class="math inline">\(n^2\)</span> 种不同的排列；然而除去自交的 <span class="math inline">\(n\)</span> 种，剩下的部分都是对称的，可以到达的位置是相同的；所以总共可以到达的位置是 <span class="math inline">\(\frac{n(n-1)}2 + 2n\)</span> 种；观察式子，不难发现：</p><ul><li><span class="math inline">\(n \leq 3\)</span> 时，<span class="math inline">\(\frac{n(n-1)}2 + 2n \geq n^2\)</span>；此时可能 <code>Alice</code> 无处可逃，但也仅限于少数情况。</li><li><span class="math inline">\(n \to \infty\)</span> 时，<span class="math inline">\(\frac{n(n-1)}2 + 2n \to \frac{n^2}2\)</span>；即使在极端情况下，<code>Alice</code> 也总是有的放矢。</li></ul><p>所以一种理智的方法就是当 <span class="math inline">\(n\)</span> 较小的时候，就暴力地检查每一个位置是否可达；否则，则可以进行有限次数的随机坐标；因为 <span class="math inline">\(n\)</span> 较大的时候，在极端的情况下不可达的位置占比接近 <span class="math inline">\(\frac12\)</span>，如果进行 <span class="math inline">\(k\)</span> 次随机，那么找不到不可达位置的几率将无限接近 <span class="math inline">\(0\)</span>；事实上，在实现上，我们也可以设置随机直到找到一个逃逸位置后中断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">coord</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    coord <span class="keyword">operator</span>+(coord rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x + rhs.x, y + rhs.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    coord <span class="keyword">operator</span>-(coord rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x - rhs.x, y - rhs.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(coord rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x == rhs.x &amp;&amp; y == rhs.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(coord rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x != rhs.x || y != rhs.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    coord() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    coord(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : x(x), y(y) &#123;&#125;</span><br><span class="line">&#125; d[N], a, b;</span><br><span class="line"></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; ta[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> valid(x, y) ((x) &gt; 0 &amp;&amp; (x) <span class="meta-string">&lt;= n &amp;&amp; (y) &gt; 0 &amp;&amp; (y) &lt;= n)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        ta[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">(coord S, coord T, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S == T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = S + d[i];</span><br><span class="line">        <span class="keyword">if</span> (t == T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (valid(t.x, t.y)) ta[t.x].insert(t.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = T - d[i];</span><br><span class="line">        <span class="keyword">if</span> (valid(t.x, t.y) &amp;&amp; ta[t.x].count(t.y))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">createRandomMachine</span><span class="params">(<span class="keyword">int</span> lb, <span class="keyword">int</span> rb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lb &gt; rb) swap(lb, rb);</span><br><span class="line">    <span class="function">uniform_real_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">dm</span> <span class="params">(lb, rb)</span></span>;</span><br><span class="line">    random_device rd;</span><br><span class="line">    <span class="function">default_random_engine <span class="title">rm</span><span class="params">(rd())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> [=]() <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> (<span class="keyword">int</span>) dm(rm); &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">coord <span class="title">gen</span><span class="params">(<span class="keyword">const</span> function&lt;<span class="keyword">int</span>()&gt;&amp; rand_int)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = rand_int(), y = rand_int();</span><br><span class="line">    <span class="keyword">while</span> (vis[x].count(y)) x = rand_int(), y = rand_int();</span><br><span class="line">    <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = read();</span><br><span class="line">    a.x = read(), a.y = read();</span><br><span class="line">    b.x = read(), b.y = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        d[i].x = read(), d[i].y = read();</span><br><span class="line">    <span class="keyword">if</span> (test(a, b, n)) <span class="built_in">puts</span>(<span class="string">&quot;Alice wins&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = coord(i, j);</span><br><span class="line">                <span class="keyword">if</span> (t != a &amp;&amp; t != b) &#123;</span><br><span class="line">                    clear(n);</span><br><span class="line">                    <span class="keyword">auto</span> res = test(b, t, n);</span><br><span class="line">                    <span class="keyword">if</span> (!res)  &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;tie %d %d\n&quot;</span>, t.x, t.y);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Bob wins&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vis[b.x].insert(b.y);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> rd = createRandomMachine(<span class="number">1</span>, n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> tt = <span class="number">100</span>; tt; -- tt) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = gen(rd);</span><br><span class="line">            vis[t.x].insert(t.y), clear(n);</span><br><span class="line">            <span class="keyword">auto</span> res = test(b, t, n);</span><br><span class="line">            <span class="keyword">if</span> (!res)  &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;tie %d %d\n&quot;</span>, t.x, t.y);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Bob wins&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要随机的合理，那么随机也是算法！</p><h3 id="i---island-tour">I - <a href="https://codeforces.com/gym/103049/problem/I">Island Tour</a></h3><blockquote><p>有一个环形公路，路边有 <span class="math inline">\(n\)</span> 个风景；现在有三个人准备从某个景区出发，顺时针绕环形公路欣赏所有风景，且彼此不希望被其他人打扰；现在已知风景 <span class="math inline">\(i \to i + 1\)</span> 的路途需要用时 <span class="math inline">\(d_i\)</span> 的时间（当然，<span class="math inline">\(n \to 1\)</span>），第 <span class="math inline">\(j\)</span> 个人想要在第 <span class="math inline">\(i\)</span> 处风景停留时间 <span class="math inline">\(t_{i, j}\)</span>；当一个人看完了所有的风景，他将瞬移回酒店；</p><p>现在要调度三人的出发景点以尽量满足他们的愿望；求是否存在一种安排，满足他们不会互相打扰；</p></blockquote><p>考虑以下暴力怎么做：我们枚举安排 <span class="math inline">\((i, j, k)\)</span>，然后在线性时间内模拟出三人的行程安排，再用线性时间去检查是否发生了冲突；显然，这样做的复杂度是 <span class="math inline">\(\mathcal{O}(n^4)\)</span> 的，不合题意；因此，我们可以考虑使用一些方法来加快这个模拟的进程，或者说省去没有必要的暴力。</p><p>注意到如果三个人发生了冲突，那么一定可以规约成其中两个人的冲突；而暴力枚举两个人行程的冲突的情况只需要 <span class="math inline">\(\mathcal{O}(n^3)\)</span> 的时间复杂度；因此，我们可以对于每两个人暴力枚举一次，并记录冲突情况；然后再遍历三人的安排情况，就可以 <span class="math inline">\(\mathcal{O}(1)\)</span> 地求出三人的冲突的情况，从而解出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">405</span>;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="built_in">bitset</span>&lt;N&gt;, N&gt; ab, ac, bc;</span><br><span class="line"><span class="keyword">int</span> d[N], a[N], b[N], c[N];</span><br><span class="line">llong iil[N], iir[N], jjl[N], jjr[N];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> step(x) ((x) % n + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> assign(x) (x##x##l[x] = x##l, x##x##r[x] = x##r)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> calcL(x) (x##l = x##r + d[x])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> calcR(x) (x##r = x##l + x##t[x])</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">simulator</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *it, <span class="keyword">const</span> <span class="keyword">int</span> *jt,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> i0, <span class="keyword">int</span> j0, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i0 == j0) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> i = i0, j = j0;</span><br><span class="line">    llong il = <span class="number">0</span>, jl = <span class="number">0</span>, ir, jr;</span><br><span class="line">    calcR(i), calcR(j);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; n; ++ t) &#123;</span><br><span class="line">        assign(i), assign(j), calcL(i), calcL(j);</span><br><span class="line">        i = step(i), j = step(j), calcR(i), calcR(j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x)</span><br><span class="line">        <span class="keyword">if</span> (iil[x] &lt; jjr[x] &amp;&amp; jjl[x] &lt; iir[x])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) d[i] = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) b[i] = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) c[i] = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">            ab[i][j] = simulator(a, b, i, j, n);</span><br><span class="line">            ac[i][j] = simulator(a, c, i, j, n);</span><br><span class="line">            bc[i][j] = simulator(b, c, i, j, n);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++ k)</span><br><span class="line">                <span class="keyword">if</span> (!(ab[i][j] || ac[i][k] || bc[j][k]))</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, i, j, k), <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>突然感觉这一场是不是实际上挺水的……这也是聪明的暴力啊（</p><h3 id="g---great-expectations">G - <a href="https://codeforces.com/gym/103049/problem/G">Great Expectations</a></h3><blockquote><p>你要速通一个游戏，它目前的记录是 <span class="math inline">\(r\)</span>；你现在设想了一种通关方式，如果一切顺利只需要 <span class="math inline">\(n &lt; r\)</span> 的时间；这种通关方式路径上有 <span class="math inline">\(m\)</span> 个高难点，对于第 <span class="math inline">\(i\)</span> 个点：它预期出现在 <span class="math inline">\(t_i\)</span> 时间，你有 <span class="math inline">\(p_i\)</span> 的把握可以成功通过，如果失败你将浪费 <span class="math inline">\(d_i\)</span> 的时间。</p><p>因为是你一个人在刷记录，所以如果你一轮失误过多，你会考虑重置游戏，从最初开始进行进程；但没有人想重复劳动，如果失误在可控制的范围内，你也会考虑就这样继续游戏；现在要求出你能刷新记录的最少的期望时间——这个时间是你从开始尝试直到打破纪录所花费的时间。</p></blockquote><p>在开始之前，我们先做如下定义；游戏开始时存在一个事件 <span class="math inline">\((t_0, p_0, d_0)\)</span>，其中 <span class="math inline">\(t_0 = 0\)</span>，<span class="math inline">\(p_0 = 1.0\)</span>；当然，惩罚时间没有意义；游戏结束时存在一个事件 <span class="math inline">\((t_E, p_E, d_E)\)</span>，其中同样有 <span class="math inline">\(t_E = n\)</span>，<span class="math inline">\(p_E = 1.0\)</span>；此外，我们计算两个事件之间所需要消耗的时间 <span class="math inline">\(\text{d}t_i = t_{i + 1} - t_i\)</span>；特殊地，有 <span class="math inline">\(\text{d}t_n = t_E - t_n\)</span>。</p><p>此外，考虑我们对于重开和继续游戏的抉择——我们有一个最大可容忍的犯错时间 <span class="math inline">\(r - n - 1\)</span>；我们暂且将它记为犯错边界 <span class="math inline">\(M\)</span>；如果我们犯错的时间尚未超过它，那么可以考虑重开和继续游戏的最佳预期时间；否则，我们只能重开，因为继续游戏已然毫无意义。</p><p>因此，我们可以考虑一个 DP：令 <span class="math inline">\(f_{i, j}\)</span> 表示即将面对第 <span class="math inline">\(i\)</span> 个事件，在这之前已经浪费了 <span class="math inline">\(j\)</span> 的时间的情况下，速通还需要的期望时间；显然，我们要求的答案就是从最开始进行游戏的时间，也就是 <span class="math inline">\(f_{0, 0}\)</span>；根据这个定义，我们也不难想到下面的转换： <span class="math display">\[f_{i, j} \to\begin{cases}f_{i + 1, j} + \text{d}t_i  &amp;, \text{success} \\f_{0, 0} &amp;, \text{failed} \ \and \  j + d_i &gt; M \\\min(f_{0, 0}, \text{d}t_i + d_i+ f_{i + 1, j + d_i}) &amp;, \text{failed} \ \and \  j + d_i \leq M\end{cases}\]</span> 实现上，不难想到这样的 DP 应该从后向前更新答案，最后求出 <span class="math inline">\(f_{0, 0}\)</span>；但是注意到转移的过程中是需要 <span class="math inline">\(f_{0, 0}\)</span> 作为参数的，而这个值是我们最后才能求出的，形成了一个循环；对于这种类似方程的情况，我们可以考虑使用二分的方法，猜测一个 <span class="math inline">\(F_{0, 0}\)</span> 作为参数先代入转移，并与最后求出的 <span class="math inline">\(f&#39;_{0, 0}\)</span> 对比，直到两者足够接近。</p><p>因此，将上述的转移套上概率 <span class="math inline">\(p_i\)</span> 之后就可以写出一个对于 <span class="math inline">\(F_{0, 0}\)</span> 的 check 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> trick = tuple&lt;<span class="keyword">int</span>, <span class="keyword">double</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5050</span>, M = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">double</span> f[M][N], tt[N];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(T x)</span> </span>&#123;<span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="number">-1</span> : x &gt; <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(a - b) &lt; eps ? <span class="number">0</span> : sgn(a - b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>), <span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n, r, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; r &gt;&gt; m;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;trick&gt; <span class="title">ts</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">    ts[<span class="number">0</span>] = make_tuple(<span class="number">0</span>, <span class="number">1.0</span>, <span class="number">0</span>);</span><br><span class="line">    ts[m + <span class="number">1</span>] = make_tuple(n, <span class="number">1.0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;[t, p, d] = ts[i];</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t &gt;&gt; p &gt;&gt; d;</span><br><span class="line">        tt[i] = t - get&lt;<span class="number">0</span>&gt;(ts[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    tt[m + <span class="number">1</span>] = n - get&lt;<span class="number">0</span>&gt;(ts[m]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> margin = r - n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> binary = [&amp;](<span class="keyword">double</span> f00) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= margin; ++ j) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [t, p, d] = ts[i];</span><br><span class="line">                f[i][j] = p * (tt[i + <span class="number">1</span>] + f[i + <span class="number">1</span>][j]);</span><br><span class="line">                <span class="keyword">if</span> (j + d &gt; margin) f[i][j] += (<span class="number">1</span> - p) * f00;</span><br><span class="line">                <span class="keyword">else</span> f[i][j] += (<span class="number">1</span> - p) * min(f00, tt[i + <span class="number">1</span>] + d + f[i + <span class="number">1</span>][j + d]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> compareTo(f00, f[<span class="number">0</span>][<span class="number">0</span>]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">double</span> ll = <span class="number">0</span>, rr = <span class="number">3e18</span>;</span><br><span class="line">    <span class="keyword">while</span> (compareTo(ll, rr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> mm = (ll + rr) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (binary(mm)) ll = mm;</span><br><span class="line">        <span class="keyword">else</span> rr = mm - eps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">7</span>) &lt;&lt; ll &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法——<strong>二分解方程</strong>——确实算是一个比较有意思的技巧；学到了许多（）此外对于概率论 DP 的题目而言，还是要注意不要陷入了误区——比如考虑重来是不是未来成功的可能性更高更加省时间这种；因为这样带来的优势无法量化，所以也就无从考察；而概率或者说是成本则是一个理智的量化标准——不用想别的，只要考它就好（</p><p>当然，上面说的这些也非常的主观……只能说之后有了更好的理解再来补充说明吧（</p><h3 id="j---joint-excavation">J - <a href="https://codeforces.com/gym/103049/problem/J">Joint Excavation</a></h3><blockquote><p>有一张图，首先你需要从中选出一些点组成一个 <code>non-self-intersecting path</code>，然后将剩下来的点平均分成 A 和 B 两组。要求整张图不存在任何一条边，使得这条边的两个端点一个属于 A 而另一个属于 B。</p></blockquote><p>没有太看懂题，，只能说英语或者说理解能力属实不是很行（）最后对着答案才算搞懂题目是什么意思==</p><p>在图中怎么样动态地维护一条边？当然是 DFS 了啊！在图中怎么样保证两种节点不直接连接？当然把连接到链上的一棵子树全部划给一个组啊！于是，就有了标准题解的构造方法：</p><ul><li>首先，将所有的节点都划给组 A；设 #A 表示 A 组的容量，#B 同上；此时 #A = n，#B = 0</li><li>从任何一个点开始 DFS；当有 #A &lt; #B 成立时，重复下面的步骤：<ul><li>若访问了一个新节点，则将它加入到 path 中——既不属于 A，也不属于 B，但是必须成链</li><li>若退出了一个节点，则将它从 path 末端移出，加入组 B</li></ul></li><li>当 #A = #B 时，退出 DFS；已经求得了满足题目要求的 A 和 B 和简单路 path</li></ul><p>这相当于我们使得 path 总是经过我们选择的根节点，然后将不同的子树根据 A 和 B 实时的大小关系分配给它们；因为总是从下而上分配，所以粒度是小的；又因为 DFS 是单点步进的，所以得到的 path 是一条简单路。而从过程的最开始，A 和 B 就不可能公用一条边。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> belong[N], A, B;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="built_in">bitset</span>&lt;N&gt; vis;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fws</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> edge = <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head;</span><br><span class="line">    <span class="built_in">vector</span>&lt;edge&gt; e;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renew</span><span class="params">(<span class="keyword">size_t</span> siz)</span> </span>&#123;</span><br><span class="line">        head.resize(siz), e.clear();</span><br><span class="line">        fill(head.begin(), head.end(), <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="function">edge <span class="title">tmp</span><span class="params">(v, head[u])</span></span>;</span><br><span class="line">        head[u] = (<span class="keyword">int</span>) e.size();</span><br><span class="line">        e.emplace_back(move(tmp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; g;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[u] &amp;&amp; A != B) &#123;</span><br><span class="line">        belong[u] = <span class="number">0</span>;</span><br><span class="line">        path.push_back(u);</span><br><span class="line">        -- A;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = g.head[u]; i &gt;= <span class="number">0</span>;</span><br><span class="line">        i = g.e[i].second) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = g.e[i].first;</span><br><span class="line">        <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v);</span><br><span class="line">        <span class="keyword">if</span> (A != B) &#123;</span><br><span class="line">            path.pop_back();</span><br><span class="line">            belong[v] = <span class="number">-1</span>;</span><br><span class="line">            ++ B;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = read(), m = read();</span><br><span class="line">    g.renew(n + <span class="number">1</span>), g.e.reserve(m * <span class="number">2</span> + <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i --;) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(), v = read();</span><br><span class="line">        g.add_edge(u, v);</span><br><span class="line">        g.add_edge(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    fill(belong, belong + <span class="number">1</span> + n, <span class="number">1</span>);</span><br><span class="line">    A = n, B = <span class="number">0</span>, dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; aa, bb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (belong[i] &lt; <span class="number">0</span>) bb.push_back(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (belong[i]) aa.push_back(i);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; path.size() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : path) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : aa) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : bb) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要是需要更加不巧妙的方法，也可以维护子树大小和，然后保证递归处理分裂的只有一颗子树（因为 path 必须是简单链）——这可以通过最后处理重儿子来保证。</p><h3 id="b---bulldozer">B - <a href="https://codeforces.com/gym/103049/problem/B">Bulldozer</a></h3><blockquote><p>有一些方块堆的高高；现在你每次操作可以推/拉一个方块，使得它的上面，右边发生一个位移；位移之后收到重力影响方块可能会下落。水平空间无限，问你使得所有的方块落到平面上需要最小的操作次数。</p><p>注意：这里的推拉操作相对之前的类似的题目要随意许多；你可以拉动任意连续的方块，也可以从夹缝中推动方块（而不需要这一面空出来）</p></blockquote><p>瞄了一眼题解，这个题竟然还是个最短路……麻了麻了，想摸了，有时间在补吧（）</p><h2 id="后记">后记</h2><p>补了这么多题目之后，感觉这套题其实真的不错——指的是比较适合我们这种基础不扎实的队伍；因为绝大多数的题目都是意在考察思维能力，而不是考察某种数据结构或者是知识点；如果区域赛是这种形式的，我们发挥正常的可能性也相对而言是更高的。当然，这一场还是很拉就是了（</p><figure><img src="https://i.loli.net/2021/05/22/jRNOvLPlYwTX7pf.gif" class="lazyload" data-srcset="https://i.loli.net/2021/05/22/jRNOvLPlYwTX7pf.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="L_O2R3_1QZCDBV0DO909UMX.gif" /><figcaption aria-hidden="true">L_O2R3_1QZCDBV0DO909UMX.gif</figcaption></figure><p>此外，队伍的配合也存在相当的问题——我能明显的感受到我和队友之间羁绊的不足；因为英文阅读能力低下的原因，我基本也只能被动地听队友给讲题意，但是这样就会因为不默契导致交流效率的低下（）此外，我个人的精神力也十分弱小——或许我真的应该正视——我能不能够集中注意力地坐五个小时还保持思维的敏捷性——这个问题了……</p><p>更多的话也不想说了；也许是因为各种各样的事情，这个月可以说过的很摸了——上一篇博文还是三周之前……回头月度总结的时候再哈好说说吧（）</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Codeforces </tag>
            
            <tag> Gym </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Ubuntu 20.04 的自用配置</title>
      <link href="/2021/some-self-use-configure-for-ubuntu-20-04/"/>
      <url>/2021/some-self-use-configure-for-ubuntu-20-04/</url>
      
        <content type="html"><![CDATA[<p>5 月就快要结束了，因为各种各样的原因，这个月可以说是几乎没有怎么训练的（）所以就演变成了交一篇这样子的水文的模样。</p><p><del>实际上这篇水文也写了一个星期，只能说不愧是我</del></p><h2 id="安装">安装</h2><h3 id="背景说明">背景说明</h3><p>为了能够更好地模拟 XCPC 大多数区域赛现场的比赛环境<del>恰好又受到了金川的刺激</del>，有因为手头边恰好有一个笔记本上拆下来的 SSD，所以就决定这么给台式机上整一个 Ubuntu 的双系统了。</p><h3 id="准备">准备</h3><p>现在的 Ubuntu 官方镜像已经十分智能了，基本上官方的安装向导已经可以满足绝大多数情况下的要求了；所以这里也就不没事找事了；需要准备两个硬盘——一个一般的 U 盘用来制作启动盘，另一个速度快一点（至少得是移动硬盘）的硬盘作为安装目标盘。</p><p>制作启动盘就是先从<a href="https://cn.ubuntu.com/download">官网</a>下载镜像，然后用免费的 Ultra ISO 写入硬盘镜像即可；制作完启动盘之后先关机进入 BIOS，暂时关闭安全启动——因为这会阻止我们从安装介质启动电脑；然后再重启，进入临时启动菜单，从制作的启动盘启动即可；</p><p>第一次进入系统，Ubuntu 需要先检查各种文件，所以会需要较长的时间；之后就会进入到熟悉的安装界面——然后对着向导点点点就行了；分区什么的也非常智能，安装向导已经预制了双系统和全新安装两种默认配置，只需要拖动 GUI 组建就可以完成分区——当然，swap 什么的它都帮你做好了。如果有网络的话，可以直接在安装的时候选择安装必要的驱动，这样也省的进了系统之后还要手动（（</p><p>安装完成之后，先进 BIOS 重新打开安全启动，再将默认启动顺序改回先 Windows 再 Ubuntu；这样每次进 Ubuntu 只需要先插上 SSD，然后进临时启动菜单选择 Ubuntu 的引导就可以了。</p><h2 id="配置-偏好">配置 &amp; 偏好</h2><p>以下部分的内容都是个人偏好的配置，仅供参考（）大概会持续更新把（</p><h3 id="系统设置相关">系统设置相关</h3><p>GNOME 桌面的设置已经提供了相当多的配置选项；直接修改既方便，也直接影响了使用体验；下面的内容就设置的每一个大栏目下要做的事情简要的说明一下：</p><h4 id="键盘快捷键">键盘快捷键</h4><p><strong>声音和媒体</strong>：如果你使用的是 Windows 键盘，那么可以将键盘上的媒体键在这里手动绑定——比如播放/暂停，上一首下一首和调节音量这种。</p><p><strong>截图</strong>：和 Windows 的习惯不一样，但是个人觉得功能比 Windows 全多了；可以把对应的公共按钮调成和 Windows 一致的按钮（比如复制（选区）截图到剪切板换成 <code>shift</code> + <code>super</code> + <code>S</code>）</p><figure><img src="https://i.loli.net/2021/05/25/eg8WkErHbVs6nR1.png" class="lazyload" data-srcset="https://i.loli.net/2021/05/25/eg8WkErHbVs6nR1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>这是个人关于屏幕截图快捷键的偏好，如果更新了大概会换掉这张图吧（</p><p>还有要提一嘴的就是，Ubuntu 的截图，虽然看起来很高级（比如这些截取窗口，都是直接绘图甚至还保留了窗口阴影的透明度），但是并不能实现“抓拍”——并不是按下 <code>Print</code> 键就会截图==</p><h4 id="显示器">显示器</h4><p>主要是为了设置缩放；就算是 2018 年的电脑，一般都大概是笔记本 1080p 或者是台式机 1400p；不管是哪种 Windows 设置的都是 125% 缩放；但是 Ubuntu 的分数缩放做得很怪，所以如果怕麻烦的话 100% 也挺好（）否则，要先开启下面的 Fractional Scaling 才能选择 125%</p><figure><img src="https://i.loli.net/2021/05/24/JyQ1YAwoD7nFvzO.png" class="lazyload" data-srcset="https://i.loli.net/2021/05/24/JyQ1YAwoD7nFvzO.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2021-05-24 21-32-09 的屏幕截图.png" /><figcaption aria-hidden="true">2021-05-24 21-32-09 的屏幕截图.png</figcaption></figure><p>看到这个选项没被汉化，下面还有 <code>May increase power usage, lower speed, or reduce display sharpness</code> 就觉得不太对劲；这种不好的预感主要体现在各种第三方软件上（）因为实际上 Ubuntu 似乎只会整数倍数缩放，分数的缩放是先将你的逻辑分辨率放大到 2 倍下的对应尺寸，然后再压缩到你物理屏幕上的——比如我的电脑两个屏幕都是 2560*1440 的，开启 1.25 缩放就是先将逻辑分辨率设为 4096*2304（也就是 1.6 倍，两倍缩放下的 0.8），再压缩到物理分辨率来的；所以不管是显卡驱动还是其他应用程序（甚至系统自带的截图）“看到”的分辨率都是 4096*2304；此时，如果应用程序不支持缩放，那么 100% 的缩放在屏幕上看起来就只有原来大小的 80%，十分痛苦==</p><h4 id="外观">外观</h4><p>强烈建议选择 Dark；如果默认，那么 VS Code 就会黑色窗口下有白色工具栏；白色的话不是很适合写代码</p><figure><img src="https://i.loli.net/2021/05/25/98KDWTsdx6QL3fu.png" class="lazyload" data-srcset="https://i.loli.net/2021/05/25/98KDWTsdx6QL3fu.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>总而言之要选择纯色（）另一个想要吐槽的就是 Dock 栏不能像 Windows 一样一个在左边一个在右边==</p><p>自动隐藏 Dock 栏总归还是不太方便，更何况 GNOME 的 Dock 没有那么舒服的可以被调出来，所以最好还是一直显示；和 Windows 看齐，将 Dock 栏的图标大小调到 <code>32*32</code> 就不会显得那么占地方了。</p><h3 id="终端">终端</h3><p>关于 zsh，你可以参考我的<a href="http://shiraha.cn/2020/use-zsh-in-windows-10-with-wtd-and-vscode/">这篇文章</a>和我的朋友的<a href="https://tmc0210.github.io/Mac%E7%9A%84%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96/">那篇文章</a>；</p><h4 id="安装-oh-my-zsh">安装 oh-my-zsh</h4><p>Ubuntu 官方镜像的 <code>apt</code> 使用的已经是国内访问起来较为舒服的源了，所以不需要换源，使用 <code>sudo apt install zsh</code> 安装 <code>zsh</code>；</p><p>完成之后，运行对应的脚本以安装 <code>oh-my-zsh</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span></span><br><span class="line"><span class="comment"># ↑ 通过 curl 或者 通过 wget ↓</span></span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>之后输入密码修改默认终端为 <code>zsh</code> 即可；Ubuntu 20.04 似乎要求重启之后，默认的终端才会自动进入 <code>zsh</code>.</p><p>为了方便以后使用，这里再把安装 <a href="https://github.com/romkatv/powerlevel10k">powerlevel10k</a> 的操作复述一次：</p><ul><li>克隆代码仓库：<code>git clone https://github.com/romkatv/powerlevel10k.git $ZSH_CUSTOM/themes/powerlevel10k</code></li><li>修改 <code>~/.zshrc</code>：<code>ZSH_THEME="powerlevel10k/powerlevel10k"</code></li><li>回到 <code>zsh</code>，自动或手动使用 <code>p10k configure</code> 更换终端主题风格，详情参考其文档</li></ul><p>然后，我们需要为 <code>zsh</code> 安装最低限度所需要的插件：<a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh-syntax-highlighting</a> 和 <a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-autosuggestions</a></p><ul><li><p>运行下面的命令以安装 zsh-syntax-highlighting：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.oh-my-zsh</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source <span class="variable">$&#123;(q-)PWD&#125;</span>/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot;</span> &gt;&gt; <span class="variable">$&#123;ZDOTDIR:-<span class="variable">$HOME</span>&#125;</span>/.zshrc</span><br><span class="line"><span class="built_in">source</span> ./zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br></pre></td></tr></table></figure></li><li><p>克隆 zsh-autosuggestions 的源代码：<code>git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</code></p></li><li><p>修改 <code>~/.zshrc</code>：<code>plugins=(git zsh-autosuggestions)</code></p></li><li><p>重启 <code>zsh</code> 或者打开一个新的会话，就会发现插件已经成功应用了</p></li></ul><p>安装 zsh-syntax-highlighting 之前要先进入一个合理的目录，用来存放其源代码。</p><h4 id="终端字体">终端字体</h4><p>此外，Ubuntu 默认的字体并不支持 Powerline 的众多图标；解决方法就是更换字体——既可以使用上一篇文章中介绍的 <a href="https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/Hack.zip">Hack Nerd Font</a>，也可以用 <a href="https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/UbuntuMono.zip">Ubuntu Nerd Font</a> <del>不过字体图标比例感人</del>；下载后安装，然后在终端中新建配置文件，选择字体即可。</p><figure><img src="https://i.loli.net/2021/05/25/36OLwPs9DReyAMY.png" class="lazyload" data-srcset="https://i.loli.net/2021/05/25/36OLwPs9DReyAMY.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>如果觉得一个个安装这些字体文件很麻烦，可以先在终端中将这些字体文件复制到 <code>/usr/share/fonts/</code> 下的某个子目录中，然后再运行下面的命令刷新字体缓存即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkfontscale</span><br><span class="line">sudo mkfontdir</span><br><span class="line">sudo <span class="built_in">fc</span>-cache -fv</span><br></pre></td></tr></table></figure><p>这样，应该就可以在其他的程序中看到这些字体了；最终终端看起来就像下面这样：</p><figure><img src="https://i.loli.net/2021/05/25/Rl4yC2qiW5Bcm8L.png" class="lazyload" data-srcset="https://i.loli.net/2021/05/25/Rl4yC2qiW5Bcm8L.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h4 id="别名">别名</h4><p>现在，我们默认使用 <code>zsh</code> 作为默认终端，而作为 Linux 终端，<code>zsh</code> 也支持使用 <code>alias</code> 指令为一些命令增加别名；如果我们将这些 <code>alias</code> 指令放在 <code>zsh</code> 的 rc 文件中，这些别名就会在 <code>zsh</code> 启动的时候装载，我们就可以直接使用了；</p><p><code>zsh</code> 有两个 rc 文件；一个全局级别的 <code>/etc/zsh/zshrc</code>，修改它需要 su 权限；另一个用户级别的 <code>~/.zshrc</code>，可以方便的修改；为了方便，我们都修改用户级别的 rc 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> cls=<span class="string">&quot;clear&quot;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="string">&quot;cd..&quot;</span>=<span class="string">&quot;cd ..&quot;</span></span><br><span class="line"><span class="built_in">alias</span> py=<span class="string">&quot;python3&quot;</span></span><br><span class="line"><span class="comment"># alias reload=&quot;source ~/.zshrc &amp; source /etc/zsh/zshrc&quot; # WSL 上正常，但是 Ubuntu 上似乎不能正常工作</span></span><br><span class="line"><span class="built_in">alias</span> omzsh=<span class="string">&quot;vim ~/.zshrc&quot;</span></span><br><span class="line"><span class="built_in">alias</span> zshrc=<span class="string">&quot;sudo vim /etc/zsh/zshrc&quot;</span></span><br><span class="line"><span class="built_in">alias</span> explorer=<span class="string">&quot;nautilus&quot;</span></span><br></pre></td></tr></table></figure><p>值得提一嘴的是 GNOME 默认的文件管理器是 <code>Nautilus file manager</code>，但是 Windows 上默认的是 Windows 资源管理器（<code>explorer</code>）；为了不去记这个奇怪的名字，我们可以制定一个别名== 别的就持续更新之后再说吧！</p><h3 id="开发环境">开发环境</h3><p>当然，既然是为了用来打 XCPC 而准备的 Ubuntu 环境，那么开发环境当然是必定不会少了：</p><h4 id="基本">基本</h4><p>首先是一些基本的程序，Ubuntu 未必全部预装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install wget curl vim git</span><br></pre></td></tr></table></figure><p>然后就是一些编译工具，主要就是 CMake、OpenJDK、Python 等等</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential cmake</span><br><span class="line">sudo apt install openjdk-14-jdk openjdk-14-jre </span><br><span class="line">sudo apt install python3-pip nodejs</span><br></pre></td></tr></table></figure><p>Ubuntu 内置了 <code>python3</code>，但是不能通过 <code>python</code> 命令唤起；我们可以为它创建一个软连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s &#x2F;usr&#x2F;bin&#x2F;python3 &#x2F;usr&#x2F;bin&#x2F;python </span><br><span class="line">sudo ln -s &#x2F;usr&#x2F;bin&#x2F;pip3 &#x2F;usr&#x2F;bin&#x2F;pip </span><br></pre></td></tr></table></figure><p>这样执行 <code>python</code> 和 <code>pip</code> 就会默认运行 <code>python3</code> 相关的程序了。</p><h4 id="关于-node.js">关于 Node.js</h4><p>除了从官网下载之外，还有一种相对比较简单的方式，可以方便地通过 <code>apt</code> 下载并安装 Node.js：</p><ul><li>首先，使用 <code>apt</code> 安装 <code>npm</code>：<code>sudo apt install npm</code></li><li>然后，使用 <code>npm</code> 安装 <code>n</code> —— 一个用来安装 Node.js 的工具：<code>sudo npm install n -g</code></li><li>然后，再使用 <code>n</code> 安装最新的 LTS 版本 Node.js：<code>sudo n lts</code></li><li>安装完成之后，运行 <code>PATH="$PATH"</code> 或者重开终端，刷新系统变量，就可以检查 <code>node -v</code> 了</li></ul><p>这个工具会自动从官网下载 <code>tar.xz</code> 包并自动安装最新的 Node.js。</p><h3 id="日用软件">日用软件</h3><p>只有开发软件当然还是远远不够的；这里列出的大多数日用软件都只需要按照官网的或者是网上到处流传的说明安装就不会出什么问题，这里只是作为列表列出防止忘记（</p><h4 id="microsoft-edge">Microsoft Edge</h4><p>Firefox 当然很好用，但是 Edge 承载了大量的同步书签之类的，而且 Chromium 内核的浏览器的表现也确实比 Firefox 要好；所以也确实得装一个：</p><p>官方网址：<a href="https://www.microsoftedgeinsider.com/zh-cn/download" class="uri">https://www.microsoftedgeinsider.com/zh-cn/download</a></p><p>下载 <code>*.deb</code> 包之后使用 <code>sudo dpkg -i</code> 安装即可。</p><h4 id="visual-studio-code">Visual Studio Code</h4><p>可以从 <code>snap</code> 商店安装；但是听说 <code>snap</code> 安装的版本无法使用中文输入法，所以还是要从官网上下载包来手动安装；前半句话我实践了，是真的；但是后半句话懒得测试了，测试完了再更新文章吧！</p><p>个人偏好：安装了插件 <code>C/C++</code>、<code>Chinese (Simplified) Language Pack for Visual Studio Code</code>、<code>vscode-icons</code>、<code>CMake Tools</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;workbench.iconTheme&quot;</span>: <span class="string">&quot;vscode-icons&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;files.autoSave&quot;</span>: <span class="string">&quot;afterDelay&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;editor.fontSize&quot;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">&quot;terminal.integrated.fontFamily&quot;</span>: <span class="string">&quot;Hack Nerd Font&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;terminal.integrated.fontSize&quot;</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="attr">&quot;git.confirmSync&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;http.proxyAuthorization&quot;</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这里是自用的 VS Code 的配置文件；如果之后有改动再更新这里吧！</p><h4 id="jetbrains-toolbox">Jetbrains Toolbox</h4><p>用来快速地安装所有的 Jetbrains IDE，教育版可以登陆账号之后一键全部激活；</p><p>官方网址：<a href="https://www.jetbrains.com/zh-cn/toolbox-app/download/download-thanks.html" class="uri">https://www.jetbrains.com/zh-cn/toolbox-app/download/download-thanks.html</a></p><p>下载的是个 <code>*.appimage</code>，给执行权限之后打开就会自动安装到电脑，之后就可以使用它安装 JB IDE 了；</p><p>它默认将 IDE 安装到 <code>~/.local/share</code> 目录下，所以如果要创建快捷方式，可以在 <code>~/.local/share/applications/</code> 目录下看到对应的 <code>*.desktop</code> 文件；复制到桌面允许运行即可。</p><h4 id="其他一般通过软件">其他一般通过软件</h4><p>因为基本都没什么坑，所以这里就列个表记录一下算了：</p><table><colgroup><col style="width: 9%" /><col style="width: 38%" /><col style="width: 9%" /><col style="width: 41%" /></colgroup><thead><tr class="header"><th>软件名</th><th>来源</th><th>类型</th><th>备注</th></tr></thead><tbody><tr class="odd"><td>Typora</td><td><a href="https://typora.io/#linux" class="uri">https://typora.io/#linux</a></td><td>apt</td><td>Markdown 编辑器，还可以搭配 PicGo <del>可惜输入法太拉了，没什么写博客的体验</del></td></tr><tr class="even"><td>QQ 音乐</td><td><a href="https://y.qq.com/download/download.html">QQ 音乐下载页</a></td><td>deb/appim行age</td><td></td></tr><tr class="odd"><td>FileZilla</td><td>snap 商店</td><td>snap</td><td>功能完备的 FTP 客户端</td></tr><tr class="even"><td>百度网盘</td><td><a href="https://pan.baidu.com/download">客户端下载</a></td><td>deb</td><td></td></tr><tr class="odd"><td>Sublime Text 3</td><td>snap 商店</td><td>snap</td><td></td></tr><tr class="even"><td>XMind 2020</td><td><a href="https://www.xmind.cn/download/">下载页面</a></td><td>deb</td><td>思维导图软件</td></tr></tbody></table><p>截至 2021-05-25，这些软件更新的时间还是比较阳间的。</p><h3 id="花里胡哨">花里胡哨</h3><p>当然，毕竟是把整块 SSD 都用来作为 Ubuntu 的系统盘了，所以不搞点花里胡哨似乎也不是很对劲；</p><h4 id="网易云音乐">网易云音乐</h4><p>官方下载网址：<a href="https://music.163.com/#/download" class="uri">https://music.163.com/#/download</a>，在某个不起眼的小角落可以下载 deb 包；Ubuntu 20.04 双击大概是装不了的，乖乖 <code>sudo dpkg -i</code> 吧（）</p><p>缓存首次启动就会发现有缩放问题，修改 <code>desktop</code> 文件（位于 <code>/usr/share/applications</code>）里的执行命令 <code>--force-device-scale-factor</code> 不起作用，但是直接终端运行带上这个参数有作用（？）；<a href="https://blog.csdn.net/a1171936767/article/details/114324666">分析</a>发现执行的实际上是一个脚本 <code>/opt/netease/netease-cloud-music/netease-cloud-music.bash</code>，而且是一个 Qt 程序；因此考虑使用针对 Qt 程序的办法）——在执行脚本中加入一个环境变量 <code>QT_SCALE_FACTOR</code> 表示缩放，如下图：</p><figure><img src="https://i.loli.net/2021/05/25/b9pTdAgWzOcK7rv.png" class="lazyload" data-srcset="https://i.loli.net/2021/05/25/b9pTdAgWzOcK7rv.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2021-05-25 04-27-08 的屏幕截图.png" /><figcaption aria-hidden="true">2021-05-25 04-27-08 的屏幕截图.png</figcaption></figure><p>之后再安装一个依赖 <code>sudo apt install libcanberra-gtk-module -y</code>，就可以正常使用网易云音乐了。</p><p>这种做法对于所有 Qt 程序都有效，<del>只要你能够找到程序的运行脚本在哪里（</del></p><h4 id="steam">Steam</h4><p>可以官网下载 <code>deb</code> 包，也可以直接使用 <code>apt</code> 安装；</p><p>首次启动大概缩放是有问题的，而且万<del>不</del>用的 <code>--force-device-scale-factor</code> 不起作用；此时需要打开它的 <code>desktop</code> 文件，修改它的启动命令，在前面加上环境变量 <code>GDK_SCALE=2</code></p><figure><img src="https://i.loli.net/2021/05/25/d9qRmQUtCAOxWM5.png" class="lazyload" data-srcset="https://i.loli.net/2021/05/25/d9qRmQUtCAOxWM5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>这样的修改大概还是不起作用的，但是非常玄学的是进去之后，调成大屏幕模式，再退出大屏幕模式，之后的缩放就一直正确了；不说奇怪只能说是非常奇怪（（（</p><p><code>GDK_SCALE</code> 听说好像是 Chromium 相关的参数，看来 Steam 客户端的 GUI 可能是浏览器套壳）</p><h3 id="杂项">杂项</h3><p>一些各种各样的小问题以及一些小操作：</p><h4 id="偏好字体">偏好字体</h4><p>首先，可以从 Windows 的字体目录 <code>C:\WINDOWS\Fonts</code> 目录下拷贝字体到 <code>/usr/share/fonts</code> 目录下，然后运行 <code>sudo fc-cache -fv</code> 来生成新的字体缓存。</p><table><colgroup><col style="width: 18%" /><col style="width: 81%" /></colgroup><thead><tr class="header"><th>字体</th><th>下载链接</th></tr></thead><tbody><tr class="odd"><td>PingFang SC</td><td><a href="https://github.com/45921/font-collection/tree/main/PingFangSC" class="uri">https://github.com/45921/font-collection/tree/main/PingFangSC</a></td></tr><tr class="even"><td>Hack Nerd Font</td><td><a href="https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/Hack.zip" class="uri">https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/Hack.zip</a></td></tr><tr class="odd"><td>Fira Code</td><td><a href="https://github.com/tonsky/FiraCode/releases/tag/5.2" class="uri">https://github.com/tonsky/FiraCode/releases/tag/5.2</a></td></tr></tbody></table><p>这里先放置一些必用字体的下载链接吧；但是只是这些是不够的，不过日后遇到了问题再说吧！</p><h4 id="和-windows-同步时间">和 Windows 同步时间</h4><p>Ubuntu 和 Windows 对于 BIOS 时间的处理方式不同；Ubuntu 认为 BIOS 上的时间就是 UTC 时间，然后会根据用户的设置的时区加上对应的偏移时间得到系统显示的时间；而 Windows 认为 BIOS 上的时间就是本地时间，不会做任何处理就会直接读取到系统上显示给用户——这导致的问题就是 Ubuntu 同步时间之后，Windows 的时间慢了八个小时。</p><p>因此，作为副系统的 Ubuntu 需要适应 Windows 的时间管理方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ntpdate</span><br><span class="line">sudo ntpdate time.windows.com</span><br><span class="line">sudo hwclock --localtime --systohc</span><br></pre></td></tr></table></figure><p>这样，再从 Ubuntu 进入 Windows 后的系统时间就是正常的了！</p><h4 id="处理图片">处理图片</h4><p>Ubuntu 上有两个很好用的命令行工具，可以用来压缩图片文件的大小；分别是 <code>jpegoptim</code> 和 <code>optipng</code>：它们都可以通过 <code>apt</code> 来安装，并支持使用参数控制输出的质量；</p><p>可以使用 <code>find . -type f -name "*.png" -exec optipng &#123;&#125; \;</code> 来递归的处理目录下的图片。</p><p>此外，文件管理器 nautilus 也有一个不错的插件 <code>nautilus-image-converter</code> 可以用来调整图片的尺寸，并且也可以方便地通过 <code>apt</code> 安装；安装完成后运行 <code>nautilus -q; nautilus &amp;</code> 重启文件管理器服务，找到任意一张图片，右击打开上下文菜单，可以看到出现了 <code>Resize Image</code> 的选项：</p><figure><img src="https://i.loli.net/2021/05/25/OqpIS2nuNaiQmHc.png" class="lazyload" data-srcset="https://i.loli.net/2021/05/25/OqpIS2nuNaiQmHc.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2021-05-25 04-00-39屏幕截图.png" /><figcaption aria-hidden="true">2021-05-25 04-00-39屏幕截图.png</figcaption></figure><p>单击打开之后，就可以缩放图像：</p><figure><img src="https://i.loli.net/2021/05/25/TuXCniBWtxePZlQ.png" class="lazyload" data-srcset="https://i.loli.net/2021/05/25/TuXCniBWtxePZlQ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2021-05-25 03-59-18 的屏幕截图.png" /><figcaption aria-hidden="true">2021-05-25 03-59-18 的屏幕截图.png</figcaption></figure><p>此外，如果还需要对于图像进行基本的编辑（比如裁剪），还需要安装 <code>gthumb</code>；它也可以通过 <code>apt</code> 安装。</p><h3 id="代理服务器设置">代理服务器设置</h3><p>因为需要访问校园网内网，所以需要设置代理（迫真</p><p>还不会搞，等以后会搞了再更新吧 ==</p><h2 id="一些说明">一些说明</h2><p>有些东西感觉放在上一板块显得过于冗长，但是感觉又不能不写；所以就开了一个这样的分块</p><h3 id="桌面图标-快捷方式">桌面图标 / 快捷方式</h3><p>Linux 没有一个明确的桌面标准，但是现在大家都在用的发行版大多都遵循了类似的规则；比如 GNOME 或者大家耳熟能详的 KDE Plasma、xorg 等等；它们显示的图标都是一类赋予了可执行权限的 <code>*.desktop</code> 文件；这些文件一般都在 <code>/usr/share</code> 的目录下，有的也会在 <code>/opt</code> 目录下；如果你通过 Jetbrains Toolbox 来安装 JB 全家桶的话，那么它安装的默认地址是 <code>~/.local/share</code> 下；<code>snap</code> 商店有的时候也会安装在 <code>/snap</code> 目录下。</p><p>一般创建快捷方式的方法，就是到这些目录下，复制出对应的 <code>.desktop</code> 文件，然后属性给可执行，并允许执行即可；使用文本方式打开这个文件，还可以看到它实际运行的命令；在有必要的情况下可以对其进行修改。</p><p>也许之后可以使用一些办法得到 GNOME 桌面获得的应用程序列表的文件来源（</p><h3 id="关于缩放">关于缩放</h3><p>前面的内容已经或多或少地提到了 Ubuntu 桌面混乱的缩放；在我的桌面环境下，实际只有 2560*1440 的屏幕上实际上跑着 4096*2304 的分辨率，100% 的程序肉眼可见的只有 80% 的大小。不仅对于没有很好适配的应用程序，对于浏览器呈现的页面来说也是这样——</p><p>Ubuntu 是有一个算是比较通用的强制缩放的开关 <code>--force-device-scale-factor=2</code>；可惜经过我的尝试，对于绝大多数软件来说都不起作用（（</p><h3 id="文件系统">文件系统</h3><p>在双系统的 Ubuntu 下，是可以通过自带文件管理器看到 Windows 下的盘符的（实际上是物理硬盘），并可以从其中读取文件，但是不能写入——这并不是因为 Ubuntu 不支持 NTFS——实际上，你插入任何一个 NTFS 移动硬盘都是可以正常读写的；导致 Ubuntu 将系统硬盘看作只读文件系统的原因是因为 Windows 默认开启快速启动，导致硬盘上写入了缓存，这会影响到 Ubuntu 对于它的访问。</p><p>当然，毕竟 Windows 是主要操作系统，为了 Ubuntu 稍微舒服一点就大改 Windows 的设置显得非常的没有必要，所以这里也就不再多作评论了（（</p><p>有待考据……如果发现什么问题之后再来更新吧！</p><h3 id="安装应用程序">安装应用程序</h3><p>一般而言，在 Ubuntu 里有几种安装程序的途径：</p><h4 id="apt">APT</h4><p><del>本 APT 具有超级牛力</del></p><p>非常熟悉；通过它可以方方便便地安装很多命令行应用和非命令行应用；通过增加 GPG 和仓库可以使得它更加广泛，可以安装更多的程序；比如 <code>deepin-wine</code> 就可以通过引入仓库后使用 <code>apt</code> 安装；</p><p>在使用 WSL 的时候，它自带的 <code>apt</code> 其实并不全面，很多软件都需要导入外部的仓库才能安装——比如说 <code>yarn</code> 又比如说 <code>openjdk</code> 等等；但是 Ubuntu 20.04 的 <code>apt</code> 已经很全面了，说实话确实省了许多功夫。</p><h4 id="dpkg">dpkg</h4><p><code>dpkg</code> 用来安装 <code>*.deb</code> 的包；很多时候下载的 <code>*.deb</code> 文件双击并不能正确安装；这个时候就需要在终端中 <code>sudo dpkg -i</code> 来安装它；当然，运行起来是什么样就保证不了了（（</p><h4 id="可执行文件">可执行文件</h4><p>诸如流行的 <code>*.appimage</code> 以及一些 <code>*.run</code> 或者 <code>*.app</code> 的文件，只需要在属性中赋予它可执行的权限就可以执行，并打开一个 GUI 窗口；有的是直接原位置运行了，有的会直接给安装到电脑中。比如 Jetbrains Toolbox 和 Qt 等程序。</p><h3 id="命令查表">命令查表</h3><p>一些不那么常用的，但是确实有可能用到的命令；硬要说肯定是可以围绕着它们写文章的，但是因为我很懒等各种客观因素，这里就先放在这里——以后补充说明的时候再更新吧！</p><table><thead><tr class="header"><th>命令</th><th>说明</th><th>备注</th></tr></thead><tbody><tr class="odd"><td><code>nvidia-smi</code></td><td>查看 Nvidia 独立显卡的运行状态</td><td></td></tr><tr class="even"><td><code>optipng &lt;file&gt; -out &lt;file&gt;</code></td><td>使用 <code>optipng</code> 压缩图片的文件大小</td><td>需要先安装 <code>optipng</code></td></tr><tr class="odd"><td><code>scrcpy</code></td><td>使用 <code>adb</code> 使得 Android 手机投屏</td><td>之后再开篇文章讲</td></tr></tbody></table><p>实际上它们如果变得常用了，我很大概率会给它们弄个别名吧（（</p><h2 id="后记">后记</h2><p>这篇文章是在安装好之后的 Ubuntu 上写的；只能说是非常难受了…… 一看输入法还是 2011-2012…… 只能说很努力了，这个年份的微软拼音还在玩泥巴呢（（</p><figure><img src="https://i.loli.net/2021/05/24/IVMp3l7Xk6YSQ9U.png" class="lazyload" data-srcset="https://i.loli.net/2021/05/24/IVMp3l7Xk6YSQ9U.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2021-05-24 20-50-43 的屏幕截图.png" /><figcaption aria-hidden="true">2021-05-24 20-50-43 的屏幕截图.png</figcaption></figure><p>不过，虽然打字万分难受，但是还是把这篇文章写完了（</p><h3 id="屏幕截图">屏幕截图</h3><figure><img src="https://i.loli.net/2021/05/25/zDIjcugWbEQHiLo.png" class="lazyload" data-srcset="https://i.loli.net/2021/05/25/zDIjcugWbEQHiLo.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="temp.png" /><figcaption aria-hidden="true">temp.png</figcaption></figure><h3 id="尚未解决的问题">尚未解决的问题</h3><p>当然，毕竟是 Ubuntu，想要用的和 Windows 一样舒服还是有一些距离的（</p><table><thead><tr class="header"><th>名称</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>有道词典缩放问题</td><td>经典不适配系统缩放导致观感 80%；通用的做法无效</td></tr><tr class="even"><td>Typora 不显示在 Dock</td><td>不仅仅是从命令行启动的 <code>typora</code>，从 GNOME 启动的也会先不显示图标</td></tr><tr class="odd"><td>Wine TIM 无字体</td><td>安装了多个字体均无效，当然缩放也有问题（</td></tr></tbody></table><p>如果以后有解决办法，再在后续的更新中说明吧！</p><h3 id="更新历史">更新历史</h3><p>记录了本文件从创建以来进行的更新：</p><table><thead><tr class="header"><th>日期</th><th>更新内容</th></tr></thead><tbody><tr class="odd"><td>2021-05-19</td><td>创建了本文档，更新了网易云音乐的缩放调整方法，更新了 Node 和快捷方式的说明</td></tr><tr class="even"><td>2021-05-25</td><td>增加了终端的配置说明，增加了一些截图，整理成文章</td></tr></tbody></table><p>大概下次有机会再整一个配置文件的备份仓库吧，Jetbrains IDE 每次重新配置老实说挺麻烦的（（</p>]]></content>
      
      
      <categories>
          
          <category> 折腾记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> 持续更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 108 回顾</title>
      <link href="/2021/codeforces-educational-round-108/"/>
      <url>/2021/codeforces-educational-round-108/</url>
      
        <content type="html"><![CDATA[<blockquote><p>补题链接：<a href="https://codeforces.com/contest/1519" class="uri">https://codeforces.com/contest/1519</a></p></blockquote><h2 id="记录">记录</h2><p>竟然足足一周没有正经的训练了…… 唉，这样可不行啊</p><p>这一场的话 ABC 肯定是没啥问题的，D 能不能做出来心里还真的没底；毕竟正式 CF 也不会允许我打了三个题然后出去吃顿饭什么的，所以只能说悬（</p><h2 id="题解">题解</h2><h3 id="a---red-and-blue-beans">A - <a href="https://codeforces.com/contest/1519/problem/A">Red and Blue Beans</a></h3><p>有手就行<del>没手不行（</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T, r, b, d;</span><br><span class="line">    <span class="keyword">for</span> (input, T; T --;) &#123;</span><br><span class="line">        input, r, b, d;</span><br><span class="line">        longs times = min(r, b);</span><br><span class="line">        longs delta = <span class="built_in">abs</span>(r - b);</span><br><span class="line">        <span class="keyword">bool</span> ok = delta &lt;= times * d;</span><br><span class="line">        output, ok ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>, <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得开 <code>long long</code> （</p><h3 id="b---the-cake-is-a-lie">B - <a href="https://codeforces.com/contest/1519/problem/B">The Cake Is a Lie</a></h3><p>稍微手玩一会就会发现其实答案是固定的值；所以只需要计算答案之后比较大小就行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> null = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">105</span>; ++ i)</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + i;</span><br><span class="line">    <span class="keyword">int</span> n, m, k, T;</span><br><span class="line">    <span class="keyword">for</span> (input, T; T --;) &#123;</span><br><span class="line">        input, n, m, k;</span><br><span class="line">        <span class="keyword">int</span> sq = min(n, m);</span><br><span class="line">        <span class="keyword">int</span> cost = <span class="built_in">abs</span>(n - m) * sq;</span><br><span class="line">        cost += sum[sq] * <span class="number">2</span> - sq - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> ok = cost == k;</span><br><span class="line">        output, ok ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>, <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手玩正方形，发现固定显然；再手玩长方形，发现多余的部分安哪里都一样，所以（</p><h3 id="c---berland-regional">C - <a href="https://codeforces.com/contest/1519/problem/C">Berland Regional</a></h3><blockquote><p>有 <span class="math inline">\(n \leq 2\cdot10^5\)</span> 个学生，每个学生都有自己所属的大学 <span class="math inline">\(u_i\)</span> 和实力 <span class="math inline">\(s_i\)</span>；设一组有 <span class="math inline">\(k\)</span> 人，第 <span class="math inline">\(j\)</span> 所大学一共有 <span class="math inline">\(\#j\)</span> 人：那么每个大学将会派出自己所属的实力最强的 <span class="math inline">\(\lfloor \frac{\#j}k\rfloor \cdot k\)</span> 人参加比赛；设比赛的影响力是所有参赛者的实力之和，求出 <span class="math inline">\(k \in [1, n]\)</span> 时赛站的实力。</p></blockquote><p>对于某个大学，它只能对 <span class="math inline">\(k \in [1, \# j]\)</span> 的比赛做出贡献——直接计算后累加就可以了；但是因为还要对每个大学的所有学生的实力进行排序，所以总复杂度是 <span class="math inline">\(\mathcal{O}(n\log n)\)</span> 的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = $.nextInt(), n, m, x;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;longs, <span class="keyword">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        $(n, m, x).nextArray(h + <span class="number">1</span>, h + <span class="number">1</span> + n);</span><br><span class="line">        sort(h + <span class="number">1</span>, h + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i) &#123;</span><br><span class="line">            ans[n - i] = i + <span class="number">1</span>;</span><br><span class="line">            heap.push(&#123; -h[n - i], i + <span class="number">1</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - m; i; -- i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [value, id] = heap.top();</span><br><span class="line">            heap.pop();</span><br><span class="line">            ans[i] = id, value -= h[i];</span><br><span class="line">            heap.push(&#123; value, id &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        longs mi = INT64_MAX, ma = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!heap.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [value, id] = heap.top();</span><br><span class="line">            minimize(mi, -value);</span><br><span class="line">            maximize(ma, -value);</span><br><span class="line">            heap.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ma - mi &lt;= x) $.put(<span class="string">&quot;YES&quot;</span>).putArray(ans + <span class="number">1</span>, ans + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">else</span> $.put(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案其实挺显然的，但是我还是想了半天（</p><h3 id="d---maximum-sum-of-products">D - <a href="https://codeforces.com/contest/1519/problem/D">Maximum Sum of Products</a></h3><blockquote><p>给了长度为 <span class="math inline">\(n \leq 5000\)</span> 的数组 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>，现在你可以翻转数组 <span class="math inline">\(a\)</span> 的一个连续子区间，问 <span class="math inline">\(\sum_{i = 1}^n a_i \cdot b_i\)</span> 的最大值</p></blockquote><p>暴力枚举反转区间 <span class="math inline">\([i, j]\)</span>，时间复杂度是 <span class="math inline">\(\mathcal{O}(n^3)\)</span> 的；考虑字符串算法中处理回文串的一些做法，我们可以枚举中间位置 <span class="math inline">\(i\)</span>，然后左右拓展翻转的区间，这样就可以使翻转的复杂度降维；总复杂度 <span class="math inline">\(\mathcal{O}(n^2)\)</span>；</p><h4 id="实现">实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> ll[N], rr[N], lc[N], rc[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = $.nextInt(), n, l, r;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        $(n, l, r).nextArray(ll + <span class="number">1</span>, ll + <span class="number">1</span> + l)</span><br><span class="line">            .nextArray(rr + <span class="number">1</span>, rr + <span class="number">1</span> + r);</span><br><span class="line">        <span class="built_in">memset</span>(lc, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">memset</span>(rc, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; ++ i) ++ lc[ll[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; ++ i) ++ rc[rr[i]];</span><br><span class="line">        <span class="keyword">int</span> lp = <span class="number">0</span>, rp = <span class="number">0</span>, lct = <span class="number">0</span>, rct = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> ded = min(lc[i], rc[i]);</span><br><span class="line">            lc[i] -= ded, rc[i] -= ded;</span><br><span class="line">            lp += lc[i] / <span class="number">2</span>, lct += lc[i];</span><br><span class="line">            rp += rc[i] / <span class="number">2</span>, rct += rc[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ded = min(lp, rp), ans = <span class="number">0</span>;</span><br><span class="line">        lct -= ded * <span class="number">2</span>, rct -= ded * <span class="number">2</span>;</span><br><span class="line">        lp -= ded, rp -= ded, ans += ded * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (lct &gt; rct) swap(lct, rct), swap(lp, rp);</span><br><span class="line">        <span class="keyword">int</span> more = rct - lct;</span><br><span class="line">        ded = min(more / <span class="number">2</span>, rp);</span><br><span class="line">        ans += ded, more -= ded * <span class="number">2</span>, rct -= ded * <span class="number">2</span>, rp -= ded;</span><br><span class="line">        <span class="keyword">if</span> (rct &gt; lct) &#123;</span><br><span class="line">            ded = more / <span class="number">2</span>, more = <span class="number">0</span>;</span><br><span class="line">            rct -= ded, lct += ded, ans += ded;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += rct;</span><br><span class="line">        $.put(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比赛中的话我真的能写出来吗？应该把，应该把（</p><h3 id="e---off-by-one">E - <a href="https://codeforces.com/contest/1519/problem/E">Off by One</a></h3><blockquote><p>二维平面的第一象限上有 <span class="math inline">\(n \leq 2\cdot10^5\)</span> 个点；每次操作，你可以选择两个没有被选中过的点，分别将它们向右或者向上移动一个单位，如果这两个点和原点三点共线，那么这次操作是有效的。问你最多可以执行的有效操作数量，并输出一种可能的操作序列。</p></blockquote><p>看起来很没有办法，但是涉及到简单平面几何，能想到的关键字也就那么多。但是即使这样，我也属实没有考虑到这实际上是一个暴力搜索的题目（</p><p>我们将每个点经过两种不同的移动之后得到的位置计算出来；那么，如果两个点可以进行一次有效的操作，就等价于它们变换得到的一个位置到原点的斜率是相等的；一个点可以进行两种不同的移动，就意味这一个点可以关联两种不同的斜率：这样，我们就得到了一张以斜率为点，而以每个可操作节点为边的图。</p><p>那么，问题就变成了找到最多的边对，它们之间共享了一个端点；或者说将每一条边分给一个端点，令端点 <span class="math inline">\(i\)</span> 分到的边数为 <span class="math inline">\(v_i\)</span>，那么答案就是 <span class="math inline">\(\sum\lfloor\frac{v_i}2\rfloor\)</span>；这是一个非常经典的问题，一种解决思路就是 DFS：对于点 <span class="math inline">\(i\)</span>，如果 <span class="math inline">\(v_i\)</span> 是奇数，就把从父亲到自己的边给自己，否则就给父亲；这样就完成了对树边的分配：</p><p>那么 DFS 树中的其他边呢？因为这是一个无向图，对于其中的每一个连通块而言，其 DFS 都是一个生成树，也就是说不存在跨越边——剩下的边对于父亲来说是前向边，对于后代来说是后向边。那么对于这些边，为了实现方便，全部都给父亲即可——而且这样也可以显然得到，这种方案只会在总边数为奇数的时候，在根节点处浪费一条边。</p><p>很经典，就是利用到父亲的边平衡子树的奇偶性；最多浪费的那条边也就是连通块生成树的根节点，<strong>他没有父亲</strong>，所以如果真的不能匹配也就只能浪费掉了。</p><h4 id="实现-1">实现</h4><p>因为斜率是铁分数，所以需要离散化（标号）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> Frac::frac;</span><br><span class="line"><span class="built_in">pair</span>&lt;frac, frac&gt; p[N];</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, N&gt; vis;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; g;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [v, ii] : g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[v] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> now = ii;</span><br><span class="line">        <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = dfs(v);</span><br><span class="line">            <span class="keyword">if</span> (tmp != <span class="number">-1</span>) &#123;</span><br><span class="line">                ans.emplace_back(now, tmp);</span><br><span class="line">                now = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (now != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="number">-1</span>) &#123;</span><br><span class="line">                ans.emplace_back(cur, now);</span><br><span class="line">                cur = <span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> cur = now;</span><br><span class="line">        <span class="keyword">else</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[u] = <span class="number">2</span>, cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = $.nextInt(), a, b, c, d;</span><br><span class="line">    g.resize(<span class="number">2</span> * n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">map</span>&lt;frac, <span class="keyword">int</span>&gt; id;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> one = frac(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        $(a, b, c, d);</span><br><span class="line">        <span class="keyword">auto</span> x = frac(a, b), y = frac(c, d);</span><br><span class="line">        p[i] = <span class="built_in">pair</span>(x.reduce(), y.reduce());</span><br><span class="line">        <span class="keyword">auto</span> k1 = (y + one) / x, k2 = y / (x + one);</span><br><span class="line">        k1.normal(), k2.normal();</span><br><span class="line">        <span class="keyword">if</span> (!id[k1]) id[k1] = ++ tot;</span><br><span class="line">        <span class="keyword">if</span> (!id[k2]) id[k2] = ++ tot;</span><br><span class="line">        g[id[k1]].emplace_back(id[k2], i);</span><br><span class="line">        g[id[k2]].emplace_back(id[k1], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) dfs(i);</span><br><span class="line">    $.put(ans.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [a, b] : ans) $.put(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现意外简单（</p><h3 id="f---chests-and-keys">F - <a href="https://codeforces.com/contest/1519/problem/F">Chests and Keys</a></h3><blockquote><p>有 <span class="math inline">\(n\)</span> 个宝箱，其中第 <span class="math inline">\(i\)</span> 个包含了 <span class="math inline">\(a_i\)</span> 个硬币；有 <span class="math inline">\(m\)</span> 把钥匙，其中第 <span class="math inline">\(j\)</span> 把可以卖 <span class="math inline">\(b_j\)</span> 个硬币。这些钥匙分别对应了不同种类的锁；如果要在第 <span class="math inline">\(i\)</span> 个箱子上安装可以用第 <span class="math inline">\(j\)</span> 把钥匙打开的锁，需要 <span class="math inline">\(c_{i, j}\)</span> 的成本；如果一个箱子上挂了多把锁，那么只有持有所有的这些钥匙才可以打开宝箱。</p><p>现在，Alice 持有这些宝箱和钥匙，并付出一定的成本来为箱子上锁；随后，Bob 会花一些硬币购买钥匙，并打开可以打开的所有宝箱以拿走其中的硬币；如果最后 Bob 的净利润严格大于 0，Bob 胜利；否则 Alice 胜利；现在，要求求出 Alice 必定胜利所需要付出的最少成本。</p><p>数据范围： <span class="math inline">\(1\leq n, m \leq 6\)</span>；<span class="math inline">\(1\leq a_i, b_j \leq 4\)</span>；<span class="math inline">\(1\leq c_{i, j} \leq 10^7\)</span>；</p></blockquote><p>只能说看到这个题目，是非常的没有想法了；但是数据又很小，像极了乱搞……那么问题就是怎么乱搞了（</p><p>首先，在解决这个问题之前，我们先解决一个经过劣化后的问题—— 如果 Alice 上锁的方式已经确定，那么 Bob 要怎么购买钥匙才能获得最大的收益呢？</p><p>为了解决这个劣化后的问题，我们对题目中描述的模型进行建模：将宝箱全部看作连接了源点的节点，且和源点连边容量为 <span class="math inline">\(a_i\)</span>；将钥匙全部看作链接了汇点的节点，且连边的容量为 <span class="math inline">\(b_j\)</span>；根据宝箱的上锁情况，从宝箱出发到对应的钥匙连边，边权是 <span class="math inline">\(\infin\)</span>；这样，我们就将上面的问题变成了一个网络流的问题。</p><p>那么，这个网络流的含义是什么呢？首先，我们可以获得的最大的收益是所有箱子的硬币之和，我们所支出的成本最多是所有的钥匙的价格之和；每当上锁，我们就相当于增加一个箱子打开的门槛—— 对于一个具体的箱子，我们打开它的成本是它所使用到的锁的钥匙的价格总和，但是不超过箱子能提供的硬币数量—— 没有人会去做一件亏本的事情。初始情况下，我们可以免费打开所有的箱子，但是因为上锁，所以我们需要付出额外的成本：因此，连边就代表了上锁带来的额外成本——这个箱子的成本需要由它上的锁对应的钥匙分担；综上所述，确定了上锁方案的情况下，Bob 得到的最大收益是： <span class="math display">\[\sum_{i = 1}^n a_i - \text{maxFlow}\]</span> 如果一个箱子的收益完全被需要用来开它的钥匙抵消了，那么就没有开的价值了；但是如果一把钥匙承担了超过它本身价值的收益的话，那么这把钥匙就有买的必要；一种达到这个最大收益的办法是购买所有出边满流的钥匙，但是购买的钥匙数量未必是最少的。</p><p>虽然，这种建模方法和常见的<del>裸的</del>网络流并不一样：因为钥匙和箱子的关系是 <code>&amp;</code> 的，因此如果按照代价建模的话，网络流可以恰好地考虑到钥匙开锁的性质和成本。</p><p>但是，即使数据范围像本题这样小，上锁方案还是有 <span class="math inline">\(nm\)</span> 种；如果要枚举所有的上锁方案，其时间复杂度是 <span class="math inline">\(\mathcal{O}(2^{nm})\)</span> 的；因此，我们回到这个问题本身：注意到，如果 Bob 总是按照最大收益来进行操作的话，那么 Bob 的收益是不可能为负数的——因为 Bob 总是可以选择不购买任何钥匙，不打开任何的箱子，这样最后的总收入是 0；那么带入到上面的网络流模型中，就是所有的宝箱的价值都作为成本流量流入了汇点；换句话说，这个网络流的一个最小割是源点和其他所有节点。</p><p>那么考虑上述的网络流中没有任何上锁的连边，我们现在来考虑在这张图中连边；我们用状态 <span class="math inline">\([F_{1..n}, L, R, P]\)</span> 来表示当前的网络流图的连边状态：<span class="math inline">\(F_i\)</span> 代表从源点到宝箱 <span class="math inline">\(i\)</span> 的连边流出的成本，<span class="math inline">\(L\)</span> 表示当前考虑的宝箱，<span class="math inline">\(R\)</span> 表示当前考虑的钥匙编号 <span class="math inline">\(j\)</span>，<span class="math inline">\(P\)</span> 表示从钥匙 <span class="math inline">\(j\)</span> 到汇点的连边流入的成本；现在，我们考虑所有的 <span class="math inline">\(i \to j\)</span> 的连边，进行动态规划：</p><ul><li>跳过 <span class="math inline">\(i \to j\)</span>：也就是这条边不上锁</li><li>利用这条边转移一些成本：这条边上锁，但是转移的一部分流量</li></ul><p>如果使用这条边转移流量，那么需要满足 <span class="math inline">\(S \to i\)</span> 和 <span class="math inline">\(j \to T\)</span> 的边都还有足够的流量剩余；更新状态之后，若所有的 <span class="math inline">\(F_i\)</span> 都已经满流了，则说明成本已经足够抵消所有的宝箱了，更新答案；同时，按照一个特定的顺序考虑 <span class="math inline">\([L, R]\)</span>，将下一对要考虑的点对更新到状态中。如果状态合法，就更新到 dp 数组中。</p><p>简单地说，因为数据范围小，我们枚举所有满足了约束条件的转移方法导致的状态，并计算所有的流空的状态的花费的最小值。因为流量最多为 <span class="math inline">\(4\)</span>，而最多的情况下也只有 <span class="math inline">\(36\)</span> 条边，在考虑到每条边容量的约束条件，实际上状态数是相当有限的。</p><h4 id="实现-2">实现</h4><p>一些小细节：我们考虑 <span class="math inline">\([L, R]\)</span> 的顺序是先改变 <span class="math inline">\(L\)</span> 再改变 <span class="math inline">\(R\)</span>，这需要体现到映射函数中。</p><p>此外，因为考虑使用边运输流量的过程，一定是 <span class="math inline">\(S\)</span> 流出的递增的过程，所以在映射函数中这一部分的值总是在最高位；</p><p>因为每次要将所有的 <span class="math inline">\([L, R]\)</span> 的状态考虑周全，所以流出流量 <span class="math inline">\(P\)</span> 在映射函数中是最低位的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, a[<span class="number">10</span>], b[<span class="number">10</span>], c[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> F = <span class="number">4e7</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> dp[F];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; flow&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> lf&#123;&#125;, rt&#123;&#125;, push&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    state() = <span class="keyword">default</span>;</span><br><span class="line">    state(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;flow, <span class="keyword">int</span> lf, <span class="keyword">int</span> rt, <span class="keyword">int</span> push)</span><br><span class="line">    : flow(flow), lf(lf), rt(rt), push(push) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">std</span>:</span>:hash&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; :</span><br><span class="line">        <span class="keyword">public</span> __hash_base&lt;<span class="keyword">size_t</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;x)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> _hashcode = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> el : x) _hashcode = _hashcode * <span class="number">5</span> + el;</span><br><span class="line">        <span class="keyword">return</span> _hashcode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> hashcode) <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _ret(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">            _ret[i] = <span class="keyword">int</span>(hashcode % <span class="number">5</span>), hashcode /= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> _ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">std</span>:</span>:hash&lt;state&gt; :</span><br><span class="line">        <span class="keyword">public</span> __hash_base&lt;<span class="keyword">size_t</span>, state&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> state &amp;x)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> _hashcode = hash&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&#123;&#125;(x.flow);</span><br><span class="line">        _hashcode = _hashcode * <span class="number">6</span> + x.rt;</span><br><span class="line">        _hashcode = _hashcode * <span class="number">6</span> + x.lf;</span><br><span class="line">        _hashcode = _hashcode * <span class="number">5</span> + x.push;</span><br><span class="line">        <span class="keyword">return</span> _hashcode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state <span class="keyword">operator</span>[](<span class="keyword">size_t</span> hashcode) <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> _push = <span class="keyword">int</span>(hashcode % <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">auto</span> _lf = <span class="keyword">int</span>((hashcode /= <span class="number">5</span>) % <span class="number">6</span>);</span><br><span class="line">        <span class="keyword">auto</span> _rt = <span class="keyword">int</span>((hashcode /= <span class="number">6</span>) % <span class="number">6</span>);</span><br><span class="line">        <span class="keyword">return</span> state(</span><br><span class="line">                hash&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&#123;&#125;[hashcode /= <span class="number">6</span>],</span><br><span class="line">                _lf, _rt, _push);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    $(n, m).nextArray(a, a + n).nextArray(b, b + m);</span><br><span class="line">    const vector&lt;int&gt; va(a, a + n), vb(b, b + m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        $.nextArray(c[i], c[i] + m);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="keyword">int</span> ans = inf; dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; F; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == inf) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">auto</span> s = hash&lt;state&gt;&#123;&#125;[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> f : &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.flow[s.lf] + f &gt; a[s.lf] ||</span><br><span class="line">                s.push + f &gt; b[s.rt]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> pay = !f ? <span class="number">0</span> : c[s.lf][s.rt];</span><br><span class="line">            <span class="keyword">auto</span> now = s;</span><br><span class="line">            now.flow[s.lf] += f, now.push += f;</span><br><span class="line">            <span class="keyword">if</span> (s.lf + <span class="number">1</span> == n) &#123;</span><br><span class="line">                now.lf = now.push = <span class="number">0</span>;</span><br><span class="line">                now.rt = s.rt + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> now.lf = s.lf + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (now.flow == va) minimize(ans, dp[i] + pay);</span><br><span class="line">            <span class="keyword">if</span> (now.rt &lt; m) &#123;</span><br><span class="line">                <span class="keyword">auto</span> id = hash&lt;state&gt;&#123;&#125;(now);</span><br><span class="line">                minimize(dp[id], dp[i] + pay);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    $.put(ans == inf ? <span class="number">-1</span> : ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能说从网络流建模，到最后的那个 DP 求解，没有一个是现在的我能想出来的（）图论，网络流，恐怖如斯——这也不是我近来第一次被网络流题目锤了== 得想点办法才行。</p><p>实际上，这个题涉及到的东西远不止这篇题解胡说八道的这么点，与之相关的知识点比想象中还是要多出许多的。</p><h2 id="后记">后记</h2><p>没什么特别想说的，一周不写代码手感属实全无了== 实际上 E 也不算是什么难题<del>虽然我也没有想到极角排序什么的</del>，但是为什么每一次遇到这种题（不管是我自己打 cf 还是在线下训练中遇到了）都做的非常的费劲呢——还是做题思维的问题吧，ACM 之所以我这种人也能勉强打打，就是因为比起 OI 而言它会更加的注重思维水平；所以还是得多想多学（</p><p>此外，我的图论属实有些拉跨——这个 F 实际上还有很多关键词相关联：比如什么最大权闭合子图啊，什么霍尔定理啊，什么二分图匹配啊之类的，但是十分恐怖的是<strong>我都不会</strong>；就算是偏向思维的比赛，也是要建立在你有足够的知识积累的基础上，只能说这样属实不行（）得花个专门的时间搞搞图论才行啊 ==</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Windows 10 设备上启动 FTP 服务</title>
      <link href="/2021/host-a-ftp-server-on-your-windows-10-pc/"/>
      <url>/2021/host-a-ftp-server-on-your-windows-10-pc/</url>
      
        <content type="html"><![CDATA[<p>一些关于在 Windows 电脑上折腾 FTP 文件传输的记录。毕竟虽然但是，华科大内网的连接速度还是非常可以的，如果能够很好的借助 FTP 传输文件的话，倒也省得我带着移动硬盘在寝室和实验室来回跑了（</p><p>本文的服务器端仅使用 Windows 10 自带的 IIS 控制面板。</p><h2 id="前置准备">前置准备</h2><p>一些开始教程之前的准备；</p><h3 id="增加-windows-功能">增加 Windows 功能</h3><p>使用 Win + R 运行 <code>optionalfeatures</code>，或者在搜索菜单中搜索“启用或关闭 Windows 功能”；</p><p>找到 <code>Internet Information Services</code>，将其下的“FTP 服务器”的所有子选项勾选，并勾选“Web 管理工具”下的“IIS 管理控制台”。</p><figure><img src="https://i.loli.net/2021/04/26/STQwHnEW4BG7YJP.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/STQwHnEW4BG7YJP.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>打开设置，进入应用 <code>-&gt;</code> 应用与功能，点击“可选功能”；搜索 <code>OpenSSH</code>，找到并安装“OpenSSH 服务器”和“OpenSSH 客户端”。</p><figure><img src="https://i.loli.net/2021/04/26/fHKQxUYBG7NCMX5.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/fHKQxUYBG7NCMX5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>现在，你应该可以通过计算机管理，或者搜索菜单找到“Internet Information Services (IIS) 管理器” 了。IIS 管理器就有点像之前的云服务器面板一样，不过是 Windows 自带的就是了（</p><p>但是因为 Windows 自身也是有防火墙的，我们要先允许 FTP 服务通过 Windows 的防火墙；在搜索菜单中搜索“允许应用通过 Windows 防火墙”，点更改设置，找到并勾选“FTP 服务器”；然后点击窗口右下角的“允许其他应用”按钮，浏览路径，找到 <code>C:\Windows\System32\svchost.exe</code>，并添加，确定。</p><p><del>其实在配置远程桌面服务的时候也需要在这里配置这一项目</del></p><h3 id="ftp-sftp-ftps">FTP &amp; SFTP &amp; FTPS</h3><p>其实你要我说也说不太清楚，截至今天我总共已经翘了 2/2（100%）节计算机网络的课了；但是一些常识性的东西还是能简单的说说的：</p><table><thead><tr class="header"><th>协议类型</th><th>端口</th><th>备注</th></tr></thead><tbody><tr class="odd"><td>FTP</td><td>21</td><td>Windows 资源管理器唯一支持的 FTP 形式；明文传输，安全性差，但是很方便</td></tr><tr class="even"><td>SFTP</td><td>22</td><td>使用 <code>sshd</code> 作为守护进程；安全，但是传输效率较为低下</td></tr><tr class="odd"><td>FTPS（Explicit）</td><td>21</td><td>需要一个证书；客户端先发起一个明文的请求，然后再切换到加密连接进行</td></tr><tr class="even"><td>FTPS（Implicit）</td><td>990</td><td>同样需要证书；全程加密连接，服务端会拒绝掉所有尝试不通过加密的请求</td></tr></tbody></table><p>实际上 FTP 开放的端口并不止一个——有命令通道和数据通道，21 一般指命令通道；FTP 的连接分为主动模式（Standard）和被动模式（Passive）：</p><ul><li>主动模式下，客户端首先通过 TCP-21 端口和服务器连接；客户端需要接受数据的时候发送 PORT 命令告诉服务器客户端用来接收数据的端口，然后服务器使用 TCP-20 端口与客户端建立连接，也就是数据通道；</li><li>被动模式下，通过 TCP-21 建立连接后发送 PASV 命令；服务端接收命令后打开一个临时端口并通知客户端，客户端再连接服务器的此端口，进行数据传送；</li></ul><p>一般来说，由于防火墙一般不允许接受外部发起的连接，所以外网的客户端可能无法使用 Passive 模式连接；</p><p>FTP 家族比较混乱，一般来说都用 SFTP 了；FTP 协议由于非常的不安全，近年来主流的浏览器都已经放弃了在浏览器中内置 FTP 的支持了——毕竟基础的支持 Windows 资源管理器也提供了。</p><h2 id="配置服务器">配置服务器</h2><p>对于 FTP、SFTP、FTPS 三种服务器的配置方法：</p><h3 id="ftp">FTP</h3><p>进入 IIS 管理器，在左侧的连接栏中找到“网站”，右键增加 FTP 站点；</p><figure><img src="https://i.loli.net/2021/04/26/hftqrD7uyjIONa3.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/hftqrD7uyjIONa3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>在弹出的窗口中指定名称和映射的物理地址，点下一步：</p><figure><img src="https://i.loli.net/2021/04/26/dUsW42MiIbk9Qtp.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/dUsW42MiIbk9Qtp.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>关于 IP 地址，你可以填写你的 IP；如果你不知道<del>填写哪一级别的 IP</del>，你也可以默认“全部为分配”，相当于填入了通配符 <code>*</code>；如果设置了其他的端口，那么访问时的 IP 地址需要带上端口号；如果提供了虚拟主机名，那么访问时还需要加上虚拟主机名，因为没有必要所以这里统统默认。</p><p>因为我们现在还不是配置 FTPS，所以选择“无 SSL”。</p><p>接下来是配置权限的页面；如果是作为一个公开的 FTP 服务器，可以勾选匿名身份验证，授权全部用户读写权限（当然，这是不可能的）；否则需要进行配置密码：</p><h4 id="windows-专业版">Windows 专业版</h4><p>用户组策略设置只有专业版的 Windows 10 才有；在计算机管理中的本地用户和组菜单中可以新建用户（组），并且进行细致的组策略管理。我们新建一个一般用户，并设置用户名和密码</p><figure><img src="https://i.loli.net/2021/04/26/P7VXZEbWmIknhej.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/P7VXZEbWmIknhej.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>注意需要取消勾选用户下次登陆时须更改密码，不然会比较麻烦。</p><figure><img src="https://i.loli.net/2021/04/26/QZOHk8Fq2bRtWBN.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/QZOHk8Fq2bRtWBN.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>然后我们回到 IIS 面板，进入我们刚才创建的服务器的主页；首先进入 FTP 身份验证页面，并且关闭匿名验证：</p><figure><img src="https://i.loli.net/2021/04/26/DuLHyEPdgCQ9jik.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/DuLHyEPdgCQ9jik.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><img src="https://i.loli.net/2021/04/26/inXVkgLwtl6N4W8.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/inXVkgLwtl6N4W8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>然后再进入到旁边的 FTP 授权规则页面，增加允许规则，并选择我们刚创建的用户（们）：</p><figure><img src="https://i.loli.net/2021/04/26/VjF2BmJD5pRNbKT.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/VjF2BmJD5pRNbKT.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>不出意外，现在已经可以正常在 Windows 资源管理器里输入 <code>ftp://localhost/</code> 来输入密码访问了。</p><h4 id="windows-家庭版">Windows 家庭版</h4><p>Windows 10 家庭版不支持组策略管理，但是支持创建账户；我们可以直接在设置页面创建一个本地的标准账户，并赋予密码，也可以在这里设置允许规则；唯一的问题就是无法进行精细的权限管理，当然，作为一个实用派的萌新，倒也没有必要搞过于精细的权限管理；真要怕被日用时开不用时关就行了，而且 FTP 一个明晃晃的明文传输，人家要真想抓包搞你你也没有什么办法（</p><p>还有一种做法是在服务器主页的右侧栏中的基本设置里（如下）的连接为中设置用户名密码，而在服务器设置里设置允许所有用户：</p><figure><img src="https://i.loli.net/2021/04/26/DXl9igdMo1kCUGF.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/DXl9igdMo1kCUGF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>但是因为我实在是不太理解微软的权限管理，所以这里也就没有尝试，不多废话了。</p><hr /><p>当然，如果你怕麻烦<del>而且心很大</del>，也可以使用你当前的账户直接连接到 FTP 服务器；此时你的账号名可以通过在 <code>CMD</code> 中运行 <code>echo %username%</code> 获得；如果你当前使用的账户连接到了 Microsoft 账户，那么也可以使用 <code>MicrosoftAccount/your@email.com</code> 作为你的用户名，登陆密码作为你的密码。</p><h3 id="ftps">FTPS</h3><p>FTPS 是 FTP over SSL 的简称，分为显式和隐式两种；很遗憾 XFTP 7 学生版并不支持<del>似乎标准版也不支持</del>，所以如果你想要通过 FTPS 连接你的 FTP 服务器，那么你需要下载合适的客户端：</p><ul><li><a href="https://www.filezilla.cn/download">FileZilla 客户端</a></li><li><del>ES 文件浏览器</del></li></ul><h4 id="ssl-证书">SSL 证书</h4><p>当然，既然是走 SSL，那么你首先要有一个 SSL 证书；可以自签，也可以绑了域名后申请一个免费的；因为我有在 DNSpod 上托管腾讯云买的域名，所以可以直接方便地申请到免费的证书；下面介绍腾讯云的证书使用方法：</p><p>下载 SSL 证书压缩包后，可以看到其中包含了一个 IIS 专用证书的目录；我们进入 IIS 面板，选择计算机名称进入到服务器主页，进入服务器证书页面：</p><figure><img src="https://i.loli.net/2021/04/26/LQpHyba3gzB7MUJ.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/LQpHyba3gzB7MUJ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>然后再右侧栏中选择导入证书，选择下载的证书文件；然后根据你的 SSL 证书提供商的说明来填入相应的信息。</p><figure><img src="https://i.loli.net/2021/04/26/waprUiXDcMlKj1Z.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/waprUiXDcMlKj1Z.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>增加完成后，你就可以在所有的需要使用 SSL 的证书的地方找到你刚增加的 SSL 证书了。当然，如果要使用这种来自运营商颁发的证书，建议在 DNS 处增加一条解析记录，这样访问也更加优雅。</p><h4 id="修改服务器配置">修改服务器配置</h4><p>进入你创建的 FTP 服务器的主页，打开 FTP SSL 设置：</p><figure><img src="https://i.loli.net/2021/04/26/83o6xaXUbZmI5Rt.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/83o6xaXUbZmI5Rt.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>进入之后就可以指定 SSL 策略了；如果选择允许 SSL 连接，那么使用 Windows 资源管理器等软件的基本 FTP 的访问将还可以进行（当然，它们依然不安全）；如果选择需要 SSL 连接，等于强制 FTPS，此时只能通过支持 FTPS 协议的客户端来访问 FTP 服务器，当然，也相对更加安全。</p><h4 id="隐式-ftps">隐式 FTPS</h4><p>因为 FTPS 隐式是通过一个固定的端口 <code>990</code> 来确立安全连接的，所以我们需要使得我们的服务器允许来自 990 端口的连接；进入 FTP 服务器主页，在右侧的操作栏中找到“绑定”并进入；增加对 990 端口的监听，并将类型设置为 ftp，就像下面这样：</p><figure><img src="https://i.loli.net/2021/04/26/eTs6juVnYmqhKDX.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/eTs6juVnYmqhKDX.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>这样重启服务器后，我们就可以通过支持 FTPS 的客户端，使用隐式的方式访问 FTP 服务器了；当然，即使不做这一步操作，我们也可以通过显式的方式使用 FTPS 协议访问 FTP 服务器。</p><h3 id="sftp">SFTP</h3><p>SFTP 和 FTP 完全不是一个东西；它借助了 <code>sshd</code> 运行，是 SSH 套件中的一个。所以在使用它之前，我们首先要在设置菜单中增加 OpenSSH 服务器功能；</p><p>然后，我们可以在管理员权限下的 Powershell 中运行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net <span class="built_in">start</span> sshd</span><br></pre></td></tr></table></figure><p>来启动 SSH 的守护进程；现在，我们应该可以在其他电脑上是用 SSH 或者客户端访问它了；使用支持 SFTP 的客户端（比如 Xftp 7）来访问它，可以直接访问到整个电脑的根目录。</p><p>当然，也可以像在 Linux 中修改 <code>sshd</code> 的配置文件一样修改；在 Windows 10 中，这个配置文件的绝对路径一般是 <code>C:\ProgramData\ssh\sshd_config</code>；</p><h4 id="限定某用户只能访问固定文件夹">限定某用户只能访问固定文件夹</h4><p>比如我们限制 <code>ftpuser</code> 只能访问 D 盘</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Match User ftpuser</span><br><span class="line">       ChrootDirectory D:\</span><br></pre></td></tr></table></figure><p>可以把上面的内容增加到 <code>sshd_config</code> 的末尾。</p><h4 id="限制本机-ssh-只能用来-sftp">限制本机 SSH 只能用来 SFTP</h4><p>将下面这句话增加到配置文件的末尾：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ForceCommand internal-sftp</span><br></pre></td></tr></table></figure><p>当然也可以配合缩进，限制特定用户的 SSH 功能（像上面那样）</p><h2 id="一些吐槽">一些吐槽</h2><p>配置过程中出现的一些神秘问题的记录</p><ul><li><p>XFTP 竟然不支持 FTPS，这是我万万没有想到的（</p></li><li><p>博主最开始尝试在 IIS 增加用户允许规则的时候甚至没有发挥作用，但是重新创建一个 FTP 服务器就没有问题了；只能说是十分神秘了（</p></li><li><p>SFTP 查看的文件列表似乎存在不全的情况，比如下图： <img src="https://i.loli.net/2021/04/26/SROZN2vk9Qrx3nI.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/SROZN2vk9Qrx3nI.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /></p><p>可以稳定地在各种客户端上复现，不知道是什么原因（）不然就用 SFTP 算了，谁搁着 FTPS 呢==</p></li></ul><p>哎，不能再折腾了，凑合着能用就要干活了，那这篇文章先到这里；如果有什么错误的话欢迎指正，如果可以解释上面的这些神秘问题的话也欢迎补充（）</p>]]></content>
      
      
      <categories>
          
          <category> 折腾记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 水 </tag>
            
            <tag> Windows 10 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round#717 div.2 回顾</title>
      <link href="/2021/codeforces-round-717-div2/"/>
      <url>/2021/codeforces-round-717-div2/</url>
      
        <content type="html"><![CDATA[<h2 id="记录">记录</h2><p>比赛的那天 <a href="https://ksmeow.moe/">KS</a> 酱办生日聚会，所以玩的有点晚——于是为了避免掉分就又开了个小号——结果还真的算是预防成功了（（只能说不愧是我==</p><p>和<a href="https://shiraha.cn/2021/codeforces-round-716-div2/">上一场</a>一样的出题人，也是熟悉的五个题目；但是这场总感觉比之前那一场要难一些——可能出题人不经意间触及了我较多的知识盲区吧（</p><h2 id="题解">题解</h2><h3 id="a---tit-for-tat">A - <a href="https://codeforces.com/contest/1516/problem/A">Tit for Tat</a></h3><p>右手就行<del>可是我白给了一发</del>；只要取出前面的加到最后一个元素上就行了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = $.nextInt(), n, k;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        input, n, k;</span><br><span class="line">        $.nextArray(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span> (k &amp;&amp; l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">auto</span> ded = min(k, a[l]);</span><br><span class="line">            k -= ded, a[l] -= ded, a[r] += ded;</span><br><span class="line">            ++ l;</span><br><span class="line">        &#125;</span><br><span class="line">        $.putArray(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到底是什么样的小天才才能写出 <code>++ l, -- r</code> 这种代码呢？以为很对称🐎（</p><h3 id="b---agaga-xooorrr">B - <a href="https://codeforces.com/contest/1516/problem/B">AGAGA XOOORRR</a></h3><p>考虑到最后只可能剩下两个相同的元素或三个相同的元素——因为更多的元素都可以合并到这两种情况上，所以只需要分别处理即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2060</span>;</span><br><span class="line">uint a[N], sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = $.nextInt(), n;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        $(n).nextArray(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] ^ a[i];</span><br><span class="line">        <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (sum[i] == (sum[n] ^ sum[i]))</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (sum[i] == (sum[j] ^ sum[i]) &amp;&amp;</span><br><span class="line">                    sum[i] == (sum[n] ^ sum[j]))</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">        $.put(found ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前白给成了直接排除一个元素，显然这是不科学的（</p><h3 id="c---baby-ehab-partitions-again">C - <a href="https://codeforces.com/contest/1516/problem/C">Baby Ehab Partitions Again</a></h3><blockquote><p>提供长度为 <span class="math inline">\(n \leq 100\)</span> 的数组 <span class="math inline">\(a\)</span>，你要从中删除一些元素，使得不可以将这个数组拆分成两个部分，使得两个部分的和相等；要求最小化删除元素的数量并输出删除元素的坐标。</p></blockquote><p>首先，显然当 <span class="math inline">\(\sum_{i = 1}^n a_i\)</span> 是奇数的时候不用删除任何元素；然后，为偶数情况下可以进行背包 <span class="math inline">\(DP\)</span> 来判断是否可能完成这样的划分；如果可以，那么问题就变成了如何删除元素。</p><p>不难想到最多只会删除一个元素，那么问题就是删除什么样的元素；我最开始因为删除最小的元素然后白给了一<strong>些</strong>罚时，因为这样是不正确的——比如删除 <code>2</code>，可以通过交换两个 <code>2</code> 和一个 <code>5</code> 来使得再次平衡；那么我们在考虑其他的一定可行的情况，就不难想到删除一个奇数。</p><p>如果整个数组都是偶数怎么办？那么我们可以整体右移 <span class="math inline">\(1\)</span> 位，显然和原数组是等价的；我们可以一直右移，直到我们找到了可以删除的奇数为止；显然，这一定可以找到；</p><p>从右移等价，我们可以联想到整个数组除以任何同一个数都是等价的；所以，一个最简单的方法就是首先约去整个数组的 <span class="math inline">\(\gcd\)</span>，然后找到一个奇数删除就行了——因为是等价的，所以这样的删除是合理的；</p><h5 id="代码实现">代码实现</h5><p>这个使用 <code>bitset</code> 的可行性背包实现属实颇有雅趣（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2050</span>, M = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = accumulate(a + <span class="number">1</span>, a + <span class="number">1</span> + n, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;N * M&gt; dp;</span><br><span class="line">    dp.<span class="built_in">set</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        dp |= (dp &lt;&lt; a[i]);</span><br><span class="line">    <span class="keyword">return</span> dp[sum / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> n = $.nextInt();</span><br><span class="line">    $.nextArray(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">if</span> (check(n)) &#123;</span><br><span class="line">        <span class="keyword">int</span> g = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            g = gcd(g, a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (a[i] / g % <span class="number">2</span>) &#123;</span><br><span class="line">                $.put(<span class="number">1</span>).put(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> $.put(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是这个卵题我白给了近十发，，我是真的菜（</p><h3 id="d---cut">D - <a href="https://codeforces.com/contest/1516/problem/D">Cut</a></h3><blockquote><p>给一个长度为 <span class="math inline">\(n \leq 10^5\)</span> 的数组 <span class="math inline">\(a\)</span>，进行 <span class="math inline">\(q\leq10^5\)</span> 次询问：每次询问关于一个区间 <span class="math inline">\([l, r]\)</span>，将它分成的最少的段数，使得每一段的 <span class="math inline">\(\text{LCM}\)</span> 都和连乘的乘积相等；求这个段数。</p></blockquote><p>首先，不难意识到 <span class="math inline">\(\text{LCM}\)</span> 和连乘积相等就是说这一段的 <span class="math inline">\(\gcd\)</span> 为 <span class="math inline">\(1\)</span>。那么问题就转化为了对于任意段 <span class="math inline">\([l, r]\)</span>，将它划分成互质的最小的段数。</p><p>那么一种很显然的想法就是对于范围内的所有质数（约 <span class="math inline">\(9600\)</span> 个）分别维护一个列表，包含了包含它为质因数的数字的下标；然后对于一个位置，对于它的每一个质因子在对应的表上二分查找出下一个位置，取最小值作为下一个区间开始的备选位置；但是这样做显然非常的啥b，因为有显而易见地简单优化<del>但是我也显而易见的没有想到</del>：</p><ul><li>我们可以倒着维护每一个质数的下一个位置，这样就不用对每个质数二分查找了</li><li>倒着转移的时候也考虑后一个位置的备选位置，这样就不用考虑到备选区间之间的冲突了</li></ul><p>那么这样，我们就可以维护出一个表 <span class="math inline">\(F_i\)</span>，表示从 <span class="math inline">\(i\)</span> 开始可以转移到的最远的备选位置；</p><p>但是这样还存在一个问题：如果所有的数字都是 <span class="math inline">\(1\)</span>，那么上面的做法会被卡成 <span class="math inline">\(n^2\)</span>；因此，为了能够快速的跳转求出区段数，我们可以利用倍增的思想，维护下两个、下四个备选位置；这样，就可以在 <span class="math inline">\(\log n\)</span> 的时间内完成转移，并且像二进制拆位那样构造出任何一个数字。</p><h5 id="代码实现-1">代码实现</h5><p>使用类筛的方法完成质因数分解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">9600</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], f[<span class="number">20</span>][N], to[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">decomposition</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">de</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (de[i].empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j += i)</span><br><span class="line">                de[j].push_back(i);</span><br><span class="line">            p.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(ref(p), ref(de));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, q, l, r;</span><br><span class="line">    $(n, q).nextArray(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">auto</span> [p, de] = decomposition(N);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; desc;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> ps = p.size();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> bound = n + <span class="number">1</span>;</span><br><span class="line">    desc.reserve(ps * <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ps; ++ i) &#123;</span><br><span class="line">        desc[p[i]] = i, to[i] = bound;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>][bound] = bound;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; -- i) &#123;</span><br><span class="line">        f[<span class="number">0</span>][i] = f[<span class="number">0</span>][i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> j : de[a[i]]) &#123;</span><br><span class="line">            minimize(f[<span class="number">0</span>][i], to[desc[j]]);</span><br><span class="line">            to[desc[j]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= bound; ++ j)</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][f[i - <span class="number">1</span>][j]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        $(l, r);</span><br><span class="line">        uint ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">            <span class="keyword">if</span> (f[i][l] &lt;= r) &#123;</span><br><span class="line">                ans += (<span class="number">1u</span> &lt;&lt; i);</span><br><span class="line">                l = f[i][l];</span><br><span class="line">            &#125;</span><br><span class="line">        $.put(ans + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使可以想到正确的维护方法，但是倍增的思想也不能不说是十分的高妙…… 学到许多（</p><h3 id="e---baby-ehab-plays-with-permutations">E - <a href="https://codeforces.com/contest/1516/problem/E">Baby Ehab Plays with Permutations</a></h3><blockquote><p>现在有长度为 <span class="math inline">\(n \leq 10^9\)</span> 的排列 <span class="math inline">\(\{1, \dots,n\}\)</span>，可以进行对于两个不同的下标两两交换的操作 <span class="math inline">\(k \leq 200\)</span> 次；问对于 <span class="math inline">\([1, k]\)</span> 次操作可以得到的不同的排列数量；</p></blockquote><p>首先，先说明一种贪心地将长度为 <span class="math inline">\(n\)</span> 的排序 <span class="math inline">\(p\)</span> 复位的做法——对于排列的最后一个位置 <span class="math inline">\([n]\)</span>：</p><ul><li>如果 <span class="math inline">\(p_n = n\)</span>，那么可以忽略这个位置；将原排列看作长度为 <span class="math inline">\(n - 1\)</span></li><li>否则，将 <span class="math inline">\(p_n\)</span> 和 <span class="math inline">\(p_{p_n}\)</span> 交换位置；此时至少可以使得 <span class="math inline">\(p_n\)</span> 复位，继续递归，但是操作次数 <span class="math inline">\(+1\)</span></li></ul><p>可以证明，这样处理完整个序列就可以得到将序列 <span class="math inline">\(p\)</span> 复位的最小操作次数。</p><p>那么，基于这种思想，我们可以构造出一种递推关系——假设 <span class="math inline">\(F_{n, j}\)</span> 表示了进行 <span class="math inline">\(j\)</span> 次交换后可以复位的、长度为 <span class="math inline">\(n\)</span> 的排列（或者说从复位的排列开始，进行 <span class="math inline">\(j\)</span> 次交换可以产生的排列）的数量：</p><ul><li><span class="math inline">\(j = 0\)</span>：此时，只有初始复位的排列一种情况；因此总是为 <span class="math inline">\(1\)</span></li><li>现在，我们考虑通过 <span class="math inline">\(F_{n - 1}\)</span> 向 <span class="math inline">\(F_n\)</span> 转移；即每次将 <span class="math inline">\(n\)</span> 放入长度为 <span class="math inline">\(n - 1\)</span> 的排列中：<ul><li>如果新放入的 <span class="math inline">\(n\)</span> 不进行交换，那么对答案没有贡献：可以直接转移</li><li>如果和前面的 <span class="math inline">\(n - 1\)</span> 个位置中的一个进行交换：那么贡献 <span class="math inline">\(1\)</span> 次次数，有 <span class="math inline">\(n - 1\)</span> 种转移方法</li></ul></li><li>综上所述，可以得到递推公式 <span class="math inline">\(F_{n, j} = F_{n - 1, j} + (n - 1) \cdot F_{n - 1, j - 1}\)</span>；</li></ul><p>那么，基于这个动态规划，我们可以有两种不同的做法：</p><h4 id="阳间做法">阳间做法</h4><p>注意到题目中的 <span class="math inline">\(k\)</span> 非常的小，所以即使进行 <span class="math inline">\(k\)</span> 次交换，最多只会使得 <span class="math inline">\(2k\)</span> 个位置错位；所以我们每次只需要能选出错位的位置长度，然后对于在这个范围内的长度求 <span class="math inline">\(F_{n, j}\)</span> 即可；那么，一种很显然的做法就是确定一个允许的错位位置的长度 <span class="math inline">\(i\)</span>，对于这个长度求 <span class="math inline">\(F\)</span>，最后统一考虑——</p><p>那么，答案长下面这样吗？ <span class="math display">\[\text{ans?}_{j} = \sum_{i = 0}^{\min(2j, n)} \mathbf{C}_n^{i} \times F_{i, j}\]</span> 不，当然不对——因为我们的 <span class="math inline">\(F_{n, j}\)</span> 可能实际上只变动了其中很少一部分的位置——而这样的话就会不可避免的和其他情况重合，导致计数的不准确；所以为了解决这个问题，我们可以考虑在<a href="https://shiraha.cn/2021/The-concept-of-dearangement-problems/">错排问题</a>种采用的解决方法——使用容斥原理包含/排除重复的部分：</p><ul><li>现在，我们定义 <span class="math inline">\(G_{n, j}\)</span> 和 <span class="math inline">\(F_{n, j}\)</span> 类似，但是每一个位置都是错排的情况数量</li><li>然后，我们在 <span class="math inline">\(F_{n, j}\)</span> 中选择一个位置固定，然后剩下的位置的任何排序就都符合要求，需要排除</li><li>但是这样的话，就会导致两个位置固定的情况被多排除了一次，需要重新包含</li><li>……</li></ul><p>所以，我们就可以在 <span class="math inline">\(\mathcal{O}(k^2)\)</span> 的时间内完成一次 <span class="math inline">\(G\)</span> 的求解；算法总复杂度是 <span class="math inline">\(\mathcal{O}(k^3)\)</span>。</p><h5 id="代码实现-2">代码实现</h5><p>一个很容易注意到的事情就是 <span class="math inline">\(\text{ans}_i\)</span> 可以由 <span class="math inline">\(\text{ans}_{i - 2}\)</span> 转移过来——因为你可以连续两次进行相同的交换来浪费两次交换机会== 由此，也很容易联想到奇偶分开（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">longs inv[N], c[N][N], f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initInverse</span><span class="params">(<span class="keyword">int</span> n, longs p)</span> </span>&#123;</span><br><span class="line">    inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        inv[i] = (p - p / i) * inv[p % i] % p;</span><br><span class="line">    inv[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">longs <span class="title">nCr</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    longs ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - r + <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        ret = ret * i % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; ++ i)</span><br><span class="line">        ret = ret * inv[i] % mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = $.nextInt(), k = $.nextInt();</span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * k; ++ i) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = <span class="number">1</span>, c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * k; ++ j) &#123;</span><br><span class="line">            f[i][j] = (f[i - <span class="number">1</span>][j] + (i - <span class="number">1</span>) * f[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">            c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    initInverse(<span class="number">2</span> * k, mod);</span><br><span class="line">    longs ans[] = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++ j) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> lim = min(n, <span class="number">2</span> * j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lim; ++ i) &#123;</span><br><span class="line">            longs cnt = <span class="number">0</span>, fix, fl;</span><br><span class="line">            <span class="keyword">for</span> (fix = <span class="number">0</span>, fl = <span class="number">1</span>; fix &lt;= i; ++ fix, fl = -fl) &#123;</span><br><span class="line">                cnt = cnt + fl * c[i][fix] * f[i - fix][j] % mod;</span><br><span class="line">                <span class="keyword">do</span> cnt = (cnt + mod) % mod; <span class="keyword">while</span> (cnt &lt; <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ans[j % <span class="number">2</span>] = (ans[j % <span class="number">2</span>] + nCr(n, i) * cnt) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        out.push_back((<span class="keyword">int</span>) ans[j % <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    $.putArray(out.begin(), out.end());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些说明：很显然 <span class="math inline">\(\mathbf{C}_i^j = \mathbf{C}_{i - 1}^j + \mathbf{C}_{i - 1}^{j - 1}\)</span>；</p><h4 id="阴间做法">阴间做法</h4><p>首先，我们需要先观察上面得到的那个递推公式，并考虑更深刻的理解它：</p><ul><li>考虑到 <span class="math inline">\(F_{n, 0} = 1\)</span>，除了递推的转移引入之外，都是通过 <span class="math inline">\(n - 1\)</span> 的形式引入的；</li><li>什么情况下会引入 <span class="math inline">\(n - 1\)</span>？当新加入的 <span class="math inline">\(n\)</span> 不放在 <span class="math inline">\([n]\)</span> 而是参与了与前面的位置交换的场合下；</li><li>引入时产生了什么副作用？因为进行了交换，所以奉献了一次交换次数，<span class="math inline">\(j = j + 1\)</span>；</li><li>所以，我们可以将 <span class="math inline">\(F_{n, j}\)</span> 看作从“下标”集合 <span class="math inline">\([0, n - 1]\)</span> 中选出一个大小 <span class="math inline">\(j\)</span> 的子集求积后求和的结果；</li></ul><p>形式化的说，我们可以得到下面的 <span class="math inline">\(F_{n, j}\)</span> 的表示形式： <span class="math display">\[F_{n, j} = \sum_{s \subset [0, n - 1] \and |s| = j} \ \prod_{i = 1}^j s_i\]</span> 那么接下来，对于全部需要的 <span class="math inline">\(j\)</span>，我们考虑从 <span class="math inline">\(F_{n}\)</span> 转移到 <span class="math inline">\(F_{2n}\)</span>：</p><ul><li><p>一个很显然的想法，就是我们从 <span class="math inline">\([0, n - 1]\)</span> 中选择 <span class="math inline">\(l\)</span> 个，从 <span class="math inline">\([n, 2n - 1]\)</span> 中选出剩下的，组成上面所提到的从集合 <span class="math inline">\([0, 2n-1]\)</span> 中选出的大小为 <span class="math inline">\(j\)</span> 子集；形式化地说就是将两部分的结果乘起来</p></li><li><p>前半部分的答案很显然是 <span class="math inline">\(F_{n, l}\)</span>，而后半部分的答案我们没有维护；但是我们可以把它看作从 <span class="math inline">\([0, n - 1]\)</span> 中选择了 <span class="math inline">\(j - l\)</span> 个，然后对于每一个都加上了 <span class="math inline">\(n\)</span>，也就是下面这样： <span class="math display">\[F&#39;_{n, j&#39;} = \sum_{s\subset [n, 2n-1] \and |s| = j&#39;} \ \prod_{i = 0}^{j&#39;}s_{i} = \sum_{s\subset [0, n-1] \and |s| = j&#39;} \ \prod_{i = 0}^{j&#39;}(s_{i} + n)\]</span> 那么这个式子展开是什么样的呢？因为这个连乘长得非常像二项式展开<del>但是不是，残念（</del>，所以我们可以想象一下它展开后的样子： <span class="math display">\[F&#39;_{n, j&#39;} = \sum_{l = 0}^{j&#39;} \mathbf{C}_{n - l}^{j&#39;-l} \times n^{j&#39;-l} \times \sum_{s\subset [0, n-1] \and |s| = l} \prod_{i = 0}^{l}s_i\]</span> 上面的式子中，有 <span class="math inline">\(\mathbf{C}_{n - l}^{j&#39; - l} = \mathbf{C}_n^{j&#39;} \times \mathbf{C}_{j&#39;}^l\)</span>；首先是选出坐标的组合数，然后乘上“二项式系数”。</p></li><li><p>然后，观察上面的式子的后半部分，我们会惊喜地发现它就是 <span class="math inline">\(F_{n, l}\)</span>，是我们已经维护的东西！</p></li></ul><p>综上所述，我们可以通过下面的转移方程完成从 <span class="math inline">\(F_{n}\)</span> 到 <span class="math inline">\(F_{2n}\)</span> 的转移： <span class="math display">\[F_{2n, J} = \sum_{j = 0}^J F_{n, j} \times F&#39;_{n, j&#39;},  \ \ j + j&#39; = J\]</span> 上式中的 <span class="math inline">\(F&#39;_{n, j}\)</span> 可以通过 <span class="math inline">\(F_{n, j}\)</span> 通过下面的多项式乘法转移得到： <span class="math display">\[F&#39;_{n, j} = \sum_{l = 0}^j \mathbf{C}_{n - l}^{j - l} \times n^{j - l} \times F_{n, l}\]</span> 当然，基础的从 <span class="math inline">\(F_{n - 1, j}\)</span> 和 <span class="math inline">\(F_{n - 1, j - 1}\)</span> 向 <span class="math inline">\(F_{n, j}\)</span> 的转化仍然有效；因此我们可以转化到任何的 <span class="math inline">\(n\)</span>：相当于我们从 <span class="math inline">\(n = 1\)</span> 出发，然后使用 <span class="math inline">\(\times2\)</span> 和 <span class="math inline">\(+1\)</span> 操作构造任何的 <span class="math inline">\(n\)</span> ——在构造的过程中完成上面的转移就可以了；一种很显然的思路就是二进制拆位，然后按位构造 <span class="math inline">\(n\)</span>：</p><h5 id="代码实现-3">代码实现</h5><p>基本的思路就是每次扩增 <span class="math inline">\(\times2\)</span>，如果这一位为 <code>1</code> 就再额外进行一次 <span class="math inline">\(+1\)</span> 扩增：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">longs inv[N], f[N], big[N], np[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initInverse</span><span class="params">(<span class="keyword">int</span> n, longs p)</span> </span>&#123;</span><br><span class="line">    inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        inv[i] = (p - p / i) * inv[p % i] % p;</span><br><span class="line">    inv[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">longs <span class="title">nCr</span><span class="params">(longs n, longs r)</span> </span>&#123;</span><br><span class="line">    longs ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = n - r + <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        ret = ret * i % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; ++ i)</span><br><span class="line">        ret = ret * inv[i] % mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculateBig</span><span class="params">(<span class="keyword">int</span> k, longs n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(big, <span class="number">0</span>, <span class="keyword">sizeof</span>(longs) * (k + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(np, <span class="number">0</span>, <span class="keyword">sizeof</span>(longs) * (k + <span class="number">1</span>));</span><br><span class="line">    np[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++ i)</span><br><span class="line">        np[i] = n * np[i - <span class="number">1</span>] % mod;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> lim = min((longs)k, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lim; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++ j) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = nCr(n - j, i - j) * f[j] % mod * np[i - j] % mod;</span><br><span class="line">            big[i] = (big[i] + t) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = $.nextInt(), k = $.nextInt();</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">bitset</span>&lt;32&gt; binary = n;</span><br><span class="line">    initInverse(N - <span class="number">1</span>, mod);</span><br><span class="line">    longs now = f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span> - __builtin_clz(n); i &gt;= <span class="number">0</span>; -- i) &#123;</span><br><span class="line">        calculateBig(k, now);</span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(longs) * (k + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= k; ++ s)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= k; ++ b)</span><br><span class="line">                <span class="keyword">if</span> (s + b &lt;= k)</span><br><span class="line">                    tmp[s + b] = (tmp[s + b] + f[s] * big[b]) % mod;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(f, tmp, <span class="keyword">sizeof</span>(longs) * (k + <span class="number">1</span>));</span><br><span class="line">        now *= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (binary.test(i)) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(longs) * (k + <span class="number">1</span>));</span><br><span class="line">            tmp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++ j)</span><br><span class="line">                tmp[j] = (f[j] + now * f[j - <span class="number">1</span>]) % mod;</span><br><span class="line">            <span class="built_in">memcpy</span>(f, tmp, <span class="keyword">sizeof</span>(longs) * (k + <span class="number">1</span>));</span><br><span class="line">            ++ now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    longs ans[] = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++ j) &#123;</span><br><span class="line">        ans[j % <span class="number">2</span>] = (ans[j % <span class="number">2</span>] + f[j]) % mod;</span><br><span class="line">        out.push_back((<span class="keyword">int</span>) ans[j % <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    $.putArray(out.begin(), out.end());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中的 <code>30 - __builtin_clz(n)</code> 的含义是： <code>int</code> 类型的 <code>n</code> 的最高位的 <code>1</code> 的所在的位置的低一位的下标；我们使用它作为扩增起点——不使用最高位的原因是我们已经从 <span class="math inline">\(1\)</span> 出发了，所以不需要对于首位的 <span class="math inline">\(1\)</span> 进行额外的扩增。</p><p>当然，上面的实现中的每次转移的时间复杂度是 <span class="math inline">\(\mathcal{O}(k^2)\)</span> 的，进行 <span class="math inline">\(\log_2n\)</span> 次转移；如果可以使用各种手段加快单次转移的速度，理论上可以做到 <span class="math inline">\(k \leq 10^5\)</span>（时间复杂度 <span class="math inline">\(\mathcal{O}(k\cdot \log k\log n)\)</span>）<del>但是我不会，原作者也不会</del></p><h2 id="后记">后记</h2><p>罚时是真的多，，明明还是可以回到 1700 的场嗯给我打成了防掉分场，只能说非常地不行了（</p><figure><img src="https://i.loli.net/2021/04/24/gTZwqeCs2iHVomn.jpg" class="lazyload" data-srcset="https://i.loli.net/2021/04/24/gTZwqeCs2iHVomn.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="JVS2TR2_F28UCRC3K_YG_3B.jpg" /><figcaption aria-hidden="true">JVS2TR2_F28UCRC3K_YG_3B.jpg</figcaption></figure><p>最近的准度不行啊，还是以后要多加注意才行；补题也要进行的更加迅速才行，不然题目真的补不完力<del>昨天半夜的 Div.1 + Div.2 还没有下落呜呜</del>（呜呜呜</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础知识：错排问题</title>
      <link href="/2021/The-concept-of-dearangement-problems/"/>
      <url>/2021/The-concept-of-dearangement-problems/</url>
      
        <content type="html"><![CDATA[<p>什么是错排问题？<strong>重排</strong>指的是在排列组合中，一个排列的所有的元素都不在原来的位置上；更加地形式化说明的话，就是对于一个包含 <span class="math inline">\(1\cdots n\)</span> 全部 <span class="math inline">\(n\)</span> 个元素的排列 <span class="math inline">\(p\)</span>，按照 <span class="math inline">\(1\)</span>-下标方法，对于任何 <span class="math inline">\(i \in [1, n]\)</span> 都满足 <span class="math inline">\(p_i \ne i\)</span>；这类问题常见的应用有信封问题（经典原型），书架问题（换皮原型）等。</p><p>那么，这篇文章着眼于如何推出错排问题的式子，以及它的简化式子展开介绍：</p><h2 id="递推公式">递推公式</h2><p>现在，我们假设有一个包含 <span class="math inline">\(1\cdots n\)</span> 全部 <span class="math inline">\(n\)</span> 个元素的排列 <span class="math inline">\(p\)</span>，并且按照 <span class="math inline">\(1\)</span>-下标方法定位；最开始时，对于任何 <span class="math inline">\(i \in [1, n]\)</span> 都满足 <span class="math inline">\(p_i = i\)</span>；那么我们对它进行操作，将它变成一个重排：</p><ul><li><p>首先从原来的序列中取出一个下标；因为不管选择哪个都是等价的，我们选择 <span class="math inline">\([n]\)</span> 位置，取出 <span class="math inline">\(n\)</span></p></li><li><p>再从剩下来的 <span class="math inline">\(n - 1\)</span> 个正确的位置中，选择一个位置 <span class="math inline">\([k]\)</span>；我们将要把 <span class="math inline">\(n\)</span> 放入 <span class="math inline">\([k]\)</span> 位置，取出 <span class="math inline">\(k\)</span></p><p>显然，这一步对于位置 <span class="math inline">\([k]\)</span> 的选择有 <span class="math inline">\(n - 1\)</span> 种不同的选择。</p></li><li><p>接下来，我们要将 <span class="math inline">\(k\)</span> 放回序列中；我们有两种选择：</p><ul><li><p>将 <span class="math inline">\(k\)</span> 放入位置 <span class="math inline">\([n]\)</span>；这样相当于交换了 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(k\)</span> 的位，使得了这两个位置符合了错排的考虑</p><p>现在还剩下 <span class="math inline">\(n - 2\)</span> 个位置，它们都是有序的；可以被作为一个子问题递归地处理</p></li><li><p>将 <span class="math inline">\(k\)</span> 放入位置 <span class="math inline">\([i \ne n]\)</span>，也就是不放入位置 <span class="math inline">\([n]\)</span>；这种情况下，我们可以这样考虑：</p><ul><li>对于位置 <span class="math inline">\([k] = n\)</span>，已经是确定的了，所以可以忽略它</li><li>我们暂时将 <span class="math inline">\(k\)</span> 放入 <span class="math inline">\([n]\)</span>，因为最终会将 <span class="math inline">\(k\)</span> 放到其他位置上，所以可以认为此时是未重排状态</li><li>此时，剩下的排列包含了 <span class="math inline">\(n - 1\)</span> 个元素，它们都“未经过重排”，可看作一个子问题递归</li></ul></li><li><p>综上所述，第一种选择是作为 <span class="math inline">\(n - 2\)</span> 的子问题，第二种选择 <span class="math inline">\(n - 1\)</span> 的子问题递归。</p></li></ul></li><li><p>那么，由于乘法法则和加法法则；令 <span class="math inline">\(D_n\)</span> 表示长度为 <span class="math inline">\(n\)</span> 的重排排列的数量，那么可得到：</p></li></ul><p><span class="math display">\[D_n = (n - 1) \cdot (D_{n - 1} + D_{n - 2})\]</span></p><p>且特殊地存在 <span class="math inline">\(D_0 = 1\)</span> 和 <span class="math inline">\(D_1 = 0\)</span>；这就是我们得到的第一个递推式子；</p><h3 id="化简">化简</h3><p>这一步的化简网上一般有两种做法；作者选择了她喜欢的一种详细介绍：</p><hr /><p>对于上述得到的重排公式，我们在等式的两侧同时减去 <span class="math inline">\(nD_{n -1}\)</span>，可得： <span class="math display">\[\begin{align}D_n - nD_{n - 1} &amp;= -D_{n - 1} + (n - 1)D_{n - 2} \\                 &amp;= -[D_{n - 1} - (n - 1)D_{n - 2}] \\                 &amp;= (-1)^2[D_{n - 2} - (n - 2)D_{n - 3}] \\                 &amp;= \cdots \\                 &amp;= (-1)^{n - 1}(D_1 - D_0) \\                 &amp;= (-1)^n\end{align}\]</span> 所以，可以得到化简后的递推公式：<span class="math inline">\(D_n = nD_{n - 1} + (-1)^n\)</span>，特别地 <span class="math inline">\(D_1 = 0\)</span>；</p><hr /><p>另一种的做法假设 <span class="math inline">\(D_n = n!M_n\)</span>，那么 <span class="math inline">\(M_1 = 0\)</span>，<span class="math inline">\(M_2 = \frac12\)</span>；</p><p>对于 <span class="math inline">\(n \geq 3\)</span> 的场合，将第一个递推公式 <span class="math inline">\(D_n = (n - 1) \cdot (D_{n - 1} + D_{n - 2})\)</span> 根据定义拆分： <span class="math display">\[\begin{align}n!M_n &amp;= (n - 1)(n - 1)!M_{n - 1} + (n - 1)(n - 2)!M_{n - 2} \\      &amp;= n!M_{n - 1} - (n - 1)!M_{n - 1} + (n - 1)!M_{n - 2} \\n!M_n - n!M_{n - 1} &amp;= -((n - 1)!M_{n - 1} - (n - 1)!M_{n - 2}) \\M_n - M_{n - 1} &amp;= -\frac1n(M_{n - 1} - M_{n - 2}) \\\end{align}\]</span> 其实这种推导和上面的是完全等价的——不如说看起来几乎完全没有怎么化简；只是因为这种推导方法在得到通项公式的时候更加的自然<del>再推导一步就得到通项公式了，所以删了（</del>。</p><h2 id="通项公式">通项公式</h2><p>只有递推公式有的时候是不够的，所以我们还需要依据上面求出的递推公式求出通项公式；这里作者提供了三种不同的推导方法：</p><h3 id="套公式">套公式</h3><p>对于形如 <span class="math inline">\(f(n) = g(n)f(n - 1) + h(n)\)</span> 的递推方程，经过暴力展开，可以得到下面的公式： <span class="math display">\[f(n) = \prod_{i = 1}^n g(i) \cdot [f(0) + \sum_{i = 1}^n \frac{h(i)}{\prod_{j = 1}^ig(j)}]\]</span> 对于我们求得的递推公式 <span class="math inline">\(D_n = nD_{n - 1} + (-1)^n\)</span>，不难通过观察得出三个部分是 <span class="math inline">\(f(x) = D_x\)</span>、<span class="math inline">\(g(x) = x\)</span>、<span class="math inline">\(h(x) = (-1)^x\)</span>；带入上面的暴力公式中，可以求出： <span class="math display">\[D_n = n! \cdot [1 + \sum_{k = 1}^n \frac{(-1)^k}{k!}] = n! \cdot \sum_{k = 0}^n \frac{(-1)^k}{k!}\]</span> 那么就得到了错排数量的通项公式。</p><h3 id="继续推导">继续推导</h3><p>在板块一提到的第二种方法化简得到的：<span class="math inline">\(M_n - M_{n - 1} = -\frac1n(M_{n - 1} - M_{n - 2})\)</span>；我们将代入多个 <span class="math inline">\(n\)</span> 并将得到的式子的左侧和右侧全部相加，可以得到： <span class="math display">\[\begin{align}M_n - M_1 &amp;= (-1)^2\frac1{2!} + (-1)^3\frac1{3!}+\dots+(-1)^n\frac1{n!} \\M_n &amp;= \sum_{k = 2}^n (-1)^n\frac1{k!} + 1 + (-1)\frac1{1!} \\M_n &amp;= \sum_{k = 0}^n (-1)^n\frac1{k!}\end{align}\]</span> 又因为 <span class="math inline">\(D_n = n!M_n\)</span>，所以 <span class="math inline">\(D_n = n!\cdot\sum_{k = 0}^n (-1)^n\frac1{k!}\)</span>，和上面的化简结果一样。</p><h3 id="容斥定理">容斥定理</h3><p>对于长度为 <span class="math inline">\(n\)</span> 的排列，一共有 <span class="math inline">\(n!\)</span> 种不同的排列；我们要求的重排排列是它的子集；因此我们考虑，如果我们将所有不是重排排列的情况去除，那么剩下的就全部是重排排列了！</p><p>假定排列的长度为 <span class="math inline">\(n\)</span>，我们令 <span class="math inline">\(A_i\)</span> 为满足 <span class="math inline">\(p[i] = i\)</span> 的排列种数，那么显然可以得到： <span class="math display">\[\begin{align}|A_i| &amp;= (n - 1)! \\|A_i \cap A_j| &amp;= (n - 2)! \\|A_i \cap A_j \cap A_k| &amp;= (n - 3)! \\&amp;\vdots\end{align}\]</span></p><p>因此，每个元素都不在对应位置的时间就是对于 <span class="math inline">\(1 \leq i \leq n\)</span> 的 <span class="math inline">\(\overline{A_i}\)</span>： <span class="math display">\[\begin{align}\bigcap_{i = 1}^n \overline{A_i} &amp;= n! - \mathbf{C}_n^1(n - 1)! + \mathbf{C}_n^2(n - 2)! - \cdots \mp \mathbf{C}_n^{n - 1}2! \pm \mathbf{C}_n^n1! \\&amp;= \sum_{k = 0}^n (-1)^k \cdot \mathbf{C}_n^k(n - k)! \\&amp;= n!\sum_{k = 0}^n (-1)^k \cdot \frac1{k!}\end{align}\]</span> 显然，这也和之前的推导结果是一致的；</p><hr /><p>那么我们可以怎么理解式子中的加加减减呢？我们首先删除以每一个 <span class="math inline">\(i\)</span> 不满足的位置，但是这样对于排列中出现了两个不满足的位置的情况额外减了一次，所以要加回来——首先组合选出两个位置，然后其他的位置全排列；但是这样又会导致有三个不满足的位置的情况多加了…… 以此类推直到所有的位置都不正确的唯一情况。</p><h3 id="母函数方法">母函数方法</h3><figure><img src="https://i.loli.net/2021/04/22/aSxhz4twsqeZD7f.jpg" class="lazyload" data-srcset="https://i.loli.net/2021/04/22/aSxhz4twsqeZD7f.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="阿哲，一下子给我整不会了.jpg" /><figcaption aria-hidden="true">阿哲，一下子给我整不会了.jpg</figcaption></figure><p><a href="https://baike.baidu.com/item/%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98/3849290#2_2">百度百科的证法</a>实在是太过玄妙，，如果有看懂了的欢迎讲给博主听（</p><h2 id="化简公式">化简公式</h2><p>但是在算法竞赛中使用这样的超级复杂的多项式通项公式约等于没有，甚至效率不如直接递推；所以我们需要使用起来更加方便的通项公式：</p><p>首先我们考虑 <span class="math inline">\(e^x\)</span> 的幂级数展开（麦克劳林公式/泰勒展开）： <span class="math display">\[\forall x \in \mathbb{C}, \ e^x = \sum_{n = 0}^{+\infty}\frac{x^n}{n!} \approx 1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} + \cdots + \frac{x^n}{n!}\]</span></p><p>泰勒展开后面还带一个余项，不过这我就真的不会了<del>高数早就还给微积分老师力</del>（</p><p>对于 <span class="math inline">\(x = -1\)</span>，我们可以得到如下的泰勒展开式： <span class="math display">\[e^{-1} = \sum_{i = 0}^n \frac{(-1)^i}{i!} + R_n \ , \ R_n = \frac{e^{-c}(c - 1)^n}{(n + 1)!} \ , \ c \in [0, 1]\]</span> 所以，我们可以认为：<span class="math inline">\(e^{-1} = \frac{D_n}{n!} + R_n\)</span>，或者 <span class="math inline">\(n!e^{-1} - D_n = n!R_n\)</span>；又因为余项 <span class="math inline">\(R_n\)</span> 在 <span class="math inline">\(c\)</span> 取 <span class="math inline">\(c = 0\)</span> 时取到上界 <span class="math inline">\(\frac1{(n + 1)!}\)</span>，因此可以得到： <span class="math display">\[|n!\cdot e^{-1} - D_n| = |n!\cdot R_n| \leq \frac{n!}{(n + 1)!} = \frac1{n + 1}\]</span> 在我们的通项公式的可行域 <span class="math inline">\(n \geq 1\)</span> 中，显然满足 <span class="math inline">\(\frac1{n + 1} \leq \frac12\)</span>；因此我们可以认为 <span class="math inline">\(D_n\)</span> 和最接近 <span class="math inline">\(\frac{n!}e\)</span> 的整数相同；所以最后我们可以将化简后的通项公式写成下面这样： <span class="math display">\[D_n = \lfloor \frac{n!}e + \frac12\rfloor\]</span> 向下取整在代码中实现也非常方便，就达到化简通项公式的目的。</p><h2 id="练习题">练习题</h2><p>这种裸题应该还是挺多的；所以我就随便挂一个经典原型了：</p><h3 id="cses.fi-1717"><a href="https://cses.fi/problemset/task/1717/"><code>cses.fi</code> 1717</a></h3><blockquote><p>有 <span class="math inline">\(n\)</span> 个小盆友，每个小盆友都买了一个圣诞礼物与其他的小盆友交换；要求每个小盆友都要得到来自其他小盆友的礼物；问一共有多少种交换方式。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n; input, n;</span><br><span class="line">    ans[<span class="number">0</span>] = ans[<span class="number">2</span>] = <span class="number">1</span>, ans[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (longs i = <span class="number">3</span>; i &lt;= n; ++ i)</span><br><span class="line">        ans[i] = <span class="keyword">int</span>((ans[i - <span class="number">1</span>] + ans[i - <span class="number">2</span>])</span><br><span class="line">                        % mod * (i - <span class="number">1</span>) % mod);</span><br><span class="line">    output, ans[n], <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为数据范围很小，所以只需要使用递推公式就可以通过此题了。</p><h2 id="后记">后记</h2><p>虽然推的时候还是很痛苦的，但是写博文的时候又觉得言之无物，，看来还是昨天晚上睡少了（</p><p>如果有机会的话再完善一下关于错排生成算法的东西吧……</p><h3 id="参考资料">参考资料</h3><ul><li><a href="https://blog.csdn.net/Ber_Bai/article/details/77112975" class="uri">https://blog.csdn.net/Ber_Bai/article/details/77112975</a></li><li><a href="https://baike.baidu.com/item/%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98/3849290" class="uri">https://baike.baidu.com/item/%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98/3849290</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> 组合数学 </tag>
            
            <tag> 推导 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round#716 div.2 回顾</title>
      <link href="/2021/codeforces-round-716-div2/"/>
      <url>/2021/codeforces-round-716-div2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>补题地址：<a href="https://codeforces.com/contest/1514" class="uri">https://codeforces.com/contest/1514</a></p></blockquote><h2 id="记录">记录</h2><p>就是我上一篇博文中提到的那个因为记错时间而忘记打的 Div2；顺便一提，这一场的下一场也是非经典时间 21:35 开始，希望可以正常打起来吧……？</p><p>曾经也在本博客的博文里登场的学弟打了 ABD 三个题，C 题奇妙的被 hack 了（）着实有点恐怖；本以为我至少也能打个 ABCD 的，没想到 CD 全都挂了，，属实不行==</p><h2 id="题解">题解</h2><h3 id="a---perfectly-imperfect-array">A - <a href="https://codeforces.com/contest/1514/problem/A">Perfectly Imperfect Array</a></h3><p>逻辑关系略绕，但是也没啥好说的（）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; pre;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = $.nextInt(), n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1e4</span>; ++ i)</span><br><span class="line">        pre.insert(i * i);</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        $(n).nextArray(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            found |= !pre.count(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        output, found ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>, <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该算是有手就行吧，主要就是看能几分钟写出来了）</p><h3 id="b---and-0-sum-big">B - <a href="https://codeforces.com/contest/1514/problem/B">AND 0, Sum Big</a></h3><p>因为要求和最大，把每一个数字按照二进制拆分，那么就是每一位的 <span class="math inline">\(1\)</span> 尽可能的多；又因为所有的数的按位与的和为 <span class="math inline">\(0\)</span>，所以每一个位都要有一个 <span class="math inline">\(0\)</span>，那么问题就变成将每一位的 <span class="math inline">\(0\)</span> 分配到不同的数字中了。显然，对于总长度为 <span class="math inline">\(k\)</span> 二进制数字，每一位都可以安放在任何数字中，总共有 <span class="math inline">\(n^k\)</span> 种。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">longs <span class="title">fastPow</span><span class="params">(longs a, longs b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    longs ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1u</span>) ans = (ans * a) % mod;</span><br><span class="line">        a = (a * a) % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1u</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, k, T;</span><br><span class="line">    input, T;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        input, n, k;</span><br><span class="line">        output, fastPow(n, k), <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典看样例猜做法（</p><h3 id="c---product-1-modulo-n">C - <a href="https://codeforces.com/contest/1514/problem/C">Product 1 Modulo N</a></h3><blockquote><p>给 <span class="math inline">\(n \leq 10^5\)</span>；现在要求求出 <span class="math inline">\(1, \dots, n-1\)</span> 的最长子序列 <span class="math inline">\(a\)</span>，满足 <span class="math inline">\(\prod a_i \mod n \equiv 1\)</span>；输出子序列 <span class="math inline">\(a\)</span> 的长度以及它包含的元素；</p></blockquote><p>一种很显然的想法是现将它们都乘起来，然后取余数，再将余数的数字从列表中删除（当然，如果为 1 就算了）从而得到了答案序列；如果再打表的话还会意识到如果 <span class="math inline">\(n\)</span> 是素数，那么答案是 <span class="math inline">\(1, \dots, n-2\)</span>；但是再稍微打表就会意识到，如果 <span class="math inline">\(n\)</span> 不是素数，那么你删除模数之后的乘积未必是 1，于是这种做法显而易见的错误了——毕竟就连样例都过不了（</p><p>稍事思考：对于任何数 <span class="math inline">\(n\)</span> 都显然有 <span class="math inline">\(\gcd(1, n) = 1\)</span>；由辗转相除法的转移式子 <code>gcd(a, b) = gcd(b, a % b)</code> 可知 <span class="math inline">\(\gcd(\prod a_i \mod n, n) = \gcd(\prod a_i, n)\)</span>；联立一下就是我们选择的序列的乘积和 <span class="math inline">\(n\)</span> 互素：如果这样，那么选择的序列中的每一个 <span class="math inline">\(a_i\)</span> 都应该和 <span class="math inline">\(n\)</span> 互素（这是必要条件）；在这样的基础上，我们先以此作为标准，过滤掉所有和 <span class="math inline">\(n\)</span> 不互质的数字。</p><p>同理，我们可以通过将剩下的数字全部乘起来取模，得到这个很大的数字和 <span class="math inline">\(n\)</span> 的最大公因数；因为现在所有的数字都和 <span class="math inline">\(n\)</span> 互素，所以这个因子一定出现在了我们选择的数字中；此时我们只要把它移除就可以了；<del>当然，如果你打表，你也能发现在删除了所有的不互质的数字之外还需要删除一个数字（</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = $.nextInt();</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    longs tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (gcd(i, n) == <span class="number">1</span>) &#123;</span><br><span class="line">            ans.insert(i);</span><br><span class="line">            tmp = tmp * i % n;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="number">1</span>) ans.erase((<span class="keyword">int</span>)tmp);</span><br><span class="line">    $.put(ans.size()).putArray(ans.begin(), ans.end());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看代码也能看出来这个过程实际上非常的自然；但是说又说不清楚…… 只能说需要补习数论了==</p><h3 id="d---cut-and-stick">D - <a href="https://codeforces.com/contest/1514/problem/D">Cut and Stick</a></h3><blockquote><p>定义“好序列”是其中没有元素出现的次数超过 <span class="math inline">\(\lceil \frac{n}2 \rceil\)</span>，其中 <span class="math inline">\(n\)</span> 是序列的长度；对于一个序列，如果它不是好序列，但你可以将它划分为 <span class="math inline">\(m\)</span> 个子序列，它们都是好序列，那么这个序列的权值是 <span class="math inline">\(m\)</span>；显然，对于一个好序列自身而言，它的权值是 <span class="math inline">\(1\)</span>。</p><p>现提供长度为 <span class="math inline">\(n \leq 3 \cdot 10^5\)</span> 的序列；进行 <span class="math inline">\(q \leq 3 \cdot 10^5\)</span> 次询问：每次询问 <span class="math inline">\([l, r]\)</span> 区间的字串序列的权值。</p></blockquote><p>可以说是一个很乱搞的题目了；如果有差不多的算法素养或者代码能力的话应该就能写出来的<del>只可惜我没有，残疾人竟是我自己</del>。下面介绍一下这个题目的三种思路：</p><hr /><p>首先，如果暴力移动区间，显然每次扩张和收缩都可以 <span class="math inline">\(O(1)\)</span> 完成：需要维护的是区间内每个数字出现的次数，以及这个次数出现的次数；因为每次移动只会使得某数字出现的次数变化 1，所以转移一定可以直接完成。</p><p>那么，对于这种询问次数很大，又可以这样暴力维护的问题，而且还没有在线的要求；我们就可以考虑使用莫队算法离线维护；时间复杂度是 <span class="math inline">\(\mathcal{O}(n \sqrt n)\)</span> 的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MO &#123;</span><br><span class="line">    <span class="keyword">int</span> block_size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">query</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> l, r, id;</span><br><span class="line"></span><br><span class="line">        query() = <span class="keyword">default</span>;</span><br><span class="line">        query(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> id) : l(l), r(r), id(id) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> query &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (l / block_size == </span><br><span class="line">                rhs.l / block_size)</span><br><span class="line">                <span class="keyword">return</span> r &lt; rhs.r;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> l &lt; rhs.l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;query&gt; req;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> cnt[N], tim[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> sig, <span class="keyword">int</span> &amp;now)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;times = tim[a[pos]];</span><br><span class="line">        <span class="keyword">if</span> (times &gt;= <span class="number">0</span>) -- cnt[times];</span><br><span class="line">        times += sig;</span><br><span class="line">        <span class="keyword">if</span> (times &gt;= <span class="number">0</span>) ++ cnt[times];</span><br><span class="line">        <span class="keyword">if</span> (sig &gt; <span class="number">0</span>) maximize(now, times);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">while</span> (!cnt[now]) -- now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> increase = [&amp;](<span class="keyword">int</span> pos) &#123; step(pos, +<span class="number">1</span>, tmp); &#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> decrease = [&amp;](<span class="keyword">int</span> pos) &#123; step(pos, <span class="number">-1</span>, tmp); &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [ql, qr, qid] : req) &#123;</span><br><span class="line">            <span class="keyword">while</span> (ql &lt; l) increase(-- l);</span><br><span class="line">            <span class="keyword">while</span> (qr &gt; r) increase(++ r);</span><br><span class="line">            <span class="keyword">while</span> (ql &gt; l) decrease(l ++);</span><br><span class="line">            <span class="keyword">while</span> (qr &lt; r) decrease(r --);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> len = qr - ql + <span class="number">1</span>;</span><br><span class="line">            ans[qid] = max(<span class="number">1</span>, <span class="number">2</span> * tmp - len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        ans.resize(m + <span class="number">1</span>);</span><br><span class="line">        block_size = (<span class="keyword">int</span>) n / <span class="built_in">sqrt</span>(m * <span class="number">2</span> / <span class="number">3</span>);</span><br><span class="line">        stable_sort(req.begin(), req.end());</span><br><span class="line">        solve(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = scanner.nextInt(),</span><br><span class="line">        m = scanner.nextInt();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        a[i] = scanner.nextInt();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = scanner.nextInt(),</span><br><span class="line">            r = scanner.nextInt();</span><br><span class="line">        MO::req.emplace_back(l, r, i);</span><br><span class="line">    &#125;</span><br><span class="line">    MO::run(n, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">        println(MO::ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别说明：分块的方法没有采用经典的 <span class="math inline">\(\lceil \sqrt{n} \rceil\)</span>，写法采用的分块方法在本题的表现更好<del>其实是抄学弟的</del>；</p><p>虽然这样修改分块方法已经使得我的莫队运行时间从 <code>2200ms</code> 变成了 <code>1800ms</code>，但是学弟原本的代码跑到了令人发指的 <code>900ms</code>…… MSYS2 这么拉的嘛（）</p><hr /><p>虽然如果要求众数，只能使用莫队这种优雅的暴力来维护；但是我们还是应该敏感地注意到众数和“过半数”的微妙的区别；虽然前者没办法用树形数据结构维护，但是后者是可以的——考虑将两个区间的结果合并成的大区间的结果：显然大区间的“过半数”必为两个子区间的“过半数”中的一个，因此可以使用线段树维护。</p><p>那么我们应该如何合并结果呢？查找一个数字在区间 <span class="math inline">\([l, r]\)</span> 中出现的次数，我们可以将这些位置存进数组里，然后使用二分查找确定上下界，那么两界之差就是我们要求的结果；这个询问的时间复杂度是 <span class="math inline">\(\mathcal{O}(\log n)\)</span> 的。</p><p>确定了合并策略，我们就可以写出下面的代码<del>什么嘛，合并策略这个抽象不是挺好用的嘛</del>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">seg_tree</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> merge_method = function&lt;T(T, T, <span class="keyword">int</span>, <span class="keyword">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> siz;</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt; t;</span><br><span class="line">    merge_method merge;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">const</span> T *arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123; t[id] = arr[l]; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        build(id * <span class="number">2</span> + <span class="number">1</span>, l, m, arr);</span><br><span class="line">        build(id * <span class="number">2</span> + <span class="number">2</span>, m, r, arr);</span><br><span class="line">        t[id] = merge(t[id * <span class="number">2</span> + <span class="number">1</span>], t[id * <span class="number">2</span> + <span class="number">2</span>], l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ll, <span class="keyword">int</span> rr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ll &gt;= rr) <span class="keyword">return</span> (T)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ll == l &amp;&amp; rr == r) <span class="keyword">return</span> t[id];</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> lv = query(id * <span class="number">2</span> + <span class="number">1</span>, l, m, ll, min(rr, m));</span><br><span class="line">        <span class="keyword">auto</span> rv = query(id * <span class="number">2</span> + <span class="number">2</span>, m, r, max(m, ll), rr);</span><br><span class="line">        <span class="keyword">return</span> merge(lv, rv, ll, rr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">seg_tree</span><span class="params">(<span class="keyword">int</span> n, merge_method m)</span> </span></span><br><span class="line">    : siz(n), merge(move(m)) &#123; t.resize(4 * n); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> T *arr)</span> </span>&#123; <span class="keyword">return</span> build(<span class="number">0</span>, <span class="number">0</span>, siz + <span class="number">1</span>, arr); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">int</span> ll, <span class="keyword">int</span> rr)</span> </span>&#123; <span class="keyword">return</span> query(<span class="number">0</span>, <span class="number">0</span>, siz + <span class="number">1</span>, ll, rr); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, q, l, r;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> count = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> ll = lower_bound(pos[i].begin(), pos[i].end(), l);</span><br><span class="line">        <span class="keyword">auto</span> rr = lower_bound(pos[i].begin(), pos[i].end(), r);</span><br><span class="line">        <span class="keyword">return</span> rr - ll;</span><br><span class="line">    &#125;;</span><br><span class="line">    $(n, q).nextArray(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        pos[a[i]].push_back(i);</span><br><span class="line">    <span class="function">seg_tree&lt;<span class="keyword">int</span>&gt; <span class="title">t</span><span class="params">(n + <span class="number">1</span>, [&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> l, <span class="keyword">int</span> r) -&gt; <span class="keyword">int</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">auto</span> aa = count(l, r, a), bb = count(l, r, b);</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">return</span> aa &gt; bb ? a : b;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line">    t.build(a);</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        $(l, r);</span><br><span class="line">        <span class="keyword">auto</span> id = t.query(l, r + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> ans = count(l, r + <span class="number">1</span>, id);</span><br><span class="line">        ans = ans * <span class="number">2</span> - (r + <span class="number">1</span> - l);</span><br><span class="line">        $.put(max(ans, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线段树总体的复杂度大概是 <span class="math inline">\(\mathcal{O}(n\log n \cdot X)\)</span> 的，其中 <span class="math inline">\(X\)</span> 是合并策略的单次操作的复杂度；那么这个问题的整体复杂度是 <span class="math inline">\(\mathcal{O}(n \log^2n)\)</span> 的，倒也可以接受。</p><hr /><p>还有一种比较野的思路，就是随机化：对于每次询问，我们在区间 <span class="math inline">\([l, r]\)</span> 中随机选择一个位置，并假定它的值的出现次数最多，并更新答案，重复多次；如果重复选择的次数足够多，就可以将出错的概率降到很低：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>, T = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, q, l, r, ans, t;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> count = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> ll = lower_bound(pos[i].begin(), pos[i].end(), l);</span><br><span class="line">        <span class="keyword">auto</span> rr = upper_bound(pos[i].begin(), pos[i].end(), r);</span><br><span class="line">        <span class="keyword">return</span> rr - ll;</span><br><span class="line">    &#125;;</span><br><span class="line">    $(n, q).nextArray(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        pos[a[i]].push_back(i);</span><br><span class="line">    <span class="function">mt19937 <span class="title">rng</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        chrono::steady_clock::now()</span></span></span><br><span class="line"><span class="function"><span class="params">        .time_since_epoch().count()</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        $(l, r), ans = <span class="number">1</span>, t = T;</span><br><span class="line">        <span class="keyword">while</span> (t --) &#123;</span><br><span class="line">            <span class="keyword">int</span> gen = a[uniform_int_distribution&lt;<span class="keyword">int</span>&gt;(l, r)(rng)];</span><br><span class="line">            maximize(ans, <span class="number">2</span> * count(l, r, gen) - (r - l + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        $.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么是真正的乱搞啊（战术后仰）因为我们求的权值是可以像最大值那样合并的，所以这样做非常合理；算法整体的时间复杂度是 <span class="math inline">\(\mathcal{O}(qT\log n)\)</span> 的，其中 <span class="math inline">\(T\)</span> 是重复随机的次数。</p><hr /><p>据出题人说，这个题还可以使用某种方法做到 <span class="math inline">\(\mathcal{O}(n\log n)\)</span>，这我就真不会了（）如果会的话欢迎教我==</p><h3 id="e---baby-ehabs-hyper-apartment">E - <a href="https://codeforces.com/contest/1514/problem/E">Baby Ehab's Hyper Apartment</a></h3><blockquote><p>有 <span class="math inline">\(n \leq 100\)</span> 个节点，每对节点之间都有一条有向边；现在你可以进行以下两种询问：</p><ul><li>询问 <span class="math inline">\(u \to v\)</span> 的方向，正向返回 <code>1</code>，否则 <code>0</code>；不超过 <span class="math inline">\(9n\)</span> 次</li><li>询问 <span class="math inline">\(u \to \{a_1, \dots, a_n\}\)</span> 中是否存在到其中任一通路，全部不可达返回 <code>0</code>，否则 <code>1</code>；不超过 <span class="math inline">\(2n\)</span> 次</li></ul><p>要求你在规定的询问次数内求出 <span class="math inline">\(n \times n\)</span> 矩阵 <span class="math inline">\(M\)</span>，<span class="math inline">\(M_{i, j}\)</span> 代表 <span class="math inline">\(i \to j\)</span> 是否可达。</p></blockquote><p>完全没有思路，，看了题解才发现需要的知识基本也都还给离散老师了，直接埋了吧（无慈悲</p><p>首先，我们考虑只使用其中的一部分边来完成所有的转移——其他的边都是多余的；然后，发现这张图是一个竞赛图：因此它必定存在一条按照某种顺序可以到达所有的点仅一次的哈密顿通路；在这条哈密顿通路上，处于偏序位置较低的点可以到达任何偏序位置较高的点。</p><p>那么，在这样的基础上，我们只需要考虑从偏序位置较高的点到达较低的点即可；假设从某个高位置 <span class="math inline">\(i\)</span> 可以到达的最低的位置是 <span class="math inline">\(p\)</span>，那么所有在 <span class="math inline">\(p\)</span> 点上，在 <span class="math inline">\(i\)</span> 点下的位置都可以从 <span class="math inline">\(i\)</span> 出发到达，而在 <span class="math inline">\(p\)</span> 点下的位置不可到达；因此，只需要找到所有位置可以到达的最低的位置，就可以知道 <span class="math inline">\(i\)</span> 点到达其他任何节点的可达情况。</p><p>那么我们应该怎么样实现呢？在竞赛图中，我们将每一条有向边都看作是一对偏序关系，然后使用归并排序，就可以得到一条哈密顿路（所代表的偏序顺序）；这也很好理解：假设我们将所有的节点分成两个部分，它们内部都已经找到了哈密顿路的偏序；那么我们就比较两个部分的最低点——它们之间一定存在偏序关系——找到其中较低的插入待求的偏序中；因为它比接下来的两个部分的最低点都要低，所以可以继续将更低的点插入其中。</p><p>在 C++ STL 中，已经有了默认的归并排序的实现 <code>stable_sort</code>，直接调用，并将第一种询问作为排序方式即可完成哈密顿路的求解。显然，这样最多会询问 <span class="math inline">\(n\log_2n\)</span> 次，对于 <span class="math inline">\(n \leq 100\)</span> 显然满足小于 <span class="math inline">\(9n\)</span>。</p><p>然后，我们维护一个指针 <span class="math inline">\(p\)</span>，指向当前可以到达的最低位置；我们只需要使用第二种询问询问在 <span class="math inline">\(p\)</span> 之前的前缀是否可以包含可以到达的位置，就可以判断是否继续将 <span class="math inline">\(p\)</span> 左移。这样，对于每个前缀位置 <span class="math inline">\(p\)</span>，都会存在一次询问的返回为 <code>1</code> 从而使得 <span class="math inline">\(p\)</span> 左移；对于每个位置 <span class="math inline">\(i\)</span>，都有一次询问返回 <code>0</code> 说明当前的 <span class="math inline">\(p\)</span> 为它可以到达的最低距离，所以询问次数也是满足 <span class="math inline">\(2n\)</span> 的限制的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">askTheEdge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = $.put(<span class="number">1</span>, a, b).flush().nextInt();</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> (<span class="keyword">bool</span>) res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">askEdges</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = $.print(<span class="number">2</span>, <span class="string">&#x27; &#x27;</span>, a, <span class="string">&#x27; &#x27;</span>, b.size(), <span class="string">&#x27; &#x27;</span>).</span><br><span class="line">                putArray(b.begin(), b.end()).flush().</span><br><span class="line">                nextInt();</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> (<span class="keyword">bool</span>) res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = $.nextInt(), n;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;128&gt; g[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = $.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">            g[i].reset(), g[i] = ~g[i];</span><br><span class="line">        vector&lt;int&gt; path(n), tmp;</span><br><span class="line">        iota(path.begin(), path.end(), <span class="number">0</span>);</span><br><span class="line">        stable_sort(path.begin(), path.end(), askTheEdge);</span><br><span class="line">        <span class="keyword">int</span> p = n - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> makeTmp = [&amp;](<span class="keyword">int</span> p) -&gt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; &#123;</span><br><span class="line">            tmp.assign(path.begin(), path.begin() + p + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++ j)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; n; ++ k)</span><br><span class="line">                        g[path[k]][path[j]] = <span class="literal">false</span>;</span><br><span class="line">                -- p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (askEdges(path[i], makeTmp(p))) -- p;</span><br><span class="line">        &#125;</span><br><span class="line">        $.put(<span class="number">3</span>).putArray(<span class="number">0</span>, n, [&amp;](<span class="keyword">int</span> i, cquery $) &#123;</span><br><span class="line">            $.putArray(<span class="number">0</span>, n, [&amp;i](<span class="keyword">int</span> j, cquery $) &#123;</span><br><span class="line">                $.print(g[i].test(j) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            &#125;, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;&quot;</span>).flush();</span><br><span class="line">        <span class="keyword">int</span> res = $.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == res) <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，第二种询问还可以使用缓存减少一定的询问次数，不过优势不明显，也实在没有必要就是了（</p><h2 id="后记">后记</h2><p>做 C 题的时候，博主也和恰好在旁边的同学 <a href="https://tmc0210.github.io">tmc</a> 讨论了为什么会想不出来——得到的回复是只是单纯的对于数论不够敏感，换句话说就是做的少了（）真的得多加注意了==</p><p>年轻人的第一个莫队题目竟然是在这样的场合…… 只能说对比就是生产力啊（</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round#715 div.2 回顾</title>
      <link href="/2021/codeforces-round-715-div2/"/>
      <url>/2021/codeforces-round-715-div2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>补题链接：<a href="https://codeforces.com/contest/1509" class="uri">https://codeforces.com/contest/1509</a></p></blockquote><h2 id="记录">记录</h2><p>其实本来今天晚上是有一个 <a href="https://codeforces.com/blog/entry/89771">Codeforces Round #716 (Div.2)</a> 的；但是因为我盲目确信它的开始时间是传统艺能 22:35，而忽略了它的开始时间和往常不同，所以最后没有打成== 但是也因此，本懒狗可以好好地补完上一场拉跨的不行的 Div2 了。</p><p>这一场可以说非常的拉跨，ABC 选手都没有当成；明明才 1700 分的我都能直接俯冲 100 分，只能说使得本菜鸡本就不高的 rating 雪上加霜（）话虽这么说，补完了发现只是自己傻逼……这是不是有点似曾相识？</p><h2 id="题解">题解</h2><h3 id="a---average-height">A - <a href="https://codeforces.com/contest/1509/problem/A">Average Height</a></h3><p>没什么好说的，偶数和奇数分别放在一起就完事了（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2050</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt();</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            a[i] = scanner.nextInt();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (a[i] % <span class="number">2</span>) ans.push_back(a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (a[i] % <span class="number">2</span> == <span class="number">0</span>) ans.push_back(a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ii : ans)</span><br><span class="line">            print(ii, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="b---tmt-document">B - <a href="https://codeforces.com/contest/1509/problem/B">TMT Document</a></h3><p>也没啥难度，总的来说只要时刻保证前缀的 <code>T</code> 比 <code>M</code> 多，并且保证最后 <code>T</code> 和 <code>M</code> 的比例正确，且每一个 <code>M</code> 的后面都一定出现了一个 <code>T</code> 就可以保证合法性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">4</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt(), n;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        scanner(n, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cntT = <span class="number">0</span>, cntM = <span class="number">0</span>, close = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;T&#x27;</span>) &#123;</span><br><span class="line">                ++ cntT;</span><br><span class="line">                <span class="keyword">if</span> (close &lt; cntM) ++ close;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> ++ cntM;</span><br><span class="line">            <span class="keyword">if</span> (cntM &gt; cntT) ok = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cntM * <span class="number">2</span> != cntT || close &lt; cntM)</span><br><span class="line">            ok = <span class="literal">false</span>;</span><br><span class="line">        println(ok ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说是这么说，可是我还是因为没有长手所以白给一发<del>残疾人竟是我自己</del>（</p><h3 id="c---the-sports-festival">C - <a href="https://codeforces.com/contest/1509/problem/C">The Sports Festival</a></h3><blockquote><p>给一个长度为 <span class="math inline">\(n &lt; 2000\)</span> 的数组，现在要求你对这个数组进行重排序，使得下列式子的值最小： <span class="math display">\[\sum_{i=1}^n\max_{j=1}^i a_j - \min_{j=1}^i a_j\]</span> 要求输出上面式子的最小值。</p></blockquote><p>这个题做的过程可以说是十分丑陋了（）尽显本人菜逼本质 == 本弱鸡甚至能在考虑出了 <span class="math inline">\(\mathcal{O}(n^2)\)</span> 的贪心的假做法的情况下不自知，甚至还迷之自信的交了一二三四发，只能说是十分地滑稽可笑了。</p><p>当然，本题的正确做法也是 <span class="math inline">\(\mathcal{O}(n^2)\)</span> 的，只不过是比贪心更加合理的多的 DP；</p><p>首先，就像我的假做法考虑到的那样：首先对于这个数组排序，然后答案的构造方法一定是从中间的某个位置向两侧发散；考虑 <span class="math inline">\(dp_{l..r}\)</span> 表示当前已经扩散到了区间 <span class="math inline">\([l, r]\)</span> 时，上面的式子的最小值；那么它只有两种转移来源——要不是加入了新的最小值 <span class="math inline">\(a_l\)</span>，又或者是加入了新的最大值 <span class="math inline">\(a_r\)</span>；所以不难得到下面的转移关系： <span class="math display">\[dp_{l..r} = (a_r - a_l) + \min(dp_{l+1..r}, dp_{l..r-1})\]</span> 那么就可以写出代码通过此题了；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2060</span>;</span><br><span class="line">longs dp[N][N], s[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    $(n).nextArray(s + <span class="number">1</span>, s + <span class="number">1</span> + n);</span><br><span class="line">    sort(s + <span class="number">1</span>, s + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; n; ++ k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= n; ++ l)</span><br><span class="line">            <span class="keyword">if</span> (l + k &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> r = l + k;</span><br><span class="line">                dp[l][r] = s[r] - s[l] + min(dp[l + <span class="number">1</span>][r], dp[l][r - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">    output, dp[<span class="number">1</span>][n], <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当初辅导某学长机试时，我苦口婆心地说“找到递推关系就是动态规划”的神态还历历在目，结果自己却深陷这样一个简单的 DP 而不自知，为自己的 <span class="math inline">\(\mathcal{O}(n^2)\)</span> 贪心假做法而沾沾自喜，属实是个小丑（</p><h3 id="d---binary-literature">D - <a href="https://codeforces.com/contest/1509/problem/D">Binary Literature</a></h3><blockquote><p>给你一个长度 <span class="math inline">\(n \leq 10^5\)</span>，以及三个长度为 <span class="math inline">\(2n\)</span> 的 01 字符串；现在你要构造一个 01 字符串，要求它至少以子序列的方式包含提供的三个字符串中的两个，且长度不能超过 <span class="math inline">\(3n\)</span>；保证这种构造一定是成立的。</p></blockquote><p>首先，考虑两个长度为 <span class="math inline">\(2n\)</span> 的字符串；我们一定可以构造出长度为 <span class="math inline">\(4n - L\)</span> 的满足子序列包含它们的串；其中 <span class="math inline">\(L\)</span> 的含义是这两个字符串的最长公共子串（LCS）。构造方法也非常的简单：对于 LCS 中的 <span class="math inline">\(L\)</span> 个字符，只插入构造的串中一次，其他的字符按照正确的顺序全部插入结果串即可。</p><p>但是众所周知，求 LCS 的算法的复杂度是 <span class="math inline">\(\mathcal{O}(n^2)\)</span> 的，而这个题目显然不允许这样的复杂度；但是因为题目中的字符串是 01 串，所以我们可以利用它的性质来考虑：</p><ul><li>01 串中不是 <code>0</code> 就是 <code>1</code>，所以长度为 <span class="math inline">\(2n\)</span> 的 01 串中至少有一个字符出现的次数大于等于 <span class="math inline">\(n\)</span></li><li>因为我们有三个这样的 01 串，所以至少有两个字符串中的某个相同的字符出现次数大于等于 <span class="math inline">\(n\)</span></li></ul><p>综上所述，我们找到这样的两个字符串；将这个字符出现的位置作为 LCS 的字符；然后使用上面的构造方法，就可以构造出长度为 <span class="math inline">\(4n - L \leq 3n\)</span>，其中 <span class="math inline">\(L \geq n\)</span> 的目标串了。</p><hr /><p>在这种思想的基础上，我们还有一种更加优雅的构造方法：首先，维护三个指针，分别指向三个字符串，并且最开始都初始化为指向串首；然后，对于每一个位置，都选择较多的字符加入答案串，并推进对应的指针；这样，当一个字符串已经完全被加入答案串之后，我们假设答案串的长度为 <span class="math inline">\(k\)</span>：</p><ul><li>因为有一个长度为 <span class="math inline">\(2n\)</span> 的字符串被完全推入了，所以 <span class="math inline">\(k \geq 2n\)</span>；</li><li>因为每次推入字符都要求了至少两个字符串当前位置为该字符，所以至少消耗了 <span class="math inline">\(2k\)</span> 个字符；</li><li>这样，三个字符串总共有 <span class="math inline">\(6n\)</span> 个字符，现在最多剩下 <span class="math inline">\(6n - 2k\)</span> 个字符，分配在两个串中；</li><li>这样，其中剩余较少的那个串最多包含 <span class="math inline">\(3n - k\)</span> 个字符；</li></ul><p>综上所述，如果我们将那个剩余最少的字符串完全推入答案串，那么答案串至少会包含这两个已经压入的字符串作为子序列，并且答案串的长度最大为 <span class="math inline">\(k + 3n - k = 3n\)</span>，符合题意；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[N * <span class="number">2</span>], b[N * <span class="number">2</span>], c[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> ans[N * <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = $.nextInt(), n, p;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> concat = [&amp;](<span class="keyword">char</span> *aa, <span class="keyword">char</span> *bb) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> na = <span class="built_in">strlen</span>(aa), nb = <span class="built_in">strlen</span>(bb);</span><br><span class="line">        <span class="built_in">strcpy</span>(ans + p, na &lt; nb ? aa : bb);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        $(n, a, b, c);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n2 = n * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> ae = a + n2, be = b + n2, ce = c + n2;</span><br><span class="line">        <span class="keyword">auto</span> pa = a, pb = b, pc = c;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (pa != ae &amp;&amp; pb != be &amp;&amp; pc != ce) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt1 = *pa + *pb + *pc - <span class="string">&#x27;0&#x27;</span> * <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">int</span> ch = (cnt1 &gt;= <span class="number">2</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            pa += (ch == *pa), pb += (ch == *pb), pc += (ch == *pc);</span><br><span class="line">            ans[p ++] = (<span class="keyword">char</span>) ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pa == ae) concat(pb, pc);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pb == be) concat(pa, pc);</span><br><span class="line">        <span class="keyword">else</span> concat(pa, pb);</span><br><span class="line">        $.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实真要说的话，我觉得在知道 LCS 是哪些位置的情况下构造这样一个串还挺……不好写的；至少写出来大概都不会太好看；更何况还要使用那个 <span class="math inline">\(\mathcal{O}(n^2)\)</span> 的 DP 求出 LCS 的位置；实际上的写法只能说是很高妙了（</p><h3 id="e---almost-sorted">E - <a href="https://codeforces.com/contest/1509/problem/E">Almost Sorted</a></h3><blockquote><p>现在定义差不多有序的排序指对于任意下标 <span class="math inline">\(i\)</span>，都满足 <span class="math inline">\(p_{i+1} \geq p_i - 1\)</span>；现在给长度为 <span class="math inline">\(n\)</span> 的初始排列（即字典序最小的排列 <span class="math inline">\(1\dots n\)</span>，要求求出字典序第 <span class="math inline">\(k\)</span> 小的差不多有序的排序；</p></blockquote><p>这题我从最开始就没往正确的地儿想；我最开始想要打表找规律，但是实际上我想找的那个规律可以说是显然的，但是更高级的规律可以说打表什么也看不出来…… <code>zcysky</code> 提示我要画树我也没领会他的意思，盲目地漫无目的地思考了一会就缴械投降了，看到题解才发现是真的高：</p><p>首先，我们要正确的理解题目的定义：差不多有序的排序，如果出现了下降的情况，定义只允许步长为 1 的递减；所以，一个差不多有序的序列可以被表示为多个公差为 1 的递减区块；而且，我们可以用反证法证明——一旦确定了序列的递减区块的划分方法，那么这个序列是唯一的——且是初始排列按照这个划分方式划分之后，将每一个区间都翻转得到的序列。</p><p>那么接下来我们考虑 <span class="math inline">\(k\)</span>-大问题：因为每个区块都是由初始排序倒转区块得到的，所以我们可以贪心的考虑，第一个区块的大小越小，那么处理后得到的序列最小；同时，再确定了第一个区块的长度之后，我们将它从原排序中移除，那么就得到了一个长度缩小的子问题；我们可以递归地处理这个问题。</p><p>然后，我们考虑对于长度为 <span class="math inline">\(n\)</span> 的排序，差不多有序的序列数量：假设我们现在有一个和这个排序等长的 01 序列，且初始它的每一位都已经置零；对于每一个划分后的区块 <span class="math inline">\([l, r]\)</span>，我们将 <span class="math inline">\(l\)</span> 位置为 1；那么可以看到除了第 0 位必须为 1，其他的每一位都可以为 1/0；因此，一共有 <span class="math inline">\(2^{n-1}\)</span> 种不同的差不多有序的序列。</p><hr /><p>至此，我们已经可以使用上面说的递归的方法来求解本题了；但是实际上还有一种更加优秀的构造方法：</p><p>考虑上面说的标记 01 序列的方法：首先我们将上面的 01 序列看作一个二进制数；并且翻转下标的对应关系——让更小的下标对应更高的位；然后改为标记右边界，即区块中最低的位；然后翻转标记方法：即初值为 1，标记的位为 0；这样就可以得到满足上面所有约束；第 <span class="math inline">\(k\)</span> 小的排列就是 <span class="math inline">\(k-1\)</span> 的二进制表示左移 1 位（最低位始终为 0）对应的二进制表示所代表的划分方式；我们根据它构造答案即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], tmp[N];</span><br><span class="line">lll fact[N];</span><br><span class="line"><span class="built_in">bitset</span>&lt;N&gt; x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    longs T = $.nextInt(), n, k;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        input, n, k;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">128</span>) &#123;</span><br><span class="line">            lll cnt = <span class="number">1</span>;</span><br><span class="line">            cnt &lt;&lt;= uint(n - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (k &gt; cnt) &#123;</span><br><span class="line">                output, <span class="number">-1</span>, <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> x.reset();</span><br><span class="line">        x = k - <span class="number">1</span>, x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        iota(a, a + n, <span class="number">1</span>);</span><br><span class="line">        reverse(a, a + n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (!x.test(i)) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; n &amp;&amp; x.test(j)) ++ j;</span><br><span class="line">                reverse(a + i, a + j);</span><br><span class="line">                i = j - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        reverse(a, a + n);</span><br><span class="line">        $.putArray(a, a + n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常地巧妙；不管是证明了划分和排列的对应性还是划分和二进制表示的对应性都非常的巧妙（）这不比你最开始考虑的先映射 <span class="math inline">\(k\)</span> 和排序的关系，再用康托展开要阳间多了？更何况康托展开是 <span class="math inline">\(\mathcal{O}(n^2)\)</span> 的呢！</p><h3 id="f---complete-the-mst">F - <a href="https://codeforces.com/contest/1509/problem/F">Complete the MST</a></h3><blockquote><p>现在给你一个有 <span class="math inline">\(n \leq 2 \cdot 10^5\)</span> 的节点的无向完全图；其中有 <span class="math inline">\(m\)</span> 条连边已经有权值（保证这部分的边的数量不超过 <span class="math inline">\(2 \cdot 10^5\)</span>），部分边没有权值（保证至少有一条边没有权值）；现在要求你为这些没有权值的边赋非负值的权值，并且整张图所有边的权值异或和为 <span class="math inline">\(0\)</span>，且图的 MST 的权值和最少。</p></blockquote><p>看起来麻烦的一匹<del>实际上也麻烦的一匹</del>，首先进行一些思考：首先，我们一定最多只给一条边赋非零值——因为把它拆分给多条边完全没有任何好处；然后，MST 肯定是尽可能的用没有权值的边——因为如果条件允许，我们可以把我们选作 MST 的边全部赋值为 0；其次，我们赋值的那条边的权值，一定是所有有权值的边的权值的异或和。</p><p>那么，我们可以通过下面的过程来求解：</p><ul><li>首先，考虑在空边构成的图上 DFS，以求出仅使用空边可以维系的连通块；<ul><li>如果在选出这些边之后仍有未使用的空边，那么我们可以把异或和赋给它：这样对权值和无贡献；</li><li>否则，我们先暂记异或和，作为将要赋给某条空边的值；</li></ul></li><li>然后，我们考虑使用 MST 算法，使用实边将第一步求出的连通块连成一个生成树；</li><li>如果一条实边不能被选入 MST，但是它连接了两个本需要依靠空边连接的连通块，那么：<ul><li>如果这条边的权值比将要赋值给空边的权值要少，那么我们可以将空边赋给这条边，并取代它；</li><li>否则，那么还是维持原判，忽略这条边；</li></ul></li><li>实际上，这个取代的过程可以通过缩小这个待赋值空边权值代销来实现。</li></ul><p>这样，我们就可以使用我们的思考，构造出这个题目的答案<del>虽然有些过程显得非常玄学就是了</del>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; disc, adj[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, u, v, w;</span><br><span class="line">    input, n, m;</span><br><span class="line">    <span class="keyword">auto</span> res = (longs) n * (n - <span class="number">1</span>) / <span class="number">2</span> - m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) disc.insert(i);</span><br><span class="line">    ya_dsu all(n + 1), real(n + 1);</span><br><span class="line">    <span class="built_in">vector</span>&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; edge;</span><br><span class="line">    <span class="keyword">const</span> function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u) &#123;</span><br><span class="line">        disc.erase(u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>;;) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = disc.lower_bound(v);</span><br><span class="line">            <span class="keyword">if</span> (it == disc.end()) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">else</span> v = *it;</span><br><span class="line">            <span class="keyword">if</span> (!adj[u].count(v)) &#123;</span><br><span class="line">                all.connect(u, v);</span><br><span class="line">                dfs(v), --res;</span><br><span class="line">            &#125;</span><br><span class="line">            ++v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    uint xs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        input, u, v, w;</span><br><span class="line">        adj[u].insert(v), adj[v].insert(u);</span><br><span class="line">        edge.emplace_back(w, u, v);</span><br><span class="line">        xs ^= (uint) w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (disc.count(i)) dfs(i);</span><br><span class="line">    <span class="keyword">if</span> (res &gt; <span class="number">0</span>) xs = <span class="number">0</span>;</span><br><span class="line">    sort(edge.begin(), edge.end());</span><br><span class="line">    longs ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>[w, u, v] : edge) &#123;</span><br><span class="line">        <span class="keyword">if</span> (all.connect(u, v)) &#123;</span><br><span class="line">            ans += w;</span><br><span class="line">            real.connect(u, v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (real.connect(u, v))</span><br><span class="line">            minimize(xs, (uint)w);</span><br><span class="line">    &#125;</span><br><span class="line">    output, ans + xs, <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 DFS 就显得尤其离谱……在 <span class="math inline">\(n = \sqrt{N}\)</span> 的准完全图里，它最坏的情况下会跑掉 <span class="math inline">\(\mathcal{\Theta}(n^2\log n)\)</span>，在其他的情况下我甚至都无法分析它的复杂度（算法设计课全还给院长了），但是就是可以过，所以…… 等我会证明它的复杂度的时候再补充说明把（</p><p>此外还值得一提的就是它的标程提供了一种优雅的路径压缩+按秩合并的并查集实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ya_dsu</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fa;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[u] &gt; fa[v]) swap(u, v);</span><br><span class="line">        fa[u] += fa[v], fa[v] = u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ya_dsu</span><span class="params">(<span class="keyword">int</span> n)</span> : <span class="title">fa</span><span class="params">(n, <span class="number">-1</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; fill(fa.begin(), fa.end(), <span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123; <span class="keyword">return</span> fa[u] &lt; <span class="number">0</span> ? u : fa[u] = id(fa[u]); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        u = id(u), v = id(v);</span><br><span class="line">        <span class="keyword">if</span> (u == v) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> join(u, v), <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123; <span class="keyword">return</span> -fa[id(u)]; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简单的说就是那个数组非根节点记录根节点的编号，而根节点为负数，且绝对值等于连通块的大小；比起我之前的经典实现节约了一个 <code>siz</code> 数组的大小，本彩笔惊为天人，高，实在是高（</p><h2 id="后记">后记</h2><p>这周，准确地说应该是上周，因为各种各样的事情——比如博客的花里胡哨啊等等——导致了我在考研复习和训练上投入的时间大幅减少；这是一个危险的信号，这周需要尽量避免。</p><p>欲辩已忘言，，明明在开始写这篇文章的时候还是感觉有好多的废话想要说的，，但是现在却对着窗口发呆，一句话也说不出来…… 唉，四点了，今天的墨墨背单词的卡又打不成了（）……因为实在是太晚了所以就不再多说些啥了，早点休息力 ==</p><p>最后送给自己一句话： <em>自分の光になれ！</em> 没有任何的典故，只是想对自己这么说而已——</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 pandoc 正确渲染多行 MathJax 公式</title>
      <link href="/2021/use-pandoc-to-render-multiline-formulas-correctly/"/>
      <url>/2021/use-pandoc-to-render-multiline-formulas-correctly/</url>
      
        <content type="html"><![CDATA[<p>随着 Hexo 的发展，有越来越多的小伙伴使用 Hexo 搭建技术博客，其中不乏大量包含数学公式的场合：为了满足这种需要，一般是在 Markdown 中使用部分 <span class="math inline">\(\LaTeX\)</span> 语法书写数学公式，Hexo 也支持使用 <code>Mathjax</code> 渲染这些公式；本是一件很舒服的事情，但是当编写多行公式的时候，会发现渲染出现错误：</p><p>比如下面的数学公式：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;bmatrix&#125;</span></span></span><br><span class="line">1 &amp; x_0 &amp; x_0^2 &amp; <span class="tag">\<span class="name">cdots</span></span> &amp; x_0^n <span class="tag">\<span class="name">\</span></span></span><br><span class="line">1 &amp; x_1 &amp; x_1^2 &amp; <span class="tag">\<span class="name">cdots</span></span> &amp; x_1^n <span class="tag">\<span class="name">\</span></span></span><br><span class="line"><span class="tag">\<span class="name">vdots</span></span> &amp; <span class="tag">\<span class="name">vdots</span></span> &amp; <span class="tag">\<span class="name">vdots</span></span> &amp; <span class="tag">\<span class="name">ddots</span></span> &amp; <span class="tag">\<span class="name">vdots</span></span> <span class="tag">\<span class="name">\</span></span></span><br><span class="line">    1 &amp; x_n &amp; x_n^2 &amp; <span class="tag">\<span class="name">cdots</span></span> &amp; x_n^n  </span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;bmatrix&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;bmatrix&#125;</span></span></span><br><span class="line">a_0 <span class="tag">\<span class="name">\</span></span> a_1 <span class="tag">\<span class="name">\</span></span> <span class="tag">\<span class="name">vdots</span></span> <span class="tag">\<span class="name">\</span></span> a_n</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;bmatrix&#125;</span></span></span><br><span class="line">=</span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;bmatrix&#125;</span></span></span><br><span class="line">y_0 <span class="tag">\<span class="name">\</span></span> y_1 <span class="tag">\<span class="name">\</span></span> <span class="tag">\<span class="name">vdots</span></span> <span class="tag">\<span class="name">\</span></span> y_n</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;bmatrix&#125;</span></span></span><br></pre></td></tr></table></figure><p>是一个和范德蒙矩阵相关的算式；它正确渲染后的样子应该是这样的： <span class="math display">\[\begin{bmatrix}    1 &amp; x_0 &amp; x_0^2 &amp; \cdots &amp; x_0^n \\    1 &amp; x_1 &amp; x_1^2 &amp; \cdots &amp; x_1^n \\    \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\    1 &amp; x_n &amp; x_n^2 &amp; \cdots &amp; x_n^n  \end{bmatrix}\begin{bmatrix}    a_0 \\ a_1 \\ \vdots \\ a_n\end{bmatrix}=\begin{bmatrix}    y_0 \\ y_1 \\ \vdots \\ y_n\end{bmatrix}\]</span> 但是实际上，渲染出来的结果很有可能是下面这样…… <span class="math display">\[\begin{bmatrix}    1 &amp; x_0 &amp; x_0^2 &amp; \cdots &amp; x_0^n \    1 &amp; x_1 &amp; x_1^2 &amp; \cdots &amp; x_1^n \    \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \    1 &amp; x_n &amp; x_n^2 &amp; \cdots &amp; x_n^n  \end{bmatrix}\begin{bmatrix}    a_0 \ a_1 \ \vdots \ a_n\end{bmatrix}=\begin{bmatrix}    y_0 \ y_1 \ \vdots \ y_n\end{bmatrix}\]</span> 实在是让人头秃（</p><h2 id="原因分析">原因分析</h2><p>一般而言，Hexo 是将公式块（被 <code>$</code> 或者 <code>$$</code> 包裹）渲染为一个元素，然后在页面中加载 <code>MathJax</code> 的 <code>JS</code> 文件。浏览器加载页面的时候运行 <code>MathJax</code> 读取这些元素中的公式并渲染完成替换的。但是 <code>marked</code> 会优先转义 Markdown 的语法，再考虑数学公式；因此当两者的语法冲突的时候，就会使得最终提供给 <code>MathJax</code> 的公式出现异常，导致渲染错误。</p><h2 id="解决方法">解决方法</h2><p>既然已经确定了渲染不正确的原因是 <code>hexo-renderer-marked</code> 的原因，那么就可以从这方面入手考虑解决方法了：</p><h3 id="修改-marked.js-源码"><del>修改 <code>Marked.js</code> 源码</del></h3><p>因为 <code>Marked.js</code> 会先将下划线 escape 成 <code>&lt;em&gt;</code>，将 <span class="math inline">\(LaTeX\)</span> 中用于换行的 <code>\\</code> 转移成 <code>\</code>，使得客户端的 <code>MathJax</code> 在渲染的时候无法正确读取公式导致渲染异常。因此，可以修改 <code>nodes_modules</code> 中的 <code>marked</code> 的源代码，或自行发布一个私有的 <code>marked</code> 作为依赖。</p><p>在 <code>marked/lib/marked.js</code> 中：</p><ul><li>去掉 <code>\</code> 的额外转义</li><li>将 <code>em</code> 标签对应的符号中，去掉 <code>_</code> ：因为 <code>markdown</code> 中有 <code>*</code> 可以表示斜体</li></ul><p>修改方式如下：</p><p>首先删除对于反斜杠的转义</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- escape: /^\\([\\`*&#123;&#125;\[\]()# +\-.!_&gt;])/,</span></span><br><span class="line"><span class="addition">+ escape: /^\\([`*&#123;&#125;\[\]()# +\-.!_&gt;])/,</span></span><br></pre></td></tr></table></figure><p>再删除对于 <code>em</code> 的多余的转义：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span></span><br><span class="line"><span class="addition">+ em:/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span></span><br></pre></td></tr></table></figure><p>遗憾地是上述做法并不适合目前较新版本的 <code>Marked.js</code>，所以现在无法使用。如果有新版本的 <code>Marked.js</code> 的修改方法也欢迎分享（</p><h3 id="强行适配渲染规则">强行适配渲染规则</h3><p>因为主要受到影响的是多行公式，所以在需要使用多行公式的时候，使用 <code>\\\\</code> 替换 <code>\\</code>，就可以保证页面的正常渲染。</p><p>但是这样并不能解决关于下划线的渲染问题<del>还是得看脸</del>，而且这样在 Typora 等可以正确渲染的本地环境下，看到的公式之间会有莫名的空行（并不优雅）。</p><h3 id="更换渲染引擎推荐">更换渲染引擎（推荐）</h3><p>既然是渲染引擎的锅，那么换一个渲染引擎就好了；下面列举作者尝试过的一些渲染引擎，并简单介绍一下它们的优缺点：</p><p>作者的博客在进行这些尝试的时候使用的主题是 <a href="https://github.com/volantis-x/hexo-theme-volantis">Volantis</a> 的 <code>4.3.1</code> 版本。</p><h4 id="hexo-renderer-markdown-it"><a href="https://github.com/hexojs/hexo-renderer-markdown-it">hexo-renderer-markdown-it</a></h4><p>和 Hexo 默认使用的 <code>hexo-renderer-marked</code> 不同，在博文的 <code>front-matter</code> 不开启 <code>mathjax</code> 的情况下，似乎会先使用 <code>Katex</code> 渲染公式。<code>Katex</code> 会在生成静态文件的过程中就完成数学公式的渲染，而不是在客户端的浏览器中。因此可以获得很棒的加载速度（毕竟在一些性能较差的设备上经常能看见公式半天加载不出来的情况）；但是问题在于 <code>katex</code> 支持的 <span class="math inline">\(\LaTeX\)</span> 实在是太少了，远远不够用。</p><p>一些 Hexo 主题的作者也会基于这个渲染器进行一些修改，作者就没有一一尝试了。</p><h4 id="hexo-renderer-kramed"><a href="https://github.com/hsfzxjy/hexo-renderer-kramed">hexo-renderer-kramed</a></h4><p>这是一个 <code>hexo-renderer-marked</code> 的分支，也会和 <code>hexo-renderer-marked</code> 产生冲突。本来应该是一个很不错的选项，但是作者在使用它作为渲染引擎后运行 <code>gulp</code> 来最小化 <code>HTML</code> 会报错…… 所以就没有继续尝试了。</p><h4 id="hexo-renderer-syzoj-renderer"><a href="https://github.com/Menci/hexo-renderer-syzoj-renderer">hexo-renderer-syzoj-renderer</a></h4><p>大佬 <a href="https://github.com/Menci">Menci</a> 出品，使用她为开源的 <code>SYZOJ</code> 写的 Markdown 渲染器来渲染文章的插件<del>其实使用的还是 <code>markdown-it</code></del>。优点是渲染行为和 <code>marked</code> 非常类似，且对于 <code>MathJax</code> 的支持和语法容忍度非常高：基本上是你在 <code>Typora</code> 里写的什么样，Hexo 渲染出来的就是什么样<del>特别是对于 SYZOJ 用户</del>，可以说是非常的舒服。</p><p>而且，虽然此渲染器使用 <code>MathJax</code> 渲染，但是这个过程也是在后端完成的。因此客户端浏览器的公式渲染速度很快，解决了 <code>MathJax</code> 公式渲染阻塞留白的问题。</p><p>但它的缺点就是在某些兼容性上可能有一些微妙的问题：博主使用的主题 <a href="https://github.com/volantis-x/hexo-theme-volantis">Volantis</a> 在开启 <code>Pjax</code> 后，包含数学公式的页面的 <code>Pjax</code> 跳转会失效（<a href="https://github.com/volantis-x/hexo-theme-volantis/issues/621">Issue #621 · volantis-x/hexo-theme-volantis</a>）；此外，很多主题会对于配置文件里写的字符串在布局的 <code>ejs</code> 文件中调用 <code>markdown()</code> 接口渲染成 Markdown，这个渲染器没有提供这个接口（也就是说，还得保留 <code>hexo-rederer-marked</code> 才可以使得这些部分正常渲染）。</p><p>如果你使用的博客主题没有 <code>Pjax</code>，或者和这个渲染器没有什么冲突的话，还是非常推荐使用的。</p><h4 id="hexo-renderer-pandoc"><a href="https://github.com/wzpan/hexo-renderer-pandoc">hexo-renderer-pandoc</a></h4><p>目前本博客采取的方案，在客户端使用 <code>mathjax</code> 渲染数学公式。相比于上面的 <code>hexo-renderer-syzoj-renderer</code> 容忍性较差：用来包裹行内公式的 <code>$</code> 和公式之间不能有空格，否则会渲染失败。此外，它对于一些其他的元素的渲染行为和 <code>hexo-renderer-marked</code> 的行为不同：比如对于 Markdown 图片 <code>![alt](url)</code>，它们的渲染结果分别如下：</p><p>使用 <code>hexo-renderer-marked</code> 的渲染结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span> <span class="attr">src</span>=<span class="string">&quot;url&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>使用 <code>hexo-renderer-pandoc</code> 的渲染结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span> <span class="attr">src</span>=<span class="string">&quot;url&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span></span><br><span class="line">    alt</span><br><span class="line">  <span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此外，另一个显著的问题是：直接写在文本中的链接（没有被 <code>&lt; &gt;</code> 和 <code>[]()</code> 包裹的链接）不会被自动加上超链接。</p><p>不过这对于 Volantis 而言倒也问题不大：上面这个问题实际上只要外挂一个 <code>CSS</code> 就没什么问题了；至少这样的渲染并不会影响到 <code>z-lazyload</code> 的脚本对于图片的标记。但是对于其他的，按照 <code>hexo-renderer-marked</code> 的渲染行为而设计主题，就可能会产生兼容性问题。</p><p>并且，使用 <code>hexo-renderer-pandoc</code> 可以正常渲染配置文件中那些使用 <code>markdown()</code> 渲染的字符串。因此真的可以卸载 <code>hexo-renderer-marked</code> 了！</p><p>另一个问题就是 <code>hexo-renderer-pandoc</code> 的渲染需要依赖本地的 <code>pandoc</code>：<a href="https://www.pandoc.org/installing.html">Pandoc - Installing pandoc</a>；如果只是本机生成静态文件再上传到服务器 / Github Page 倒也不算是什么问题了，但是如果我们使用自动部署，就需要对原来的部署脚本进行一些修改：</p><h5 id="github-action">Github Action</h5><p>在编译和部署的命令之前增加安装 Pandoc 的命令：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+ - name: Setup Pandoc</span></span><br><span class="line"><span class="addition">+   run: |</span></span><br><span class="line"><span class="addition">+     wget https://github.com/jgm/pandoc/releases/download/2.10.1/pandoc-2.10.1-1-amd64.deb</span></span><br><span class="line"><span class="addition">+     sudo dpkg -i pandoc-2.10.1-1-amd64.deb</span></span><br></pre></td></tr></table></figure><h5 id="vercel">Vercel</h5><p>目前无法在 Vercel 上安装 <code>Pandoc</code>，所以无法使用 Vercel 来构建博客的静态文件。</p><h2 id="总结">总结</h2><ul><li><code>hexo-renderer-syzoj-renderer</code>：如果对 <code>Pjax</code> 没有什么要求，且使用的主题没有兼容性的问题；</li><li><code>hexo-renderer-pandoc</code>：兼容性略好，但是无法使用 <code>Vercel</code> 自动构建静态页面；</li></ul><p>Volantis 的社区里也确实没有说这个相关的文章啊，还是写一篇好了（</p><p>虽然但是，还是希望能够解决这个兼容性问题能用上 <code>hexo-renderer-syzoj-renderer</code> 啊（）用 Pandoc 渲染在各种方面还是有点麻烦了==</p>]]></content>
      
      
      <categories>
          
          <category> 折腾记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 水 </tag>
            
            <tag> hexo </tag>
            
            <tag> 废话 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round#714 div.2 回顾</title>
      <link href="/2021/codeforces-round-714-div2/"/>
      <url>/2021/codeforces-round-714-div2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>补题链接：<a href="https://codeforces.com/contest/1513" class="uri">https://codeforces.com/contest/1513</a></p></blockquote><h2 id="记录">记录</h2><p>总算是最后勉勉强强地成为了 ABCD 选手，，但是因为失明不长脑子以及没有手等众多因素，导致我这场比赛的罚时高的离谱，，四个题都会做甚至排名 500+（</p><p>当然，这场的题目比昨天发的<a href="https://shiraha.cn/2021/codeforces-round-712-div2/">那篇文章</a>的那套题还要水的多，，只能说…什么也说不出（</p><figure><img src="https://i.loli.net/2021/04/12/1MZkR637v5xn2zC.jpg" class="lazyload" data-srcset="https://i.loli.net/2021/04/12/1MZkR637v5xn2zC.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="S3DP4B0L_1J2VG8J0_7_W.jpg" /><figcaption aria-hidden="true">S3DP4B0L_1J2VG8J0_7_W.jpg</figcaption></figure><p>然后吃午饭的时候看一 20 级学弟在群里装杯，一查 CF 结果昨天这场他做了五个题，罚时也把我吊起来打……老年人的眼泪不争气地掉了下来（</p><h2 id="题解">题解</h2><h3 id="a---array-and-peaks">A - <a href="https://codeforces.com/contest/1513/problem/A">Array and Peaks</a></h3><p>没什么好说的，由手就行，没手也行（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = $.nextInt(), n, k;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        input, n, k;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; (n - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">            output, <span class="number">-1</span>, <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++ i)</span><br><span class="line">                a[i * <span class="number">2</span> + <span class="number">2</span>] = n - i;</span><br><span class="line">            <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">                <span class="keyword">if</span> (!a[i]) a[i] = ++ cur;</span><br><span class="line">            $.putArray(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="b---and-sequences">B - <a href="https://codeforces.com/contest/1513/problem/B">AND Sequences</a></h3><p>显然，考虑极端情况 <span class="math inline">\(a_1 \&amp; a_2 \&amp; \cdots \&amp; a_{n - 1} = a_n\)</span> 是成立的，那么显然有 <span class="math inline">\(\&amp;_{i = 1}^n a_i = a_n\)</span>；同理也可以证明 <span class="math inline">\(\&amp;_{i = 1}^n a_i = a_1\)</span>；因此只需要先对数组求按位与的和，然后查找这个数字在数组里出现的次数；从中选择两个放在头尾，剩下的数字放在中间随便摆。</p><p>很简单的一个题，思路也很清晰……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], fact[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    fact[<span class="number">0</span>] = fact[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (longs i = <span class="number">2</span>; i &lt; N; ++ i)</span><br><span class="line">        fact[i] = <span class="keyword">int</span>(fact[i - <span class="number">1</span>] * i % mod);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = $.nextInt(), n;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        $(n).nextArray(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">        uint mask = ~<span class="number">0u</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            mask &amp;= (uint) a[i];</span><br><span class="line">        longs cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (mask == a[i]) ++ cnt;</span><br><span class="line">        cnt = cnt * (cnt - <span class="number">1</span>) % mod;</span><br><span class="line">        output, cnt * fact[n - <span class="number">2</span>] % mod, <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来应该是这样的，，但是因为我最开始预处理的时候没有赋值 <code>fact[0] = 1</code>，导致我 WA 的生活不能自理直接放弃，直到最后面才意识到这个问题的，，，我是傻逼嘛（</p><h3 id="c---add-one">C - <a href="https://codeforces.com/contest/1513/problem/C">Add One</a></h3><p>显然，对于一个具体的数字，我们进行 <span class="math inline">\(n\)</span> 次变换的结果时独立确定的，也可以表现为 10 个数字的个数。因为变换的上线也只有 <span class="math inline">\(2 \times 10^5\)</span> 级别，所以完全可以预处理后，对于具体的数字变形后查询得到答案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10</span>][N], f[<span class="number">10</span>][<span class="number">10</span>], tmp[<span class="number">10</span>], cnt[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span> tmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++ i)</span><br><span class="line">        tmp[i + <span class="number">1</span>] = f[id][i];</span><br><span class="line">    tmp[<span class="number">1</span>] += f[id][<span class="number">9</span>], tmp[<span class="number">0</span>] += f[id][<span class="number">9</span>];</span><br><span class="line">    tmp[<span class="number">1</span>] %= mod, tmp[<span class="number">0</span>] %= mod;</span><br><span class="line">    longs ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : tmp) ret += i;</span><br><span class="line">    <span class="built_in">memcpy</span>(f[id], tmp, <span class="keyword">sizeof</span> tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(ret %= mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++ i)</span><br><span class="line">        f[i][i] = dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++ j)</span><br><span class="line">            dp[j][i] = transfer(j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = $.nextInt(), n, m;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        input, n, m;</span><br><span class="line">        longs ans = <span class="number">0</span>;</span><br><span class="line">        itoa(n, s, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">char</span> *st = s;</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">        <span class="keyword">while</span> (*st) ++ cnt[*st - <span class="string">&#x27;0&#x27;</span>], st ++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++ i) &#123;</span><br><span class="line">            ans += <span class="number">1l</span>l * dp[i][m] * cnt[i];</span><br><span class="line">            ans %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        output, ans, <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，我这样写还是有点蠢的：实际上并不需要枚举每一个数字的变换，只需要枚举 0 的变换即可。</p><h3 id="d---gcd-and-mst">D - <a href="https://codeforces.com/contest/1513/problem/D">GCD and MST</a></h3><blockquote><p>一张图，有 <span class="math inline">\(n\)</span> 个节点，每个点都有权值 <span class="math inline">\(a_i\)</span>；相邻节点之间连接了权值为 <span class="math inline">\(p\)</span> 的边（共 <span class="math inline">\(n - 1\)</span> 条）；此外，对于下标 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 即 <span class="math inline">\(1 \leq i &lt; j \leq n\)</span>，如果满足 <span class="math inline">\(\gcd_{k = i}^j a_k = \min_{k = i}^j a_k\)</span>，则 <span class="math inline">\(i \leftrightarrow j\)</span> 之间连接一条权重为 <span class="math inline">\(\min_{k = i}^j a_k\)</span> 的边；</p><p>现在要求求出这张图的最小生成树的边权值之和。</p></blockquote><p>看到最小值，就联想到要考虑最小值的区间；先对于 <span class="math inline">\(a[i]\)</span> 排序，然后对于每个最小值，向左向右尝试找到包含这个最小值的连续区间；显然，这个连续区间中的每一个节点都可以互相连接边权为这个最小值的边；对于长度为 <span class="math inline">\(l\)</span> 的这样的区间，我们只需要连接 <span class="math inline">\(l - 1\)</span> 条这样的边即可。</p><p>这样虽然解决了最小值区间内的问题，但是最小值区间之间也可能连边；所以最小值探边界的时候，如果遇到了已经被之前的（更小的）最小值占领的区间，仍需要额外考虑一次来判断是否可以连边来连接两个区间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = $.nextInt(), n, p;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">-1</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, greater&lt;&gt;&gt; heap;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        $(n, p).nextArray(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (!heap.empty()) heap.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            heap.emplace(a[i], i);</span><br><span class="line">        <span class="keyword">int</span> res = n - <span class="number">1</span>;</span><br><span class="line">        longs ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!heap.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [x, ii] = heap.top();</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= p) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> heap.pop();</span><br><span class="line">            <span class="keyword">if</span> (vis[ii] == T) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> vis[ii] = T;</span><br><span class="line">            <span class="keyword">int</span> g = x, l = ii - <span class="number">1</span>, r = ii + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> gg = gcd(x, a[l]);</span><br><span class="line">                <span class="keyword">if</span> (gg == g) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (vis[l] == T) &#123;</span><br><span class="line">                        -- l; <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> vis[l --] = T;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (r &lt;= n) &#123;</span><br><span class="line">                <span class="keyword">auto</span> gg = gcd(x, a[r]);</span><br><span class="line">                <span class="keyword">if</span> (gg == g) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (vis[r] == T) &#123;</span><br><span class="line">                        ++ r; <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> vis[r ++] = T;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += longs(r - l - <span class="number">2</span>) * x;</span><br><span class="line">            res -= r - l - <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += <span class="number">1l</span>l * res * p;</span><br><span class="line">        output, ans, <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想通了实际上也就这么一回事，但是我却还是白给了两发…… 因为我认为我的手会敲出和我脑子想象中一样的代码，但是实际上手没有，，导致我一度以为我想错了开始胡思乱想，，还是菜的离谱了点（</p><h3 id="e---cost-equilibrium">E - <a href="https://codeforces.com/contest/1513/problem/E">Cost Equilibrium</a></h3><blockquote><p>有一个长度为 <span class="math inline">\(n\)</span> 的数组，每个位置都有值 <span class="math inline">\(a_i\)</span>；现在你可以花费 <span class="math inline">\(x \cdot |i - j|\)</span> 的成本，使得 <span class="math inline">\(a_i\)</span> 减少 <span class="math inline">\(x\)</span> 并使得 <span class="math inline">\(a_j\)</span> 增加 <span class="math inline">\(x\)</span>，操作中不能有任何值变为负数；每个点只能进行一类操作（减少操作和增加操作不能出现在同一个节点上）；将数组中的所有值全部变为相等而进行的操作带来的成本和定义为数组的成本。</p><p>现在要求你重新排列数组，使得数组的成本的最小值和最大值相等。求出这样重新排列后的数组的个数。</p></blockquote><p>题目一通花里胡哨完了之后实际上没啥内容；首先排除 <span class="math inline">\(\sum a_i \mod n \neq 0\)</span> 的情况。那么剩下来的情况就都满足 <span class="math inline">\(n \ | \sum a_i\)</span>；令 <span class="math inline">\(x = \sum a_i \div n\)</span>。</p><p>然后考虑：因为每个节点只能承担一种角色，所以</p><ul><li><span class="math inline">\(a_i &gt; x\)</span> 的节点只能是出点，<span class="math inline">\(a_i &lt; x\)</span> 的节点只能是入点</li><li><span class="math inline">\(a_i \neq x\)</span> 的节点不能参与任何操作</li></ul><p>失明的我一开始把这个限制条件看成了每个节点只能运入一次运出一次，然后鼓捣了个假做法，发现和题解完全不同<del>但是过了样例，要是比赛中这样那我大概也是个假人了</del>，不过似乎可以出个新题（？）</p><p>我们记小于平均值的节点的数量为 <span class="math inline">\(l\)</span>，大于平均值的节点数量为 <span class="math inline">\(g\)</span>；那么可以进行下面的猜想：</p><ul><li><span class="math inline">\(l = 0\)</span> 并且 <span class="math inline">\(g = 0\)</span>：显然，全数组已经相同，只有 <span class="math inline">\(1\)</span> 种排列满足要求</li><li><span class="math inline">\(l = 1\)</span> 或 <span class="math inline">\(g = 1\)</span>：出点/入点是确定的，所以运输方案只有一种；任何排列都满足要求</li><li>否则：出点们和入点们分布在数组的两侧且互不相交时才可以满足要求</li></ul><p>关于第三条，很显然如果出入点之间产生了交错，那么中间节点的运输方向的改变会影响到答案。</p><p>又因为输出的是重排后的序列的种类数，所以在直接求排列数之后需要特殊处理出现了相同数字的位置：将它们的排列数从总的排列数中除掉；而等于平均值插入到排序中可以使用组合数求出。</p><h4 id="补题代码">补题代码</h4><p>因为涉及到了排列组合，并且是模意义下运算，所以需要预处理阶乘和阶乘的逆元。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], n, fact[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Inverse &#123;</span><br><span class="line">    <span class="function">longs <span class="title">fastPow</span><span class="params">(longs a, longs b, longs mod)</span> </span>&#123;</span><br><span class="line">        longs ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1u</span>) ans = (ans * a) % mod;</span><br><span class="line">            a = (a * a) % mod;</span><br><span class="line">            b &gt;&gt;= <span class="number">1u</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">longs <span class="title">inverse</span><span class="params">(longs a, longs p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; p || a &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; p) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> fastPow(a, p - <span class="number">2</span>, p) % p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    fact[<span class="number">0</span>] = fact[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (longs i = <span class="number">2</span>; i &lt; N; ++i)</span><br><span class="line">        fact[i] = <span class="keyword">int</span>(fact[i - <span class="number">1</span>] * i % mod);</span><br><span class="line">    inv[N - <span class="number">1</span>] = (<span class="keyword">int</span>)Inverse::inverse(fact[N - <span class="number">1</span>], mod);</span><br><span class="line">    <span class="keyword">for</span> (longs i = N - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        inv[i] = (<span class="keyword">int</span>)(inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> nCr = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &lt; <span class="number">0</span> || b &gt; a) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        longs ret = fact[a];</span><br><span class="line">        ret = (ret * inv[a - b]) % mod;</span><br><span class="line">        ret = (ret * inv[b]) % mod;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)ret;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    $(n).nextArray(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    lll sum = accumulate(a + <span class="number">1</span>, a + <span class="number">1</span> + n, (lll) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sum % n) &#123;</span><br><span class="line">        output, <span class="number">0</span>, <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> x = sum / n;</span><br><span class="line">    <span class="keyword">int</span> less = <span class="number">0</span>, greater = <span class="number">0</span>, equal = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    cnt.reserve(N * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        ++cnt[a[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; x) ++greater;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &lt; x) ++less;</span><br><span class="line">        <span class="keyword">else</span> ++equal;</span><br><span class="line">    <span class="keyword">if</span> (!less &amp;&amp; !greater) &#123;</span><br><span class="line">        output, <span class="number">1</span>, <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (less == <span class="number">1</span> || greater == <span class="number">1</span>) &#123;</span><br><span class="line">        lll ans = fact[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [k, v] : cnt)</span><br><span class="line">            ans = (ans * inv[v]) % mod;</span><br><span class="line">        output, ans, <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> ans = (lll)fact[less] * fact[greater] % mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [k, v] : cnt)</span><br><span class="line">            <span class="keyword">if</span> (k != x)</span><br><span class="line">                ans = (ans * inv[v]) % mod;</span><br><span class="line">        ans *= <span class="number">2</span>, ans %= mod;</span><br><span class="line">        ans = (ans * nCr(n, equal)) % mod;</span><br><span class="line">        output, ans, <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为最开始没有特判全数组相等的情况，所以白给了一发（</p><h3 id="f---swapping-problem">F - <a href="https://codeforces.com/contest/1513/problem/F">Swapping Problem</a></h3><blockquote><p>现在你有两个长度为 <span class="math inline">\(n\)</span> 的数组 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>；数组的权值之和是 <span class="math inline">\(\sum|a_i - b_i|\)</span>；你现在可以进行最多 1 次的交换：将 <span class="math inline">\(b\)</span> 中的两个数字交换位置；问可以求得的最小权值是多少。</p></blockquote><p>对于每个位置 <span class="math inline">\(i\)</span>，我们可以将它看作一个区间；那么权值和就是所有的区间大小的和。我们能做的是交换其中某两个区间的特定端点，从而使得总区间大小变小。要想实现这种交换，我们交换的两个端点在对应的区间中的角色必须不同（显然，如果角色相同，交换了没有任何意义）；</p><p>而进行简单的推导我们可以得出猜想：交换了两个在对应区间中角色不同的端点，带来的贡献是两个区间重复部分的 2 倍；如果两个区间没有重叠，那么就会造成两个区间间隔的两倍的负贡献。因此，我们只要找到来自两个部分的，且有最大覆盖的区间，就可以求出最小的权值。</p><p>我们将所有的区间分成两类：<span class="math inline">\(I\)</span> 类以 <span class="math inline">\(a_i\)</span> 为左端点，而 <span class="math inline">\(II\)</span> 类以 <span class="math inline">\(b_i\)</span> 为左端点；因此，交换的两个区间必须一个来自 <span class="math inline">\(I\)</span>，另一个来自 <span class="math inline">\(II\)</span>；在按照左边界排序之后，维护每组的前缀的最大右边界；这样我们就可以快速的查找对于某个区间而言，可能形成最大覆盖的来自另一组的区间；遍历一组，查找另一组，更新答案即可。</p><h4 id="补题代码-1">补题代码</h4><p>当然，这个经典的问题也可以使用双指针来解决，就像下面这样；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortVector</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">    sort(vec.begin(), vec.end());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    $(n).nextArray(a + <span class="number">1</span>, a + <span class="number">1</span> + n)</span><br><span class="line">        .nextArray(b + <span class="number">1</span>, b + <span class="number">1</span> + n);</span><br><span class="line">    lll ans = <span class="number">0</span>, origin = <span class="number">0</span>, pp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; I, II;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; b[i]) &#123;</span><br><span class="line">            I.emplace_back(a[i], b[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            II.emplace_back(b[i], a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        origin += <span class="built_in">abs</span>(a[i] - b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> sizI = I.size(), sizII = II.size();</span><br><span class="line">    sortVector(I), sortVector(II);</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; heap;</span><br><span class="line">    ans = origin, pp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [L, R] : I) &#123;</span><br><span class="line">        <span class="keyword">while</span> (pp &lt; sizII &amp;&amp; II[pp].first &lt;= L) &#123;</span><br><span class="line">            heap.push(II[pp].second), ++ pp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!heap.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> lastR = heap.top();</span><br><span class="line">            minimize(ans, origin - <span class="number">2</span> * (min(lastR, R) - L));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!heap.empty()) heap.pop();</span><br><span class="line">    pp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [L, R] : II) &#123;</span><br><span class="line">        <span class="keyword">while</span> (pp &lt; sizI &amp;&amp; I[pp].first &lt;= L) &#123;</span><br><span class="line">            heap.push(I[pp].second), ++ pp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!heap.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> lastR = heap.top();</span><br><span class="line">            minimize(ans, origin - <span class="number">2</span> * (min(R, lastR) - L));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    output, ans, <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老年人光是想着怎么维护这个区间的最大覆盖就想了半个上午，属实不行（</p><h2 id="后记">后记</h2><p>唉，感觉这一场也没什么难的啊，只可惜前面罚时实在是太多了，，写代码的时候竟然连 <span class="math inline">\(0!=1\)</span> 这种常识性的东西都能不注意，也算是重新认识了自己==</p><p>今晚还有 EDU 场，不废话了，好好打啊（</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round#712 div.2 回顾</title>
      <link href="/2021/codeforces-round-712-div2/"/>
      <url>/2021/codeforces-round-712-div2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>补题链接：<a href="https://codeforces.com/contest/1504" class="uri">https://codeforces.com/contest/1504</a></p></blockquote><h2 id="记录">记录</h2><p>只能说进入四月一来一直颓的可以，，不仅没怎么训练没怎么准备考研，倒是莫名其妙地出去混了一天又一天，真的是愧对父母，，虽然出了各种各样的事情，但是再怎么说成年人还是应该对自己的行为负责…… 不废话了（</p><p>题目的话，A 白给一发，不过当时带人来 401 玩了，我还没有牛逼到一心二用还能好好写代码（）然后干脆直接 Div1 起步，从 C 开始做；然后做出了 C 和 D（当然，也花了相当的时间）之后就没怎么管了，，再之后（指一个星期之后的今天）补完了所有的题目。</p><p>但是听说这场 ABC 蓝名选手是要掉分的，做出了 ABCD 四个题的喜悦瞬间荡然无存，，</p><h2 id="题解">题解</h2><h3 id="a---déjà-vu">A - <a href="https://codeforces.com/contest/1504/problem/A">Déjà Vu</a></h3><p>反正就是破坏回文串：最简单的方法就是在前面加或者在后面加；都不行就输出 <code>NO</code> 就完事了（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> null = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[N], b[N], c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = $.nextInt();</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        input, a;</span><br><span class="line">        <span class="keyword">auto</span> n = <span class="built_in">strlen</span>(a);</span><br><span class="line">        <span class="built_in">strcpy</span>(b, a);</span><br><span class="line">        b[n] = <span class="string">&#x27;a&#x27;</span>, b[n + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(c, b);</span><br><span class="line">        reverse(c, c + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(b, c) != <span class="number">0</span>) &#123;</span><br><span class="line">            $.put(<span class="string">&quot;YES&quot;</span>).put(b);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(b + <span class="number">1</span>, a);</span><br><span class="line">        b[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>, b[n + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(c, b);</span><br><span class="line">        reverse(c, c + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(b, c) != <span class="number">0</span>) &#123;</span><br><span class="line">            $.put(<span class="string">&quot;YES&quot;</span>).put(b);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> $.put(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便，这是我第一次使用全新的<del>傻逼</del>快读板子 <code>cquery</code>，IO 交互和以往的代码可能有较大的差距（</p><h3 id="b---flip-the-bits">B - <a href="https://codeforces.com/contest/1504/problem/B">Flip the Bits</a></h3><p>和前缀和很想，可以很容易的想到如果要反转，反转的端点一定要出现在可以翻转的位置上；</p><p>本来想着先遍历维护端点，在遍历求区间，在验证区间是否合法的；但是实际上只需要双指针（甚至单个指针）就完事了；代码量远没有我想象的那么大……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> null = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = $.nextInt();</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = $.nextInt();</span><br><span class="line">        $(a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> cnt0 = <span class="number">0</span>, cnt1 = <span class="number">0</span>, ok = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] != b[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt1 != cnt0) &#123; ok = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="keyword">while</span> (a[j] != b[j]) &#123;</span><br><span class="line">                    ++ (a[j] == <span class="string">&#x27;1&#x27;</span> ? cnt1 : cnt0);</span><br><span class="line">                    ++ j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cnt1 != cnt0) &#123; ok = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">                <span class="keyword">else</span> i = j;</span><br><span class="line">            &#125;</span><br><span class="line">            ++ (a[i] == <span class="string">&#x27;1&#x27;</span> ? cnt1 : cnt0);</span><br><span class="line">        &#125;</span><br><span class="line">        $.put(ok ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能说写代码还是写少了，，惭愧惭愧（</p><h3 id="c---balance-the-bits">C - <a href="https://codeforces.com/contest/1504/problem/C">Balance the Bits</a></h3><blockquote><p>给一个 01 字符串：现在你要构造两个等长的括号序列，要求字符串为 0 的位置两个序列的括号不同，为 1 的位置相同；输出一种构造或者声明这是不可能的。</p></blockquote><p>显然，0 和 1 的位置必须都是偶数个，并且两端的数字都为 1；否则显然不行。</p><p>现在分开考虑 0 和 1；0 本身构成的序列一定是一个合理的序列，但是要求翻转之后也要成立；为了避免麻烦的括号嵌套，只能构造为 <code>()()()...</code> 的序列了；这样翻转之后的 <code>)()()(...</code> 也可以和两端为 1 的位置匹配。</p><p>同样还是为了解决麻烦的括号嵌套问题：因为 0 位置翻转之后可能会造成不必要的闭括号，所以考虑尽量提高嵌套层数；构造为 <code>...((()))...</code> 的形式可以达到这个目标；至此，我们得到了一种构造方法；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> s[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt();</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        scanner(s);</span><br><span class="line">        <span class="keyword">int</span> cnt0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;0&#x27;</span>) ++ cnt0;</span><br><span class="line">        <span class="keyword">if</span> (cnt0 % <span class="number">2</span> || s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> || </span><br><span class="line">            s[n - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) println(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            println(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> cnt1 = n - cnt0, half = cnt1 / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> flag0 = <span class="number">0</span>, flag1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">                    ans[i] = flag1 ++ &lt; half ? <span class="string">&#x27;(&#x27;</span> : <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> ans[i] = flag0 ? <span class="string">&#x27;(&#x27;</span> : <span class="string">&#x27;)&#x27;</span>, flag0 = <span class="number">1</span> - flag0;</span><br><span class="line">            ans[n] = <span class="string">&#x27;\0&#x27;</span>, println(ans);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&#x27;0&#x27;</span>) ans[i] = ans[i] == <span class="string">&#x27;(&#x27;</span> ? <span class="string">&#x27;)&#x27;</span> : <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            println(ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我也不知道怎么证明，，<a href="https://codeforces.com/blog/entry/89319">题解</a>也什么都没有说清楚……只能说想到了就是想到了（</p><h3 id="d---3-coloring">D - <a href="https://codeforces.com/contest/1504/problem/D">3-Coloring</a></h3><blockquote><p>有 <span class="math inline">\(n \times n\)</span> 的棋盘和三种颜料；提供一个长度为 <span class="math inline">\(n^2\)</span> 操作序列，对于每个操作，你可以将任意一个没有染色的格子染色为提供的颜色之外的颜色；要求染色完成后没有任何四联通的两个位置同色，过程<strong>强制在线</strong>。</p></blockquote><p>没长眼睛的我一开始看成了必须染色为提供的颜色；然后白乎了半天证明了这个问题是无解的——还好我后来又重新读题了== 将两种指示归因为一种颜色，另一个指示归因为另一个颜色，然后交叉的填即可——如果有一种颜色先填满，那么这个指令就以另一种颜色填入另一组位置即可；显然，这样是合理的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n, b, x, y, a;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> t = n * n;</span><br><span class="line">    <span class="keyword">int</span> T = t;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; pos1, pos2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            ((i + j) % <span class="number">2</span> ? pos2 : pos1).emplace(i, j);</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        <span class="keyword">switch</span> (a)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> (!pos2.empty()) </span><br><span class="line">                    x = pos2.front().first, </span><br><span class="line">                    y = pos2.front().second, </span><br><span class="line">                    b = <span class="number">2</span>, pos2.pop();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    x = pos1.front().first, </span><br><span class="line">                    y = pos1.front().second, </span><br><span class="line">                    b = <span class="number">3</span>, pos1.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> (!pos1.empty())</span><br><span class="line">                    x = pos1.front().first, </span><br><span class="line">                    y = pos1.front().second, </span><br><span class="line">                    b = <span class="number">1</span>, pos1.pop();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    x = pos2.front().first, </span><br><span class="line">                    y = pos2.front().second, </span><br><span class="line">                    b = <span class="number">3</span>, pos2.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">if</span> (!pos1.empty())</span><br><span class="line">                    x = pos1.front().first, </span><br><span class="line">                    y = pos1.front().second, </span><br><span class="line">                    b = <span class="number">1</span>, pos1.pop();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    x = pos2.front().first, </span><br><span class="line">                    y = pos2.front().second, </span><br><span class="line">                    b = <span class="number">2</span>, pos2.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>愿天堂没有失明🙏</p><h3 id="e---travelling-salesman-problem">E - <a href="https://codeforces.com/contest/1504/problem/E">Travelling Salesman Problem</a></h3><blockquote><p>有 <span class="math inline">\(n\)</span> 个城市，每个城市有一个美丽值 <span class="math inline">\(a_i\)</span> 和起步价 <span class="math inline">\(c_i\)</span>，初始在 <span class="math inline">\(1\)</span> 号城市；现在我们要到达所有的 <span class="math inline">\(n\)</span> 个城市一次后返回 <span class="math inline">\(1\)</span> 号城市；路途 <span class="math inline">\(i \to j\)</span> 的花费是 <span class="math inline">\(\max(c_i, a_j - a_i)\)</span>，求出达成目标的最少花费。</p></blockquote><p>从哪个城市出发无所谓的，因为路程是一个环；考虑这个起步价是一条路途出边决定的，而我们确定要从每个城市出去一次，所以这笔钱省不了；问题就在如何最小化额外花费；考虑路途 <span class="math inline">\(i \to j\)</span> 的额外花费，我们不难得到： <span class="math display">\[\max(c_i, a_j - a_i) = c_i + \max(0, a_j - a_i - c_i)\]</span> 显然，我们可以把美丽值看作是海拔：这样下坡就是免费的，上坡的话根据起点有所减费。我们的旅途反正是一个环，此时就转变为从最高点俯冲而下，然后再借助某些位置作为减费跳板回到山顶；这样的话会重复访问节点？拜托，俯冲的时候跳过这些节点不就完了，反正又不要钱（</p><p>此时，我们已经可以将这个问题转化为一个最短路问题，建模求解；建图方式如下：</p><ul><li>下坡：相邻的位置之间连边，显然免费</li><li>上坡：在坡上二分查找，找到最高的可以被减至 0 费的位置<ul><li>对于这个位置，显然连免费边：定义里都已经这么说了</li><li>对于这个位置的更高位置，连边，并用公式计算费用</li></ul></li></ul><p>其实原问题就可以朴素建图解决，但是边数是 <span class="math inline">\(O(n^2)\)</span> 的只能作罢；但是为什么可以这么建图呢？现在对于这个建图方法的合理性进行简单的说明：</p><p>下坡的话已经没有什么好说的了，我直接连免费边和从一堆免费边过去有什么区别呢？上坡的话可这么理解：首先上坡肯定是尽量的最大化的利用减费的——但是并不是没有代价：如果你要采用某个点的减费政策，就要放弃看来自更低的位置的减费；而前者未必比后者优。因此这个抉择就可以转化为：对于每个节点的减费政策，我是直接采用还是放弃前面的减费政策。</p><p>在前面的减费非常诱人的情况下，可能包含了多个可以免费的上坡位置——但是我们只需要建最高的位置即可：因为其他的位置可以用下坡边回流；但是一定会有一个位置，它可以减费但是无法减至免费：这个位置是关键位置，不可以被其他的边表示，因此也要连边。</p><p>综上所述，上述建图就可以完成对原问题的描述；在建图上跑最短路就可以得到答案。</p><hr /><p>当然，题解还提供了一种更简单的做法，但是相应地也更加的抽象难懂：</p><p>就像上面说的那样，下坡已经无所畏惧了，问题就是怎么巧妙利用减费来上坡；因此我们可以对所有节点根据“海拔”排序之后，从底部出发，递推地维护上坡到每个位置之后的最小花费。转化的答案可以描述为下面： <span class="math display">\[\sum_{i = 2}^n \max(0, a_i - \max_{j&lt;i}(a_j + c_j))\]</span> 即维护在更低位置中的最大折扣，到达每个位置的费用都等于到达最大折扣的位置的最少费用加上利用这个折扣跳转到当前位置的费用之和。但是我们毕竟只关注到达顶点的费用，如对于每一个位置都严格的维护这个又显的太过于复杂；所以只需要维护到达每个位置使用可用的最大减费之后的费用和即可。</p><p>那么为什么这样是正确的呢？显然，在没有这个减费的情况下，上坡的费用完全就是势能的转化：那个<del>高中物理</del>名词叫啥我忘记了；减费政策就相当于在坡上放倒三角；我们维护的总是当前势能加上减费后能量最高的位置——也就是加上减费后最高的位置。我们爬斜坡需要能量，但是倒三角覆盖的部分不需要能量；因此，我们只需要尽量用倒三角覆盖斜坡，就可以统计得到最小的费用。</p><h4 id="补题代码">补题代码</h4><p>贪心也得取之有道啊，瞎**贪心是做不出题目的啊（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], c[N], id[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> a[l] &lt; a[r];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">    longs ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        a[i] = scanner.nextInt(),</span><br><span class="line">        c[i] = scanner.nextInt(),</span><br><span class="line">        ans += c[i];</span><br><span class="line">    iota(id, id + <span class="number">1</span> + n, <span class="number">0</span>);</span><br><span class="line">    sort(id + <span class="number">1</span>, id + <span class="number">1</span> + n, compare);</span><br><span class="line">    longs discount = a[id[<span class="number">1</span>]] + c[id[<span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, p = id[i]; </span><br><span class="line">        i &lt;= n; p = id[++ i])</span><br><span class="line">    &#123;</span><br><span class="line">        ans += max(<span class="number">0l</span>l, a[p] - discount);</span><br><span class="line">        maximize(discount, (longs)a[p] + c[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    println(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能说做题的时候还是瞎想多了，，</p><h3 id="f---flip-the-cards">F - <a href="https://codeforces.com/contest/1504/problem/F">Flip the Cards</a></h3><blockquote><p>有 <span class="math inline">\(n\)</span> 张牌，牌的两面写了互不相同的 <span class="math inline">\([1, 2n]\)</span> 的数字；现在你需要对牌进行排序，并翻转部分牌，得到一个新的牌的序列：满足正面的数字递增且反面的数字递减。求出最少的翻转次数或者证明这不可能。</p></blockquote><p>我距离做出这个题的距离还是挺遥远的…… 甚至当晚看题解都没有看懂……菜爆了（</p><p>首先需要意识到有解的套牌必须满足一张牌的两面必须一个属于 <span class="math inline">\([1, n]\)</span> 另一个属于 <span class="math inline">\([n+1, 2n]\)</span>，否则无解；这也很好理解，毕竟我问我的学弟队友，他也是一眼意识到这个<del>只有我这个老东西后知后觉了呜呜</del></p><p>满足了上述限制的套牌，我们先进行翻转，保证正面比反面的数字小，那么就可以桶排序；按照正面数字排序之后的套牌，第 <span class="math inline">\(i\)</span> 张的正面数字是 <span class="math inline">\(i\)</span>，反面的数字记为 <span class="math inline">\(f[i]\)</span>；</p><p>首先给出一种确定可以构造出满足题意的排序的构造方法：如果上述的 <span class="math inline">\(f[i]\)</span> 构成的序列，可以拆分成两个递减的子序列，那么可以将拆解得到的两个部分中的一部分翻转后倒序，拼装到另一个部分的后面组成一个满足题意的序列；如果考虑到最少翻转次数，只需要翻转其中翻转成本较低的一组即可。</p><p>翻转成本的计算也非常简单：分成的序列中可能包含了一些在桶排序的时候翻转的卡牌，翻转一个序列的成本就是另一个序列中的这些卡牌的数量加上待翻转序列中除此之外的卡牌的数量。</p><p>但是问题就是 <span class="math inline">\(f[i]\)</span> 可能有多种分割的方法；而上述翻转的成本中的冗余都是因为有些卡牌可以放到另一个序列中避免翻转或者翻转回来导致的。因此我们有必要进行唯一的最优分解，才能求出这个答案；最优的分解很显然就是每当出现逆序对的时候，考虑翻转的成本，并选择更优的一侧翻转；之后将这些逆序对合并成序列即可。</p><p>但是并不是所有的划分都是可以复原的，所以划分时需要加入条件；这里采用的是 <span class="math inline">\(f[i]\)</span> 的前缀最小值大于后缀最大值的时候可以划分；这至少是一个充分的条件，保证翻转之后的序列的两个部分可以嵌套着还原为原序列。</p><p>虽然有很多部分还是没有太清楚的明白，但是还是知道了一些事情：我只需要考虑可以构造出最小花费的序列的方法即可，至于有没有别的方法，Who care？当然，必要性还是需要证明的……这我就实在不太懂了（</p><h4 id="补题代码-1">补题代码</h4><p>经典对着标程猜测题解，，逊（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a[N];</span><br><span class="line"><span class="built_in">bitset</span>&lt;N&gt; rev;</span><br><span class="line"><span class="keyword">int</span> f[N], suf[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = $.nextInt();</span><br><span class="line">    $.nextArray(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">bool</span> legal = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i].first &gt; a[i].second) &#123;</span><br><span class="line">            swap(a[i].first, a[i].second);</span><br><span class="line">            rev.<span class="built_in">set</span>(a[i].first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[i].first &gt; n || a[i].second &lt;= n) &#123;</span><br><span class="line">            legal = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> f[a[i].first] = a[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!legal) &#123;</span><br><span class="line">        output, <span class="number">-1</span>, <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        suf[n + <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; -- i)</span><br><span class="line">            suf[i] = max(f[i], suf[i + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> pref = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">int</span> cosA = <span class="number">0</span>, cosB = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; seqA, seqB;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            minimize(pref, f[i]);</span><br><span class="line">            <span class="keyword">if</span> (seqA.empty() || seqA.back() &gt; f[i])</span><br><span class="line">                seqA.push_back(f[i]), cosA += rev[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (seqB.empty() || seqB.back() &gt; f[i])</span><br><span class="line">                seqB.push_back(f[i]), cosB += rev[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                output, <span class="number">-1</span>, <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pref &gt; suf[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> sizA = (<span class="keyword">int</span>)seqA.size(),</span><br><span class="line">                    sizB = (<span class="keyword">int</span>)seqB.size();</span><br><span class="line">                ans += min(cosA + sizB - cosB, cosB + sizA - cosA);</span><br><span class="line">                cosA = cosB = <span class="number">0</span>;</span><br><span class="line">                seqA.clear(), seqB.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        output, ans, <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这甚至还是个 2-SAT 问题，，可以见得乱搞的方法有很多，只是我都不会罢了（</p><h2 id="后记">后记</h2><p>想到了昨天 zcysky 说过的：Div2 本身已经足够白给了；突然就再次的感觉到——不管是为了什么的努力，重要的是看到成效，而不仅仅是自虐地自我满足。说教别人警惕这种繁荣的幻想的同时，我自己不也是这样吗？</p><p>对于我这种起步晚，学习慢的残疾 ICPCer 而言，更应该是脚踏实地地讲究训练方法效率，做有用的事情才行啊（</p><figure><img src="https://i.loli.net/2021/04/11/kupnAj6r93Io4yK.jpg" class="lazyload" data-srcset="https://i.loli.net/2021/04/11/kupnAj6r93Io4yK.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="YJ_JI1_O_AZV2_HWPA_YQ.jpg" /><figcaption aria-hidden="true">YJ_JI1_O_AZV2_HWPA_YQ.jpg</figcaption></figure><p>唉，还是且行且珍惜——</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础知识：FFT - 简单入门</title>
      <link href="/2021/The-concept-of-fft-introducing-edition/"/>
      <url>/2021/The-concept-of-fft-introducing-edition/</url>
      
        <content type="html"><![CDATA[<p>一句话简介：FFT 即<strong>快速傅里叶变换</strong>，是一种可以在 <span class="math inline">\(n\log n\)</span> 的时间内完成多项式乘法的算法——的一部分。</p><h2 id="前置知识">前置知识</h2><p>在了解 FFT 之前，你可能需要先知道的一些东西：</p><h3 id="多项式">多项式</h3><p>对于数域 <span class="math inline">\(\mathbb{F}\)</span>，若有 <span class="math inline">\(\forall i\in\{1,2,3,\cdots,n \}\)</span>，则： <span class="math display">\[f(x)=a_0+a_1x+a_2x^2+\cdots+a_nx=\sum_{i=0}^n a_ix^i \ (a_n \neq 0)\]</span> 为数域 <span class="math inline">\(\mathbb{F}\)</span> 上的一个多项式；该多项式的次数即为其中最高次项的次数为 <span class="math inline">\(n\)</span>，记作 <span class="math inline">\(\deg f(x) = n\)</span>；</p><h4 id="表示方法">表示方法</h4><p>通常有两种表示方法</p><h5 id="系数表示法">系数表示法</h5><p>即上文定义中的表示方法，是一个向量；可以映射为系数向量 <span class="math inline">\(\vec{a}\)</span>： <span class="math display">\[f(x) = \sum_{i = 0}^n a_ix^i ⇔ \vec{a} = (a_0, a_1, \cdots ,a_n) \ (a_n \neq 0)\]</span> 我们将向量 <span class="math inline">\(\vec{a}\)</span> 成为多项式 <span class="math inline">\(f(x)\)</span> 的系数表示。</p><h5 id="点值表示法">点值表示法</h5><p>设 <span class="math inline">\(\deg f(x) = n\)</span>；众所周知，确定一个 <span class="math inline">\(n\)</span> 次函数的解析式，需要 <span class="math inline">\(n + 1\)</span> 个点的坐标；同理，这样也可以确定一个有 <span class="math inline">\(n + 1\)</span> 个系数的 <span class="math inline">\(n\)</span> 次多项式。</p><p>因此，对于 <span class="math inline">\(\forall x_i \in \mathbb{F}, i \in [0, n]\)</span>，有 <span class="math inline">\(y_i = f(x_i)\)</span>；如果对于 <span class="math inline">\(\forall i \neq j\)</span> 总是满足 <span class="math inline">\(x_i \neq x_j\)</span>，那么我们可以在数域 <span class="math inline">\(\mathbb{F}\)</span> 中绘制 <span class="math inline">\(n+1\)</span> 个点，获得 <span class="math inline">\(n+1\)</span> 个不同的方程，从而确定这个多项式；</p><p>那么，这 <span class="math inline">\(n + 1\)</span> 个不同的点构成的<strong>点集</strong>，就是多项式的点值表示。</p><p>如果将这 <span class="math inline">\(n + 1\)</span> 个不同的点代入表达式中进行运算，可以得到下面的矩阵等式： <span class="math display">\[\begin{bmatrix}    1 &amp; x_0 &amp; x_0^2 &amp; \cdots &amp; x_0^n \\    1 &amp; x_1 &amp; x_1^2 &amp; \cdots &amp; x_1^n \\    \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\    1 &amp; x_n &amp; x_n^2 &amp; \cdots &amp; x_n^n  \end{bmatrix}\begin{bmatrix}    a_0 \\ a_1 \\ \vdots \\ a_n\end{bmatrix}=\begin{bmatrix}    y_0 \\ y_1 \\ \vdots \\ y_n\end{bmatrix}\]</span> 我们将最左侧的 <span class="math inline">\(n + 1\)</span> 阶矩阵称为范德蒙矩阵。</p><hr /><p>那么如何转换多项式的两种表达方式呢？</p><ul><li><p>系数表达式 <code>=&gt;</code> 点值表达式</p><p>这个还是非常的简单的；只需要选取 <span class="math inline">\(n + 1\)</span> 个不同的 <span class="math inline">\(x_i\)</span>，分别带入解析式中求出 <span class="math inline">\(y_i\)</span> 即可。我们假定使用快速幂计算乘方，那么这样做的复杂度就是 <span class="math inline">\(O(n^2\log n)\)</span> 的。</p></li><li><p>点值表达式 <code>=&gt;</code> 系数表达式</p><p>这个过程又被称为<strong>多项式插值</strong>；朴素地，我们可以将多项式看作一个 <span class="math inline">\(n\)</span> 次函数，将点值表达中的 <span class="math inline">\(n + 1\)</span> 个点代入其中得到等数目的方程，然后求解这个方程组得到每个系数，组成系数表达式。</p><p>形式化地说，我们可以利用范德蒙矩阵进行高斯消元，就可以在 <span class="math inline">\(O(n^3)\)</span> 的时间内求解；但是这样实在是太慢了，时间上无法接受；因此我们也可以用拉格朗日插值法求解： <span class="math display">\[f(x) = \sum_{i = 1}^n y_i \prod_{i = j} \frac{x-x_j}{x_i-x_j}\]</span> 这样，我们可以在 <span class="math inline">\(O(n^2)\)</span> 的时间复杂度内完成多项式插值。</p></li></ul><p>虽然但是，我们可以看到想要在这两种形式中转化，一般会消耗大量的时间。</p><h4 id="操作">操作</h4><p>令参与操作的两个多项式为 <span class="math inline">\(f(x)\)</span> 和 <span class="math inline">\(g(x)\)</span>；若 <span class="math inline">\(\deg f(x) \neq \deg g(x)\)</span>，我们可以为其中度数较小的一方增加系数为 <span class="math inline">\(0\)</span> 的高次项，从而使得两个多项式齐次；因此，下面的讨论都仅针对于两个多项式齐次的情况。</p><p>此外，如果两个多项式均仅提供点值表示，那么要求提供的点值的横坐标一一对应且相等。</p><p>现在假定 <span class="math inline">\(\deg f(x) = \deg g(x) = n\)</span>，系数表示分别为 <span class="math inline">\(\vec{a}、\vec{b}\)</span>；</p><h5 id="加减法">加减法</h5><p>对于系数表示，若 <span class="math inline">\(h(x) = f(x) ± g(x)\)</span>，则有： <span class="math display">\[h(x) = f(x) ± g(x) = \sum_{i = 0}^n (a_i ± b_i)x^i\]</span> 且 <span class="math inline">\(h(x)\)</span> 的系数表示记为 <span class="math inline">\(\vec{c}\)</span>，那么 <span class="math inline">\(c_i = a_i ± b_i\)</span>；</p><p>对于点值表示，只需要将对应的纵坐标相加/相减即可。</p><h5 id="乘法卷积">乘法（卷积）</h5><p>同上，对于系数表示，可以得到多项式乘法的定义如下： <span class="math display">\[h(x) = (f \cdot g)(x) = f(x) \times g(x) = \sum_{i = 0}^n \sum_{j = 0}^n a_ib_jx^{i + j}\]</span> 显然，两个 <span class="math inline">\(n\)</span> 次的多项式相乘会得到一个 <span class="math inline">\(2n\)</span> 次的多项式；若 <span class="math inline">\(h(x)\)</span> 的系数表示记为 <span class="math inline">\(\vec{c}\)</span>，那么也有： <span class="math display">\[c_i= \sum_{j+k=i}a_jb_k = \sum_{j = i}^{n} a_jb_{i - j}\]</span> 那么系数向量 <span class="math inline">\(\vec{c}\)</span> 为稀疏向量 <span class="math inline">\(\vec{a}、\vec{b}\)</span> 的卷积，记作：<span class="math inline">\(\vec{c} = \vec{a} ∗ \vec{b}\)</span>；</p><p>对于点值表示，依然只需要将对应的纵坐标相乘即可；但是因为新得到的多项式次数更高，所以每个因子多项式都需要提供 <span class="math inline">\(2n\)</span> 个点参与运算；</p><hr /><p>综上所述，我们可以看到：因为多项式运算本质上还是多项式的值进行运算，所以对于点值表示法而言，这些运算都是可以 <span class="math inline">\(O(n)\)</span> 完成的（即仅将对应点值的纵坐标进行运算即可）；唯一需要注意的就是多项式乘法，点值表示法需要提供更多组点值进行运算。</p><h3 id="复数">复数</h3><p><del>高 等 数 学 和 复 变 函 数 的 完 全 败 北</del></p><p>首先定义虚数单位 <span class="math inline">\(i^2 = -1\)</span>；则所有形如： <span class="math display">\[z = a + bi, \ \ a,b \in \mathbb{R}\]</span> 的数字为复数，它们构成的集合成为复数集，记为 <span class="math inline">\(\mathbb{C}\)</span>；上面的表达式中，<span class="math inline">\(a\)</span> 被称为实部，<span class="math inline">\(b\)</span> 被称为虚部。</p><h4 id="复平面">复平面</h4><p>复平面是一个笛卡尔平面，有两条坐标轴，纵轴为虚轴，横轴为实轴，两轴相互垂直；对于每一个复数 <span class="math inline">\(z = a + bi\)</span>，它都可以在复平面上被表示为一个从原点指向点 <span class="math inline">\((a, b)\)</span> 的<strong>向量</strong>；显然，复数和复平面上从原点出发的向量之间的映射关系是双射。</p><p>和一般向量一样，以实轴正方向为始，<span class="math inline">\(\vec{z}\)</span> 为终的角 <span class="math inline">\(\theta\)</span> 称为复数 <span class="math inline">\(z\)</span> 的<strong>幅角</strong>。</p><h4 id="基本操作">基本操作</h4><ul><li>模：即复数在复平面上所对应的向量的模，记作 <span class="math inline">\(|z|\)</span>；<span class="math inline">\(|z| = \sqrt {a^2 + b^2}\)</span></li><li>共轭复数：复数在复平面上所对应的向量关于实轴对称后对应的复数，记为 <span class="math inline">\(\bar{z}\)</span>；<ul><li><span class="math inline">\(z\)</span> 和 <span class="math inline">\(\bar{z}\)</span> 的实部相同，虚部互为相反数</li><li>两者的幅角满足：<span class="math inline">\(\theta_{z} + \theta_{\bar{z}} = \pi\)</span></li><li>两者的模满足：<span class="math inline">\(|z| = |\bar{z}|\)</span></li></ul></li></ul><h4 id="运算">运算</h4><p>令参与运算的两个复数为 <span class="math inline">\(z_1 = a_1 + b_1i\)</span> 和 <span class="math inline">\(z_2 = a_2 + b_2i\)</span>；</p><ul><li><p>加减法：<span class="math inline">\(z = z_1 ± z_2\)</span></p><ul><li><span class="math inline">\(z = (a_1 ± a_2) + (b_1 ± b_2)i\)</span></li><li>对于向量：按照平行四边形定则</li></ul></li><li><p>乘法：<span class="math inline">\(z = z_1 \times z_2\)</span></p><ul><li><p>$z = (a_1 + b_1i) (a_2 + b_2i) = $ <span class="math inline">\((a_1a_2 - b_1b_2) + (a_1b_2 + a_2b_1)i\)</span></p></li><li><p>对于向量：它们的幅角满足 <span class="math inline">\(\theta_z = \theta_{z_1} + \theta_{z_2}\)</span></p></li><li><p>对于向量：它们的模满足 <span class="math inline">\(|z| = |z_1| \times|z_2|\)</span></p></li><li><p>若 <span class="math inline">\(z_2 = \bar{z_1}\)</span>，那么 <span class="math inline">\(z = a_1^2 + b_1^2\)</span>，显然是一个实数</p></li></ul></li><li><p>除法：<span class="math inline">\(z = \frac{z_1}{z_2}\)</span></p><ul><li>通分 <span class="math inline">\(\bar{z_2}\)</span>，可以得到：<span class="math inline">\(z = \frac{z_1\bar{z_2}}{a_2^2 + b_2^2}\)</span></li><li>显然，分母是实数，所以可以直接除进分子的实部和虚部</li></ul></li><li><p>指数幂：首先，有<strong>欧拉公式</strong> <span class="math inline">\(e^{i\theta} = \cos\theta + i\sin\theta\)</span></p><ul><li><blockquote><p>在数学分析和复变函数中，欧拉公式是一个把复指数函数与三角函数联系起来的一个公式： <span class="math display">\[e^{i\theta} = \cos\theta + i\sin\theta\]</span> 这个恒等式就是欧拉公式，它是数学里最令人着迷的一个公式——它将数学里最重要的几个数字联系到了一起：</p><ul><li>两个超越数：自然对数的底 <span class="math inline">\(e\)</span>，圆周率 <span class="math inline">\(\pi\)</span>；</li><li>两个单位：虚数单位 <span class="math inline">\(i\)</span> 和自然数的单位 <span class="math inline">\(1\)</span> ；</li><li>以及被称为人类伟大发现之一的 <span class="math inline">\(0\)</span>。</li></ul><p>它将指数函数的定义域扩大到复数，建立了三角函数和指数函数的关系，被誉为“数学中的天桥”。因此数学家们评价它是“上帝创造的公式”。</p></blockquote></li><li><p>任何复数都可以表示为欧拉公式的形式，即： <span class="math display">\[z = |z|\cos\theta_z + i|z|\sin\theta_z = |z|e^{i\theta_z}\]</span></p></li><li><p>特殊值：当 <span class="math inline">\(\theta = \pi\)</span> 时，有 <span class="math inline">\(e^{i\pi} = -1\)</span></p></li><li><p>因此，复数的幂只需要将它转化为欧拉公式的形式，然后取幂即可</p></li></ul></li></ul><p>和多项式一样，复数的运算也需要根据不同的运算在不同的表示形式中反复切换。</p><h3 id="单位根">单位根</h3><p>在 <span class="math inline">\(\mathbb{C}\)</span> 中，满足 <span class="math inline">\(x^n = 1\)</span> 的 <span class="math inline">\(x\)</span> 被称为 <strong><span class="math inline">\(n\)</span> 次单位根</strong>；根据<a href="https://baike.baidu.com/item/%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86/18104">代数基本定理</a>可知，<span class="math inline">\(n\)</span> 次单位根共有 <span class="math inline">\(n\)</span> 个，它们分别是： <span class="math display">\[x_k = e^{i\frac{2k\pi}{n}}, \ k \in [0, n)\]</span> 显然，<span class="math inline">\(x_k^n = 1\)</span>；可以用上一节讲到的欧拉公式来证明。</p><h4 id="性质">性质</h4><p>因为 <span class="math inline">\(\sin\theta + \cos\theta = 1\)</span>，所有的 <span class="math inline">\(n\)</span> 次单位根的模均为 <span class="math inline">\(1\)</span>.</p><p>在复平面上，<span class="math inline">\(n\)</span> 个 <span class="math inline">\(n\)</span> 次单位根平分了单位圆，且和单位圆的 <span class="math inline">\(n\)</span>-等分线重叠。</p><h4 id="本原单位根">本原单位根</h4><p>定义：<span class="math inline">\(0\)</span> 到 <span class="math inline">\((n - 1)\)</span> 次幂的值能生成全部 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(n\)</span> 次单位根的 <span class="math inline">\(n\)</span> 次单位根称为为 <span class="math inline">\(n\)</span> 次本原单位根。</p><p>显然，对于任何 <span class="math inline">\(n &gt; 1\)</span>，<span class="math inline">\(x_1 = e^{i\frac{2\pi}{n}}\)</span> 是一个 <span class="math inline">\(n\)</span> 次本原单位根。</p><p>特别地，我们记 <span class="math inline">\(\omega_n = e^{i \frac{2\pi}{n}} = \cos \frac{2\pi}{n} + i \sin \frac{2\pi}{n}\)</span> 为 <span class="math inline">\(n\)</span> 次本原单位根；虽然它未必唯一，但是接下来的所有讨论中的“<span class="math inline">\(n\)</span> 次本原单位根”都特指 <span class="math inline">\(\omega_n\)</span>。</p><p><span class="math inline">\(n\)</span> 次本原单位根 <span class="math inline">\(\omega_n\)</span> 有一些特殊的运算性质：</p><ul><li><p>折半定理：<span class="math inline">\((\omega_n^k)^2 = \omega_{\frac{n}2}^k\)</span></p></li><li><p>令 <span class="math inline">\(n\)</span> 为偶数：<span class="math inline">\(\omega_n^{\frac{n}2 + k} = -\omega_n^k\)</span></p></li><li><p>相消定理：<span class="math inline">\(\omega_{dn}^{dk} = \omega_n^k\)</span></p></li><li><p>求和定理：可以描述为如下公式：</p><p><span class="math display">\[\sum_{i = 0}^{n - 1} (\omega_n^k)^i = \begin{cases}0, \ \ &amp; k \neq mn \ , \ m \in \mathbb{Z} \\n, \ \ &amp; k = mn \ , \ m \in \mathbb{Z}\end{cases}\]</span> 在 <span class="math inline">\(k \neq mn\)</span> 的场合下，由于公比不为 <span class="math inline">\(1\)</span>，我们可以用等比数列的求和公式推导： <span class="math display">\[\sum_{i = 0}^{n - 1} (\omega_n^k)^i = \frac{1 - (\omega_n^k)^n}{1 - \omega_n^k} = \frac{1 - 1}{1 - \omega_n^k} = 0\]</span> 否则，公比为 <span class="math inline">\(\omega_n^k = 1\)</span>，上述推导并不成立；但由于 <span class="math inline">\(\omega_n^n = \omega_n^0 = 1\)</span>，所以上计算结果为 <span class="math inline">\(n\)</span>；</p></li></ul><p>显然，第一个式子是成立的：每份角度扩大一倍，那么可以等分的份数就减为一半，这很合理；</p><p>显然，<span class="math inline">\(\omega_n^{\frac{n}2}\)</span> 的幅角是 <span class="math inline">\(\pi\)</span>；由和差角公式可以知道幅角加上 <span class="math inline">\(\pi\)</span> 意味着正弦和余弦值都变为原来的相反数，所以第二个式子也非常的正确；证毕（</p><p>相消定理也非常的好理解：两边的表达式转化为欧拉公式的形式是一样的。</p><p><del>不会有人真的连高中数学学的三角函数相关变换的忘记了吧？不会这人就是我吧？</del></p><hr /><p>到现在为止，我们已经把必要的前置知识<del>数学基础</del>给介绍完了。</p><h2 id="分析过程">分析过程</h2><p>根据上面的描述，我们已经知道了对于多项式的系数表示，计算其乘法需要 <span class="math inline">\(O(n^2)\)</span> 的时间；而对于点值表示法，这个运算只需要 <span class="math inline">\(O(n)\)</span> 的时间；但是如果我们想要通过两个多项式的系数表示得到它们乘积的系数表示，我们需要遵循以下的步骤：</p><ul><li><strong>求值</strong>：将待乘的多项式转化为点值表示，需要 <span class="math inline">\(O(n^2)\)</span></li><li><strong>运算</strong>：点值表示多项式乘法，需要 <span class="math inline">\(O(n)\)</span></li><li><strong>插值</strong>：将得到的结果转化为系数表示，朴素算法需要 <span class="math inline">\(O(n^3)\)</span>，不低于 <span class="math inline">\(O(n^2)\)</span></li></ul><p>可以看出，如果仅是将多项式转化为点值表示，并不能做到算法复杂度的降低——但是它为我们提供了思路：如果我们能将求值和插值步骤优化到低于 <span class="math inline">\(O(n^2)\)</span>，就可以降低多项式乘法的整体复杂度。</p><h3 id="离散傅里叶变换">离散傅里叶变换</h3><p>特别地，现在对上面的步骤进行一些定义：</p><ul><li><strong>离散傅里叶变换（DFT）</strong>：指求出一个 <span class="math inline">\(n - 1\)</span> 次多项式在每个 <span class="math inline">\(n\)</span> 次单位根下的点值的过程</li><li><strong>离散傅里叶逆变换（IDFT）</strong>：将上面求出的那些点值重新插值得到系数表示的过程</li></ul><p>对于多项式 <span class="math inline">\(f(x)\)</span>，若 <span class="math inline">\(\deg f(x) = n - 1\)</span>，那么对它进行的 DFT 被称为长度为 <span class="math inline">\(n\)</span> 的离散傅里叶变换，记作 <span class="math inline">\(\text{DFT}_n(f)\)</span>。</p><p>显然，这个操作就是朴素做法，具有 <span class="math inline">\(O(n^2)\)</span> 的时间复杂度；现在我们考虑使用 FFT 优化它。</p><h3 id="快速傅里叶变换">快速傅里叶变换</h3><p>现在，我们假设 <span class="math inline">\(n\)</span> 是偶数，且有 <span class="math inline">\(m = \frac{n}2\)</span>；有多项式 <span class="math inline">\(f(x) = \sum_{i = 0}^{n - 1} a_ix^i\)</span>，显然 <span class="math inline">\(\deg f(x) = n - 1\)</span>；</p><h4 id="分治">分治</h4><p>考虑分治：我们对 <span class="math inline">\(f(x)\)</span> 的系数角标按照奇偶性进行分类，可以得到： <span class="math display">\[\begin{align}f(x) &amp;= \sum_{i = 0}^{m - 1} a_{2i}x^{2i} + \sum_{i = 0}^{m - 1} a_{2i+1}x^{2i+1} \\     &amp;= \sum_{i = 0}^{m - 1} a_{2i}x^{2i} + x(\sum_{i = 0}^{m - 1} a_{2i+1}x^{2i}) \\     &amp;= \sum_{i = 0}^{m - 1} a_{2i}(x^2)^i + x(\sum_{i = 0}^{m - 1} a_{2i+1}(x^2)^i)\end{align}\]</span> 我们对于前半部分（偶数部分）记作 <span class="math inline">\(f_0(x)\)</span>，后半部分（奇数部分）记为 <span class="math inline">\(f_1(x)\)</span>： <span class="math display">\[\begin{align}    f_0(x) &amp;= \sum_{i = 0}^{m - 1} a_{2i}x^i \\    f_1(x) &amp;= \sum_{i = 0}^{m - 1} a_{2i + 1}x^i \\\end{align}\]</span> 那么，<span class="math inline">\(f(x)\)</span> 可以被表示为如下形式： <span class="math display">\[f(x) = f_0(x^2) + x \cdot f_1(x^2)\]</span> 如果知道了 <span class="math inline">\(f_0(x)\)</span> 和 <span class="math inline">\(f_1(x)\)</span> 在 <span class="math inline">\(n\)</span> 个不同的位置的值，那么我们只需要计算 <span class="math inline">\(O(n)\)</span> 次上式，就可以得到 <span class="math inline">\(f(x)\)</span> 的点值表示了；然后可以继续递归处理 <span class="math inline">\(f_{0/1}\)</span>；</p><p>但是仅仅是这压根是不够的；根据主定理，因为 <span class="math inline">\(f_{0/1}\)</span> 各需要递归一次，所以复杂度还是 <span class="math inline">\(O(n^2)\)</span> 的。</p><h4 id="使用单位根">使用单位根</h4><p>因此，我们考虑代入单位根求 <span class="math inline">\(\text{DFT}_n(f)\)</span>。根据单位根的性质，我们知道了 <span class="math inline">\(\omega_n^{m + k} = -\omega_n^k\)</span>：这提示我们需要考虑小于 <span class="math inline">\(m\)</span> 次的点值和大于等于 <span class="math inline">\(m\)</span> 次的点值之间存在的关系；因此我们以此进行分类讨论：</p><p>对于 <span class="math inline">\(k \in [0, m)\)</span>，我们可以利用单位根的折半定理进行简化，有： <span class="math display">\[\begin{align}f(\omega_n^k) &amp;= f_0((\omega_n^k)^2) + \omega_n^k \cdot f_1((\omega_n^k)^2) \\              &amp;= f_0(\omega_m^k) + \omega_n^k \cdot f_1(\omega_m^k)\end{align}\]</span> 在考虑 <span class="math inline">\(k + m \in [m, n)\)</span>，我们同样可以利用单位根的性质得到下面的化简： <span class="math display">\[\begin{align}f(\omega_n^{k + m}) &amp;= f_0((\omega_n^{k + m})^2) + \omega_n^{k + m} \cdot f_1((\omega_n^{k + m})^2) \\                    &amp;= f_0((-\omega_n^k)^2) - \omega_n^k \cdot f_1((-\omega_n^k)^2) \\                    &amp;= f_0((\omega_n^k)^2) - \omega_n^k \cdot f_1((\omega_n^k)^2) \\                    &amp;= f_0(\omega_m^k) - \omega_n^k \cdot f_1(\omega_m^k)\end{align}\]</span> 上面的两个式子又被称为<strong>蝴蝶操作</strong>，式子中的 <span class="math inline">\(\omega_n^k\)</span> 又被称为旋转因子；</p><p>至于叫“蝴蝶操作”这个名字的原因，现在我们可以考虑两层：一层是我们将要求的 <span class="math inline">\(f(x)\)</span>，它的 DFT 长度为 <span class="math inline">\(n\)</span>；另一层是我们已经求好的（或者将要递归去求的）<span class="math inline">\(f_{0/1}(x)\)</span>，它们的 DFT 长度均为 <span class="math inline">\(m\)</span>；对于 <span class="math inline">\(f_{0/1}(\omega_m^k)\)</span>，它们能影响到的位置只有 <span class="math inline">\(f(\omega_n^k)\)</span> 和 <span class="math inline">\(f(\omega_n^{k + m})\)</span>；所以可以画出下面的图：</p><figure><img src="https://i.loli.net/2021/03/30/7OEYgBQdZq4jeyR.jpg" class="lazyload" data-srcset="https://i.loli.net/2021/03/30/7OEYgBQdZq4jeyR.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="要不是不会画矢量图，谁愿意iPad手画呢？" /><figcaption aria-hidden="true">要不是不会画矢量图，谁愿意iPad手画呢？</figcaption></figure><p>图中实边贡献的权值为 +1，虚边的权值是 -1；结合推导的式子很容易理解，形状也许确实是蝴蝶（</p><p>综上所述，我们可以发现：<span class="math inline">\(k \geq m\)</span> 部分的值可以在求 <span class="math inline">\(k &lt; m\)</span> 部分的值时一并求出；因此，只要知道了<span class="math inline">\(f_0(x)\)</span> 和 <span class="math inline">\(f_1(x)\)</span> 在小于 <span class="math inline">\(m\)</span> 次位置的值（显然，这是 <span class="math inline">\(m = \frac{n}2\)</span> 次），就可以在 <span class="math inline">\(O(n)\)</span> 的时间内求出 <span class="math inline">\(f(x)\)</span> 在整全部 <span class="math inline">\(n\)</span> 个位置的值；显然，和朴素做法一样，这个过程也是递归的。</p><p>分析算法的时间复杂度：<span class="math inline">\(T(n) = T(\frac{n}2) + O(n)\)</span>，典型的 <span class="math inline">\(O(n\log n)\)</span>；</p><p>综上所述，得到的快速计算 <span class="math inline">\(\text{DFT}_n(f)\)</span> 的方法，就被称为 FFT。</p><h3 id="插值方法">插值方法</h3><p>在上一个部分，我们已经将朴素求值的过程用 FFT 取代，获得了更优的时间复杂度；但是朴素插值的过程仍然是 <span class="math inline">\(O(n^2)\)</span> 的；这个部分将说明朴素 IDFT 的过程，并尝试压缩它的时间复杂度。</p><h4 id="离散傅里叶逆变换">离散傅里叶逆变换</h4><blockquote><h5 id="问题">问题</h5><p>有 <span class="math inline">\(\deg f(x) = n - 1\)</span> 的多项式 <span class="math inline">\(f(x)\)</span> ；已知其点值表示 <span class="math inline">\(\{(x_k, \ y_k) \ | \ k \in [0, n)\}\)</span>；其中： <span class="math display">\[\text{DFT:} \ \ y_k = \sum_{i = 0}^{n - 1} a_ix_i \ , \ x_i = \omega_n^{ik}\]</span> 现在我们要从这个点集反向求出 <span class="math inline">\(f(x)\)</span> 的系数表示 <span class="math inline">\(\vec{a}\)</span>。</p></blockquote><p>至于这个问题的推导结果，<del>因为我不会推导</del>我们先给出它的结论： <span class="math display">\[\text{IDFT:} \ \ a_k = \frac1n \sum_{i = 0}^{n - 1}y_i\omega_n^{-ki}\]</span> 然后我们进行反向推导，来证明它确实是 <span class="math inline">\(\text{DFT}\)</span> 式子的逆变换：</p><ul><li><p>将 <span class="math inline">\(\text{IDFT}\)</span> 式子中的 <span class="math inline">\(y_i\)</span> 展开为 <span class="math inline">\(\text{DFT}\)</span> 式： <span class="math display">\[\begin{align}a_k = \frac1n \sum_{i = 0}^{n - 1}y_i\omega_n^{-ki} &amp;= \frac1n \sum_{i = 0}^{n - 1}\sum_{j = 0}^{n - 1} a_j\omega_n^{ji}\omega_n^{-ki} \\&amp;= \frac1n \sum_{i = 0}^{n - 1}\sum_{j = 0}^{n - 1} a_j\omega_n^{i(j - k)} \\&amp;= \frac1n \sum_{j = 0}^{n - 1} a_j\sum_{i = 0}^{n - 1}(\omega_n^{j - k})^i\end{align}\]</span></p></li><li><p>现在我们使用单位根的求和定理来考虑等式右侧的 <span class="math inline">\(\sum_{i = 0}^{n - 1}(\omega_n^{j - k})^i\)</span>：</p><ul><li><p><span class="math inline">\(j = k\)</span> 时，<span class="math inline">\(\omega_n^{i(j - k)} = \omega_n^0 = 1\)</span>，故： <span class="math display">\[\sum_{i = 0}^{n - 1}(\omega_n^{j - k})^i = 1 \times n = n\]</span></p></li><li><p><span class="math inline">\(j \neq k\)</span> 时，由求和定理可知： <span class="math display">\[\sum_{i = 0}^{n - 1}(\omega_n^{j - k})^i = 0\]</span> 既可以使用消去定理，也可以使用单位根的定义得到这个值为 0；</p></li><li><p>综上所述，仅当 <span class="math inline">\(j = k\)</span> 时，外侧的求和会对结果产生 <span class="math inline">\(n\)</span> 倍的贡献。</p></li></ul></li><li><p>因此，我们可以继续推导第一步我们得到的式子： <span class="math display">\[\begin{align}a_k = \frac1n \sum_{i = 0}^{n - 1}y_i\omega_n^{-ki} &amp;= \frac1n \sum_{j = 0}^{n - 1} a_j\sum_{i = 0}^{n - 1}(\omega_n^{j - k})^i \\&amp;= \frac1n a_k \times n\end{align}\]</span> 显然，等式的两侧是相等的。</p></li></ul><p>所以，我们证明了提供的结论确实是 <span class="math inline">\(\text{DFA}\)</span> 的逆变换。</p><p>如果愿意，也可以把式子写成矩阵的形式，然后对对应的矩阵求逆，也能得到这个结果。</p><p>分析这种做法的复杂度：对于每一个 <span class="math inline">\(k \in [0, n)\)</span> 我们都需要 <span class="math inline">\(O(n)\)</span> 的时间去求出等式右侧的求和；所以 <span class="math inline">\(\text{IDFT}\)</span> 公式的复杂度毫无疑问也是 <span class="math inline">\(O(n^2)\)</span> 的。</p><h4 id="快速傅里叶逆变换">快速傅里叶逆变换</h4><p>那么现在，我们就要考虑如何在更短的复杂度下求解 IDFT。显然 IDFT 公式也是一个多项式，我们定义： <span class="math display">\[a_k = F(x_k) = \frac1n \sum_{i = 0}^{n - 1}y_ix_k^i, \ \ x_k = \omega_n^{-k}\]</span> 在回忆一下我们前面刚推到完的 FFT： <span class="math display">\[y_k = f(x_k) = \sum_{i = 0}^{n - 1}a_ix_k^i, \ \ x_k = \omega_n^k\]</span> 我们就会发现它们出奇的相似！（好吧，我也是推到这一步才豁然开朗，，只能说我确实把复变函数的一些知识忘得精光，完全的不掌握了把）；<span class="math inline">\(\omega_n^k\)</span> 和 <span class="math inline">\(\omega_n^{-k}\)</span> 很显然是一对共轭复数——在复平面的角度来看它们只是幅角的旋转方向不同，实际上还是一一对应的；所以我们完全可以把 FFT 的方法拿到这里来，求出 <span class="math inline">\(F(x)\)</span> 在 <span class="math inline">\(\omega_n\)</span> 不同幂下的值之后，翻转结果就可以得到答案（<span class="math inline">\(\omega_n^{-k} = \omega_n^{n-k}\)</span>）。</p><p><del>是不是突然有些明白了在蝴蝶操作中 <span class="math inline">\(\omega_n^k\)</span> 被称为旋转因子的原因了（</del></p><p>综上所述，FFT + 事后翻转 = <span class="math inline">\(\text{IFFT}\)</span>；这就是快速傅里叶逆变换插值，时间复杂度显然是 <span class="math inline">\(O(n\log n)\)</span>。</p><hr /><p>综上所述，我们使用 <span class="math inline">\(\text{FFT}\)</span> 和 <span class="math inline">\(\text{IFFT}\)</span> 取代求值和插值步骤朴素的 <span class="math inline">\(\text{DFT}\)</span> 和 <span class="math inline">\(\text{IDFT}\)</span> 算法，就可以把多项式的点值表达和系数表达之间的互相转化的复杂度从 <span class="math inline">\(O(n^2)\)</span> 降为 <span class="math inline">\(O(n\log n)\)</span>，从而得到了一个总体复杂度为 <span class="math inline">\(O(n\log n)\)</span> 的多项式乘法的算法。</p><p>所以严格上来说，快速的多项式乘法算法并不是 FFT；FFT 只是其中非常重要的组成部分罢了。</p><h2 id="算法实现">算法实现</h2><p>好了，你已经学会了 FFT 了！快上！（指上机写代码</p><h3 id="朴素的递归实现">朴素的递归实现</h3><p>然后我们就写出了像上面说的那样的递归 FFT：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">complex</span> <span class="title">getW</span><span class="params">(uint n, uint k = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> angle = (k % n) * PI * <span class="number">2</span> / n;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(<span class="built_in">cos</span>(angle), <span class="built_in">sin</span>(angle));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subprocess</span><span class="params">(addr f, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> m = n / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">complex</span>&gt; &amp;sub = _alloc(n);</span><br><span class="line">    <span class="keyword">auto</span> f0 = sub.begin(), f1 = f0 + m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i)</span><br><span class="line">        f0[i] = f[i * <span class="number">2</span>],</span><br><span class="line">        f1[i] = f[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    subprocess(f0, m);</span><br><span class="line">    subprocess(f1, m);</span><br><span class="line">    <span class="keyword">auto</span> unit = getW(n), w = getW(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i)</span><br><span class="line">        f[i] = f0[i] + w * f1[i],</span><br><span class="line">        f[i + m] = f0[i] - w * f1[i],</span><br><span class="line">        w *= unit;</span><br><span class="line">    _free_mem_stack_frame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是最核心的递归过程；一些包装的函数在下面：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">complex</span>&gt; &amp;p, <span class="keyword">bool</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    subprocess(p.begin(), p.size());</span><br><span class="line">    <span class="keyword">if</span> (inv) reverse(++ p.begin(), p.end());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">complex</span>&gt; &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;start(p, <span class="literal">false</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ifft</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">complex</span>&gt; &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    start(p, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> n = p.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : p) _post_ifft(i, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是系数表达变点值表达，只需要开始递归即可；反之，在得到结果之后还需要进行后处理：首先将答案数组的 <span class="math inline">\([1, N - 1]\)</span> 位置翻转（因为 <span class="math inline">\(\omega_n^0 = \omega_n^n\)</span>，所以交换的是 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(n - 1\)</span> 的位置），然后根据推导的表达式，我们还要对每个位置都除 <span class="math inline">\(N\)</span>；需要注意的是这一步也会引入误差，需要 <code>round</code>。</p><hr /><p>然后我们再为它添加一些头和尾的代码，用来去做模板题检验正确性：<a href="https://www.luogu.com.cn/problem/P3803">【模板】多项式乘法（FFT）</a>；增加的代码就像下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n = scanner.nextInt(),</span><br><span class="line">        m = scanner.nextInt();</span><br><span class="line">    <span class="built_in">vector</span>&lt;FFT::<span class="built_in">complex</span>&gt; a, b;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> siz = FFT::stretch(n + m);</span><br><span class="line">    a.resize(siz), b.resize(siz);</span><br><span class="line">    FFT::init_mem_pool(siz);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">        a[i].real(scanner.nextInt());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i)</span><br><span class="line">        b[i].real(scanner.nextInt());</span><br><span class="line">    FFT::fft(a), FFT::fft(b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; siz; ++ i)</span><br><span class="line">        a[i] *= b[i];</span><br><span class="line">    FFT::ifft(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + m; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)a[i].real() &lt;&lt; <span class="string">&quot; \n&quot;</span>[n + m == i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后交上去就会发现…… A 了？和别人博客里说的不一样啊？</p><figure><img src="https://i.loli.net/2021/03/30/8GPRMhTuwJ24Cq6.png" class="lazyload" data-srcset="https://i.loli.net/2021/03/30/8GPRMhTuwJ24Cq6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="_SPHGR0A___IYE3_WVFES_3.png" /><figcaption aria-hidden="true">_SPHGR0A___IYE3_WVFES_3.png</figcaption></figure><p>实际上是因为递归带来的较大的常数开销，很大一部分都来自于每层递归重复开辟内存空间用来做分治；因此，我写的时候就使用了一个内存池来处理递归中带来的内存分配和释放，就可以有效的降低它的常数。</p><p>当然，这种做法还是不够快的；所以我们还要对它继续优化。</p><h3 id="优化迭代实现">优化迭代实现</h3><p>因为递归是从上到下的过程，那么我们的迭代实现就是一个从下而上的一个过程。</p><p>我们把长度为 <span class="math inline">\(8\)</span> 的情况下，上述朴素的递归做法的调用树画出来，如下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Layer 1:   0 1 2 3 4 5 6 7</span><br><span class="line">  &#x2F;  \</span><br><span class="line">Layer 2:   0 2 4 6   1 3 5 7</span><br><span class="line">  &#x2F;  \  &#x2F;  \</span><br><span class="line">Layer 3: 0 4 2 6 1 5 3 7</span><br><span class="line"> &#x2F; \  &#x2F; \ &#x2F; \ &#x2F; \</span><br><span class="line">Layer 4:04261537</span><br></pre></td></tr></table></figure><p>当然，只看这个我们什么也看不出来；现在我们将焦点集中在最后一层上，并将它们的二进制和二进制反转以及二进制反转后得到的数字写出来，如下表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Layer 4:04261537</span><br><span class="line">Binary:000 100 010 110 001 101 011 111</span><br><span class="line">Reverse:000 001 010 011 100 101 110 111</span><br><span class="line">Decimal:01234567</span><br></pre></td></tr></table></figure><p>可以看出最后一层经过一番操作之后就变成了最开始的数组。因此，我们只需要在最开始的数组上进行这样的一番操作，就可以得到最后一层的这个新的数组，同时第一次合并也只是对相邻的位置进行合并。那么这样上面那几层就可以这样一直合并上去得到最终的数组了。</p><p>那么我们要怎么样快速的进行这一波神秘操作呢？现在我们考虑反转后的二进制表示（<span class="math inline">\(1, 2, \dots,2^k-1\)</span>），我们可以按照这样的顺序构造出这个序列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">round 1:(1)001(0)000</span><br><span class="line">round 2:(3)011(2)010(1)001(0)000</span><br><span class="line">round 3:...(6)110(5)101(4)100(3)011(2)010(1)001(0)000</span><br></pre></td></tr></table></figure><p>第一轮，所有的位都是 <code>0</code>；第一个位置是 <code>0</code> 已经满足了要求；我们选择最低位，放置 <code>1</code>，得到了序列 <code>0, 1</code>；第二轮，已经有满足要求的序列长度 2，我们选择次低位，将这一位置 <code>1</code>，那么又可以填两个数字，这两个数字的相对位置就和最开始满足要求的序列那样…… 最终，重复 <code>n</code> 次就可以构造出 <span class="math inline">\(0,\dots,2^k-1\)</span> 的序列。</p><p>那么我们现在构造的是二进制反向的序列，那么只需要从高位开始，重复这个过程就可以了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;uint&gt; &amp;<span class="title">reverse</span><span class="params">(uint length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">vector</span>&lt;uint&gt; <span class="title">rev</span><span class="params">(length)</span></span>;</span><br><span class="line">    uint msk = length &gt;&gt; <span class="number">1u</span>, i = <span class="number">0</span>;</span><br><span class="line">    rev[i ++] = <span class="number">0</span>, rev[i ++] = msk;</span><br><span class="line">    <span class="keyword">for</span> (uint w = <span class="number">2</span>; w &lt; length; w &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        msk &gt;&gt;= <span class="number">1u</span>;</span><br><span class="line">        <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; w; ++ j)</span><br><span class="line">            rev[i ++] = rev[j] | msk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的数组是关于原数组的一个排序。我们只需要利用这个排列进行<strong>位逆序置换</strong>——因为每一个 <code>i</code> 和 <code>rev[i]</code> 都是一一对应的，它们本是有序的，那么只要交换所有逆序的对，就可以得到适用迭代的数组。</p><p>计算在 <span class="math inline">\(n\)</span> 次单位根的各幂次点值的时候，令 <span class="math inline">\(m=\frac{n}2\)</span>，那么 <span class="math inline">\(f_0\)</span> 和 <span class="math inline">\(f_1\)</span> 已经由下层（迭代意义上的上层）计算并储存在 <span class="math inline">\(A[k]\)</span> 和 <span class="math inline">\(A[k+m]\)</span> 处，只需取出来计算后更新对应的值就完成了一层的迭代。到此，我们已经完成了对迭代优化的实现的过程描述，核心代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">complex</span>&gt; &amp;p, <span class="keyword">bool</span> inv)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> siz = p.size();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> rev = reverse(siz);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; siz; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (rev[i] &gt; i) swap(p[rev[i]], p[i]);</span><br><span class="line">        <span class="keyword">for</span> (uint n = <span class="number">2</span>, m = <span class="number">1</span>; n &lt;= siz; m = n, n &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> unit = get_w(n), w = get_w(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (uint l = <span class="number">0</span>, r = n - <span class="number">1</span>; r &lt;= siz; l += n, r += n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">complex</span> w0 = w, d, tmp0, tmp1;</span><br><span class="line">                <span class="keyword">for</span> (uint i = l, lim = l + m; i &lt; lim; ++ i)</span><br><span class="line">                    d = w0 * p[i + m], tmp0 = p[i] + d, tmp1 = p[i] - d,</span><br><span class="line">                    p[i] = tmp0, p[i + m] = tmp1, w0 *= unit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (inv) reverse(++ p.begin(), p.end());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样也可以通过上面的那个模板题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="comment">//  freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n = scanner.nextInt(),</span><br><span class="line">        m = scanner.nextInt();</span><br><span class="line">    <span class="built_in">vector</span>&lt;FFT2::<span class="built_in">complex</span>&gt; a, b;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> siz = FFT2::stretch(n + m);</span><br><span class="line">    a.resize(siz), b.resize(siz);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">        a[i].real(scanner.nextInt());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i)</span><br><span class="line">        b[i].real(scanner.nextInt());</span><br><span class="line">    FFT2::fft(a), FFT2::fft(b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; siz; ++ i)</span><br><span class="line">        a[i] *= b[i];</span><br><span class="line">    FFT2::ifft(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + m; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)a[i].real() &lt;&lt; <span class="string">&quot; \n&quot;</span>[n + m == i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，FFT 就简要的介绍完了。</p><h2 id="参考资料">参考资料</h2><ul><li><a href="https://blog.csdn.net/alpha202/article/details/90737497" class="uri">https://blog.csdn.net/alpha202/article/details/90737497</a></li><li><a href="https://www.luogu.com.cn/blog/fusu2333/solution-p3803" class="uri">https://www.luogu.com.cn/blog/fusu2333/solution-p3803</a></li><li><a href="https://blog.csdn.net/waduan2/article/details/79529900" class="uri">https://blog.csdn.net/waduan2/article/details/79529900</a></li><li><a href="https://blog.csdn.net/qq_38944163/article/details/81835205" class="uri">https://blog.csdn.net/qq_38944163/article/details/81835205</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round#710 div.3 回顾</title>
      <link href="/2021/codeforces-round-710-div3/"/>
      <url>/2021/codeforces-round-710-div3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>比赛链接：<a href="https://codeforces.ml/contest/1506" class="uri">https://codeforces.ml/contest/1506</a></p></blockquote><h2 id="记录">记录</h2><p>比赛的时候可以说还是有点捞的，，竟然没有时间写完最后一题，属是不是很行（</p><p>但是精彩还是在比完之后：</p><figure><img src="https://i.loli.net/2021/03/27/2JZwcepftOClvbS.png" class="lazyload" data-srcset="https://i.loli.net/2021/03/27/2JZwcepftOClvbS.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="_XMUTFT_4YHFRV__35DML_Y.png" /><figcaption aria-hidden="true">_XMUTFT_4YHFRV__35DML_Y.png</figcaption></figure><p>直呼就这？</p><table><thead><tr class="header"><th style="text-align: center;">Penalty</th><th style="text-align: center;">A</th><th style="text-align: center;">B</th><th style="text-align: center;">C</th><th style="text-align: center;">D</th><th style="text-align: center;">E</th><th style="text-align: center;">F</th><th style="text-align: center;">G</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">168</td><td style="text-align: center;"><font color="#0a0">+</font></td><td style="text-align: center;"><font color="#0a0">+1</font></td><td style="text-align: center;"><font color="#0a0">+</font></td><td style="text-align: center;"><font color="red">-2</font></td><td style="text-align: center;"><font color="red"><strong>-1</strong></font></td><td style="text-align: center;"><font color="#0a0">+</font></td><td style="text-align: center;"><font color="#999">-1</font></td></tr></tbody></table><h2 id="题解">题解</h2><p>毕竟是 Div3，所以就只贴被 Hack 的题和没写出来的题好了：</p><h3 id="d---epic-transformation">D - <a href="https://codeforces.com/contest/1506/problem/D">Epic Transformation</a></h3><p>原来是 <code>unordered_map</code> 被卡了，，也不能这么说，也许遍历 <code>unordered_map</code> 就是意外的要慢（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt();</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        cnt.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            ++ cnt[scanner.nextInt()];</span><br><span class="line">        <span class="keyword">int</span> major = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [k, v] : cnt)</span><br><span class="line">            maximize(major, v);</span><br><span class="line">        println(max(n % <span class="number">2</span>, major - (n - major)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哦，，破案了，，实际上是不断扩容消耗了大量的时间，，在使用之前预留空间就没有任何问题（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt();</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        cnt.clear(), cnt.reserve(n * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            ++ cnt[scanner.nextInt()];</span><br><span class="line">        <span class="keyword">int</span> major = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [k, v] : cnt)</span><br><span class="line">            maximize(major, v);</span><br><span class="line">        println(max(n % <span class="number">2</span>, major - (n - major)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就结果而言实际上跑的比 <code>map</code> 还要快：</p><figure><img src="https://i.loli.net/2021/03/27/plQCvT5VZODM9nk.png" class="lazyload" data-srcset="https://i.loli.net/2021/03/27/plQCvT5VZODM9nk.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="M_H5_L__9533_L__SQT__EV.png" /><figcaption aria-hidden="true">M_H5_L__9533_L__SQT__EV.png</figcaption></figure><p>上面是 <code>unordered_map</code> + <code>reserve</code> 两倍空间，下面是 <code>map</code>；</p><h3 id="e---restoring-the-permutation">E - <a href="https://codeforces.com/contest/1506/problem/E">Restoring the Permutation</a></h3><p>没什么好说的，典型的复杂度估计错误，，这种数据范围 <code>1e5</code> 的，还要求在指定范围内寻找最大最小值的，拿个对数数据结构维护一下是再适合不过了；而且实际上也不难写，，只能说有些意识还是不够（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> pmx[N], pmn[N], q[N];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; umx, umn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt();</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>, mn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> update =</span><br><span class="line">    [&amp;](<span class="keyword">int</span> pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (++ mx &lt; pos) umx.insert(mx);</span><br><span class="line">        <span class="keyword">while</span> (++ mn &lt; pos) umn.insert(mn);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            q[i] = scanner.nextInt();</span><br><span class="line">        <span class="built_in">memset</span>(pmx, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">memset</span>(pmn, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">        umx.clear(), umn.clear();</span><br><span class="line">        pmx[<span class="number">1</span>] = pmn[<span class="number">1</span>] = q[<span class="number">1</span>], mx = mn = <span class="number">0</span>;</span><br><span class="line">        update(q[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (q[i] &gt; q[i - <span class="number">1</span>])</span><br><span class="line">                pmx[i] = pmn[i] = q[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pmx[i])</span><br><span class="line">            &#123;</span><br><span class="line">                pmx[i] = *umx.rbegin();</span><br><span class="line">                umx.erase(*umx.rbegin());</span><br><span class="line">            &#125; <span class="keyword">else</span> update(pmx[i]);</span><br><span class="line">            <span class="keyword">if</span> (!pmn[i])</span><br><span class="line">            &#123;</span><br><span class="line">                pmn[i] = *umn.begin();</span><br><span class="line">                umn.erase(umn.begin());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            print(pmn[i], <span class="string">&quot; \n&quot;</span>[i == n]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            print(pmx[i], <span class="string">&quot; \n&quot;</span>[i == n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看来对 <code>bitset</code> 的无脑崇拜也得差不多得了（</p><h3 id="g---maximize-the-remaining-string">G - <a href="https://codeforces.com/contest/1506/problem/G">Maximize the Remaining String</a></h3><p>十分经典的问题，讲清楚了其实就没什么好说的；只能说思考题目的时候应该更加地理性，而不是总是对玄学抱有不切实际的幻想；比如这个题，如果看到就去考虑什么玄学构造方法，瞎几把贪，还欺骗自己的做法是正确的且很有道理，那就会贻笑大方，一辈子也做不出了（</p><p>首先，很显然待构造的 <span class="math inline">\(t\)</span> 是 <span class="math inline">\(s\)</span> 的子序列：这说明我们可能可以按照顺序遍历每个字符，来确定是否要把它加入到 <span class="math inline">\(t\)</span> 的末尾（当然 <span class="math inline">\(t\)</span> 最开始是一个空串）；对于一个构造到一半的 <span class="math inline">\(t\)</span>，在某个位置 <span class="math inline">\(i\)</span> 的字符 <span class="math inline">\(s[i]\)</span> 可以加入 <span class="math inline">\(t\)</span> 的末尾的必要条件是，<span class="math inline">\(s\)</span> 从 <span class="math inline">\(i\)</span> 开始的后缀（后面记作 <span class="math inline">\(s_i\)</span>）包含了所有 <span class="math inline">\(t\)</span> 不包含的字符。</p><p>显然，<span class="math inline">\(t\)</span> 的总长度也是确定的（并且极其有限），所以我们可以遍历字符串 <span class="math inline">\(t\)</span> 需要，但是目前的构造阶段还不包含的可能的字符，找到可以插入且尽可能大的字符插入即可。每次插入的字符都确保它的后缀中有足够的其他字符使得构造不会失败，因此我们总是可以找到合理的字符并插入其中。</p><p>当然，这里实际上也有一个小小的贪心：字符串前面的字符大的字符串字典序更大（可以说是显然了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> s[N], t[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> suffix =</span><br><span class="line">    [&amp;](<span class="keyword">char</span> ch, <span class="keyword">int</span> st)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;p = pos[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">auto</span> it = lower_bound(p.begin(), p.end(), st);</span><br><span class="line">        <span class="keyword">if</span> (it == p.end()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> *it;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> count =</span><br><span class="line">    [&amp;](<span class="keyword">int</span> st)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;ii : pos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = lower_bound(ii.begin(), ii.end(), st);</span><br><span class="line">            <span class="keyword">if</span> (it != ii.end()) ++ ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        scanner(s);</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s), len = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; <span class="title">ss</span><span class="params">(s, s + n)</span></span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> siz = ss.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">            pos[s[i] - <span class="string">&#x27;a&#x27;</span>].push_back(i);</span><br><span class="line">        <span class="keyword">int</span> st = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (len &lt; siz)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> add = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> ch : ss)</span><br><span class="line">                <span class="keyword">if</span> (count(suffix(ch, st)) + len == siz)</span><br><span class="line">                    maximize(add, ch);</span><br><span class="line">            t[len ++] = add;</span><br><span class="line">            st = suffix(add, st) + <span class="number">1</span>;</span><br><span class="line">            pos[add - <span class="string">&#x27;a&#x27;</span>].clear();</span><br><span class="line">            ss.erase(add);</span><br><span class="line">        &#125; t[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        println(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次检查一个字符是否合法的复杂度是 <span class="math inline">\(O(26\text{log}n)\)</span> 的，因为只有小写拉丁字母，所以检查次数是 <span class="math inline">\(O(26\cdot26)\)</span> 的；上面的代码去重用了 <code>set</code>（其实完全没必要），复杂度是 <span class="math inline">\(O(n\text{log}n)\)</span> 的；综上所述，总时间复杂度是 <span class="math inline">\(O((26^3 + n)\cdot\text{log}n)\)</span> 的；如果不用 <code>set</code> 去重，时间复杂度可以做到 <span class="math inline">\(O(\text{log}n)\)</span> 的。</p><h2 id="后记">后记</h2><p>不要盲目崇拜 <code>bitset</code> 和 <code>unordered_map</code>；至少要明白使用它们意味着什么：</p><p><code>unordered_map</code> 本质是哈希表，它的访问是将键值经过哈希计算映射到本地的连续空间，从而可以快速的“随机访问”的；如果这段连续空间不足以存储数据，就必须要开辟更大的空间，并且 <code>rehash</code>，从而将键值映射到更大的连续空间中；这个过程很显然是极其耗时的，但是在做题的时候我们大概知道元素的数量，所以可以使用它提供的 <code>reserve</code> 方法，预留足够的空间，就可以减少这个过程的发生，从而达到提速的目的。</p><p>当然，<code>pb_ds</code> 里的哈希表又是另一回事，得找个时间去了解才行。</p><p>至于这个 G，确实是和我还颇有渊源，，，这个就不提了（）但是确实在做题的时候应当舍弃不切实际的无聊幻想，用做题的思维去考虑才行==</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 106 回顾</title>
      <link href="/2021/codeforces-educational-round-106/"/>
      <url>/2021/codeforces-educational-round-106/</url>
      
        <content type="html"><![CDATA[<blockquote><p>补题链接：<a href="https://codeforces.com/contest/1499" class="uri">https://codeforces.com/contest/1499</a></p></blockquote><h2 id="记录">记录</h2><p>一开始还是挺像模像样的，快速地切掉了 ABC 三个题，然后在 D 题处一直瞎想，看着通过人数从 30 涨到 600 左右直到比赛结束……这种感觉是真的不好（）到底是什么使得我变得总是做不出 D 呢…… 确实需要好好反思（</p><h2 id="题解">题解</h2><h3 id="a---domino-on-windowsill">A - <a href="https://codeforces.com/contest/1499/problem/A">Domino on Windowsill</a></h3><p>不用管怎么摆放；因为只有两排，所以只需要看格子数够不够就行；</p><h4 id="代码">代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt();</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n, k1, k2, w, b;</span><br><span class="line">        scanner(n, k1, k2, w, b);</span><br><span class="line">        <span class="keyword">int</span> ww = (k1 + k2) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> bb = (<span class="number">2</span> * n - k1 - k2) / <span class="number">2</span>;</span><br><span class="line">        println(ww &gt;= w &amp;&amp; bb &gt;= b ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="b---binary-removals">B - <a href="https://codeforces.com/contest/1499/problem/B">Binary Removals</a></h3><p>数据规模很小；所以只需要遍历 0-1 分界点的位置，然后 <span class="math inline">\(O(n)\)</span> 检查是否可行即可。</p><h4 id="代码-1">代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt();</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        scanner(s);</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">bool</span> ok = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">bitset</span>&lt;N&gt; del;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            del.reset();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (s[j] == <span class="string">&#x27;1&#x27;</span>) del.<span class="built_in">set</span>(j);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (s[j] == <span class="string">&#x27;0&#x27;</span>) del.<span class="built_in">set</span>(j);</span><br><span class="line">            <span class="keyword">bool</span> _ok = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (del[j] &amp;&amp; del[j - <span class="number">1</span>]) _ok = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (_ok) ok = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        println(ok ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="c---minimum-grid-path">C - <a href="https://codeforces.com/contest/1499/problem/C">Minimum Grid Path</a></h3><p>首先，你至少要转一次弯才能到达终点，所以你的路程段数至少是两段；因为只有两个方向，所以你每转一次弯就相当于在两种方向来回横跳；注意到题目说的是第 x 段路的费用是 <span class="math inline">\(c_x\)</span>；所以显然偶数段的路和奇数段的路方向不同，且恰好占据了两个方向——且两个方向都需要走 <span class="math inline">\(n\)</span> 的长度；</p><p>因为转方向之后至少要在这一段路之间走 1 个单位，所以如果在某个方向走了 <span class="math inline">\(x\)</span> 段路，其中费用最小的为 <span class="math inline">\(c_x&#39;\)</span>，所有的这些路段的单价总和为 <span class="math inline">\(C_x\)</span>，那么这个方向上最便宜的走法一定是花费 <span class="math inline">\(C_x + (n - x)c_x&#39;\)</span> 的：即在花费最小的路段尽可能地走，但是<strong>之前</strong>经过的不那么优的路段只走一段；</p><p>还需要注意的就是两个方向并不是独立的：因为是连贯的折线，所以在两个方向上走的段数差不能超过 1；一种比较优雅的遍历方法就是遍历所有的段数，然后分别处理两边的最优花费，求和取最小值。</p><h4 id="代码-2">代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">longs c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt();</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            c[i] = scanner.nextInt();</span><br><span class="line">        longs ans = c[<span class="number">1</span>] * n + c[<span class="number">2</span>] * n;</span><br><span class="line">        longs odd = c[<span class="number">1</span>], even = c[<span class="number">2</span>];</span><br><span class="line">        longs os = c[<span class="number">1</span>], es = c[<span class="number">2</span>];</span><br><span class="line">        longs on = <span class="number">1</span>, en = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            ++ (i % <span class="number">2</span> ? on : en);</span><br><span class="line">            (i % <span class="number">2</span> ? os : es) += c[i];</span><br><span class="line">            minimize((i % <span class="number">2</span> ? odd : even), c[i]);</span><br><span class="line">            <span class="keyword">auto</span> tmp = odd * (n - on) + os + even * (n - en) + es;</span><br><span class="line">            minimize(ans, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        println(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="d---the-number-of-pairs">D - <a href="https://codeforces.com/contest/1499/problem/D">The Number of Pairs</a></h3><blockquote><p>给定三个整数 <span class="math inline">\(c\)</span>， <span class="math inline">\(d\)</span>，<span class="math inline">\(x\)</span>；它们满足 <span class="math inline">\(1 \leq c, d, x \leq 10^7\)</span>；现给定等式： <span class="math display">\[c \cdot \mathrm{lcm}(a, b) - d \cdot \mathrm{gcd}(a, b) = x\]</span> 且 <span class="math inline">\(a, b\)</span> 均为正整数；求出满足该等式的 <span class="math inline">\((a, b)\)</span> 的对数。</p></blockquote><p>这个等式首先一看就是要化简的：令 <span class="math inline">\(K = \mathrm{gcd}(a, b)\)</span>；那么就可以将 a 和 b 表示为 <span class="math inline">\(a = nK, \ b = mK\)</span>，其中的 n 和 m 显然满足 <span class="math inline">\(n,m \in N^+\)</span> 和 <span class="math inline">\(\mathrm{gcd}(n, m) = 1\)</span>；那么我们就可以进行如下的等价变换： <span class="math display">\[\begin{align}c \cdot \mathrm{lcm}(a, b) - d \cdot \mathrm{gcd}(a, b) &amp;= x \\c \cdot \frac{ab}{\mathrm{gcd}(a, b)} - d \cdot \mathrm{gcd}(a, b) &amp;= x \\c \cdot nmK - d \cdot K &amp;= x \\K &amp;= \frac{x}{cnm - d}\end{align}\]</span> 那么，记 <span class="math inline">\(y = cnm - d\)</span>，这个问题就变成了求满足这个等式的互质的 <span class="math inline">\((n, m)\)</span> 的对数。具体的做法就是枚举 <span class="math inline">\(x\)</span> 的因子 <span class="math inline">\(y\)</span>：如果满足 <span class="math inline">\(c \mid (d + y)\)</span>，那么 <span class="math inline">\(nm = \frac{d + y}{c}\)</span>；记 <span class="math inline">\(z = nm\)</span>，因为 n 和 m 互质，所以 <span class="math inline">\(z\)</span> 的每一个不同的质因子要不全部属于 n，要不全部属于 m；用 <span class="math inline">\(P_z\)</span> 表示 z 的不同的质因子的数量，那么对于 z，满足条件的 (n, m) 一共有 <span class="math inline">\(2^{P_z}\)</span> 对。</p><p>实际实现时，可以先用线性筛预处理数据范围内的 <span class="math inline">\(P\)</span> 数组，然后根据输入计算答案。</p><h4 id="代码-3">代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> A = <span class="number">2e7</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> linear_sieve &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">longs <span class="title">fastPow</span><span class="params">(longs a, ulongs b)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt(), c, d, x;</span><br><span class="line">    <span class="keyword">using</span> linear_sieve::cnt;</span><br><span class="line">    linear_sieve::start();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> calc =</span><br><span class="line">    [&amp;](longs y) -&gt; longs</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((d + y) % c) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> z = (d + y) / c;</span><br><span class="line">        <span class="keyword">return</span> fastPow(<span class="number">2</span>, cnt[z]);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        scanner(c, d, x);</span><br><span class="line">        longs ans = <span class="number">0</span>, y;</span><br><span class="line">        <span class="keyword">for</span> (y = <span class="number">1</span>; y * y &lt; x; ++ y)</span><br><span class="line">            <span class="keyword">if</span> (!(x % y))</span><br><span class="line">                ans += calc(y) + calc(x / y);</span><br><span class="line">        <span class="keyword">if</span> (y * y == x) ans += calc(y);</span><br><span class="line">        println(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是：虽然数据范围是 <code>1e7</code> 的，但是 z 是有可能大于 <code>1e7</code> 的；所以预处理的数据范围要更广。</p><h4 id="事后分析">事后分析</h4><p>虽然也确实推了式子，也至少推到了这份题解中提到的第二部；但是这实在是太像 <span class="math inline">\(\mathrm{exgcd}\)</span> 了：如果假设 lcm 和 gcd 都为未知变量的话；但是就像刚才所推导的那样，这两个未知变量之间本就有所联系，并且这个联系的关系也是不定的（lcm 是 gcd 的倍数），求出了倍数还是要进行这样的拆分，就非常的不合理。</p><h3 id="e---chaotic-merge">E - <a href="https://codeforces.com/contest/1499/problem/E">Chaotic Merge</a></h3><blockquote><p>……</p></blockquote><h3 id="f---diameter-cuts">F - <a href="https://codeforces.com/contest/1499/problem/F">Diameter Cuts</a></h3><p>等待题解中……</p><h2 id="后记">后记</h2><p>和之前的发挥不是很正常的比赛是一样的：总是感觉自己的思维非常的不稳定——不在能做出题的频道上；之前解决这种问题是静下心来仔细想想自己到底有哪些地方出了问题，也许现在也是需要这样的时候吧（</p><figure><img src="https://i.loli.net/2021/03/19/6reayQYokJgTK9C.png" class="lazyload" data-srcset="https://i.loli.net/2021/03/19/6reayQYokJgTK9C.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="猫猫脸.png" /><figcaption aria-hidden="true">猫猫脸.png</figcaption></figure><p>不过我确实需要静下心来好好地想想了…… 愉快犯是不够扎实的（</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round#708 div.2 回顾</title>
      <link href="/2021/codeforces-round-708-div2/"/>
      <url>/2021/codeforces-round-708-div2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>补题链接：<a href="https://codeforces.com/contest/1497">Dashboard - Codeforces Round #708 (Div. 2) - Codeforces</a></p></blockquote><h2 id="记录">记录</h2><p><del>推特做题术</del></p><figure><img src="https://i.loli.net/2021/03/18/zHg9q4sJCewaoEQ.png" class="lazyload" data-srcset="https://i.loli.net/2021/03/18/zHg9q4sJCewaoEQ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="7_QMZFWQ_2JMS4Z46F_T9.png" /><figcaption aria-hidden="true">7_QMZFWQ_2JMS4Z46F_T9.png</figcaption></figure><p>虽然还是勉强保住了 ABC 选手的尊严，但是这场题目是真的偏简单…… ABC 连两千名都进不了（）明明参加人数就只有两万人不到，可以说是很捞了== 赛后一看 E1 比 D 简单，C2 比 C1 简单，也真神秘（</p><h2 id="题解">题解</h2><h3 id="a---meximization">A - <a href="https://codeforces.com/contest/1497/problem/A">Meximization</a></h3><p>看样例猜解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt();</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            ++ cnt[scanner.nextInt()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [i, ii] : cnt)</span><br><span class="line">            print(i, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [i, ii] : cnt)</span><br><span class="line">            <span class="keyword">while</span> (-- ii) print(i, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="b---m-arrays">B - <a href="https://codeforces.com/contest/1497/problem/B">M-arrays</a></h3><p>按照 <span class="math inline">\(\mathrm{mod} \ m\)</span> 进行分组统计答案就行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], cnt[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt();</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt(),</span><br><span class="line">            m = scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            a[i] = scanner.nextInt();</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            ++ cnt[a[i] % m];</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="keyword">bool</span>(cnt[<span class="number">0</span>]), lim = m / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lim; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> aa = cnt[i], bb = cnt[m - i];</span><br><span class="line">            <span class="keyword">if</span> (!aa &amp;&amp; !bb) <span class="keyword">continue</span>;</span><br><span class="line">            ans += max(<span class="built_in">abs</span>(bb - aa), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        println(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="c1---k-lcm-easy-version">C1 - <a href="https://codeforces.com/contest/1497/problem/C1">k-LCM (easy version)</a></h3><p>实际上没我代码写的那么复杂；如果是奇数的话就输出 <code>1 k/2 k/2</code> 就行，偶数但是不是 4 的倍数的话就是 <code>2 k/2-1 k/2-1</code>；再不然就是 <code>n/2 n/4 n/4</code>；不用看了，肯定是对的 ==</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt();</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt(),</span><br><span class="line">            k = scanner.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (__builtin_popcount(n) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            print(n / <span class="number">2</span>, <span class="string">&#x27; &#x27;</span>, n / <span class="number">4</span>, <span class="string">&#x27; &#x27;</span>, n / <span class="number">4</span>, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        longs mod2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!(n % <span class="number">2</span>)) n /= <span class="number">2</span>, mod2 *= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = n / <span class="number">2</span>;</span><br><span class="line">        print(mod2, <span class="string">&#x27; &#x27;</span>, mod2 * tmp, <span class="string">&#x27; &#x27;</span>, mod2 * tmp, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="c2---k-lcm-hard-version">C2 - <a href="https://codeforces.com/contest/1497/problem/C2">k-LCM (hard version)</a></h3><p>这个题目就更搞了…… 因为服务器中途宕机的原因，我交的很慢，甚至还因为原想法过于花哨边界条件太多而 wa 了一发（）但是实际上这个题比 C1 还要简单：</p><p>对于 n 和 k，只需要先输出 <code>k - 3</code> 个 <code>1</code>，然后再用 C1 的办法处理就行了（（（</p><p>显然，C1 的办法保证得到的三个数的 LCM 满足 <code>lcm &lt;= (k - 3) / 2</code>，而我们其他的数都是 1，对 lcm 没有任何贡献，所以最后的结果显然也是满足题意的（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">C1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span>) print(<span class="string">&quot;1 &quot;</span>, n / <span class="number">2</span>, <span class="string">&#x27; &#x27;</span>, n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">4</span>) print(<span class="string">&quot;2 &quot;</span>, n / <span class="number">2</span> - <span class="number">1</span>, <span class="string">&#x27; &#x27;</span>, n / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> print(n / <span class="number">2</span>, <span class="string">&#x27; &#x27;</span>, n / <span class="number">4</span>, <span class="string">&#x27; &#x27;</span>, n / <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt();</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt(),</span><br><span class="line">            k = scanner.nextInt();</span><br><span class="line">        <span class="keyword">int</span> m = k - <span class="number">3</span>; C1(n - m);</span><br><span class="line">        <span class="keyword">while</span> (m --) print(<span class="string">&quot; 1&quot;</span>);</span><br><span class="line">        println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就不贴我赛场上写的丑陋的<del>甚至还 WA 了一发</del>代码了…… 我真傻，真的（</p><figure><img src="https://i.loli.net/2021/03/18/Ty7Fu6nVh8zq4Xs.png" class="lazyload" data-srcset="https://i.loli.net/2021/03/18/Ty7Fu6nVh8zq4Xs.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="XJQ1VOCX5_3_D_4ML2KN.png" /><figcaption aria-hidden="true">XJQ1VOCX5_3_D_4ML2KN.png</figcaption></figure><p>还是不够机智==</p><h3 id="d---genius">D - <a href="https://codeforces.com/contest/1497/problem/D">Genius</a></h3><blockquote><p>有 <span class="math inline">\(1 \dots n\)</span> 共 <span class="math inline">\(n \leq 5000\)</span> 个位置：<span class="math inline">\(i\)</span>-th 位置有 <span class="math inline">\(tag_i\)</span>、<span class="math inline">\(c_i = 2^i\)</span> 和 <span class="math inline">\(s_i\)</span> 分数；初始有 <span class="math inline">\(\mathrm{IQ} = 0\)</span> 和 <span class="math inline">\(S = 0\)</span>；</p><p>如果你当前在 <span class="math inline">\(i\)</span> 点，那么仅当 <span class="math inline">\(\mathrm{IQ} &lt; |c_i - c_j|\)</span> 和 <span class="math inline">\(tag_i \ne tag_j\)</span> 同时满足时才能到达 <span class="math inline">\(j\)</span> 点；<br />到达 <span class="math inline">\(j\)</span> 点之后，你的 <span class="math inline">\(\mathrm{IQ}\)</span> 变为 <span class="math inline">\(|c_i - c_j|\)</span>，并且获得 <span class="math inline">\(|s_i - s_j|\)</span> 分数；</p><p>你可以任意选择起点，问你可以获得的最大分数；</p><p><strong>特别说明</strong>：<font color="red">内存限制 32MB</font></p></blockquote><p>首先，定义边权 <span class="math inline">\(w_{i, j} = |c_i - c_j|\)</span>；显然所有的边的“边权”都是不同的；然后考虑动态规划：定义 <span class="math inline">\(F_i\)</span> 表示最后停留在点 <span class="math inline">\(i\)</span> 最大能获得的分数；显然最初情况下全部为 0；然后转换题目限制条件，进行转移：</p><ul><li><span class="math inline">\(tag_i \ne tag_j\)</span>：这个简单，如果不满足直接阻止对应的转移就行了。</li><li><span class="math inline">\(\mathrm{IQ} &lt; |c_i - c_j|\)</span>：意思就是说走的边越来越长；因此我们总是先转移短边再转移长边就行。</li></ul><p>综上所述，我们就可以在一维 DP 内完成答案的求解；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5050</span>;</span><br><span class="line"><span class="keyword">int</span> s[N], tag[N];</span><br><span class="line">longs dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt();</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            tag[i] = scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            s[i] = scanner.nextInt();</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(longs) * (n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j; -- j)</span><br><span class="line">                <span class="keyword">if</span> (tag[i] != tag[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">auto</span> ii = dp[i], jj = dp[j];</span><br><span class="line">                    <span class="keyword">auto</span> add = <span class="built_in">abs</span>(s[i] - s[j]);</span><br><span class="line">                    maximize(dp[i], jj + add);</span><br><span class="line">                    maximize(dp[j], ii + add);</span><br><span class="line">                &#125;</span><br><span class="line">        println(*max_element(dp + <span class="number">1</span>, dp + <span class="number">1</span> + n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有的时候想问题还是要跳出局部纵观全体；像这个题就是做的时候视野集中在走的策略上，并且还被预处理 tag 连通块的想法所牵制，最后离正解渐行渐远（</p><h3 id="e1---square-free-division-easy-version">E1 - <a href="https://codeforces.com/contest/1497/problem/E1">Square-free division (easy version)</a></h3><blockquote><p>给定长度为 <span class="math inline">\(n \leq 2 \cdot 10^5\)</span> 的数组；现在你需要将数组划分成一些连续的段，使得每个段中不包含两个数，它们的乘积为完全平方数；求满足此要求可以划分的最少的段数。</p></blockquote><p>首先肯定要对数组里每个数字进行分解质因数；因为相乘就是分解质因数得到的多项式的指数相加，而完全平方数分解得到的多项式的指数均为 2；那么我们可以得到结论：如果 x 和 y 的乘积是完全平方数，那么 x 和 y 分解质因数得到的多项式中关于每一个质数的指数都是 <span class="math inline">\(\mathrm{mod} \ 2\)</span> 相等的。</p><p>因此，我们只需要记录每个元素质因数分解之后指数 <span class="math inline">\(\mathrm{mod} \ 2\)</span> 的情况，然后划分不包含相同 pattern 的元素即可：这样，这个问题就退化为划分不包含相等数字的段；众所周知，这个问题可以贪心的解决。</p><p>那么应该如何维持这个 pattern 呢？使用一个很大的 <code>bitset</code> 嘛？完全没有必要：因为 <span class="math inline">\(a_i \leq 10^7\)</span>，那么质因子指数不会超过 1 的 pattern 的乘积自然也不会超过这个限制；所以只需要将它们乘起来就可以了，即快又优雅（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>, A = <span class="number">1e7</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], pattern[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// PrimeFactorizationSieve()</span></span><br><span class="line"><span class="keyword">namespace</span> PFS &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt();</span><br><span class="line">    <span class="keyword">using</span> PFS::prime, PFS::fact;</span><br><span class="line">    PFS::start();</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt(),</span><br><span class="line">            k = scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            a[i] = scanner.nextInt();</span><br><span class="line">        fill(pattern, pattern + n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">exp</span> = <span class="number">0</span>, base = <span class="number">0</span>, tmp = a[i];</span><br><span class="line">            <span class="keyword">while</span> (tmp &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> p = fact[tmp];</span><br><span class="line">                <span class="keyword">if</span> (base == p) ++ <span class="built_in">exp</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">exp</span> % <span class="number">2</span>) pattern[i] *= base;</span><br><span class="line">                    base = p, <span class="built_in">exp</span> = <span class="number">1</span>;</span><br><span class="line">                &#125; tmp /= p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">exp</span> % <span class="number">2</span>) pattern[i] *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; unique;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; unique.insert(pattern[i ++]))</span><br><span class="line">            <span class="keyword">if</span> (unique.count(pattern[i])) ++ ans, unique.clear();</span><br><span class="line">        println(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真就比 D 简单呗？以后打 CF 也不能盯着一个题死看了，得适当设定递归深度（（</p><p>话说我的欧拉筛写成函数竟然会过不了编译（提示编译得到的文件过大），只好拆成命名空间的形式才能过，倒是挺神秘的有点==</p><h3 id="e2---square-free-division-hard-version">E2 - <a href="https://codeforces.com/contest/1497/problem/E2">Square-free division (hard version)</a></h3><blockquote><p>在 E1 的基础上，你获得了 <span class="math inline">\(k \leq 20\)</span> 次的单点修改的机会：你可以将任意位置修改为任意数字不超过 <span class="math inline">\(k\)</span> 次；</p></blockquote><p>看到 k 非常的小，所以可以考虑 DP；令 DP 数组 <span class="math inline">\(F_{i, j}\)</span> 的含义是在长度为 i 的前缀中，允许不超过 j 次的修改，可以得到的最少的分段数；那么，我们至少可以考虑到两种显然的转移：</p><ul><li>若 <span class="math inline">\(j &gt; 0\)</span>，那么显然可以从 <span class="math inline">\(F_{i,k} (k &lt; j)\)</span> 转移到 <span class="math inline">\(F_{i, j}\)</span>；</li><li>若区间 <span class="math inline">\((i, k]\)</span> 消耗了 <span class="math inline">\(x\)</span> 次修改而得以连续，那么 <span class="math inline">\(F_{k, j + x} = F_{i, j} + 1\)</span></li></ul><p>因此，如果我们可以维护一段区间维持连续而消耗的次数，就可以利用第二种转移求出最后的答案；</p><p>当然，我们不可能去维护所有的区间；将第二种转移反过来，我们只需要维护对于每一个满足 <span class="math inline">\(x \leq j\)</span> 的修改次数，以一个确定的右端点 <span class="math inline">\(i\)</span>，可以到达的最远的左端点 <span class="math inline">\(l\)</span> 即可。这样的转移一定是更优的。而预处理求出这个距离也并不难；我们依然可以像 E1 那样通过一次遍历就完成维护（因为 <code>pattern</code> 的大小是有限的，我们可以使用桶来去重而不是 <code>set</code>，这样时间复杂度就是线性的）；维护 <span class="math inline">\(k\)</span> 中不同的修改情况的复杂度是 <span class="math inline">\(O(nk)\)</span> 的；</p><p>这样，我们就可以利用上面说到的两种转移方法进行转移了；时间复杂度是 <span class="math inline">\(O(nk^2)\)</span> 的；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>, A = <span class="number">1e7</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], pattern[N], cnt[A];</span><br><span class="line"><span class="keyword">int</span> ll[N][<span class="number">25</span>], f[N][<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// PrimeFactorizationSieve()</span></span><br><span class="line"><span class="keyword">namespace</span> PFS &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt();</span><br><span class="line">    <span class="keyword">using</span> PFS::prime, PFS::fact;</span><br><span class="line">    PFS::start();</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt(),</span><br><span class="line">            k = scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            a[i] = scanner.nextInt();</span><br><span class="line">        fill(pattern, pattern + n + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="built_in">exp</span> = <span class="number">0</span>, base = <span class="number">0</span>, tmp = a[i];</span><br><span class="line">            <span class="keyword">while</span> (tmp &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> p = fact[tmp];</span><br><span class="line">                <span class="keyword">if</span> (base == p) ++ <span class="built_in">exp</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">exp</span> % <span class="number">2</span>) pattern[i] *= base;</span><br><span class="line">                    base = p, <span class="built_in">exp</span> = <span class="number">1</span>;</span><br><span class="line">                &#125; tmp /= p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">exp</span> % <span class="number">2</span>) pattern[i] *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cur = n + <span class="number">1</span>, use = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; -- i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (cur - <span class="number">1</span> &gt;= <span class="number">1</span> &amp;&amp;</span><br><span class="line">                       use + !!cnt[pattern[cur - <span class="number">1</span>]] &lt;= j)</span><br><span class="line">                    use += !!(cnt[pattern[-- cur]] ++);</span><br><span class="line">                ll[i][j] = cur;</span><br><span class="line">                <span class="keyword">if</span> (cnt[pattern[i]] --&gt; <span class="number">1</span>) -- use;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="built_in">memset</span>(f[i], <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(f[i]));</span><br><span class="line">        <span class="built_in">memset</span>(f[<span class="number">0</span>], <span class="number">0</span>, <span class="keyword">sizeof</span>(f[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= k; ++ j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j) minimize(f[i][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt;= j; ++ l)</span><br><span class="line">                    minimize(f[i][j], f[ll[i][l] - <span class="number">1</span>][j - l] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= k; ++ i)</span><br><span class="line">            minimize(ans, f[n][i]);</span><br><span class="line">        println(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记">后记</h2><p>《就这》：比赛中：Codeforces 服务器就这？比赛后：你这通过情况就这？</p><p><del>服务器恢复：拿好你的 15 分钟，我们没有找到任何 unrated 的原因！半小时后：我们 unrated 了！</del></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客 2021 年度训练联盟热身训练赛第二场 回顾</title>
      <link href="/2021/nowcoder-2021-training-league-warm-up-2/"/>
      <url>/2021/nowcoder-2021-training-league-warm-up-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>比赛链接：<a href="https://ac.nowcoder.com/acm/contest/12794" class="uri">https://ac.nowcoder.com/acm/contest/12794</a></p></blockquote><p>非常的垃圾，这一场几乎全部都是水题== 当然还混入了大量说不清道不明的阅读理解一般又臭又长的题面…… 只能说恶心他🐎给恶心开门，恶心到家了（）</p><p>实况：AK（10/10），Rank=39</p><table><thead><tr class="header"><th style="text-align: center;">Penalty</th><th style="text-align: center;">A</th><th style="text-align: center;">B</th><th style="text-align: center;">C</th><th style="text-align: center;">D</th><th style="text-align: center;">E</th><th style="text-align: center;">F</th><th style="text-align: center;">G</th><th style="text-align: center;">H</th><th style="text-align: center;">I</th><th style="text-align: center;">J</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">1056</td><td style="text-align: center;">+</td><td style="text-align: center;">+</td><td style="text-align: center;">+</td><td style="text-align: center;">+1</td><td style="text-align: center;">+1</td><td style="text-align: center;">+1</td><td style="text-align: center;">+5</td><td style="text-align: center;">+1</td><td style="text-align: center;">+</td><td style="text-align: center;">+</td></tr></tbody></table><p>没什么好说的，，直接贴代码好了<del>这将成为目前为止本博客最水题解</del></p><h2 id="题解">题解</h2><h3 id="a---binarize-it">A - <a href="https://ac.nowcoder.com/acm/contest/12794/A">Binarize It</a></h3><p>签到，队友 A 的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> t, n, m, k;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// #define COMP_DATA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> tcase;</span><br><span class="line">    read(tcase);</span><br><span class="line">    <span class="keyword">while</span> (tcase--)</span><br><span class="line">    &#123;</span><br><span class="line">        read(n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input value: %d\n%d\n\n&quot;</span>, n, <span class="keyword">int</span>(<span class="built_in">pow</span>(<span class="number">2</span>, <span class="keyword">int</span>(<span class="built_in">ceil</span>(<span class="built_in">log10</span>(n) / <span class="built_in">log10</span>(<span class="number">2</span>))))));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然有些意义不明的变量（</p><h3 id="b---g2g-c-u-l8r">B - <a href="https://ac.nowcoder.com/acm/contest/12794/B">g2g c u l8r</a></h3><p>纯字符串暴力题；让我熟悉了在 C++ 中读入整行的一些操作和注意事项</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">// std::cin.tie(nullptr);</span></span><br><span class="line">    <span class="comment">// std::cout.tie(nullptr);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T, q; <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; dict;</span><br><span class="line">    <span class="built_in">string</span> s, t;</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        getline(<span class="built_in">cin</span>, t);</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>, size = t.length();</span><br><span class="line">        <span class="keyword">while</span> (cur &lt; size) <span class="keyword">if</span> (t[cur] == <span class="string">&#x27; &#x27;</span>) ++ cur; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        dict[s] = t.substr(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q; getline(<span class="built_in">cin</span>, s);</span><br><span class="line">    <span class="keyword">while</span> (q --)</span><br><span class="line">    &#123;</span><br><span class="line">        getline(<span class="built_in">cin</span>, s);</span><br><span class="line">        stringstream ss(s), out;</span><br><span class="line">        <span class="keyword">while</span> (ss &gt;&gt; t)</span><br><span class="line">            <span class="keyword">if</span> (dict.count(t)) out &lt;&lt; dict[t] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">else</span> out &lt;&lt; t &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="keyword">auto</span> str = out.str();    </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回想起了刚入坑时在洛谷训练场写红题的恐惧（</p><h3 id="c---tip-to-be-palindrome">C - <a href="https://ac.nowcoder.com/acm/contest/12794/C">Tip to be Palindrome</a></h3><p>签到；虽然可以考虑一些手段，但是因为数据范围实在是太小了，所以只需要模拟就行了……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s = to_string(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() / <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = s.length() - i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[i] != s[j])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// #define COMP_DATA</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">int</span> tcase;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; tcase;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &lt;= <span class="number">20000</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (check(i))</span><br><span class="line">            q.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (tcase--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">ceil</span>(<span class="number">1.0</span> * n * <span class="number">1.2</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Input cost: &quot;</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = q[lower_bound(q.begin(), q.end(), l) - q.begin()];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans - n &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">            &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就是先预处理完了所有的回文，然后根据输入去查找答案。</p><h3 id="d---soccer-standings">D - <a href="https://ac.nowcoder.com/acm/contest/12794/D">Soccer Standings</a></h3><p>运算符重载题，当然前提是你读完了那又臭又长的题面描述：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n, t, g;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">using</span> team = tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ss;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; val;</span><br><span class="line">    <span class="built_in">vector</span>&lt;team&gt; cnt;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> init = [&amp;]</span><br><span class="line">    &#123;</span><br><span class="line">        ss.clear(), val.clear();</span><br><span class="line">        cnt.clear();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cmp = []</span><br><span class="line">    (<span class="keyword">const</span> team &amp;a, <span class="keyword">const</span> team &amp;b) -&gt; <span class="keyword">bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;[ano, a1, a0, aw, at, al, apt] = a;</span><br><span class="line">        <span class="keyword">auto</span> &amp;[bno, b1, b0, bw, bt, bl, bpt] = b;</span><br><span class="line">        <span class="keyword">auto</span> ad = a1 - a0, bd = b1 - b0;</span><br><span class="line">        <span class="keyword">if</span> (apt != bpt) <span class="keyword">return</span> apt &gt; bpt;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ad != bd) <span class="keyword">return</span> ad &gt; bd;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a1 != b1) <span class="keyword">return</span> a1 &gt; b1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> ano &lt; bno;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">string</span> s, a, b; <span class="keyword">int</span> aa, bb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t &gt;&gt; g;</span><br><span class="line">        <span class="keyword">while</span> (t --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            ss.push_back(s);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(ss.begin(), ss.end());</span><br><span class="line">        t = ss.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; ++ i)</span><br><span class="line">            val[ss[i]] = i,</span><br><span class="line">            cnt.emplace_back(i, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);    </span><br><span class="line">        <span class="keyword">while</span> (g --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; aa</span><br><span class="line">                &gt;&gt; b &gt;&gt; bb;</span><br><span class="line">            <span class="keyword">int</span> aaa = val[a], bbb = val[b];</span><br><span class="line">            <span class="keyword">auto</span> &amp;[ano, a1, a0, aw, at, al, apt] = cnt[aaa];</span><br><span class="line">            <span class="keyword">auto</span> &amp;[bno, b1, b0, bw, bt, bl, bpt] = cnt[bbb];</span><br><span class="line">            a1 += aa, b0 += aa, b1 += bb, a0 += bb;</span><br><span class="line">            <span class="keyword">if</span> (aa &gt; bb)</span><br><span class="line">            &#123;</span><br><span class="line">                ++ aw, ++ bl;</span><br><span class="line">                apt += <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (aa &lt; bb)</span><br><span class="line">            &#123;</span><br><span class="line">                ++ bw, ++ al;</span><br><span class="line">                bpt += <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> ++ at, ++ bt, ++ apt, ++ bpt;</span><br><span class="line">        &#125;   </span><br><span class="line">        sort(cnt.begin(), cnt.end(), cmp);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Group &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;:\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ii : cnt)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> [no, _1, _0, win, tie, lose, pt] = ii;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ss[no] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; pt &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; win &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">                 &lt;&lt; lose &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; tie &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; _1 &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">                 &lt;&lt; _0 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确实，属性并不是都同号的 :-)</p><h3 id="e---nih-budget">E - <a href="https://ac.nowcoder.com/acm/contest/12794/E">NIH Budget</a></h3><p>本场为数不多的有点技术含量的题目之一——不过是个背包板子；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, 4&gt; info[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n = scanner.nextInt(), d, b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        scanner(d, b);</span><br><span class="line">        <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (b + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; d; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[cost, save] : info[j])</span><br><span class="line">                scanner(cost, save);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; d; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = b; x &gt;= <span class="number">0</span>; -- x)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[cost, save] : info[j])</span><br><span class="line">                    <span class="keyword">if</span> (x - cost &gt;= <span class="number">0</span>)</span><br><span class="line">                        maximize(dp[x], dp[x - cost] + save);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Budget #&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: Maximum of &quot;</span> &lt;&lt; dp[b]</span><br><span class="line">             &lt;&lt; <span class="string">&quot; lives saved.&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不会有人不会写背包吧，<del>不会这个人就是我自己吧（逃</del></p><h3 id="f---interstellar-love">F - <a href="https://ac.nowcoder.com/acm/contest/12794/F">Interstellar Love</a></h3><p>并查集；注意只有一个的星星的连通块不是一个星座</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> DSU</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> fa[N], siz[N], cnt[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">            fa[i] = i, siz[i] = <span class="number">1</span>, cnt[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">father</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> fa[u] == u ? u : (fa[u] = father(fa[u]));&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fx = father(x), fy = father(y);</span><br><span class="line">        <span class="keyword">if</span> (fx == fy) <span class="keyword">return</span> <span class="keyword">void</span>(cnt[fx] ++);</span><br><span class="line">        <span class="keyword">if</span> (siz[fx] &lt;= siz[fy]) </span><br><span class="line">            fa[fx] = fy, siz[fy] += siz[fx], </span><br><span class="line">            cnt[fy] += cnt[fx] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> fa[fy] = fx, siz[fx] += siz[fy], </span><br><span class="line">            cnt[fx] += cnt[fy] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> tt = <span class="number">1</span>; tt &lt;= n; ++ tt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> s = scanner.nextInt(),</span><br><span class="line">            c = scanner.nextInt();</span><br><span class="line">        DSU::init(s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (c --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = scanner.nextInt(), </span><br><span class="line">                v = scanner.nextInt();</span><br><span class="line">            DSU::join(u, v);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">bitset</span>&lt;N&gt; star, fix;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> fa = DSU::father(i);</span><br><span class="line">            <span class="keyword">auto</span> e = DSU::cnt[fa], v = DSU::siz[fa];</span><br><span class="line">            <span class="keyword">if</span> (v &lt;= <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            star.<span class="built_in">set</span>(fa);</span><br><span class="line">            <span class="keyword">if</span> (e &gt;= v) fix.<span class="built_in">set</span>(fa);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Night sky #&quot;</span> &lt;&lt; tt &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; star.count()</span><br><span class="line">             &lt;&lt; <span class="string">&quot; constellations, of which &quot;</span> &lt;&lt; fix.count()</span><br><span class="line">             &lt;&lt; <span class="string">&quot; need to be fixed.&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&amp;id=1423038384&amp;auto=0&amp;height=66"></iframe><h3 id="g---plate-spinning">G - <a href="https://ac.nowcoder.com/acm/contest/12794/G">Plate Spinning</a></h3><p>虽然没什么内容但是被恶心到了…… 需要特判当只有一个盘子的时候始终可行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt(),</span><br><span class="line">            m = scanner.nextInt();</span><br><span class="line">        <span class="keyword">auto</span> t = <span class="number">1.0</span> * n * <span class="number">0.5</span> * <span class="number">5</span>;</span><br><span class="line">        print(<span class="string">&quot;Circus Act &quot;</span>, i, <span class="string">&quot;:\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || t &lt;= <span class="number">1.0</span> * m)</span><br><span class="line">            println(<span class="string">&quot;Chester can do it!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> println(<span class="string">&quot;Chester will fail!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这一个题就奉献了快两个小时的罚时（）</p><h3 id="h---the-eternal-quest-for-caffeine">H - <a href="https://ac.nowcoder.com/acm/contest/12794/H">The Eternal Quest for Caffeine</a></h3><p>除了单程往返，还要考虑源点在中间，路径绕一个环的情况；我最开始的时候就没有考虑那种情况，所以莽了（）后来队友给我改成了遍历一个段，就对了（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">16</span>;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="built_in">bitset</span>&lt;N&gt;, N&gt; machine;</span><br><span class="line"><span class="built_in">bitset</span>&lt;N&gt; ok;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n, s, m, t, x;</span><br><span class="line">    <span class="keyword">char</span> state;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> T = <span class="number">1</span>; T; ++T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; s &gt;&gt; m;</span><br><span class="line">        <span class="keyword">if</span> (!n &amp;&amp; !s &amp;&amp; !m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ii : machine) ii.reset();</span><br><span class="line">        ok.reset();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">            <span class="keyword">while</span> (t--) <span class="built_in">cin</span> &gt;&gt; x, machine[i].<span class="built_in">set</span>(x);</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; state;</span><br><span class="line">            <span class="keyword">if</span> (state == <span class="string">&#x27;Y&#x27;</span>) ok.<span class="built_in">set</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">bool</span> haveSource = <span class="literal">false</span>, flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">bitset</span>&lt;N&gt; tmp;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; ++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    tmp |= machine[k];</span><br><span class="line">                    <span class="keyword">if</span> (k == s) haveSource = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (ok[k]) flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (haveSource &amp;&amp; flag &amp;&amp; tmp.count() == m)</span><br><span class="line">                    ans = min(ans, (j - i) * <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Test case #&quot;</span> &lt;&lt; T &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; <span class="number">0x3f3f3f3f</span>) <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Impossible&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然是队友给我改过的，但是这也算是我过的吧（</p><h3 id="i---pegasus-circle-shortcut">I - <a href="https://ac.nowcoder.com/acm/contest/12794/I">Pegasus Circle Shortcut</a></h3><p>平面几何运算板子题：对着题目嗯模拟就成了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Geo &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">double</span> cx, cy, sx, sy, tx, ty;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span> ans[] = &#123;<span class="string">&quot;Stick to the Circle.&quot;</span>, <span class="string">&quot;Watch out for squirrels!&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">using</span> Geo::point, Geo::number;</span><br><span class="line">    <span class="keyword">const</span> number PI = <span class="number">3.1415926535897932384626</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> T = <span class="number">1</span>, n; T; ++ T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; cx &gt;&gt; cy &gt;&gt; sx &gt;&gt; sy &gt;&gt; tx &gt;&gt; ty;</span><br><span class="line">        <span class="keyword">if</span> (cx == <span class="number">0.</span> &amp;&amp; cy == <span class="number">0.</span> &amp;&amp; sx == <span class="number">0.</span> &amp;&amp;</span><br><span class="line">            sy == <span class="number">0.</span> &amp;&amp; tx == <span class="number">0.</span> &amp;&amp; ty == <span class="number">0.</span>) <span class="keyword">break</span>;</span><br><span class="line">        point s(sx, sy), t(tx, ty), c(cx, cy);    </span><br><span class="line">        point last(sx, sy), now;</span><br><span class="line">        number interior = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">cin</span> &gt;&gt; n; n --;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; now.x &gt;&gt; now.y;</span><br><span class="line">            interior += now.distance(last);</span><br><span class="line">            last = now;</span><br><span class="line">        &#125; interior += t.distance(last);</span><br><span class="line">        <span class="keyword">auto</span> str0 = s - c, str1 = t - c;</span><br><span class="line">        <span class="keyword">auto</span> ang = <span class="built_in">abs</span>(str0.angle() - str1.angle());</span><br><span class="line">        number d = c.distance(s) + c.distance(t);</span><br><span class="line">        minimize(ang, <span class="number">2</span> * PI - ang);</span><br><span class="line">        number circular = d * ang / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">bool</span> ok = Geo::compareTo(interior, circular) &lt;= <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; T &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans[ok] &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，前提是要有靠谱的板子。</p><h3 id="j---lowest-common-ancestor">J - <a href="https://ac.nowcoder.com/acm/contest/12794/J">Lowest Common Ancestor</a></h3><p>用数组模拟二叉树，给定两个下标求它们的 LCA 的下标；很显然，用数组模拟二叉树的子节点就是 <code>&lt;&lt;= 1</code>；所以 LCA 显然就是在二进制表示下两个节点下标的公共前缀代表的下标。</p><p>问题就是题目给的还是恶心的 16 进制；我队友拿 Python 写过了，但是我尝试拿 C++ 写崩了…… 所以最后屈服于 Java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">int</span> T = sc.nextInt();</span><br><span class="line">    sc.nextLine();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= T; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> line = sc.nextLine();</span><br><span class="line">            <span class="keyword">var</span> ab = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">var</span> a = <span class="keyword">new</span> BigInteger(ab[<span class="number">0</span>], <span class="number">16</span>);</span><br><span class="line">            <span class="keyword">var</span> b = <span class="keyword">new</span> BigInteger(ab[<span class="number">1</span>], <span class="number">16</span>);</span><br><span class="line">            <span class="keyword">var</span> aa = a.toString(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">var</span> bb = b.toString(<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">int</span> lim = Math.min(aa.length(), bb.length());</span><br><span class="line">            <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (cur &lt; lim &amp;&amp;</span><br><span class="line">                aa.charAt(cur) == bb.charAt(cur))</span><br><span class="line">                ++ cur;</span><br><span class="line">            <span class="keyword">var</span> prefix = aa.substring(<span class="number">0</span>, cur);</span><br><span class="line">            <span class="keyword">var</span> c = <span class="keyword">new</span> BigInteger(prefix, <span class="number">2</span>);</span><br><span class="line">            System.out.printf(<span class="string">&quot;Case #%d: %s\n\n&quot;</span>, i, c.toString(<span class="number">16</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🐎的，在 C++ 我都不用 <code>printf</code>，在 Java 里却用的一身的劲儿（</p><p>特别注意：因为 ACM 是只保证有 Java 8 的，所以上面的代码过不了编译（</p><h2 id="后记">后记</h2><p>没什么好说的…… 只能说这样的比赛差不多得了，好自为之（）</p><figure><img src="https://i.loli.net/2021/03/15/PXnUOMxQRc64CDW.jpg" class="lazyload" data-srcset="https://i.loli.net/2021/03/15/PXnUOMxQRc64CDW.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="H10~JZ__G1_PZGUP1YLLUJ2.jpg" /><figcaption aria-hidden="true">H10~JZ__G1_PZGUP1YLLUJ2.jpg</figcaption></figure><p>但是打的还是有那么一点点捞；要是模拟题写的这么慢准度这么差那我也差不多得了（</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Nowcoder </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round#705 div.2 回顾</title>
      <link href="/2021/codeforces-round-705-div2/"/>
      <url>/2021/codeforces-round-705-div2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>补题链接：<a href="https://codeforces.com/contest/1493/" class="uri">https://codeforces.com/contest/1493/</a></p></blockquote><h2 id="记录">记录</h2><p>很捞，ABC 选手都没有当成，属是不是很行（</p><figure><img src="https://i.loli.net/2021/03/13/AbGmrYDnZPVaLiy.jpg" class="lazyload" data-srcset="https://i.loli.net/2021/03/13/AbGmrYDnZPVaLiy.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="a.jpg" /><figcaption aria-hidden="true">a.jpg</figcaption></figure><p>补了题之后发现这场甚至还算比较简单的，肺都气炸（</p><h2 id="题解">题解</h2><h3 id="a---anti-knapsack">A - <a href="https://codeforces.com/contest/1493/problem/A">Anti-knapsack</a></h3><blockquote><p>给定 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(k\)</span>，要求选出最大的子集 <span class="math inline">\(S \subset [1, n]\)</span>，使得不存在集合 <span class="math inline">\(T \subseteq S\)</span> 满足 <span class="math inline">\(\sum_{i \in T}i = k\)</span>；</p></blockquote><p>明明是个签到题但是我却白给一发；最开始写的是由前缀和小于 k 的数字构成小于 k 的部分，但是仔细想想就会发现这个数字集合显然不如 <code>k / 2</code> 大==</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt();</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n, k;</span><br><span class="line">        $$ n, k;</span><br><span class="line">        <span class="keyword">int</span> ans = n - k + k / <span class="number">2</span>;</span><br><span class="line">        println(ans);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (k + <span class="number">1</span>) / <span class="number">2</span>; i &lt; k; ++ i)</span><br><span class="line">            print(i, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k + <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            print(i, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日常脑瘫操作（</p><h3 id="b---planet-lapituletti">B - <a href="https://codeforces.com/contest/1493/problem/B">Planet Lapituletti</a></h3><p>纯暴力就行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fast_read</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">fast_read</span> <span class="title">operator</span>, (<span class="title">name</span> &amp;<span class="title">x</span>)</span></span><br><span class="line"><span class="class">    &#123;</span>scanner(x); <span class="keyword">return</span> fast_read&#123;&#125;;&#125;</span><br><span class="line">&#125; fastRead;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> $$ fastRead,</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> trans[] = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;-&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mirror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, <span class="keyword">char</span> *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;:&#x27;</span>) t[<span class="number">4</span> - i] = <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span> t[<span class="number">4</span> - i] = trans[s[i] - <span class="string">&#x27;0&#x27;</span>];</span><br><span class="line">    t[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">turn</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> H = (s[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + s[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">        M = (s[<span class="number">3</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + s[<span class="number">4</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(H, M);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">(<span class="keyword">int</span> H, <span class="keyword">int</span> M, <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s[<span class="number">0</span>] = H / <span class="number">10</span> % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    s[<span class="number">1</span>] = H % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    s[<span class="number">3</span>] = M / <span class="number">10</span> % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    s[<span class="number">4</span>] = M % <span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    s[<span class="number">2</span>] = <span class="string">&#x27;:&#x27;</span>, s[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt(), h, m;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> validator =</span><br><span class="line">    [&amp;](<span class="keyword">const</span> <span class="keyword">char</span> *s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">auto</span> [H, M] = turn(s);</span><br><span class="line">        <span class="keyword">return</span> H &gt;= <span class="number">0</span> &amp;&amp; H &lt; h &amp;&amp; M &gt;= <span class="number">0</span> &amp;&amp; M &lt; m;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> tik =</span><br><span class="line">    [&amp;](<span class="keyword">char</span> *s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [H, M] = turn(s);</span><br><span class="line">        ++ M; H = (H + M / m) % h;</span><br><span class="line">        M %= m;</span><br><span class="line">        make(H, M, s);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> s[<span class="number">6</span>], t[<span class="number">6</span>];</span><br><span class="line">        $$ h, m, s;</span><br><span class="line">        mirror(s, t);</span><br><span class="line">        <span class="keyword">while</span> (!validator(t))</span><br><span class="line">            tik(s), mirror(s, t);</span><br><span class="line">        println(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是代码有点花里胡哨</p><h3 id="c---k-beautiful-strings">C - <a href="https://codeforces.com/contest/1493/problem/C">K-beautiful Strings</a></h3><blockquote><p>定义<strong>K-美丽</strong>的字符串：字符串中所有出现的字符的出现次数都是 k 的整数倍；</p><p>现在给 <span class="math inline">\(n \leq 10^5\)</span> 和 <span class="math inline">\(k \leq n\)</span>，问可以得到的字典序最小但是字典序大于等于原串的的<strong>K-美丽</strong>的字符串；如果这样的字符串不存在，输出 <code>-1</code>；</p></blockquote><p>怎么说呢，首先需要明确以下几点：</p><ul><li>只有字符串长度为 K 的倍数的字符串才有可能成为题目要求的字符串</li><li>因为满足要求的字符串字典序要比原串大，所以尽可能小的唯一方法是尽可能地保留前缀</li><li>同上，保留前缀后的第一位的字符一定要大于等于原串对应位置的字符</li></ul><p>综上所述，我们可以得到一种<del>优雅</del>并且正确的写法：</p><ul><li>如果原串已经是一个 K - 美丽的字符串了，就直接输出</li><li>倒序遍历可能维护的前缀长度，并维护前缀不同字符的出现次数</li><li>尝试将前缀后的第一个字符修改为任何大于原串的字符</li><li>判断除去该字符的后缀能否和前面的已确定字符组成 K - 美丽字符串</li></ul><p>然后就可以写出这个题的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fast_read</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">fast_read</span> <span class="title">operator</span>, (<span class="title">name</span> &amp;<span class="title">x</span>)</span></span><br><span class="line"><span class="class">    &#123;</span>scanner(x); <span class="keyword">return</span> fast_read&#123;&#125;;&#125;</span><br><span class="line">&#125; fastRead;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> $$ fastRead,</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">char</span> s[N], app[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt(), n, k, need;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> stillNeed =</span><br><span class="line">    [&amp;](<span class="keyword">int</span> x) &#123;<span class="keyword">return</span> (k - x % k) % k;&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> alter =</span><br><span class="line">    [&amp;](<span class="keyword">char</span> ch, <span class="keyword">int</span> delta)</span><br><span class="line">    &#123;</span><br><span class="line">        need -= stillNeed(cnt[ch - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">        cnt[ch - <span class="string">&#x27;a&#x27;</span>] += delta;</span><br><span class="line">        need += stillNeed(cnt[ch - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        $$ n, k;</span><br><span class="line">        <span class="keyword">if</span> (n % k) &#123;println(<span class="number">-1</span>); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">        $$ s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">            ++ cnt[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = need = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++ i)</span><br><span class="line">            need += stillNeed(cnt[i]);</span><br><span class="line">        <span class="keyword">if</span> (!need) &#123;println(s); <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">        &#123;</span><br><span class="line">            alter(s[i], <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> alt = s[i] + <span class="number">1</span>; alt &lt;= <span class="string">&#x27;z&#x27;</span>; ++ alt)</span><br><span class="line">            &#123;</span><br><span class="line">                alter(alt, +<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (i + need &lt; n)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++ j)</span><br><span class="line">                        print(s[j]);</span><br><span class="line">                    print((<span class="keyword">char</span>)alt);</span><br><span class="line">                    <span class="keyword">int</span> cur = <span class="number">0</span>, res = n - i - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">char</span> ch = <span class="string">&#x27;a&#x27;</span>; ch &lt;= <span class="string">&#x27;z&#x27;</span>; ++ ch)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> m = stillNeed(cnt[ch - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">                        res -= m;</span><br><span class="line">                        <span class="keyword">while</span> (m --) app[cur ++] = ch;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span> (res --) app[cur ++] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                    app[cur] = <span class="number">0</span>;</span><br><span class="line">                    sort(app, app + cur);</span><br><span class="line">                    println(app);</span><br><span class="line">                    <span class="keyword">goto</span> complete;</span><br><span class="line">                &#125;</span><br><span class="line">                alter(alt, <span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        complete: <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上也没有那么多需要注意的地方，关键就在于最开始写代码的思路是否正确）如果抓着修改字符来看的话，代码会难想而且难写许多，浪费比赛时间。</p><h3 id="d---gcd-of-an-array">D - <a href="https://codeforces.com/contest/1493/problem/D">GCD of an Array</a></h3><blockquote><p>给一个长度为 <span class="math inline">\(n \leq 2 \cdot 10^5\)</span> 的数组 <span class="math inline">\(a\)</span>，满足 <span class="math inline">\(a_i \leq 2 \cdot 10^5\)</span>；</p><p>然后对这个数组进行 <span class="math inline">\(q \leq 2 \cdot 10^5\)</span> 次操作：单点修改为原来的 <span class="math inline">\(x\)</span> 倍，且 <span class="math inline">\(x \leq 2 \cdot 10^5\)</span>；</p><p>在每次操作后，要求输出现在数组的 gcd 对于 <code>1e9 + 7</code> 的模数。</p></blockquote><p>STL 嗯做题：首先要意识到将所有的 <span class="math inline">\(a_i\)</span> 分解成 <span class="math inline">\(\prod p_j^{k_i}\)</span> 的形式，那么 GCD 可以表示为 <span class="math inline">\(\prod p_j^{\textrm{min}k_i}\)</span>；又因为修改只有单点倍增，GCD 只会有增无减；所以可以考虑用 STL 维护每个数组成员的分解结果，以及整个数组每个质因子的分解结果集合，需要支持查询最小值；</p><p>这样，每当进行单点修改时，我们就可以通过更新分解结果，然后更新数组质因子的维护结果，并借此更新答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> $$ fastRead,</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> n&gt; <span class="function"><span class="keyword">auto</span> &amp;<span class="title">EulerSieve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">array</span>&lt;<span class="keyword">int</span>, n + 1&gt; vis;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            prime.push_back(i), vis[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; pp : prime)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((longs)i * pp &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            vis[i * pp] = pp;</span><br><span class="line">            <span class="keyword">if</span> (i % pp == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">longs <span class="title">fastPow</span><span class="params">(longs a, ulongs b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    longs ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1u</span>) ans = (ans * a) % mod;</span><br><span class="line">        a = (a * a) % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1u</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n, q, a;</span><br><span class="line">    longs ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> pp = EulerSieve&lt;N&gt;();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; part;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;&gt; maintain;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> update =</span><br><span class="line">    [&amp;](<span class="keyword">int</span> div, <span class="keyword">int</span> last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (maintain[div].size() != n) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> now = *maintain[div].begin();</span><br><span class="line">        ans = ans * fastPow(div, now - last) % mod;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> alter =</span><br><span class="line">    [&amp;](<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span> != x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> div = pp[x], cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (div == pp[x])</span><br><span class="line">                ++ cnt, x /= div;</span><br><span class="line">            <span class="keyword">auto</span> old = part[i][div];</span><br><span class="line">            part[i][div] += cnt;</span><br><span class="line">            <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (maintain[div].size() == n)</span><br><span class="line">                last = *maintain[div].begin();</span><br><span class="line">            <span class="keyword">if</span> (old)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = maintain[div].find(old);</span><br><span class="line">                maintain[div].erase(it);</span><br><span class="line">            &#125;</span><br><span class="line">            maintain[div].insert(old + cnt);</span><br><span class="line">            update(div, last);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    $$ n, q, part.resize(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) $$ a, alter(i, a);</span><br><span class="line">    <span class="keyword">int</span> i, x;</span><br><span class="line">    <span class="keyword">while</span> (q --) $$ i, x, alter(i, x), println(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="e---enormous-xor">E - <a href="https://codeforces.com/contest/1493/problem/E">Enormous XOR</a></h3><blockquote><p>对于两个大整数 <span class="math inline">\(l\)</span> 和 <span class="math inline">\(r\)</span>（<span class="math inline">\(l \leq r\)</span>），定义函数： <span class="math inline">\(G_{l, r} = \bigoplus_{i=l}^ri\)</span>，<span class="math inline">\(F _ {l, r} = \mathrm{max} _ {l \leq x \leq y \leq r} G _ {x, y}\)</span>；</p><p>现在给定 <span class="math inline">\(l\)</span> 和 <span class="math inline">\(r\)</span> 的二进制表示形式（<span class="math inline">\(l \leq r &lt; 2^{10^6}\)</span>）；要求求出 <span class="math inline">\(F_{l, r}\)</span> 的值。</p></blockquote><p>抖机灵题：令 <span class="math inline">\(l\)</span> 和 <span class="math inline">\(r\)</span> 的最高位分别为 <span class="math inline">\(H_l\)</span>，<span class="math inline">\(H_r\)</span>；</p><p>如果 <span class="math inline">\(H_l \ne H_r\)</span>，那么显然有 <span class="math inline">\(F_{l, r} = 2^{H_r + 1} - 1\)</span>：因为 <span class="math inline">\(2^{H_r},\ 2^{H_r} - 1 \in [l, r]\)</span> 显然成立，而 <span class="math inline">\(2^{H_r} \oplus (2^{H_r} - 1) = 2^{H_r + 1} - 1\)</span>；否则，答案至少有最大值 <span class="math inline">\(r\)</span>；考虑选出答案的区间：为了保持可能存在的最高位存在，得到答案的区间 <span class="math inline">\([x, y]\)</span> 的大小必定是奇数；且不难想到其中 <span class="math inline">\(y = r\)</span>；</p><p>我们考虑 <span class="math inline">\(r\)</span> 的奇偶性：</p><ul><li>如果 <span class="math inline">\(r\)</span> 为奇数，因此除了最大的一个数字之后，最大的数字是 <span class="math inline">\(r - 1\)</span>——除了奇数位之外和 <span class="math inline">\(r\)</span> 完全一致；不难发现区间中的数字是成对出现的，因此 <span class="math inline">\(r\)</span> 能确定保留的位只有奇数位，不如 <span class="math inline">\(r\)</span> 优；</li><li>如果 <span class="math inline">\(r\)</span> 为偶数，同理，显然最低位（奇偶位）必然为 1，所以异或值为 <span class="math inline">\(r + 1\)</span>，更优；</li></ul><p>但是以上操作都要建立在区间 <span class="math inline">\([l, r]\)</span> 允许的情况下；如果允许区间小于 3，则无法进行上述操作，答案为 <span class="math inline">\(r\)</span>；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> $$ fastRead,</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> l[N], r[N], ans[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">    $$ l, r;</span><br><span class="line">    <span class="keyword">int</span> hl = <span class="number">0</span>, hr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l[hl] != <span class="string">&#x27;1&#x27;</span>) ++ hl;</span><br><span class="line">    <span class="keyword">while</span> (r[hr] != <span class="string">&#x27;1&#x27;</span>) ++ hr;</span><br><span class="line">    <span class="keyword">if</span> (hl != hr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = min(hl, hr); i &lt; n; ++ i)</span><br><span class="line">            ans[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min(hl, hr); ++ i)</span><br><span class="line">            ans[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ans[n] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (r[n - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        <span class="built_in">memcpy</span>(ans, r, <span class="keyword">sizeof</span> ans);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(tmp, r, <span class="keyword">sizeof</span> tmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">            <span class="keyword">if</span> (tmp[i] == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">            &#123;tmp[i] = <span class="string">&#x27;0&#x27;</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span> tmp[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(ans, r, <span class="keyword">sizeof</span> ans);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(tmp, l) &gt;= <span class="number">0</span>) ans[n - <span class="number">1</span>] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    println(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="f---enchanted-matrix">F - <a href="https://codeforces.com/contest/1493/problem/F">Enchanted Matrix</a></h3><blockquote><p>这是一个交互题；有一个 <span class="math inline">\(n \times m\)</span> 的矩阵，求合法的 <span class="math inline">\((x, y)\)</span> 的数对个数：</p><p>合法的 <span class="math inline">\((x, y)\)</span> 数对的定义：可以将原矩阵完整的划分为一些 <span class="math inline">\(x \times y\)</span> 的子矩阵，这些子矩阵相等。</p><p>最多可以询问 <span class="math inline">\(3 \cdot \lfloor \textrm{log}_2(n + m) \rfloor\)</span> 次两个不相交的子矩阵是否相等。</p></blockquote><h4 id="分析">分析</h4><p>首先可以意识到这个问题中行列是互相独立的问题：显然有 <code>[x, y] === [x, m] &amp;&amp; [n, y]</code></p><p>然后再一个显然的就是要求出这个数对，必须要先求出行列方向上的最短循环节，再由循环节凑出其他的答案——这是一个很常见的套路：串的分多段全等的问题可以转化为找它的最短循环节。</p><hr /><p>如何在单维（也就是一个串）中寻找最短的循环节呢？我们首先利用筛预处理出范围内整数的质因数分解，然后以每一个质因数作为本次分段数，在上一次分割后的循环节上进行尝试；最后剩下的没有被除去的质因数的乘积就是最短循环节的长度。</p><hr /><p>那么如何判断分出的段在当前串中是否是循环节呢？</p><p>首先，如果不考虑重叠的限制条件，对于任何串的候选循环节；我们先令该串包含了 <span class="math inline">\(L\)</span> 个候选循环节，候选循环节的长度为 <span class="math inline">\(x\)</span>：这样，我们只需要比较原串长度为 <span class="math inline">\((L - 1)x\)</span> 的前缀和长度为 <span class="math inline">\((L - 1)x\)</span> 的后缀是否相等即可；也就是前 <span class="math inline">\(L - 1\)</span> 节和后 <span class="math inline">\(L - 1\)</span> 节是否相等；这也是很容易证明的；</p><p>但是题目限制了不允许询问重叠的区间，所以上述做法在这并不可行；但是我们还是可以基于这种思路，采用迂回的办法来完成询问；因为我们每次都是对于一个串（原串或者已经被分割后的），使用它长度的质因数来作为划分段数；令划分的段数为 <span class="math inline">\(L\)</span>，这里的段显然和上面说的候选循环节由相同的意义。</p><p>因为 <span class="math inline">\(L\)</span> 是质因数，所以只有可能是两种情况：</p><ul><li><span class="math inline">\(L = 2\)</span>，此时直接询问两段是否相等即可；</li><li><span class="math inline">\(L &gt; 2\)</span>，此时 <span class="math inline">\(L\)</span> 必定是奇数；令 <span class="math inline">\(l = \lfloor \frac{L}2 \rfloor\)</span>；<ul><li>我们选取前 <span class="math inline">\(l\)</span> 段作为中转，那么还剩下连续的 <span class="math inline">\(l + 1\)</span> 段</li><li>剩下的 <span class="math inline">\(l + 1\)</span> 段也是奇数，可以使用最初说的方法进行判断</li><li>但是我们不直接比较重叠的两段，而是让它们分别于前面选出的中转段进行比较</li></ul></li><li>这样就可以在 2 次询问之内判断一个候选循环节是否是串的循环节</li></ul><p>综上所述，我们就可以在题目规定的询问次数之内完成最小循环节的求解了；</p><hr /><p>还需要特别注意的是，答案并不是最小循环节划分的段数的乘积；而是划分段数的因数个数的乘积。</p><h4 id="代码">代码</h4><p>下面代码的欧拉筛以经过修改：可以使用代码中的办法从小到大地获取一个整数的质因数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> w, <span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; h &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; w &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x1 &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">         &lt;&lt; y1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x2 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp; <span class="built_in">cin</span> &gt;&gt; tmp; <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> n&gt; <span class="function"><span class="keyword">auto</span> &amp;<span class="title">sieve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">array</span>&lt;<span class="keyword">int</span>, n + 1&gt; vis;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            prime.push_back(i), vis[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; pp : prime)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((longs)i * pp &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            vis[i * pp] = pp;</span><br><span class="line">            <span class="keyword">if</span> (i % pp == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">auto</span> p = sieve&lt;N&gt;();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> askM =</span><br><span class="line">    [&amp;](<span class="keyword">int</span> len, <span class="keyword">int</span> time) -&gt; <span class="keyword">bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> h = n, w = time / <span class="number">2</span> * len;</span><br><span class="line">        <span class="keyword">if</span> (time == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> ask(h, w, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, w + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span></span><br><span class="line">            ask(h, w, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, w + <span class="number">1</span>) &amp;&amp;</span><br><span class="line">            ask(h, w, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, w + len + <span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> askN =</span><br><span class="line">    [&amp;](<span class="keyword">int</span> len, <span class="keyword">int</span> time) -&gt; <span class="keyword">bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> h = time / <span class="number">2</span> * len, w = m;</span><br><span class="line">        <span class="keyword">if</span> (time == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> ask(h, w, h + <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span></span><br><span class="line">            ask(h, w, h + <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>) &amp;&amp;</span><br><span class="line">            ask(h, w, h + len + <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">auto</span> [nn, mm] = <span class="built_in">make_pair</span>(n, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nn; i &gt; <span class="number">1</span>; i /= p[i])</span><br><span class="line">        <span class="keyword">if</span> (askN(nn / p[i], p[i])) nn /= p[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mm; i &gt; <span class="number">1</span>; i /= p[i])</span><br><span class="line">        <span class="keyword">if</span> (askM(mm / p[i], p[i])) mm /= p[i];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> nt = n / nn, mt = m / mm; </span><br><span class="line">    longs np = <span class="number">0</span>, mp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nt; ++ i) np += !(nt % i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= mt; ++ i) mp += !(mt % i);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;! &quot;</span> &lt;&lt; np * mp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后不能直接输出 <code>nt * mt</code>！</p><h2 id="后记">后记</h2><h3 id="参考资料">参考资料</h3><ul><li><a href="https://www.cnblogs.com/zjjws/p/14500255.html" class="uri">https://www.cnblogs.com/zjjws/p/14500255.html</a></li><li><a href="https://codeforces.com/blog/entry/88422" class="uri">https://codeforces.com/blog/entry/88422</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用又拍云联盟作为博客的图床</title>
      <link href="/2021/use-upyun-free-service-to-host-a-image-service/"/>
      <url>/2021/use-upyun-free-service-to-host-a-image-service/</url>
      
        <content type="html"><![CDATA[<p>当然，现在市面上已经有了一些既可以白嫖而且质量不错的免费图床，可以为我们的静态博客提供图片存储服务：比如 <a href="https://sm.ms/">SM.MS</a> 和 <a href="https://7bu.top/">去不图床</a> <del>和 Github</del>；但是把图片放在别人的图床上总觉得不太安定，再加上<a href="https://www.upyun.com/">又拍云</a>长期有活动赠送 10 GB 存储空间和 15 GB 流量每月，所以考虑利用又拍云搭建一个个人图床。</p><h2 id="申请又拍云联盟">申请又拍云联盟</h2><p>首先前往又拍云注册账号，然后进入<a href="https://www.upyun.com/league">又拍云联盟</a>的活动页面选择申请；</p><p>申请又拍云联盟唯二的要求是实名和将又拍云的 logo 置于一个你的网站的底部，大概就像这样：</p><center><small><p align="center"><span>本网站由 <img src="https://cdn.jsdelivr.net/gh/YukiNoUta/cdn-static@main/blog/svg/upyun.svg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/YukiNoUta/cdn-static@main/blog/svg/upyun.svg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" width="53" height="18" style="fill: currentColor;"/> 提供 CDN 加速/云存储服务</span></p></small></center><p>如果你是使用 Hexo 等静态网站生成器生成你的个人网站，可以在你使用的主题的文档中寻找修改配置文件来自定义网站 footer 的方法；或者将下面的 HTML 片段增加到对应的布局文件中去：对于 Hexo 的大多数主题，这个文件往往是位于主题的 <code>layout</code> 目录下的 <code>layout.ejs</code> 或者 <code>footer.ejs</code> 中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>本网站由 <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/gh/YukiNoUta/cdn-static@main/blog/svg/upyun.svg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;53&quot;</span> <span class="attr">height</span>=<span class="string">&quot;18&quot;</span> <span class="attr">style</span>=<span class="string">&quot;fill: currentColor;&quot;</span>/&gt;</span> 提供 CDN 加速/云存储服务<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里使用的图片来源是我预置于 Github 上的；你也可以从官网下载它的 logo 并且至于一个可以访问的位置。</p><p>又拍云审核完了之后，你就应该会获得一张 67 元的代金券。</p><h2 id="开启服务">开启服务</h2><p>前往又拍云的<a href="https://console.upyun.com/dashboard/">控制台</a>，登录已经申请又拍云联盟的账号；在导航栏中的云产品下选择云存储服务；点击右上角的按钮创建新服务；为这个服务提供一个名字，就创建了一个存储桶。</p><figure><img src="https://i.loli.net/2021/03/05/fYApPS5gqtxHVbR.png" class="lazyload" data-srcset="https://i.loli.net/2021/03/05/fYApPS5gqtxHVbR.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="YJX_P7PQF_FH_N_XM8YUA.png" /><figcaption aria-hidden="true">YJX_P7PQF_FH_N_XM8Y<sub>U</sub>A.png</figcaption></figure><p>创建完成之后，就可以在你的控制台页面中看到你创建的存储桶：</p><figure><img src="https://i.loli.net/2021/03/05/fvCzbPMk5rIEdoH.png" class="lazyload" data-srcset="https://i.loli.net/2021/03/05/fvCzbPMk5rIEdoH.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="SLVV_B5T@QHB_2_WQH_HN5A.png" /><figcaption aria-hidden="true">SLVV_B5T@QHB_2_WQH_HN5A.png</figcaption></figure><p>然后进入刚创建的云存储服务，进行功能配置：</p><figure><img src="https://i.loli.net/2021/03/05/Vj8s3yfkEdgQUxS.png" class="lazyload" data-srcset="https://i.loli.net/2021/03/05/Vj8s3yfkEdgQUxS.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="3BQS_O_1S0CZKJ_P_4F_CV7.png" /><figcaption aria-hidden="true">3BQS_O_1S0CZKJ_P_4F_CV7.png</figcaption></figure><h3 id="配置操作员">配置操作员</h3><p>有了存储桶之后，还需要一个对这个存储桶拥有读写权限的主体才可以进行操作；在又拍云中，这个主体就是操作员；在功能配置中选择存储管理子项，下拉页面找到操作员授权选项，点击右侧按钮“授权”。</p><p>默认新用户是没有操作员的，需要先新建一个操作员身份；创建之后需要将网页生成的操作员的密钥保存备用，然后将存储桶的读写权限赋予操作员即可。操作完成后大概长这样：</p><figure><img src="https://i.loli.net/2021/03/05/sH7XKTvG4tibqhr.png" class="lazyload" data-srcset="https://i.loli.net/2021/03/05/sH7XKTvG4tibqhr.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O1R8UU_7S_5N___9BD_D_LU.png" /><figcaption aria-hidden="true">O1R8UU_7S_5N___9BD_D_LU.png</figcaption></figure><h3 id="防盗链设置">防盗链设置</h3><p>理论上现在已经可以使用刚创建的操作员身份上传图片了，但是还需要为我们的存储桶增加访问控制：云上服务的流量是有成本的，如果不做防盗链，我们的图片链接可能会被他人引用，从而产生不必要的流量。现在一般的云服务提供商的 OSS 服务都会提供防盗链的配置选项；又拍云的防盗链配置项在“访问控制”一栏中；找到并点击右侧的管理按钮进入配置：</p><figure><img src="https://i.loli.net/2021/03/05/OYW4ZUw6R2nyoil.png" class="lazyload" data-srcset="https://i.loli.net/2021/03/05/OYW4ZUw6R2nyoil.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="EG_ORH__6E__JC6JWVWO~F.png" /><figcaption aria-hidden="true">EG_ORH__6E__JC6JWVWO~F.png</figcaption></figure><p>需要注意的是：图中的通配符 <code>*.shiraha.cn</code> 和 <code>@</code>（也就是 <code>shiraha.cn</code>）并不等价；如果你和我一样直接使用 <code>@</code>，你需要额外增加一条允许的规则。</p><blockquote><h4 id="关于-referer-的科普"><strong>关于 Referer 的科普</strong></h4><p>Referer 是 HTTP 请求的 header 的一部分；当浏览器或者其他的软件要向 Web 服务器发起请求时，请求头中就包含了这一信息。它记录了当前页面的上一页面：打个比方，我从这个博客（<code>https://shiraha.cn</code>）点击了<a href="https://pages.shiraha.cn/gallery/">黄油画廊</a>，那么浏览器发起的请求中就可以看到我这个博客的地址：</p><figure><img src="https://i.loli.net/2021/03/05/Lm2eVtkuOQDjKyU.png" class="lazyload" data-srcset="https://i.loli.net/2021/03/05/Lm2eVtkuOQDjKyU.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="E6YSUL_CFW1BW@_MH____LD.png" /><figcaption aria-hidden="true">E6YSUL_CFW1BW@_MH____LD.png</figcaption></figure><p>上面的这个画面可以在任何现代浏览器的开发者工具-&gt; 网络栏目中看到。</p><p>轶闻：其实 Referer 本是 Referrer 在 HTTP/1.0 协议中的错误拼写<del>甚至现在还会被 Typora 和 Microsoft Editor 划线 Typo</del>，只是因为矫正成本过大才一直将错就错；然而现在已经被收录作为一个正确的词汇了<del>典型的鲁迅式将错就错</del></p><p>综上所述，一般情况下，我们可以使用 Referer 来判断我们的页面/链接是否被其他的网站所引用——或者说盗用了；在防盗链的时候，我们就可以拦截 Referer 不是我们想要的网址的请求，并且跳转到服务器想要跳转的页面去。</p><h5 id="关于空-referer">关于空 Referer</h5><p>空 Referer 的定义：<code>Referer === '' || Referer === null</code>；通俗的说，就是请求头中的 Refer 字段为空串或者不包含 Referer 字段。</p><p>前面已经说过了，Referer 的含义就是当前页面的上一个页面（请求的地址）；如果这个请求地址是不存在的话，Referer 字段自然就为空。当然，使用某些工具也可以造成这样的结果。</p><p>在防盗链中，如果设置了允许 Referer 为空，就意味着你<strong>允许</strong>浏览器或者重定向通过直接 URL 访问你的资源；如果不允许，那么这些请求将被拦截。</p></blockquote><p>一般来说我们通过白名单限制只有我们自有的域名来访问我们的存储桶；至于 <code>localhost</code> 则是取决于你是否希望在本地测试你的博客的时候访问你上传到图床的图片：如果不包含这条，你在本地运行你的静态博客的时候，这部分图片是无法加载的。Referer 的含义已经介绍了；但是就实际应用而言，不允许 Referer 为空会使得无法通过链接下载你的图片和 Typora 的预览。</p><figure><img src="https://i.loli.net/2021/03/05/OfHaBnyT8Izo1GP.png" class="lazyload" data-srcset="https://i.loli.net/2021/03/05/OfHaBnyT8Izo1GP.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="P_Z0LYI9_C0A_938NR_17.png" /><figcaption aria-hidden="true">P_Z0LYI<code>9_C0A_938NR_1</code>7.png</figcaption></figure><p>配置完了选择应用大概就会便乘上面的那个样子。</p><h3 id="绑定域名可选">绑定域名（可选）</h3><p>因为又拍云对于存储桶提供的只是一个测试域名；我们虽然可以通过这个域名访问我们的存储桶数据，但是又拍云并不保证我们可以长期使用这个域名；所以，如果你拥有一个二级域名，可以考虑将一个子域名分配给这个 OSS 服务，并且启用 SSL。当然，因为又拍云的服务在大陆，所以你使用的这个域名需要先行备案。</p><p>在功能配置页面的“域名管理”一栏中找到加速域名项，点击右边的域名绑定，就可以将一个已经有过 ICP 备案的域名绑定到这个服务中。至于 ICP 备案，它要求你（主体）需要拥有一台有公网 IP 地址的云服务器，所以你可能需要去各大云服务提供商的网站上看看了。</p><p>成功绑定后，你就可以在功能配置页面的“HTTPS”一栏找到 HTTPS 配置选项；点击右侧管理，就可以设置你绑定的域名的 HTTPS 设置：你可以开启强制 HTTPS 访问，这样就可以避免在开启了 HTTPS 博客中引用 HTTP 链接的图片可能导致的各种各样的问题。</p><p>开启 HTTPS 之前，你需要为你绑定的子域名申请一个 SSL 证书：很多云服务商在出售域名或者提供 DNS 服务的时候会提供配套的申请免费 TrustAsia 或者 Let's Encrypt 的证书，如果没有的话，你也可以直接在又拍云上申请；而这只需要遵循又拍云的页面指导就可以轻松完成，而且还是秒批（</p><h2 id="使用-picgo-客户端">使用 PicGo 客户端</h2><p>和一般的公开图床不同，我们需要直接或者通过 API 访问我们的存储桶，而不是一个直观的网页；如果每次上传图片都需要打开又拍云控制台必然是非常的麻烦的；一种比较方便的方法就是使用开源工具 <a href="https://picgo.github.io/">PicGo</a>。</p><h3 id="配置-picgo-访问又拍云">配置 PicGo 访问又拍云</h3><p>从官方网站中下载 PicGo 并成功安装之后运行：在左侧栏中找到图床设置 -&gt; 又拍云图床，会看到下面的画面：</p><figure><img src="https://i.loli.net/2021/03/05/IukCXoDlieWr5JE.png" class="lazyload" data-srcset="https://i.loli.net/2021/03/05/IukCXoDlieWr5JE.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="79_HOFOY9VPCWP6K9_4DDHY.png" /><figcaption aria-hidden="true">79_HOFOY9VPCWP6K9_4DDHY.png</figcaption></figure><p>其中前四项为必填项，分别要填入的内容是：又拍云服务名（存储桶名）、你授权的操作员名、网页生成的操作员密钥、又拍云提供的测试域名或你绑定的域名；为了方便管理，你也可以指定你通过 PicGo 上传的图片在存储桶的存储位置；“设定网址后缀”是又拍云提供的功能，可以自行探索（</p><p>填入信息并保存后，就可以将又拍云设置为默认图床，并上传图片进行测试了。</p><h3 id="连接-typora">连接 Typora</h3><p>较新版本的 Typora 支持插入图片式自动通过 PicGo 上传，所以在开始本步骤之前需要先确保你使用的 Typora 是新版本：否则请先前往<a href="https://typora.io/">官网</a>下载最新版本。</p><p>首先先配置 PicGo：在左侧的 PicGo 设置中找到“设置Server”项；PicGo 理论上是默认设置了这一项的，但是仍然要确保它已经开启；如果你需要进行图片的版本控制，也可以开启在“设置Server”下面的一些重命名的选项；开启的界面如下：</p><figure><img src="https://i.loli.net/2021/03/05/Sn9w7IMz2QAg8pD.png" class="lazyload" data-srcset="https://i.loli.net/2021/03/05/Sn9w7IMz2QAg8pD.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="_M__2_6_YS2JX@AU__P@N0.png" /><figcaption aria-hidden="true">_M__2_6_YS2JX@AU__P<span class="citation" data-cites="N0.png">@N0.png</span></figcaption></figure><p>然后打开新版的 Typora，在偏好设置-&gt;图像中设置插入图片时上传图片；并在上传服务设定中指定使用<code>PicGo (app)</code>，并指定 PicGo 的安装路径；最后点击验证图片的上传选项按钮测试。</p><figure><img src="https://i.loli.net/2021/03/05/N2AJbUqvdujZfTz.png" class="lazyload" data-srcset="https://i.loli.net/2021/03/05/N2AJbUqvdujZfTz.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="U0W_~@_ZRT3_PAK6DOGT_TO.png" /><figcaption aria-hidden="true">U0W_~<span class="citation" data-cites="_ZRT3_PAK6DOGT_TO.png">@_ZRT3_PAK6DOGT_TO.png</span></figcaption></figure><p>设置完成后，当你在使用 Typora 进行 Markdown 写作时，就可以简单地将图片拖进 Typora 中，它将自动使用 PicGo 上传图片到指定的默认云服务中。</p><h3 id="上传图片测试">上传图片测试</h3><p>下面是一张来自于刚部署的图床的图片：</p><figure><img src="https://img.shiraha.cn/shiraha-moe/test.png" class="lazyload" data-srcset="https://img.shiraha.cn/shiraha-moe/test.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="test" /><figcaption aria-hidden="true">test</figcaption></figure><p>因为我开启了空 Referer 防盗链，并在白名单中加入了 <code>localhost</code>，因此它在开发模式下（<code>localhost</code>）可以访问；但是如果复制链接直接在浏览器窗口中或者使用 Typora 打开它的源文件，都无法预览。</p><p>如果出现了错误，还可以在 PicGo 设置中查看它的日志文件。</p>]]></content>
      
      
      <categories>
          
          <category> 折腾记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 云服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019 CCPC 秦皇岛区域赛 回顾</title>
      <link href="/2020/2019-ccpc-qinhuangdao/"/>
      <url>/2020/2019-ccpc-qinhuangdao/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面">写在前面</h2><p>已经有相当一段时间没有写过博客了；也许是因为牛客多校某次讲评时老师说的：如果为了写博客而写博客，那么写博客对于个人而言又有多少除了心理满足之外的意义呢？这句话一时间使我陷入了迷惘—— 应当警惕隐藏在其中的形式主义（</p><p>但是在漫长的补题不写博客的日子后，我渐渐发现博客的优点也确实存在：比如客观上可以加深对于题目的印象；外加如今 8 个月的寒假已经结束，是时候重新启用这个博客记录题解了。</p><p>废话少说，那么从今往后（包括那些今天之后修改的博文）的博文，如果是题解，就尽量控制废话数量：不再包含题目的详细的翻译什么的（但根据情况可能会有一句话的大意描述），也不会按照顺序一个题一个题的创建标题了——完全根据补题情况——也就是说补了几个写几个；虽然少了很多东西，但是会包括必须的资源下载的链接；至于每一个具体的题目，简单的讲解思路就直接贴代码了。</p><blockquote><p>团队链接：<a href="https://vjudge.net/contest/395445/" class="uri">https://vjudge.net/contest/395445/</a> 比赛链接：<a href="https://codeforces.com/gym/102361/" class="uri">https://codeforces.com/gym/102361/</a> 没有找到官方的题解幻灯片 / PDF</p></blockquote><h2 id="d---decimal"><a href="https://vjudge.net/problem/Gym-102361D">D - Decimal</a></h2><p>老签到题了，大胆猜测只有 2 和 5 的数字满足要求，就过了（</p><p>但是考场却 WA 了一发，还搞了半天，离谱儿</p><h3 id="代码">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">unsigned</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">0</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) ch == <span class="string">&#x27;-&#x27;</span> &amp;&amp; (f = !f), ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t = nextInt();</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nextInt();</span><br><span class="line">        <span class="keyword">while</span> (n % <span class="number">2</span> == <span class="number">0</span>) n /= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (n % <span class="number">5</span> == <span class="number">0</span>) n /= <span class="number">5</span>;</span><br><span class="line">        <span class="built_in">printf</span>(n == <span class="number">1</span> ? <span class="string">&quot;No\n&quot;</span> : <span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="f---forest-program"><a href="https://vjudge.net/problem/Gym-102361F">F - Forest Program</a></h2><p>也是个简单的题目；给一个包含一些树和仙人掌树的“森林”，你可以删除一些边以破坏掉全部的仙人掌树，使得得到的森林仅包含树；求模意义下达到目标的方案数；</p><p>仙人掌树，指的是那些不包含自环和重边，每一条边可能且最多只属于一个简单环的连通图。</p><h3 id="思路">思路</h3><p>如果一个图是树，又或者是森林，那么随便怎么删边，它都一定满足题目要求，那么假设这个森林里有 m 个边，方案数量就是 <span class="math inline">\(2^m\)</span> 种；</p><p>如果一个连通图是仙人掌，且假设它一共有 m 条边，含有一个边长为 c (m &gt; c) 的环，那么：</p><ul><li>不属于环的部分：和上面一般树/森林一样，可以随意删除</li><li>属于环的部分：环内可以随意删除，但是至少要删去 1 条边</li></ul><p>那么可以通过简单的 DFS 找到所有的环，然后根据上面的结论，将非环部分和每一个环分别处理，然后结果乘起来就得到的了答案；</p><h3 id="代码-1">代码</h3><p>需要注意输入的图可能包含多个连通块，需要进行处理后才能计算答案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">unsigned</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">0</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) ch == <span class="string">&#x27;-&#x27;</span> &amp;&amp; (f = !f), ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w, next;</span><br><span class="line">    edge() = <span class="keyword">default</span>;</span><br><span class="line">    edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> next)</span><br><span class="line">    : u(u), v(v), w(w), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>, M = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> longs mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">longs <span class="title">fastPow</span><span class="params">(longs a, longs b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    longs ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) ans = (ans * a) % mod;</span><br><span class="line">        a = (a * a) % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FWS</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> head[N];</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    edge ee[M * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n = N - <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ee[tot] = edge(u, v, w, head[u]);</span><br><span class="line">        head[u] = tot ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">const</span> function&lt;<span class="keyword">void</span>(edge&amp;)&gt;&amp; func)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = head[st]; ~c; c = ee[c].next)</span><br><span class="line">            func(ee[c]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ring;</span><br><span class="line"><span class="built_in">bitset</span>&lt;N&gt; vis;</span><br><span class="line"><span class="keyword">int</span> dfn[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[u] = dfn[p] + <span class="number">1</span>;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    FWS::forEach(u, [&amp;](edge &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.v == p) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (dfn[e.v])</span><br><span class="line">            <span class="keyword">if</span> (dfn[u] &gt; dfn[e.v])</span><br><span class="line">                ring.push_back(dfn[u] - dfn[e.v] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span>;</span><br><span class="line">        <span class="keyword">else</span> dfs(e.v, u);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> n = nextInt(), m = nextInt();</span><br><span class="line">    FWS::init(n);</span><br><span class="line">    <span class="keyword">auto</span> cnt = m;</span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = nextInt(), v = nextInt();</span><br><span class="line">        FWS::addEdge(u, v, <span class="number">0</span>);</span><br><span class="line">        FWS::addEdge(v, u, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dfn[<span class="number">0</span>] = <span class="number">0</span>, dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) dfs(i, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ii : ring) cnt -= ii;</span><br><span class="line">    <span class="keyword">auto</span> ans = fastPow(<span class="number">2</span>, cnt);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ii : ring)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = fastPow(<span class="number">2</span>, ii);</span><br><span class="line">        t = (t - <span class="number">1</span> + mod) % mod;</span><br><span class="line">        ans = ans * t % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要看到树上有环就满脑子 tarjan 啊 kora，好好地区别 SCC 和环啊草！</p><h2 id="i---invoker"><a href="https://vjudge.net/problem/Gym-102361I">I - Invoker</a></h2><p>简单的 DP；虽然看起来吓死人，但是三个字母长的序列翻来覆去也就六种情况，直接暴力转移完全大丈夫</p><p><del>于是就有了下面这种在考场上写的丑陋代码</del></p><h3 id="代码-2">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VAR(var) <span class="meta-string">&quot;&quot;</span>#var<span class="meta-string">&quot; = &quot;</span> &lt;&lt; var</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">unsigned</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">0</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) ch == <span class="string">&#x27;-&#x27;</span> &amp;&amp; (f = <span class="number">1</span>), ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">longs dp[N][<span class="number">6</span>];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; mm[<span class="number">6</span>];</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mov</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = x - <span class="number">1</span>, b = x;</span><br><span class="line">    <span class="keyword">char</span> aa = s[a - <span class="number">1</span>], bb = s[b - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (aa == bb)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++ i)</span><br><span class="line">            dp[b][i] = dp[a][i];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[x][j] = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> add = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (mm[i][aa][<span class="number">1</span>] == mm[j][bb][<span class="number">0</span>] &amp;&amp;</span><br><span class="line">                mm[i][aa][<span class="number">2</span>] == mm[j][bb][<span class="number">1</span>])</span><br><span class="line">                add = + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mm[i][aa][<span class="number">2</span>] == mm[j][bb][<span class="number">0</span>])</span><br><span class="line">                add = + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> add = + <span class="number">3</span>;</span><br><span class="line">            dp[x][j] = <span class="built_in">min</span>(dp[x][j], dp[x - <span class="number">1</span>][i] + add);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> &amp;m = mm[<span class="number">0</span>];</span><br><span class="line">    m[<span class="string">&#x27;Y&#x27;</span>] = <span class="string">&quot;QQQ&quot;</span>, m[<span class="string">&#x27;V&#x27;</span>] = <span class="string">&quot;QQW&quot;</span>, m[<span class="string">&#x27;G&#x27;</span>] = <span class="string">&quot;QQE&quot;</span>, m[<span class="string">&#x27;C&#x27;</span>] = <span class="string">&quot;WWW&quot;</span>, m[<span class="string">&#x27;X&#x27;</span>] = <span class="string">&quot;QWW&quot;</span>;</span><br><span class="line">    m[<span class="string">&#x27;Z&#x27;</span>] = <span class="string">&quot;WWE&quot;</span>, m[<span class="string">&#x27;T&#x27;</span>] = <span class="string">&quot;EEE&quot;</span>, m[<span class="string">&#x27;F&#x27;</span>] = <span class="string">&quot;QEE&quot;</span>, m[<span class="string">&#x27;D&#x27;</span>] = <span class="string">&quot;WEE&quot;</span>, m[<span class="string">&#x27;B&#x27;</span>] = <span class="string">&quot;QWE&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ii : m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">6</span>; ++ i)</span><br><span class="line">            mm[i][ii.first] = m[ii.first];</span><br><span class="line">        swap(mm[<span class="number">1</span>][ii.first][<span class="number">1</span>], mm[<span class="number">1</span>][ii.first][<span class="number">2</span>]);</span><br><span class="line">        swap(mm[<span class="number">2</span>][ii.first][<span class="number">0</span>], mm[<span class="number">2</span>][ii.first][<span class="number">1</span>]);</span><br><span class="line">        mm[<span class="number">3</span>][ii.first] = mm[<span class="number">2</span>][ii.first];</span><br><span class="line">        swap(mm[<span class="number">3</span>][ii.first][<span class="number">1</span>], mm[<span class="number">3</span>][ii.first][<span class="number">2</span>]);</span><br><span class="line">        mm[<span class="number">4</span>][ii.first] = mm[<span class="number">1</span>][ii.first];</span><br><span class="line">        swap(mm[<span class="number">4</span>][ii.first][<span class="number">0</span>], mm[<span class="number">4</span>][ii.first][<span class="number">1</span>]);</span><br><span class="line">        mm[<span class="number">5</span>][ii.first] = mm[<span class="number">4</span>][ii.first];</span><br><span class="line">        swap(mm[<span class="number">5</span>][ii.first][<span class="number">1</span>], mm[<span class="number">5</span>][ii.first][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++ i) dp[<span class="number">1</span>][i] = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">auto</span> siz = s.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; siz; ++ i) mov(i + <span class="number">1</span>);</span><br><span class="line">    longs ans = dp[siz][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">6</span>; ++ i)</span><br><span class="line">        ans = <span class="built_in">min</span>(dp[siz][i], ans);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans + siz &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="j---muv-luv-extra"><a href="https://vjudge.net/problem/Gym-102361J">J - MUV LUV EXTRA</a></h2><p>给定参数 a 和 b，记截断小数的小数部分的循环节长度为 l，出现的循环节循环部分长度为 p，要求计算 <span class="math display">\[a \times p - b \times l\]</span> 的最大值；a 和 b 均为正整数；</p><h3 id="思路-1">思路</h3><p>本来还以为要考虑 a 和 b 的大小关系，考虑什么单调性什么什么的，结果连怎么找到循环节都没想出来，经济基础都没建立还满脑子上层建筑，跟个脑瘫似的（笑）一直听着隔壁队伍大声吵吵 KMP，也没做出这个题==</p><p>但是它确实是脑瘫 KMP 题；</p><p>一般 KMP 找到的是什么？模式串所有前缀的 border —— 也就是最长的公共<strong>真</strong>前后缀；这样当模式串在后缀的后面匹配失败的时候，就可以直接原地起飞回到前缀的后面，省去了前缀部分的匹配。</p><p>这个题目要关注的是被截断的小数部分，可以看成字符串；因为要求的循环节是从后面延申的，所以求所有前缀的 border 并无卵用，应该求后缀的 border；因此我们 KMP 之前需要翻转小数部分</p><p>那么我们可以发现，原本 KMP 中的 border 的前缀部分现在变成后缀，后缀变成了前缀；现在的后缀和前缀依然是相等的；这样就符合了循环小数的定义：我们可以把字符串后缀除了 border 后缀部分的部分看作是循环节，后缀 border 看作是循环节的延申，就可以对于每一个后缀求出 p 和 l 了；</p><!-- ![kmp](https://cdn.jsdelivr.net/gh/ymd45921/util_assets@master/post/2020-fall-acm/kmp-muv-luv-extra.png) --><center>这里本来有张图，但是画错了……</center><p>需要注意的是这并没有覆盖全部的情况：比如字符串 <code>...ABCABCA</code>，它只考虑了 l = 3, p = 4 和 l = 3, p = 7 的情况，没有考虑到 l = 6 和 p = 7 的情况，但是因为 a 和 b 都是正整数，所以显然 l 较小的时候比较占优势；因为 border 是最大的真公共子串，所以它一定会包含所有可以包含的部分，所以它总是会包含最优的 l；</p><p>如果不是这样的话这就变得有点麻烦了（</p><h3 id="代码-3">代码</h3><p>注意：因为字符串的下标从 0 开始，所以 p = 0 （即第一位失配）的值是无意义的，不应该考虑；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">unsigned</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">0</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) ch == <span class="string">&#x27;-&#x27;</span> &amp;&amp; (f = !f), ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e7</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">buildKMP</span>(<span class="title">const</span> <span class="title">T</span> *<span class="title">arr</span>, <span class="title">vector</span>&lt;int&gt; &amp;<span class="title">kmp</span>, <span class="title">int</span> <span class="title">length</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    kmp.resize(length + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = kmp[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; length)</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == j || arr[i] == arr[j])</span><br><span class="line">        &#123;</span><br><span class="line">            ++ i, ++ j;</span><br><span class="line">            <span class="keyword">if</span> (i == length || arr[i] != arr[j])</span><br><span class="line">                kmp[i] = j;</span><br><span class="line">            <span class="keyword">else</span> kmp[i] = kmp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> j = kmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    longs a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    getline(<span class="built_in">cin</span>, s, <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">    getline(<span class="built_in">cin</span>, s, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    reverse(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; kmp;</span><br><span class="line">    buildKMP(s.c_str(), kmp, s.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> siz = s.<span class="built_in">size</span>();</span><br><span class="line">    longs ans = <span class="number">-0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span>; p &lt;= siz; ++ p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = p - kmp[p];</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, a * p - b * l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外还有需要注意的是：上面代码的优化后的 KMP 求出的并不是严格的 border，虽然就算不管这个还是可以过掉这道题就是了，但是也许可以进行更深层次的讨论；</p><h2 id="e---escape"><a href="https://vjudge.net/problem/Gym-102361E">E - Escape</a></h2><p>一个 n * m 的矩阵，有的位置有墙，其他的可以通行；在第一行的上面有 a 个机器人，在最后一行下面有 b 个出口；机器人只能走直线，但是你可以加入转向器（两个方向对换，但是阻止另外两个方向）改变机器人前进的方向；问 a 个机器人是否都能够到达出口；</p><h3 id="思路-2">思路</h3><p>有的人看到只有 100 的数据范围就想到了网络流，有的人看到了 a 进 b 出想到网络流<del>，还有的人纠结了转向器的含义纠结了半个小时</del></p><p>首先给出结论：若可以到达终点，任何两个机器人的行动路线之间一定不会有长度大于 0 的公共部分；或者说，不会有两个机器人通过同一个转向器；解释如下：</p><ul><li>若没有障碍，没有转向器：一个入口格子上只能有一个机器人；他们直走，互相平行；</li><li>若它们经过了同一个转向器转向：那么转向前它们的方向相同，但这样的机器人对在起点就不存在；</li><li>若他们被不同的转向器转到同一方向：在前面的转向器一定会阻挡后面的机器人；</li></ul><p>因此，可以得到推论：每一个格子只可以被横着通过一次，竖着通过一次；若转向，会同时占用横竖；</p><p>综上所述，可以建立网络流：在空格子之间建立双向边，在“横格子”和“竖格子”之间建立双向边，跑最大流即可；若最大流等于机器人总数，则满足题目要求。</p><h3 id="代码-4">代码</h3><p>网络流最大流的图中可以出现重边！不用担心，嗯流就完事了（</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USE_DINIC</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">unsigned</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">0</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) ch == <span class="string">&#x27;-&#x27;</span> &amp;&amp; (f = !f), ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> X = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">char</span> g[X][X];</span><br><span class="line"><span class="keyword">int</span> p[X], e[X];</span><br><span class="line"><span class="keyword">int</span> n, m, t, a, b;</span><br><span class="line"><span class="keyword">int</span> h[X][X], v[X][X];</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> number = <span class="keyword">int</span>;               <span class="comment">// 设置流量数据类型</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = X * X * <span class="number">3</span>, M = N * <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, next;</span><br><span class="line">    number w;</span><br><span class="line">    edge() = <span class="keyword">default</span>;</span><br><span class="line">    edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, number w, <span class="keyword">int</span> next)</span><br><span class="line">            : u(u), v(v), w(w), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FWS</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> head[N];</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    edge ee[M * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> method = function&lt;<span class="keyword">void</span>(<span class="keyword">const</span> edge &amp;e)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n = N - <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, number w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ee[tot] = &#123;u, v, w, head[u]&#125;;</span><br><span class="line">        <span class="keyword">return</span> head[u] = tot ++;        <span class="comment">// 返回加入的边的编号，方便处理重边</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">const</span> method &amp;iter)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ii = head[u];</span><br><span class="line">             ii != <span class="number">-1</span>;</span><br><span class="line">             ii = ee[ii].next)</span><br><span class="line">            iter(ee[ii]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FN</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;    <span class="comment">// 严格匹配 number，不要自动转型！</span></span><br><span class="line">    <span class="keyword">int</span> S, T, total = <span class="number">0</span>;    <span class="comment">// 重新建图之后的节点数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, number w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> pos = FWS::addEdge(u, v, w);</span><br><span class="line">        FWS::addEdge(v, u, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_DINIC</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Dinic 算法</span></span><br><span class="line"><span class="comment">     * O (n²m)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - 在残量网络上使用 BFS 构造分层图</span></span><br><span class="line"><span class="comment">     * - 在分层图上 DFS 寻找增广路，并更新边权</span></span><br><span class="line"><span class="comment">     * - 当前弧优化：避免寻找不可能增广的边</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">namespace</span> Dinic</span><br><span class="line">    &#123;</span><br><span class="line">        number dis[N];</span><br><span class="line">        <span class="keyword">int</span> cur[N]; <span class="comment">// 当前弧优化</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先创建分层图</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">            <span class="keyword">static</span> <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">            <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(number) * (total + <span class="number">1</span>));</span><br><span class="line">            q.push(S); dis[S] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!q.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> cc = head[u]; cc != <span class="number">-1</span>; cc = ee[cc].next)</span><br><span class="line">                &#123;</span><br><span class="line">                    edge&amp; e = ee[cc];</span><br><span class="line">                    <span class="keyword">int</span> v = e.v; <span class="keyword">auto</span> w = e.w;</span><br><span class="line">                    cur[u] = head[u];</span><br><span class="line">                    <span class="keyword">if</span> (!w || dis[v] &lt;= dis[u] + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    dis[v] = dis[u] + <span class="number">1</span>; q.push(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dis[T] != inf;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">number <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, number inflow)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">            <span class="keyword">if</span> (u == T) <span class="keyword">return</span> inflow;</span><br><span class="line">            number outflow = <span class="number">0</span>, rest = inflow;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> &amp;cc = cur[u]; cc != <span class="number">-1</span>; cc = ee[cc].next)  <span class="comment">// 当前弧优化</span></span><br><span class="line">            &#123;</span><br><span class="line">                edge &amp;e = ee[cc], &amp;r = ee[uint(cc) ^ <span class="number">1u</span>];</span><br><span class="line">                <span class="keyword">int</span> v = e.v; <span class="keyword">auto</span> w = e.w;</span><br><span class="line">                <span class="keyword">if</span> (!w || dis[v] != dis[u] + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> t = dfs(v, <span class="built_in">min</span>(w, rest));</span><br><span class="line">                outflow += t; e.w -= t; r.w += t; rest -= t;</span><br><span class="line">                <span class="keyword">if</span> (!rest) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!outflow) dis[u] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> outflow;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">number <span class="title">go</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            number maxFlow = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (bfs()) maxFlow += dfs(S, inf);</span><br><span class="line">            <span class="keyword">return</span> maxFlow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined USE_ISAP</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Improved Shortest Augumenting Path</span></span><br><span class="line"><span class="comment">     * O (n²m)，比起 Dinic 算法只需要一次 BFS</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - 反向 BFS 并标记节点深度</span></span><br><span class="line"><span class="comment">     * - 正向 DFS，用尽节点的出流时回溯加深深度</span></span><br><span class="line"><span class="comment">     * - gap 优化：当某一深度不再包含节点时停止搜索</span></span><br><span class="line"><span class="comment">     * - 当 S 的深度达到 n 时，搜索一定结束</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 和 Dinic 类似，本算法也可以进行当前弧优化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">namespace</span> ISAP</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> dep[N], gap[N]; <span class="comment">// 节点的深度 &amp; 特定深度节点的数量</span></span><br><span class="line">        number maxFlow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur[N];         <span class="comment">// 当前弧优化</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">memset</span>(dep, <span class="number">-1</span>, <span class="keyword">sizeof</span> dep);</span><br><span class="line">            <span class="built_in">memset</span>(gap, <span class="number">0</span>, <span class="keyword">sizeof</span> gap);</span><br><span class="line">            dep[T] = <span class="number">0</span>, gap[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q; q.push(T);</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">            <span class="keyword">while</span> (!q.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> u = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> cc = head[u]; cc != <span class="number">-1</span>; cc = ee[cc].next)</span><br><span class="line">                &#123;</span><br><span class="line">                    edge&amp; e = ee[cc]; <span class="keyword">int</span> v = e.v;</span><br><span class="line">                    <span class="keyword">if</span> (dep[v] != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    q.push(v);</span><br><span class="line">                    ++ gap[dep[v] = dep[u] + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">number <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, number flow)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (u == T) <span class="keyword">return</span> maxFlow += flow, flow;</span><br><span class="line">            number used = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> cc = head[u]; cc != <span class="number">-1</span>; cc = ee[cc].next)</span><br><span class="line">            &#123;</span><br><span class="line">                edge&amp; e = ee[cc], &amp;r = ee[uint(cc) ^ <span class="number">1u</span>];</span><br><span class="line">                <span class="keyword">int</span> v = e.v; <span class="keyword">auto</span> w = e.w;</span><br><span class="line">                <span class="keyword">if</span> (!w || dep[v] + <span class="number">1</span> != dep[u]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">auto</span> t = dfs(v, <span class="built_in">min</span>(w, flow - used));</span><br><span class="line">                <span class="keyword">if</span> (t) e.w -= t, r.w += t, used += t;</span><br><span class="line">                <span class="keyword">if</span> (used == flow) <span class="keyword">return</span> used;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (-- gap[dep[u]] == <span class="number">0</span>) dep[S] = total + <span class="number">1</span>;</span><br><span class="line">            ++ gap[++ dep[u]];</span><br><span class="line">            <span class="keyword">return</span> used;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">number <span class="title">go</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            maxFlow = <span class="number">0</span>;</span><br><span class="line">            bfs();</span><br><span class="line">            <span class="keyword">while</span> (dep[S] &lt; total)</span><br><span class="line">                <span class="built_in">memcpy</span>(cur, FWS::head, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (total + <span class="number">1</span>)),  <span class="comment">// 当前弧优化</span></span><br><span class="line">                        dfs(S, inf);</span><br><span class="line">            <span class="keyword">return</span> maxFlow;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setInfo</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;FN::S = s, FN::T = t, FN::total = cnt;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> r &gt; <span class="number">0</span> &amp;&amp; r &lt;= n &amp;&amp; c &gt; <span class="number">0</span> &amp;&amp; c &lt;= m;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 思考这样处理的合理性？</span></span><br><span class="line"><span class="comment">// 直接加两条边或者加重边没有区别</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdgeX</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FWS::addEdge(u, v, <span class="number">1</span>);</span><br><span class="line">    FWS::addEdge(v, u, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FN;</span><br><span class="line">    S = T = total = <span class="number">0</span>;</span><br><span class="line">    FWS::init(<span class="number">2</span> + n * m * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="built_in">memset</span>(h[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (m + <span class="number">1</span>)),</span><br><span class="line">        <span class="built_in">memset</span>(v[i], <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (m + <span class="number">1</span>));</span><br><span class="line">    S = ++ total, T = ++ total;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">1</span>; r &lt;= n; ++ r)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">1</span>; c &lt;= m; ++ c)</span><br><span class="line">        &#123;</span><br><span class="line">            h[r][c] = ++ total, v[r][c] = ++ total;</span><br><span class="line">            <span class="keyword">if</span> (g[r][c] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (in(r - <span class="number">1</span>, c) &amp;&amp; g[r - <span class="number">1</span>][c] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    addEdgeX(v[r - <span class="number">1</span>][c], v[r][c]);</span><br><span class="line">                <span class="keyword">if</span> (in(r, c - <span class="number">1</span>) &amp;&amp; g[r][c - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    addEdgeX(h[r][c - <span class="number">1</span>], h[r][c]);</span><br><span class="line">                addEdgeX(h[r][c], v[r][c]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a; ++ i)</span><br><span class="line">        addEdge(S, v[<span class="number">1</span>][p[i]], <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= b; ++ i)</span><br><span class="line">        addEdge(v[n][e[i]], T, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; (g[i] + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a; ++ i)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; p[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= b; ++ i)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; e[i];</span><br><span class="line">        buildGraph();</span><br><span class="line">        <span class="keyword">auto</span> res = FN::Dinic::go();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (res == a ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再度验证了我全新版本网络流板子的正确性<del>建图的时候请务必记得分配源点和汇点</del></p><h2 id="k---muv-luv-unlimited"><a href="https://vjudge.net/problem/Gym-102361K">K - MUV LUV UNLIMITED</a></h2><p><del>是有趣的新游戏</del></p><p>有一棵树，先手和后手轮流操作，每次可以拿掉若干叶子结点（但不能不拿），拿到根结点的人获胜。问先手是否必胜。</p><h3 id="思路-3">思路</h3><p>有很多种思考的模型：从简单考虑到复杂情况和状态转化的推导；下面进行示例</p><p>首先考虑在一棵树的某个非叶结点下面加上一个叶子结点：</p><ul><li>原树是必败态，那么先手第一次只取新叶子后就留下了必败态，所以新树是必胜态</li><li>原树是必胜态，那么先手第一次取下新叶子和原树必胜态中第一步应该取下的叶子，所以新树还是必胜态</li></ul><p>所以说，当不管原树怎么样，只要有一个叶子节点的父亲度数大于等于 2，那么它就是必胜态</p><p>当然，显然这不是充要条件：比如原树是一个链的时候，并不存在这样的叶子节点，但是依然可以根据链的长度的奇偶性来判断当前是必胜态还是必败态。显然，这也不是一个充要条件；</p><p>但是链最终可以转化成上面说的那种必胜态的树型，只是先手后手必须一片叶子一片叶子的拿才可以；那么我们假设某长度为 x 的链的末端的叶子节点有一个度数大于等于 2 的祖先，设这个祖先的子节点是 a，那么问题就变成了怎么样删除节点让 a 节点成为叶子节点时玩家先手。形式化的说：假设当前树有 k 条链，链上当前的叶子节点和上述 a 节点的距离为 xi；每次可以选择部分 xi 使得它们减一，将其中一个减小到 0 的人输掉游戏。</p><p>因为树只会有上面两种构造，所以上述两种情况包括了全部的可能性；对于任何一棵树，我们只需要分析它的所有叶子节点距离第一个父亲节点度数大于 2 的节点的距离，也就是转化成上面的形式，从而可以进行胜败态的分析。</p><p>当 xi 中出现了偶数的时候，先手可以选择所有长度为偶数的链减一；这样就转化为了所有链长为奇数的状态；当最短链长为 1 的时候，当前玩家必败；当链长为其他奇数的时候，当前先手所作的任何行为产生的偶数长的链都可以被后手抵消，所以全部链长为奇数是必败态，出现了偶数的链长是必胜态。</p><h3 id="代码-5">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">unsigned</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">0</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) ch == <span class="string">&#x27;-&#x27;</span> &amp;&amp; (f = !f), ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> f ? -x : x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> deg[N], p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t = nextInt();</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nextInt();</span><br><span class="line">        <span class="built_in">memset</span>(deg, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">            ++ deg[p[i] = nextInt()];</span><br><span class="line">        <span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (!deg[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> x = i, len = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (x &amp;&amp; deg[p[x]] == <span class="number">1</span>)</span><br><span class="line">                    x = p[x], ++ len;</span><br><span class="line">                ok &amp;= <span class="keyword">bool</span>(len % <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(!ok ? <span class="string">&quot;Takeru\n&quot;</span> : <span class="string">&quot;Meiya\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="a---angle-beats"><a href="https://vjudge.net/problem/Gym-102361A">A - Angle Beats</a></h2><p>一个平面里有 n 个点，现在每次询问给一个新点 P，你需要从 n 个点中选出两个点和 P 构成直角三角形；一共询问 q 次，求对于每次询问，可以构成直角三角形的不同方案数量；</p><h2 id="c---sakurada-reset"><a href="https://vjudge.net/problem/Gym-102361C">C - Sakurada Reset</a></h2><p>给定数列 A 和 B，将数列中的每个子序列都看作一个 1000 进制数，问有多少对 (x,y)满足 x 是 A 的某个子序列，y 是 B 的某个子序列，并且 x &gt; y；相同的子序列需要去重。</p><h3 id="思路-4">思路</h3><p>有句古话说：所有的计数问题都可以直接或间接地使用动态规划来解</p><h2 id="后记">后记</h2><p>这个出题人老二次元了<del>而且还是个重度 MUV-LUV 厨</del></p><p>因为这次主要的时间花在了博弈论上，所以深有感触；对于树的两种状态的分析都有，但是却没有将它们结合起来考虑，导致这个题花了很多时间。</p><p>我们队竟然没有人会平面几何（悲），这不太行；该努力学习提升自己的塑料平面几何水平了（</p><h3 id="参考链接">参考链接</h3><ul><li><a href="https://www.cnblogs.com/LMCC1108/p/11577614.html" class="uri">https://www.cnblogs.com/LMCC1108/p/11577614.html</a></li><li><a href="https://blunt-axe.gitee.io/2019/10/11/20191011-CCPC2019-Tutorial/" class="uri">https://blunt-axe.gitee.io/2019/10/11/20191011-CCPC2019-Tutorial/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Codeforces </tag>
            
            <tag> Gym </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在服务器上部署 SYZOJ</title>
      <link href="/2020/deploy-syzoj-on-a-server/"/>
      <url>/2020/deploy-syzoj-on-a-server/</url>
      
        <content type="html"><![CDATA[<p>什么是<a href="https://github.com/syzoj/syzoj">syzoj</a>？<del>什么是<a href="https://zh.wikipedia.org/wiki/在线评测系统">OJ</a></del></p><p>虽说理论上既然自己搭 OJ 就应该仿真一点，搭个 DomJudge 之类的官方用品；但是对于博主而言，好看就是生产力，所以就选择了界面相对更加美观，且由中国人开发的 SYZOJ 了；毕竟搭建 OJ 本身也没啥意义，我也不会出题，比赛的话使用现成的 <a href="https://vjudge.net/">vjudge</a> 不知道高到哪里去了（</p><p>硬要说意义的话…… 只能说是熟悉一下服务器部署？或者说给一成不变的生活去找一些乐子？大概也就这样吧 ==</p><p>因为官方已经有详尽的<a href="https://github.com/syzoj/syzoj/wiki/部署指南">部署指南</a>，所以已经有的东西就不再重复说明了，只重点介绍本人踩坑。</p><h2 id="事前准备">事前准备</h2><p>因为是回忆性质的文章，很多东西也不会讲的很详细很有条理；我尽力：</p><ul><li>Vultr 超低级服务器 *1（1 vCore &amp; 1 GB RAM &amp; 25 GB SSD &amp; 1Mbps &amp; Ubuntu 18.04）</li><li>Xshell 6（学生可以<a href="https://www.netsarang.com/zh/free-for-home-school/">白嫖</a>阉割版，但是已经够用了）</li><li>机场为你提供的纸飞机（不推荐了，推荐了你站就没了==）</li><li><del>一个域名，增加 A 记录解析到你的服务器</del>（如果是国内域名还需备案）</li><li><del>其他的服务器，用来搞分布式评测提升效率和使用体验</del>（有钱我也想）</li></ul><p>有了这些，我们就可以一边参考官方的<a href="https://github.com/syzoj/syzoj/wiki/部署指南">部署指南</a>来配置了；</p><p>在 Vultr 上购买了服务器并且成功启动之后，可以将得到的 IPv4 地址在<a href="https://www.vps234.com/ipchecker/">这个网站</a>上过一遍，确保在国内的服务是正常的；毕竟在某一个时期似乎很流行购买 Vultr 服务器去搭建 SSR，再加上 Vultr 的 IP 地址更换非常容易，导致它很多的 IP 都已经被大陆 GFW 给 ban 了；如果你还希望在国内可以访问这个服务器，建议一直更换到上面的检测通过<del>反正就一毛钱</del>；</p><h2 id="配置-ssh-代理">配置 SSH 代理</h2><p>就算上面的服务器可以通过测试，也不代表着你可以舒服的使用它：因为墙的存在总会或多或少的阻挠你，而且服务器远在国外，本身连接的速度就相对比较慢<del>还可能有高的无法忍受的延迟</del>；所以要做些什么才行——</p><p>国内服务器？确实配置更高，对于带学生的价格也更加优惠；但是你想要忍受国内那离谱的备案程序吗？</p><p>在正式开始之前先说一下 VPN 和 sock5 代理的区别：</p><h3 id="vpn-sock5">VPN &amp; sock5</h3><p>一般来说，像纸飞机这样的代理程序和 VPN 是不一样的：VPN 是你计算机网络的唯一出口，甚至你还会获得 VPN 分配的虚拟 IP；VPN 会接管所有的流量，等同于你处在另一个网络中；而 sock5 代理则是启动一个基于较低层次的网络协议的服务，sock5 协议只负责发送数据包，而不在意顶层应用层的协议<del>因而速度较快</del>；客户端（比如纸飞机）会在计算机上启动一个端口，并监听发送到该端口的所有数据，通过远程的服务器进行转发从而实现科学上网；</p><p>所谓的纸飞机全局代理模式，是利用 Windows 10 提供的代理功能，将电脑上所有的流量转发到它所在的服务端口；由它进行转发从而实现所谓的“代理全局流量”；事实上当开启了全局模式的 Shadowsock 不正确退出时，因为没有回收 Windows 10 中的代理配置，从而导致无法上网。</p><p>Windows 10 的这项功能在 设置 &gt; 网络和 Internet &gt; 代理 中；有一项是全局代理；这里已经体现了 代理 ≠ VPN 的概念。</p><h3 id="ssh-proxy">SSH Proxy</h3><p>在 Linux 中，终端不走代理是默认设置，而在 Windows 中却比较少见——但并不是不存在；我原本使用 Fluent Terminal 自带的 SSH 客户端，但是因为实在无法忍受其速度，外加上不可配置最终切换了 Xshell；</p><p>和 ping 不同，我原以为 SSH 连接也是低层网络，但是 Juice SSH 客户端是可以使用 SSR 加速的；所以 PC 端也可以通过代理来提升连接质量：在 Xshell 的会话属性中，可以指定代理服务器；我们将它设置为 <code>http://127.0.0.1:1080/</code> —— IP 地址是 localhost 的默认值，而 1080 是 ShadowsocksR 运行的默认本地端口，就可以让 ssh 的连接通过代理访问远程服务器。</p><h2 id="安装-yarn">安装 Yarn</h2><p><strong><a href="https://yarn.bootcss.com/">Yarn</a></strong> 在我还在搞前端开发<del>搬砖</del>的时候已经使用过很多次了；Windows 的安装十分方便：去官网下载 msi 安装包，使用 Windows 的包管理器 Chocolatey / Scoop 安装，或者直接使用 Node.js 的 <code>npm</code> 来安装都可以；但是在 Linux 中似乎却没有这么容易：</p><p>如果你使用 <code>sudo apt install yarn</code>，你只会获得一个 0.32 的阴间版本的 yarn；在任何一个有 <code>yarn.lock</code>，你认为可以执行脚本的情况下它都会报错“缺少 scenario”；正确的安装方法是需要先增加 yarn 的仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://dl.yarnpkg.com/debian/ stable main&quot;</span> | sudo tee /etc/apt/sources.list.d/yarn.list</span><br></pre></td></tr></table></figure><p>注意，在运行在 WSL 1 上的 Ubuntu 20.04 上执行代码会出现 <code>gpg</code> 的错误；参考 <a href="https://stackoverflow.com/questions/46013544/yarn-install-command-error-no-such-file-or-directory-install">stackoverflow</a> 得知这是由于 Ubuntu 20.04 不再支持 WSL 1 导致；当在 Debian 10 WSL 上执行这些命令的时候是可以正常工作的（当然可能会出现因为下载 GPG 公钥失败导致的错误）</p><p>增加仓库之后再执行 <code>apt</code> 的安装命令就可以安装正常可用的 yarn 了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install yarn</span><br></pre></td></tr></table></figure><p>当然也可以使用 <code>npm install -g yarn</code> 来安装 yarn：可是当你已经安装了来自 apt 的低版本 yarn 后，这样可能不会成功；</p><h2 id="评测端的沙箱">评测端的沙箱</h2><p>Wiki 中给定的从 Github 下载的镜像只能在国外的云服务器上正常下载；如果你需要在国内的服务器上下载沙箱文件，可以使用开发者 HeRaNO 的<a href="https://seafile.t123yh.xyz:2/f/124a91be48ad41b98668/?dl=1">seafile镜像</a>处下载；</p><p>此外，下载的 <code>.tar.xz</code> 文件中已经包含了 <code>rootfs</code> 目录；如果按照教程上的做法新建文件夹，可能会导致这个文件夹被嵌套两次（<a href="https://zhuanlan.zhihu.com/p/44218633">HeRaNO 的知乎文章</a>）；所以可以将该部分命令替换成如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 源地址：https://github.com/syzoj/sandbox-rootfs/releases/download/181202/sandbox-rootfs-181202.tar.gz</span></span><br><span class="line">wget -O /sandbox-rootfs.tar.xz https://seafile.t123yh.xyz:2/f/124a91be48ad41b98668/?dl=1</span><br><span class="line">md5sum /sandbox-rootfs.tar.xz</span><br><span class="line"><span class="comment"># 预计计算结果为 09fe4fc407e4580e9ae4de8e2af5918e sandbox-rootfs.tar.xz</span></span><br><span class="line">mkdir -p /opt/syzoj/sandbox</span><br><span class="line"><span class="built_in">cd</span> /opt/syzoj/sandbox/</span><br><span class="line">tar xvf /sandbox-rootfs.tar.xz</span><br></pre></td></tr></table></figure><p>下载完成后可以计算 MD5 值来确定文件在下载过程中没有损坏；</p><h2 id="安装-redis">安装 redis</h2><p>虽然上面安装 yarn 已经搞得我对 <code>apt</code> 非常害怕，但是 redis 还是可以通过 <code>apt</code> 来安装的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y redis-server</span><br></pre></td></tr></table></figure><p>但是需要注意的是安装之后的服务名既不是 <code>redis.service</code> 也不是 <code>redisd.service</code>；</p><h2 id="安装-node.js-10">安装 Node.js 10</h2><p>默认 Ubuntu 18.04 的 <code>apt</code> 安装的 node 是 8.1.0 版本的，这比启动 SYZOJ 评测端所要求的最低版本 10.0 要低；参考上面说到的 yarn 的安装方法，我们需要在使用 <code>apt</code> 安装 node 之前更新存储库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_10.x | sudo bash</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt -y install gcc g++ make</span><br><span class="line">sudo apt -y install nodejs</span><br></pre></td></tr></table></figure><p>更新存储库后就可以安装新版本的 Node.js 了；同样，安装 <code>yarn</code> 包管理器也需要增加对应存储库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -sL https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb https://dl.yarnpkg.com/debian/ stable main&quot;</span> | sudo tee /etc/apt/sources.list.d/yarn.list</span><br><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install yarn</span><br></pre></td></tr></table></figure><p>之后才可以通过 <code>apt</code> 安装正常版本的 <code>yarn</code>。</p><h2 id="systemd-守护进程">systemd 守护进程</h2><p>首先需要在 <code>/usr/lib/systemd/system/</code> 目录下创建自己的守护进程的服务文件 <code>*.service</code></p>]]></content>
      
      
      <categories>
          
          <category> 折腾记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> syzoj </tag>
            
            <tag> nginx </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nowcoder 2020 暑期多校训练 （4）</title>
      <link href="/2020/nowcoder-2020-summer-multi-4/"/>
      <url>/2020/nowcoder-2020-summer-multi-4/</url>
      
        <content type="html"><![CDATA[<h2 id="a---ancient-distance">A - <a href="https://ac.nowcoder.com/acm/contest/5669/A">Ancient Distance</a></h2><h2 id="b---basic-gcd-problem">B - <a href="https://ac.nowcoder.com/acm/contest/5669/B">Basic Gcd Problem</a></h2><h2 id="c---count-new-string">C - <a href="https://ac.nowcoder.com/acm/contest/5669/C">Count New String</a></h2><blockquote><p>给长度为 n 的字符串 S，定义函数 f(S, x, y) 的值是 长度为 y - x + 1 的字符串，它的第 k 个字符是 <span class="math inline">\(max_{i=x...x+k-1} S_i\)</span>；</p><p>现定义集合 A = {$$}</p></blockquote><h2 id="d---dividing-strings">D - <a href="https://ac.nowcoder.com/acm/contest/5669/D">Dividing Strings</a></h2><h2 id="e---eliminate">E - <a href="https://ac.nowcoder.com/acm/contest/5669/E">Eliminate++</a></h2><h2 id="f---finding-the-order">F - <a href="https://ac.nowcoder.com/acm/contest/5669/F">Finding the Order</a></h2><h2 id="g---geometry-challenge">G - <a href="https://ac.nowcoder.com/acm/contest/5669/G">Geometry Challenge</a></h2><h2 id="h---harder-gcd-problem">H - <a href="https://ac.nowcoder.com/acm/contest/5669/H">Harder Gcd Problem</a></h2><h2 id="i---investigating-legions">I - <a href="https://ac.nowcoder.com/acm/contest/5669/I">Investigating Legions</a></h2><h2 id="j---jumping-on-the-graph">J - <a href="https://ac.nowcoder.com/acm/contest/5669/J">Jumping on the Graph</a></h2><h2 id="后记">后记</h2>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Nowcoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nowcoder 2020 暑期多校训练 （3）</title>
      <link href="/2020/nowcoder-2020-summer-multi-3/"/>
      <url>/2020/nowcoder-2020-summer-multi-3/</url>
      
        <content type="html"><![CDATA[<p>这一轮比赛的题目明显比起之前要友好许多——至少在最后一刻都能让队友满载做题，甚至还能感觉到一丝时间不够用……这比起之前的比赛可以说是天大的进步了，不过这也都是因为题目友好；而且简单的能做的题目就要尽快做出来这一愿望在这次比赛砸的荡然无存（签到题 +5 <del>我来给大家表演一个队友消失术</del></p><figure><img src="https://i.loli.net/2020/07/19/7WJINdO6k9SLMTn.gif" class="lazyload" data-srcset="https://i.loli.net/2020/07/19/7WJINdO6k9SLMTn.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="89K5SF2PF2J7JT8QD.gif" /><figcaption aria-hidden="true">89K5SF2PF2J7JT8QD.gif</figcaption></figure><p>虽然题目数量变多了，但是这一次的题目应该会比之前的要好补；</p><p>因为接下来比赛还有好多，所以接下来的题目若无必要就都不放题目翻译了…… 毕竟像我这种萌新写翻译还是挺花时间的，补题才是要紧之事（</p><h2 id="a---clam-and-fish">A - <a href="https://ac.nowcoder.com/acm/contest/5668/A">Clam and Fish</a></h2><p>简单题，队友 A 的</p><h2 id="b---classical-string-problem">B - <a href="https://ac.nowcoder.com/acm/contest/5668/B">Classical String Problem</a></h2><h2 id="c---operation-love">C - <a href="https://ac.nowcoder.com/acm/contest/5668/C">Operation Love</a></h2><p>平面几何，给手形，可能翻转放大缩小，判断是左手还是右手；因为点是根据时针方向给的（这点省了很多事，有一说一我并不知道不按照顺序给我要怎么办），只需要一个叉积判断顺逆时针就完事；观察图形，最长边只有一个，所以可以利用最长边定位；确定方向之后，最长边前后长度就可以用作左右手的判据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">unsigned</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Geo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> number = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line">    <span class="keyword">const</span> number eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(number x)</span> </span>&#123;<span class="keyword">return</span> x &lt; -eps ? <span class="number">-1</span> : x &gt; eps;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(number a, number b)</span> </span>&#123;<span class="keyword">return</span> compareTo(a-b);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        number x, y;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">point</span>() = <span class="keyword">default</span>;</span><br><span class="line">        <span class="built_in">point</span>(number x, number y) : x(x), y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">point</span> <span class="keyword">operator</span> +(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> &#123;x + rhs.x, y + rhs.y&#125;;&#125;</span><br><span class="line">        <span class="built_in">point</span> <span class="keyword">operator</span> -(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> &#123;x - rhs.x, y - rhs.y&#125;;&#125;</span><br><span class="line">        number <span class="keyword">operator</span> *(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x * rhs.x + y * rhs.y;&#125;</span><br><span class="line">        <span class="built_in">point</span> <span class="keyword">operator</span> *(<span class="keyword">const</span> number rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> &#123;rhs * x, rhs * y&#125;;&#125;</span><br><span class="line">        <span class="built_in">point</span> <span class="keyword">operator</span> /(<span class="keyword">const</span> number rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> &#123;x / rhs, y / rhs&#125;;&#125;</span><br><span class="line">        <span class="built_in">point</span> &amp;<span class="keyword">operator</span> +=(<span class="keyword">const</span> <span class="built_in">point</span>&amp; rhs) &#123;x += rhs.x; y += rhs.y; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">        <span class="built_in">point</span> &amp;<span class="keyword">operator</span> -=(<span class="keyword">const</span> <span class="built_in">point</span>&amp; rhs) &#123;x -= rhs.x; y -= rhs.y; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">        <span class="built_in">point</span> &amp;<span class="keyword">operator</span> *=(<span class="keyword">const</span> number rhs) &#123;x *= rhs; y *= rhs; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">        <span class="built_in">point</span> &amp;<span class="keyword">operator</span> /=(<span class="keyword">const</span> number rhs) &#123;x /= rhs; y /= rhs; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> ==(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x == rhs.x &amp;&amp; y == rhs.y;&#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> !=(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> !(rhs == *<span class="keyword">this</span>);&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">number <span class="title">dot</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x * rhs.x + y * rhs.y;&#125;</span><br><span class="line">        <span class="function">number <span class="title">cross</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> rhs.y * x - rhs.x * y;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(dot(*<span class="keyword">this</span>));&#125;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">distance</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span> &amp;b)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> (*<span class="keyword">this</span> - b).length();&#125;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">distance</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span> &amp;ls, <span class="keyword">const</span> <span class="built_in">point</span> &amp;rs)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> <span class="built_in">fabs</span>((ls - *<span class="keyword">this</span>).cross(rs - *<span class="keyword">this</span>)) / ls.distance(rs);&#125;</span><br><span class="line">        <span class="function"><span class="built_in">point</span> <span class="title">normal</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> (x || y) ? *<span class="keyword">this</span> / length() : <span class="built_in">point</span>(<span class="number">0</span>, <span class="number">0</span>);&#125;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">angle</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">atan2</span>(y, x);&#125;</span><br><span class="line">        <span class="function"><span class="built_in">point</span> <span class="title">rotate</span><span class="params">(number a)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;number c = <span class="built_in">cos</span>(a), s = <span class="built_in">sin</span>(a); <span class="keyword">return</span> &#123;c * x - s * y, s * x + c * y&#125;;&#125;</span><br><span class="line">        <span class="function"><span class="built_in">point</span> <span class="title">perpendicular</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> &#123;-y, x&#125;;&#125;</span><br><span class="line">        <span class="function"><span class="built_in">point</span> <span class="title">symmetry</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> &#123;-x, -y&#125;;&#125;</span><br><span class="line">        <span class="function">number <span class="title">square</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x * x + y * y; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">line</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="built_in">point</span> s, t;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">line</span>() = <span class="keyword">default</span>;</span><br><span class="line">        <span class="built_in">line</span>(number a, number b, number x, number y) : s(a, b), t(x, y) &#123;&#125;</span><br><span class="line">        <span class="built_in">line</span>(<span class="keyword">const</span> <span class="built_in">point</span> &amp;s, <span class="keyword">const</span> <span class="built_in">point</span> &amp;t) : s(s), t(t) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">onLeft</span><span class="params">(<span class="built_in">point</span> p, <span class="built_in">line</span> l)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        number xx = (l.t - l.s).cross(p - l.s);</span><br><span class="line">        <span class="keyword">return</span> compareTo(xx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">point</span> = Geo::<span class="built_in">point</span>;</span><br><span class="line"><span class="keyword">using</span> number = Geo::number;</span><br><span class="line"><span class="keyword">using</span> Geo::compareTo;</span><br><span class="line"></span><br><span class="line"><span class="built_in">point</span> p[<span class="number">25</span>];</span><br><span class="line">number d[<span class="number">25</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++ i)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; p[i].x &gt;&gt; p[i].y;</span><br><span class="line">        d[<span class="number">0</span>] = p[<span class="number">0</span>].distance(p[<span class="number">19</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; ++ i)</span><br><span class="line">            d[i] = p[i].distance(p[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> xp = <span class="number">0</span>; number xx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (compareTo(d[i], xx) &gt; <span class="number">0</span>) xx = d[i], xp = i;</span><br><span class="line">        <span class="keyword">auto</span> hand = Geo::<span class="built_in">line</span>(p[xp], p[(xp + <span class="number">19</span>) % <span class="number">20</span>]);</span><br><span class="line">        <span class="keyword">auto</span> &amp;ff = p[(xp + <span class="number">18</span>) % <span class="number">20</span>], &amp;bb = p[(xp + <span class="number">1</span>) % <span class="number">20</span>];</span><br><span class="line">        <span class="keyword">if</span> (Geo::onLeft(ff, hand) &gt; <span class="number">0</span>)  <span class="comment">// counterclockwise</span></span><br><span class="line">            <span class="keyword">if</span> (compareTo(d[(xp + <span class="number">1</span>) % <span class="number">20</span>], d[(xp + <span class="number">19</span>) % <span class="number">20</span>]) &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;left&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;right&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span>                            <span class="comment">// clockwise</span></span><br><span class="line">            <span class="keyword">if</span> (compareTo(d[(xp + <span class="number">1</span>) % <span class="number">20</span>], d[(xp + <span class="number">19</span>) % <span class="number">20</span>]) &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;right&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;left&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>这题最开始我还把左右手弄反了，神秘</del></p><h2 id="d---points-construction-problem">D - <a href="https://ac.nowcoder.com/acm/contest/5668/D">Points Construction Problem</a></h2><h2 id="e---two-matchings">E - <a href="https://ac.nowcoder.com/acm/contest/5668/E">Two Matchings</a></h2><h2 id="f---fraction-construction-problem">F - <a href="https://ac.nowcoder.com/acm/contest/5668/F">Fraction Construction Problem</a></h2><h2 id="g---operating-on-a-graph">G - <a href="https://ac.nowcoder.com/acm/contest/5668/G">Operating on a Graph</a></h2><h2 id="h---sort-the-strings-revision">H - <a href="https://ac.nowcoder.com/acm/contest/5668/H">Sort the Strings Revision</a></h2><h2 id="i---sorting-the-array">I - <a href="https://ac.nowcoder.com/acm/contest/5668/I">Sorting the Array</a></h2><h2 id="j---operating-on-the-tree">J - <a href="https://ac.nowcoder.com/acm/contest/5668/J">Operating on the Tree</a></h2><h2 id="k---eleven-game">K - <a href="https://ac.nowcoder.com/acm/contest/5668/K">Eleven Game</a></h2><h2 id="l---problem-l-is-the-only-lovely-problem">L - <a href="https://ac.nowcoder.com/acm/contest/5668/L">Problem L is the Only Lovely Problem</a></h2><p>真 · 签到题；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">unsigned</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; ++ i) s[i] = <span class="built_in">tolower</span>(s[i]);</span><br><span class="line">    <span class="keyword">auto</span> ss = <span class="built_in">string</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (ss.length() &gt;= <span class="number">6</span> &amp;&amp; ss.substr(<span class="number">0</span>, <span class="number">6</span>) == <span class="string">&quot;lovely&quot;</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;lovely&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ugly&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比赛场上写的代码属实不好看，可以动作更快一些的（</p><h2 id="后记">后记</h2><p>赛后复盘，觉得能力范围应该在七题以上，部分简单题的实现速度可以更快；但是这些题目中有不少题目都是那个大一队友想出来的，这果然还是不太行；</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Nowcoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组会分享：TypeScript &amp; React 简单入门</title>
      <link href="/2020/Dian-hawkeye-introducing-of-typescript-and-react/"/>
      <url>/2020/Dian-hawkeye-introducing-of-typescript-and-react/</url>
      
        <content type="html"><![CDATA[<p>在目前主流的三大前端框架中，React 应该是和 TypeScript 联系最为紧密的；TypeScript 已经可以完美的融入到 React 的工具链中，所以若需要开发现代的、整洁的 React 应用， TypeScript 不可或缺；</p><p>此外，在 React 工具链中，React-Router 和 React-Redux 是重要的部分，它们也对 TypeScript 有很好的支持；这篇文章将结合刚过去不久的工程实训，谈谈我在使用 TypeScript + React 工具链的一些想法和实践；</p><h2 id="typescript-入门">TypeScript 入门</h2><p>有道：学习一门语言的最好方法是看它的<a href="https://www.tslang.cn/">官方文档</a>；</p><p>下面仅简单的介绍一些可以用的到的东西：</p><h3 id="建立项目">建立项目</h3><p>考虑到你组项目常用 React + antd 组合，所以可以通过执行下面命令创建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn create react-app antd-demo-ts --template typescript</span><br><span class="line"><span class="comment"># ↑ yarn || npm ↓</span></span><br><span class="line">npx create-react-app antd-demo-ts --typescript</span><br></pre></td></tr></table></figure><p>均使用 <strong>CRA</strong> 创建样板项目，具体的配置被隐藏，一般需要 <code>eject</code> 后才可以修改；</p><p>虽然理论上需要使用 <code>tsc</code> 将 TypeScript 代码编译成 js 代码，但是这些事情都已经被脚手架集成了，所以在 React 项目中不用考虑这些事情。</p><p>需要注意的是，很多 node 模块默认是不包含 TypeScript 支持的；当你需要向一个 TypeScript 工程中引入某个模块时，不仅需要安装这个模块，还需要安装它的类型声明文件，就像这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add react-router-dom @types/react-router-dom</span><br><span class="line"><span class="comment"># ↑ yarn || npm ↓</span></span><br><span class="line">npm install react-router-dom @types/react-router-dom</span><br></pre></td></tr></table></figure><p>否则，IDE 将会因为找不到类型声明文件而报错，或提示你没有安装对应的包。</p><h3 id="类型标识">类型标识</h3><p>TypeScript 和 JavaScript 的核心区别；即使 React.js 可以通过 jsdoc 或者 proptype 进行类型检查和 IDE 指导，但是均没有 TypeScript 原生的类型检查来的优雅自然：</p><blockquote><p>jsDoc：受有限的支持，在部分 IDE 中甚至不会有语法高亮；仅能在有限的环境中提供 IDE 建议，而不是强制的语法保证；毕竟本质上只是注释。</p><p>propType：是运行时的类型检查，并不能在编译期间提供任何指引。</p></blockquote><p>类型标识的格式：<code>变量名 / 参数名 / 类域名 : 类型标识符</code>，这些声明和 JavaScript 所在位置一样。</p><p>类型标识符包括 JavaScript Object 类型和由库定义的类型；浏览器，网页对象模型中的类型已经在 React 中定义好，也可以直接使用：</p><table><colgroup><col style="width: 20%" /><col style="width: 80%" /></colgroup><thead><tr class="header"><th>组别</th><th>标识符</th></tr></thead><tbody><tr class="odd"><td>JSON</td><td><code>number</code>, <code>string</code>, <code>object</code>, <code>any</code>, <code>null</code>, <code>undefined</code>, <code>boolean</code>, <code>&lt;class&gt;[]</code>, <code>void</code></td></tr><tr class="even"><td>TypeScript 特有</td><td><code>never</code>：表示的是永不存在的值的类型<br /><code>any</code>：表示任何类型，TypeScript 将放弃类型检查</td></tr><tr class="odd"><td>函数</td><td><code>(param: any) =&gt; void</code>：括号中是参数类型，需要指定参数名，但只对比参数类型</td></tr><tr class="even"><td>用户定义的类型</td><td>使用 <code>interface</code> 关键字定义的类型和 <code>type</code> 关键字定义的类型</td></tr><tr class="odd"><td>React 常见类型</td><td><code>React.Component&lt;P,S&gt;</code>：组件类，P 是 props 类型，S 是 state 类型<br /><code>JSX.Element</code>：JSX 标签类型，可以作为组件的返回值<br /><code>React.CSSProperties</code>：描述了 style 的对象，连字符被更换成了驼峰命名法<br /><code>React.&lt;...&gt;Event</code>：代表各种 HTML 事件的类型，如 change 和 keyboard 等</td></tr></tbody></table><p>在 TypeScript 中，声明变量的类型如果不能由上下文自动推导，将提示错误：即你需要在任何不能推断类型的地方使用类型标识规定类型才能使得代码通过编译；</p><h3 id="类型运算">类型运算</h3><p>比起其他强类型语言类型的麻烦，TypeScript 提供了灵活的类型运算；我们称其结果为<strong>类型谓词</strong>：</p><table><colgroup><col style="width: 17%" /><col style="width: 82%" /></colgroup><thead><tr class="header"><th>关键字</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><code>typeof</code></td><td>获得其后跟随的变量类型，具体如下：<br />- 跟随普通变量将获得变量的类型<br />- 跟随字符串将获得字符串字面量的类型<br />- 跟随对象将获得包含对象中所有属性的类型<br />- 跟随<strong>箭头函数</strong>将获得该函数的类型签名<br />这个表达式运行的结果是类型谓词。</td></tr><tr class="even"><td><code>interface</code></td><td>类似 C 中的结构体（下文简称），声明包含特定属性的对象的类型谓词；</td></tr><tr class="odd"><td><code>type</code></td><td>用来声明类型（谓词）或者类型别名；它可以接受：<br />- 一个类型谓词的赋值，形如 <code>typeof xxx</code><br />- 使用 <code>|</code> 或 <code>&amp;</code> 运算符组合的类型，形如 <code>string | number</code><br />- 接受字符串/数字字面量类型，形如 <code>'big' | 'small'</code><br />格式为 <code>type MyType = &lt;类型谓词&gt;</code>，接下来你可以使用 <code>MyType</code> 了；</td></tr><tr class="even"><td><code>Partial&lt;T&gt;</code></td><td>T 为结构体，得到 T 所有域均为可选的类型谓词</td></tr><tr class="odd"><td><code>Required&lt;T&gt;</code></td><td>T 为结构体，得到 T 所有域均为必须的类型谓词</td></tr><tr class="even"><td><code>Nullable&lt;T&gt;</code></td><td>T 为结构体，得到 T 所有域均为可空的类型谓词</td></tr></tbody></table><p>↑↑ 后三个这种“类型”还有很多，出现在 <code>typescript/lib/lib.es5.d.ts</code> 的 1440 行左右，可以去看（</p><p>声明 <code>interface</code> 时，可以对成员变量标志后增加 <code>?</code> 来表明它是可选的，也可以在标志前增加 <code>readonly</code> 来表明它是只读的；比如你可以这样声明一个 “结构体”：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">    username: <span class="built_in">string</span>;</span><br><span class="line">    avatar: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">readonly</span> password?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你只需要一个 <code>interface</code> 中的部分属性的时候（比如后端通信），就可以使用 <code>Partial&lt;User&gt;</code> 来获得这样的类型；</p><h3 id="在-react-中使用">在 React 中使用</h3><p>React 现在有两种写法：一种是比较经典的 class 写法，还有一种是比较新的 React Hook 写法；它们均能和 TypeScript 较好的联动，增加代码的整洁程度：</p><h4 id="class-写法">class 写法</h4><p>首先，我们继承的 <code>React.Component</code> 的定义是 <code>React.Component&lt;P, S&gt;</code>；两个泛型参数分别制定了 props 类型和 state 类型，因此我们在创建一个组件时，需要先定义该组件的 props 和 state 的类型谓词；因为它们都是一个对象，所以我们使用 <code>interface</code> 定义它们的类型；一般遵循如下格式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component, CSSProperties&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">    style?: Partial&lt;CSSProperties&gt;;</span><br><span class="line">    className?: <span class="built_in">string</span>;</span><br><span class="line">    children?: JSX.Element | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IState &#123;</span><br><span class="line">    data: <span class="built_in">object</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> App <span class="keyword">extends</span> Component&lt;IProps, IState&gt; &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">props: IProps</span>) &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="built_in">this</span>.state = &#123;</span><br><span class="line">            data: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render(): JSX.Element &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;className, style&#125; = <span class="built_in">this</span>.props;</span><br><span class="line">        <span class="keyword">return</span> &lt;div className=&#123;className&#125; style=&#123;style ?? &#123;&#125;&#125;&gt;</span><br><span class="line">            &#123;<span class="built_in">this</span>.props.children&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大体和 JavaScript 一致，只是增加了类型标识；需注意非箭头方法仍然需要 this 绑定；</p><h4 id="react-hook-写法">React Hook 写法</h4><p>其实只是函数式组件的写法，和 Hook 相关的内容暂时扯不上太多关系：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;CSSProperties, FC, memo, useState&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> IProps &#123;</span><br><span class="line">    style?: Partial&lt;CSSProperties&gt;;</span><br><span class="line">    className?: <span class="built_in">string</span>;</span><br><span class="line">    children?: JSX.Element | <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App: FC&lt;IProps&gt; = memo(<span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> [data, setData] = useState(&#123;&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &lt;div className=&#123;className&#125; style=&#123;style ?? &#123;&#125;&#125;&gt;</span><br><span class="line">        &#123;<span class="built_in">this</span>.props.children&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>只是当组件需要持有状态时，采用 <code>useState</code> 钩子创建即可；下面列出了一些常用 Hook：</p><table><colgroup><col style="width: 14%" /><col style="width: 14%" /><col style="width: 71%" /></colgroup><thead><tr class="header"><th>Hook</th><th>来源</th><th>作用</th></tr></thead><tbody><tr class="odd"><td><code>useState</code></td><td>React</td><td>为当前的函数组件增加一个状态；返回一个包含状态和修改函数的数组；</td></tr><tr class="even"><td><code>useContext</code></td><td>React</td><td>在 Provider 下使用，获取其提供的共享 Context 对象；</td></tr><tr class="odd"><td><code>useEffect</code></td><td>React</td><td>用于取代 class 型组件的生命周期方法：<br />它接受两个参数：一个回调函数（异步）和一个包含依赖项的数组；<br />当依赖项发生变化时，它会调用回调函数；<br />省略第二个参数：每次重新渲染时调用回调函数；<br />第二个参数为空：仅第一次渲染时调用回调函数</td></tr><tr class="even"><td><code>useReducer</code></td><td>React</td><td>和 <code>useState</code> 类似；接受 Reducer 函数和初始状态作为参数；</td></tr><tr class="odd"><td><code>useHistory</code></td><td>React-Router</td><td>在路由组件下使用，获得该路由依据的 History 对象，可用于跳转页面；</td></tr></tbody></table><p>但是 TypeScript 的强大之处并没有体现出来，当和 Redux 一起使用，组件的类型不能够明晰的分辨出时，TypeScript 所提供的类型提示的作用才可以真正反映出来；</p><h2 id="redux-入门">Redux 入门</h2><p>Redux 是前端的一个中心化数据管理的框架；它将一些组件中需要重复使用的数据提取出来，存储到一个统一的位置供组件拿取；并通过统一的预定义的行为对存储的数据进行修改，从而达成了数据流可控；在 React 中，Redux 通过 React 组件的上下文来实现；</p><p>本部分进行简单的 Redux 概念介绍，并结合 React Hook 和 TypeScript 构建代码：</p><h3 id="概念介绍">概念介绍</h3><p>首先先介绍专有名词：</p><ul><li><strong>Store</strong>：即存储，中心化状态管理体系中数据存储的地方；对于 React 等现代前端框架而言，每个 SPA 仅持有 <strong>1 个</strong>；它是一个树状结构，可以用对象的形式表示；</li><li><strong>Action</strong>：即行为，用来修改 store 中存储的状态；一般来说，它是一个<strong>对象</strong>，包含这个 Action 是什么以及执行这个行为所需要的数据；</li><li><strong>Reducer</strong>：用来处理 Action，是一个<strong>函数</strong>；它接受 store 的上一个状态和 Action，返回新的 store 状态；它是一个<strong>纯函数</strong>，且定义了 store 的结构；</li><li><strong>Action Creator</strong>：即行为创造器，它可以接受必须的信息，用来生成一个符合要求的 Action 对象，是一个函数；</li></ul><p>实际上，Redux 的工作流程可以概括为下图：</p><figure><img src="https://cdn.jsdelivr.net/gh/ymd45921/util_assets@master/post/web-frontend-react/Redux.svg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ymd45921/util_assets@master/post/web-frontend-react/Redux.svg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="流程图" /><figcaption aria-hidden="true">流程图</figcaption></figure><p>由 Action Creator 创造的 Action 对象可以通过 <code>store.dispatch()</code> 方法分发给 Store，Store 根据 Action 的类型（即这是什么行为）将它交给对应的 Reducer 计算出新的状态进行更新；</p><p>和 Store 的树形结构一样，Reducer 也是树形结构——可包含多个子 Reducer，和 Store 一一对应；Store 的树形结构来自 JavaScript 对象的嵌套，Reducer 的树形结构来自于多个子 Reducer 的合并；一般写法如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> StoreState &#123;</span><br><span class="line">    user: UserStore;</span><br><span class="line">    homepage: HomepageStore;</span><br><span class="line">    component: ComponentStore;</span><br><span class="line">    category: CategoryStore;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducers = combineReducers(&#123;</span><br><span class="line">    user: userReducer,</span><br><span class="line">    homepage: homepageReducer,</span><br><span class="line">    component: componentReducer,</span><br><span class="line">    category: categoryReducer,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> enhancer = composeWithDevTools(AsyncMiddleware);</span><br><span class="line"><span class="keyword">const</span> store = createStore(reducers, enhancer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App: FC = memo(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">&lt;/&gt;</span><br><span class="line">    &lt;/Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面代码中的 <code>XxxStore</code> 和 <code>xxxReducer</code> 分别是子 Store 和子 reducer，唯一的根 Store 即由合并得到的根 Reducer 生成的 <code>store</code>；<code>enhancer</code> 是增强件，可以用来强化 Redux 的功能；上图的 ”Async Middleware“ 就是其中一种，这里先不细说；创建的 Store 需要使用 Provider 提供给虚拟 DOM 某节点下所有的节点，这里通过 React 的上下文来实现；</p><p><code>composeWithDevTools</code> 来自 node 模块 <code>redux-devtools-extension</code>；它可以和 Chrome 同名插件配合使用，输出 Action 对 Redux Store 的更改轨迹，并随时查看 Store 中存储的值；它也属于 enhancer 的一种，建议使用；</p><h3 id="关于-react-redux">关于 React-Redux</h3><p>可以看到，Redux 这种设计模式适用于任何根据数据渲染组件的前端框架，这当然包括 React；React-Redux 的出现代替了上面提到的“订阅/通知”，而采用一种更加自然的方式帮助我们完成了这项工作。</p><p>在说这个之前先说一种在 React 中非常常见的设计模式：</p><blockquote>#####<center>有状态组件和无状态组件</center><p>顾名思义，状态指 React 中的 state；有状态组件不仅需要参与页面渲染，还需要包含逻辑来维护它自身所持有的状态；而无状态组件仅根据父组件传进来的 props 渲染视图；</p><p>软件设计中有一个原则，叫做“责任分离”：即让一个模块的责任尽量少；当模块负责的内容过多，应当将模块进行拆分，以使得每一个模块尽可能专注一个事务，以方便后续维护。</p><p>显然，渲染视图和维护状态的逻辑并不是一项功能，特别是当逻辑复杂时，会导致很大的组件——这对于后期项目维护来说是致命的；一种显然的解决措施就是将维护状态逻辑和渲染视图分离，即将一个“传统组件”拆分成有状态组件（即“容器”）和无状态组件（即“视图”）；</p><p>首先，渲染视图和逻辑并不沾边，这样的分割是合理的；其次，这样做可以方便的更换数据管理的方式：比如有状态组件从 Redux 获取数据；也可以方便的更换数据的展示方式，这样做均只需要修改对应的组件即可，避免了对代码的大规模改动。</p></blockquote><p>如果我们要在项目中使用 Redux，显然视图组件的数据来源是 Redux，我们应当使用这种设计模式；但是这方面的工作 React-Redux 已经帮我们做好了，我们只需要专注视图组件的展示即可；React-Redux 提供了方便的 API 实现 Store 中数据和视图状态的双向绑定：</p><ul><li><strong>mapStateToProps</strong>：将 Store 中储存的状态双向绑定到组件的 Props，从而组件可以通过 Props 获得渲染视图所需要的状态；它的类型声明是 <code>(state: Store) =&gt; object</code>；</li><li><strong>mapDispatchToProps</strong>：将 Store 接受的 Action 的 Creator 通过 Props 传递给组件；Action 是改变 Store 状态唯一的途径，组件可以通过这些方法产生需要的 Action 并且自动分发到 Store；</li><li><strong>connect</strong>：接受上面的两个用户定义的方法和视图组件，自动生成一个该视图组件的容器组件；这个容器组件可以读取 Store 中特定的数据并交给视图组件渲染，并在必要时触发 Action；</li></ul><p>简单的说，就是用户提供用于渲染视图的无状态组件，以及该组件需要进行的 Action，也就是逻辑，由 React-Redux 负责生成对应组件的容器；用户无需进行具体的组件状态管理，只需要定义 Action 和编写视图组件；在所有需要使用到该组件的场合使用 React-Redux 自动生成的组件即可；</p><h3 id="使用-redux">使用 Redux</h3><p>使用 React 的好处不言而喻；状态的更改有迹可循，组件并不需要维持很多状态就可以渲染视图，整个项目的逻辑更加的清晰自然；但是缺点也是显而易见的——将所有的操作定义为 Action 将产生大量的”无用代码“，增加了项目的代码量和复杂程度；React 自身也有优秀的状态管理，如果完全使用 Redux 作为状态管理，也是对 React 的功能的一种浪费；因此要做到有的放矢，才是最佳实践：</p><ul><li>被多个 React 组件共享的状态需要放进 Redux</li><li>组件重新装载，仍然需要持有之前的状态时需要放进 Redux</li><li>否则，这个状态就放在 React 组件中好了</li></ul><p>通过上面的方法可以判断一个状态是否要放进 Redux 中；对于放进 Redux 状态，我们仍然需要遵循一些”公理“，来使得代码的逻辑更加的合理：</p><ul><li>Redux 中的数据应当是范式化的 ”Raw Data“</li><li>通过 selector 将处理后的数据传送给组件</li><li>只有少量的关键组件 connect 了 Redux Store</li></ul><p>Selector 相当于 Vue 中的计算属性 computed：它以 Store 中存储的一些数据为基础，记忆化的存储计算结果，且仅在这些数据源发生改变时才重新计算；比起 React 每次使用数据都进行重复计算要更加高效；Selector 本质上只是接受状态的函数，包含计算出容器所需要的数据的逻辑；它可复用，且一般在 mapStateToProps 中使用；</p><h3 id="处理异步事件">处理异步事件</h3><p>如果仅使用前面提到的 Redux，我们需要为一个异步事件确定三个 Action：它们分别在异步事件开始时、异步事件 Fulfilled 和 Rejected 的情况下被触发；对应 Promise 的 resolve 和 reject；如果这些操作都在需要执行异步请求的组件中手动调用，将造成大量的重复代码，不可取；但是 Redux 的设计要求 Action 只能是同步的，我们并不能想当然的将一个异步事件做成一个 Action；此时就需要异步中间件了。</p><p>异步中间件仍然需要定义多个 Action，但是它将根据异步请求的结果自动地调用后续 Action，减少了代码重复；同时，异步 Action 遵循了 Redux 的标准，它对状态的修改也是可追溯的；常用的异步中间件如下：</p><ul><li><strong>Redux-thunk</strong>：简单易上手，但功能有限；它会在第一个 Action 发出之后，自动地发出第二个 Action 用异步获取的数据来更新状态；</li><li><strong>Redux-observable</strong>：基于 RxJS 的 <code>observer</code> 实现，功能强大，可以处理复杂的事件流，但是学习门槛较高；</li><li><strong>Redux-Saga</strong>：基于 JavaScript Generator 语法，介于上述两者之间；下文将着重介绍它的使用；</li></ul><p>异步中间件属于对于 Redux 的拓展，在创建 store 时需要将需要的中间件放在上文代码 <code>enhancer</code> 的位置；</p><h4 id="中间件原理">中间件原理</h4><p>分析 Redux 的工作流程，Reducer 和 Action 是纯函数和纯对象，并不能进行改动；再参考上面说的没有中间件的情况下异步 Action 的方法，考虑到我们需要在 Action 分发的过程中增加中间件来自动完成一些工作；</p><p>中间件相当于一个改造过的 <code>store.dispatch</code>；dispatch 方法可以拿到行为和前状态，并且有和可以改变状态的 Reducer 通信的能力；如果我们需要做什么包含副作用的行为，在 dispatch 函数内最合适不过了；所谓中间件，就是按照 Redux 的标准对 dispatch 方法进行了一些改造，增强了它的功能；</p><p>比如 <code>redux-logger</code> 中间件，他会在收到前状态和行为时打印前状态，并且在和 Reducer 通信后打印新状态；又比如上面提到的 <code>redux-thunk</code> 中间件要求 Action Creator 返回一个异步请求执行前和执行后都会发起同步 Action 的函数；这种特别的 Action Craetor 产生的 Action 本不能被 dispatch 函数处理，但是中间件增强了它的功能，使得这种 Action 被中间件处理成可以自动发起第二个 Action 的效果；从而达到了异步通信的目的；</p><h3 id="使用-redux-saga">使用 Redux-Saga</h3><p>Redux-Saga 采用了 JavaScript 的生成器语法；它接管部分 Action，在收到 Action 时产生一个生成器对象，并且逐步执行其中的语句——这个过程保证了其内部语句执行的顺序；这个过程中可以发起新的 Action，由中间件自动完成；为了和普通的 Action 区分开来，我们将这部分被接管的 Action 称为 Saga；</p><h4 id="生成器语法">生成器语法</h4><p>首先先介绍大家都很熟悉的 <code>yield</code> 关键字：它在 C# 和 Python 中都存在<del>也即将出现在 C++ 2a</del>，在各领域（如 Unity 游戏编程）的协程中发挥作用；JavaScript / TypeScript 的 <code>yield</code> 和其它语言类似，如果理解的话就不用看下面了；</p><p>生成器函数使用 <code>function*</code> 声明，调用它将返回一个迭代器；每次调用迭代器都将执行到 <code>yield</code> 语句所在位置，并将该语句的值作为阶段性返回值返回，直到该函数中所有的语句都已经执行完毕；简单的说，<code>yield</code> 语句将会确保严格按照其顺序执行；</p><p>在 Redux-Saga 中，我们并不需要手动的去调用迭代器的 <code>next</code> 方法，中间件将会替我们完成；</p><h4 id="saga-的组成">Saga 的组成</h4><p>和定义 Action 类似，定义 Saga 依然需要包含四个部分；但是它们被 dispatch 后的处理方式不同：</p><p>一般的 Action 需要被 Reducer 接受并且利用 <code>switch</code> 语句计算新状态，而 Saga 需要被已注册的监视函数监听后，根据定义的并行策略调用生成器函数，并自动迭代；异步 Action 需要发起的其他 Action 均可以作为该生成器函数中可迭代的一步；</p><p>因此，对于一个 Saga，我们还需要额外定义它的监视函数（仅包含一个语句，决定了这个异步行为的策略）和它的生成器函数（包含了这个行为需要进行的异步操作逻辑），代码范例见下文代码范式；</p><h4 id="使用-saga">使用 Saga</h4><p>和普通的 Action 一样，将 Saga 的 Action Creator 通过 React-Redux 的 <code>mapDispatchToProps</code> 方法传递给组件即可；创造出的 Saga 会被注册的监听函数捕捉，并自动迭代生成器函数；</p><h3 id="代码范式">代码范式</h3><p>对于上一部分提到的一些名词，这里展示一些使用 TypeScript 编写的范式代码供参考：</p><h4 id="action-action-creator">Action &amp; Action Creator</h4><p>定义一个 Action 至少需要下面四个声明：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> LOGIN = <span class="string">&#x27;LOGIN&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> LOGIN = <span class="keyword">typeof</span> LOGIN;<span class="comment">// 取字符串字面量作为此 Action 的类型标识</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> Login &#123;</span><br><span class="line">    <span class="keyword">type</span>: LOGIN;<span class="comment">// Action 的类型声明，必须包含 type 域</span></span><br><span class="line">    token: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params">token: <span class="built_in">string</span></span>): <span class="title">Login</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="keyword">type</span>: LOGIN, token&#125;;<span class="comment">// Action Creator 制造一个 Action 对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Action 标识字符串，Action 表示类型谓词，Action 对象的类型谓词和 Action Creator 函数；一般分别采用大写 + 下划线、大写 + 下划线、Pascal 命名法、驼峰命名法来命名；</p><h4 id="reducer">Reducer</h4><p>一个 Reducer 也许要包含下面四个部分：接受的 Action 类型，由它更新的子 store 的类型声明，这个子 store 的初始值以及 Reducer 函数；</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Action = actions.Login | actions.Logout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> UserStore &#123;</span><br><span class="line">    token: <span class="built_in">string</span>;</span><br><span class="line">    info: User;</span><br><span class="line">    isLoading: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> init: UserStore = &#123;</span><br><span class="line">    token: <span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;token&#x27;</span>) ?? <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    info: &#123;&#125; <span class="keyword">as</span> User,</span><br><span class="line">    isLoading: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">userReducer</span>(<span class="params">state = init, action: Action</span>): <span class="title">UserStore</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> actions.LOGIN:</span><br><span class="line">            <span class="keyword">const</span> &#123;token&#125; = action;</span><br><span class="line">            <span class="built_in">localStorage</span>.setItem(<span class="string">&#x27;token&#x27;</span>, token);</span><br><span class="line">            <span class="keyword">return</span> &#123;...state, token&#125;;</span><br><span class="line">        <span class="keyword">case</span> actions.LOGOUT:</span><br><span class="line">            <span class="built_in">localStorage</span>.removeItem(<span class="string">&#x27;token&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span> &#123;...userInit, token: <span class="string">&#x27;&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从外部导入已经定义好的 Action 对象类型谓词，并将该 Reducer 需要处理的 Action 类型通过类型运算符 <code>|</code> 合并起来，就是这个 Reducer 需要接受的 Action 类型的类型谓词；</p><p>Reducer 函数需要接受上一个 Store 的状态和要进行的 Action 对象，通过 <code>switch</code> 语句匹配 Action 标识类型并且进行对应的操作，计算出新对象返回；当上一个 Store 状态不存在时，填入初始值；</p><h4 id="react-redux">React-Redux</h4><p>下面的代码为视图组件 AppBar 创造了一个容器类：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;connect&#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;bindActionCreators, Dispatch&#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> AppBar <span class="keyword">from</span> <span class="string">&#x27;../components/AppBar&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state: StoreState</span>) =&gt;</span> (&#123;</span><br><span class="line">    loggedIn: <span class="function">(<span class="params">state</span>) =&gt;</span> !!state.user.token,<span class="comment">// 一个简单的 selector</span></span><br><span class="line">    userInfo: state.user,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch: Dispatch</span>) =&gt;</span> bindActionCreators(&#123;</span><br><span class="line">    updateToken: actions.login,</span><br><span class="line">    logout: actions.logout,</span><br><span class="line">&#125;, dispatch)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> StateProps = ReturnType&lt;<span class="keyword">typeof</span> mapStateToProps&gt;;</span><br><span class="line"><span class="keyword">type</span> DispatchProps = ReturnType&lt;<span class="keyword">typeof</span> mapDispatchToProps&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> AppBarProps = StateProps &amp; DispatchProps;<span class="comment">// 作为 AppBar 视图组件的 IProps</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(AppBar);</span><br></pre></td></tr></table></figure><p>上述代码中提到的 <code>connect</code> 其实需要接受四个类型参数：<code>&lt;TStateProps = &#123;&#125;, TDispatchProps = &#123;&#125;, TOwnProps = &#123;&#125;, State = DefaultRootState&gt;</code>；但是因为可以类型推导以及默认值，所以这里没有写明：</p><ul><li><code>TStateProps</code>：由 <code>mapStateToProps</code> 带来的 props，上述代码中已经赋值给了 <code>StateProps</code>；</li><li><code>TDispatchProps</code>：由 <code>mapDispatchToProps</code> 带来的 props，上述代码中已经赋值给了 <code>DispatchProps</code>；</li><li><code>TOwnProps</code>：除了这些之外该组件需要的 props；比如需要传入路由参数时，该值应当为 <code>RouteComponentProps</code>；</li><li><code>State</code>：即原始 Store 的类型，已经通过默认值自动赋值了，一般不需要修改；</li></ul><p>当你要将路由参数传入容器时，不仅需要显式地传入类型参数 <code>RouteComponentProps</code>，还需要将组件使用 <code>withRouter</code> 方法处理；即：<code>export default withRouter(connect&lt;StateProps, DispatchProps, RouteComponentProps, StoreState&gt;(mapStateToProps, mapDispatchToProps)(AppBar));</code>；</p><h4 id="redux-saga">Redux-Saga</h4><p>和其他异步中间件一样，Redux-Saga 接管了部分 Action 的处理，我们称这些 Action 为 Saga；下面是定义一个 Saga 并且将它应用到 store 的代码样例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;put, takeLatest, call, all&#125; <span class="keyword">from</span> <span class="string">&#x27;redux-saga/effects&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> createSagaMiddleware <span class="keyword">from</span> <span class="string">&#x27;redux-saga&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">worker</span>(<span class="params">action: $actions.FetchInfoStart</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> put(actions.processStarted());<span class="comment">// 发起异步操作开始的 Action</span></span><br><span class="line">        <span class="keyword">const</span> res = <span class="keyword">yield</span> axios.get(api.me);<span class="comment">// 调用异步 API</span></span><br><span class="line">        <span class="keyword">const</span> body = res.data;</span><br><span class="line">        <span class="keyword">if</span> (body.code &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">yield</span> put(actions.InfoFetched(action.uid, body.data));<span class="comment">// 发起更新数据的 Action</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">yield</span> <span class="built_in">console</span>.log(body.msg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">yield</span> message.error(e.toString());<span class="comment">// 可以发起 Reject 的第二个 Action</span></span><br><span class="line">        $history.push(url.$<span class="number">404</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">yield</span> put(actions.processHandled());<span class="comment">// 发起 Fulfill 的第二个 Action</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">watcher</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> takeLatest($actions.FETCH_USER_INFO_START, worker);<span class="comment">// 另有 takeEvery 代表允许并行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sagas = [watcher];<span class="comment">// 用来存放不同 saga 的 watcher</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">Sagas</span>(<span class="params"></span>) </span>&#123;<span class="comment">// 注册所有的 saga</span></span><br><span class="line">    <span class="keyword">yield</span> all(sagas.map(<span class="function"><span class="params">saga</span> =&gt;</span> call(saga)));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> saga = createSagaMiddleware();</span><br><span class="line"><span class="keyword">const</span> AsyncMiddleware = applyMiddleware([saga]);</span><br><span class="line"><span class="keyword">const</span> enhancer = composeWithDevTools(AsyncMiddleware);<span class="comment">// 组合 enhancer，引入 devtool</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducers, enhancer);<span class="comment">// 创建 store</span></span><br><span class="line">saga.run(Sagas);<span class="comment">// 启动 Redux-Saga</span></span><br></pre></td></tr></table></figure><p>代码中的 <code>takeLatest</code> 表示不允许并行，仅监听并执行最新的异步 Action；</p><h2 id="react-router-5.x">React-Router 5.x</h2><p>官方文档还停留在 3.0 版本，可是这玩意从 4.x 开始就已经和之前截然不同了；本部分的内容也无法解释很多，仅从个人使用的过程中总结一下经验和踩过的坑；</p><h3 id="安装">安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn add react-router react-router-dom @types/react-router @types/react-router-dom</span><br><span class="line"><span class="comment"># ↑ yarn || npm ↓</span></span><br><span class="line">npm install react-router react-router-dom @types/react-router @types/react-router-dom</span><br></pre></td></tr></table></figure><h3 id="组件">组件</h3><p>常用的组件包括三种：</p><ul><li>根组件（路由组件）：使用 history 模式的 <code>BrowserRouter</code> 和使用 hash 模式的 <code>HashRouter</code></li><li>路径匹配组件：可嵌套的路径组件 <code>Route</code> 和非嵌套的 <code>Switch</code> 组件；</li><li>导航跳转：<code>Link</code> 组件和 <code>NavLink</code> 组件、<code>Redirect</code> 组件等；</li></ul><p>除非在静态服务器上部署使用 hash 路由，否则强烈建议使用基于 History 的 <code>BrowswerRouter</code>；</p><p>Route 组件接受的参数主要包括下面的内容：</p><table><thead><tr class="header"><th>props</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><code>path: string</code></td><td>路由的路径；在没有 <code>exact</code> 标志时只匹配前缀，且按照从上到下的顺序匹配</td></tr><tr class="even"><td><code>exact: boolean</code></td><td>精准匹配标志；当包含此标志时，路径匹配将要求完全一致，但忽略末尾的 '/'</td></tr><tr class="odd"><td><code>component</code></td><td>渲染组件；当路径匹配成功时需要渲染的组件</td></tr><tr class="even"><td><code>render</code></td><td>渲染函数；当路径匹配成功时将调用此函数渲染视图，可用于 SPA 的懒加载</td></tr><tr class="odd"><td><code>children</code></td><td>可以是其他路由组件以组成嵌套路由；也可以只是一般的 JSX</td></tr></tbody></table><p>因为 React-Router 导航的 Web 应用本质是单页应用（SPA）；当应用包含过多信息时，第一次载入将会十分耗时；我们可以将一些暂时不需要渲染的页面（组件）延迟加载，从而缩短第一次加载所需要的时间，提升用户体验：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Homepage = lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../containers/pages/homepage&quot;</span>));</span><br><span class="line"><span class="keyword">const</span> User = lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;../containers/pages/user&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Index: FC = memo(<span class="function">() =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    useEffect(<span class="function">() =&gt;</span> <span class="built_in">window</span>.scrollTo(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> load = <span class="function">(<span class="params">Component: JSX.Element</span>) =&gt;</span> (props: RouteComponentProps) =&gt; (</span><br><span class="line">        &lt;Container &#123;...props&#125;&gt;</span><br><span class="line">            &lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt;</span><br><span class="line">                &#123;Component&#125;</span><br><span class="line">            &lt;/Suspense&gt;</span><br><span class="line">        &lt;/Container&gt;</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">          &lt;Route path=&#123;url.login&#125; exact component=&#123;Login&#125; /&gt;</span><br><span class="line">          &lt;Route path=&#123;url.register&#125; exact component=&#123;Register&#125; /&gt;</span><br><span class="line">          &lt;Route path=&#123;url.root&#125; exact render=&#123;load(&lt;Homepage /&gt;)&#125; /&gt;</span><br><span class="line">          &lt;Route path=&#123;url.user&#125; exact render=&#123;load(&lt;User /&gt;)&#125; /&gt;</span><br><span class="line">          &lt;Redirect to=&#123;url.$<span class="number">404</span>&#125;/&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在 <code>load</code> 方法中还可以自定义当按需加载的组件还在加载中时需要显示的内容：比如一个 Loading 的动画、一个进度条或者是骨架屏，显著提升用户体验；</p><h3 id="路由传参">路由传参</h3><p>在 TypeScript 中，路由传递的参数的类型谓词是 <code>RouteComponentProps</code>；如果你需要在一个组件中使用路由参数，你需要在导出该组件时使用 <code>withRouter</code> 方法将它包裹，并修改显式声明的 <code>IProps</code>；</p><p>传入 Route 参数之后，就可以通过 <code>match</code> 来获得匹配信息：比如通过 <code>match.params</code> 来获得路由参数；</p><h3 id="路由跳转">路由跳转</h3><p>有两种方法：经典的做法就是通过上面组件中的 <code>Link</code> 等导航组件进行跳转；当你使用 <code>BrowserRouter</code> 作为根路由组件时，你也可以在其子组件中通过 <code>useHistory</code> 钩子获得 History 对象，然后通过 <code>history.push</code> 方法进行路由跳转；需要注意的是 <code>useHistory</code> 是钩子，仅能在函数式 React 组件中使用；且当该组件渲染在跟路由组件外时，通过该钩子会得到 <code>undefined</code> 并且报错；</p><p>当然，上述做法都是需要在视图之内的地方才可以使用路由跳转的；如果你想要在视图之外的地方（比如异步逻辑层）进行路由跳转…… <strong>人不能，至少不应该</strong>。建议停下来思考有没有更好的实现方法；当然方法还是有的：比如在逻辑层使用 <code>ReactDOM.render</code> 在某个不可见的地方渲染一个 <code>Link</code> 组件，又或者让根组件使用外部的 history 对象；但是这样写出来一定是烂代码所以这里就不细说了。</p><h2 id="后记-总结">后记 &amp; 总结</h2><p>不是多少有技术含量的东西，但是属于读了一些还算整洁的 React 源代码的一些收获；按照这样的实践方法写出的代码确实要来的更加整洁；但是任何事情都没有绝对的最优实践：即使完全按照上面说到的这些写法来构筑代码，如果缺乏一个合理的设计，盲目追求“最佳实践”，最终只会适得其反。</p><p>虽然 Redux 提供了可追踪的状态管理，但是根据上面的代码范式也很容易知道，这是建立在大量繁杂的代码基础上的； 本质上 Redux 通过增加了额外的 Action 和 Reducer 代码来增强项目的可维护性，但是增加的代码是不是必要的</p><h3 id="参考资料">参考资料</h3><p><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" class="uri">http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html</a><br /><a href="https://www.tslang.cn/docs/home.html" class="uri">https://www.tslang.cn/docs/home.html</a><br /><a href="https://juejin.im/book/5ba42844f265da0a8a6aa5e9/section/5ba4840f5188255c791b0008" class="uri">https://juejin.im/book/5ba42844f265da0a8a6aa5e9/section/5ba4840f5188255c791b0008</a><br /><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html" class="uri">http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html</a><br /><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html" class="uri">http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html</a><br /><a href="https://www.cnblogs.com/samve/p/12435908.html" class="uri">https://www.cnblogs.com/samve/p/12435908.html</a><br /><a href="https://redux-saga-in-chinese.js.org/" class="uri">https://redux-saga-in-chinese.js.org/</a><br /><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators" class="uri">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators</a></p>]]></content>
      
      
      <categories>
          
          <category> Web </category>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课内作业 </tag>
            
            <tag> Web </tag>
            
            <tag> Dian </tag>
            
            <tag> React </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nowcoder 2020 暑期多校训练 （2）</title>
      <link href="/2020/nowcoder-2020-summer-multi-2/"/>
      <url>/2020/nowcoder-2020-summer-multi-2/</url>
      
        <content type="html"><![CDATA[<p>比完看到群里一群 hack 老哥和暴躁老哥，萌新不敢说话（</p><figure><img src="https://i.loli.net/2020/07/13/xpC7TEYt8sRZKGP.png" class="lazyload" data-srcset="https://i.loli.net/2020/07/13/xpC7TEYt8sRZKGP.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="3FUEYCMFGCVMO_XE2OY.png" /><figcaption aria-hidden="true">3FUEYCMFGCVMO_XE2OY.png</figcaption></figure><p>看着带佬们讨论，发现争议的 hack，卡常数，栈空间等问题都和我们没有关系…… 那没事了（</p><h2 id="a---all-with-pairs">A - <a href="https://ac.nowcoder.com/acm/contest/5667/A">All with Pairs</a></h2><blockquote><p>给定 n 个字符串，定义 f(s, t) 的值为满足 s 的前缀和 t 的后缀相等的最长长度，且不存在时为 0；</p><p>现要求计算出 <span class="math inline">\(\sum_{i=1}^n \sum_{j=1}^n f^2(s_i, s_j)\ mod\ 998244353\)</span>；也就是说求给定的 n 个字符串中任意两个字符串的“公共前后缀”长度之在模意义下的和；</p><p>数据范围：n ≤ 1e5，Σ|s| ≤ 1e6；</p></blockquote><p>和上一次多校的第一题一样，是我不喜欢的字符串题目，所以直接对着题解说好了：要求求出所有的两个字符串排列的最大公共顶针字串的长度在模意义下的和；因为字符串总长并不大，所以可以用 O(Σ|s|) 的时间预处理所有字符串的前/后缀哈希，利用哈希进行子串匹配；</p><p>接下来再遍历所有字符串的后/前缀，和已经预处理的哈希进行匹配即可；但是因为我们只计算最大公共子串长度的和，不必要的子串需要减掉，所以可以考虑使用 KMP 构建出 next 数组，然后利用这个 next 数组主动地去重；</p><p>仿造标程写的代码↓↓，并且重构了一下相关的板子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> ulongs = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">unsigned</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> uint N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> uint M = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> uint mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> StringHash</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> hashArray = <span class="built_in">vector</span>&lt;ulongs&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hashMachine</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> base, offset;</span><br><span class="line">        hashArray <span class="built_in">pow</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">idx</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> ch)</span></span>&#123;<span class="keyword">return</span> ch - <span class="string">&#x27;a&#x27;</span>;&#125;</span><br><span class="line"></span><br><span class="line">        explicit hashMachine(int n, int b = 233, int k = 5): base(b), offset(k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pow</span>.resize(n);</span><br><span class="line">            <span class="built_in">pow</span>[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">                <span class="built_in">pow</span>[i] = <span class="built_in">pow</span>[i - <span class="number">1</span>] * base;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, hashArray &amp;var)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">                var[i] = var[i - <span class="number">1</span>] * base + idx(s[i - <span class="number">1</span>]) + offset;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">ulongs <span class="title">get</span><span class="params">(hashArray &amp;var, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!l) <span class="keyword">return</span> var[r];</span><br><span class="line">            <span class="keyword">auto</span> len = r - l;</span><br><span class="line">            <span class="keyword">return</span> var[r] - var[l] * <span class="built_in">pow</span>[len];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildKMP</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;kmp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    kmp[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> length = s.length();</span><br><span class="line">    <span class="keyword">while</span>(i &lt; length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">-1</span> == j || s[i] == s[j])</span><br><span class="line">            kmp[++ i] = ++ j;</span><br><span class="line">        <span class="keyword">else</span> j = kmp[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;ulongs, uint&gt; $<span class="built_in">map</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; $next[M];</span><br><span class="line"><span class="built_in">vector</span>&lt;ulongs&gt; $hash[M];</span><br><span class="line">ulongs cnt[N], ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> hm = StringHash::hashMachine(N, <span class="number">6151</span>);</span><br><span class="line">    <span class="keyword">auto</span> handleHash = [&amp;](<span class="keyword">int</span> ii)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        $next[ii].resize(len + <span class="number">1</span>);</span><br><span class="line">        $hash[ii].resize(len + <span class="number">1</span>);</span><br><span class="line">        buildKMP(s, $next[ii]);</span><br><span class="line">        hm.make(s, $hash[ii]);</span><br><span class="line">        <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; len; ++ i)</span><br><span class="line">            ++ $<span class="built_in">map</span>[hm.<span class="built_in">get</span>($hash[ii], i, len)];</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s, handleHash(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> length = $hash[i].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> &amp;kmp = $next[i];</span><br><span class="line">        <span class="keyword">for</span> (uint j = <span class="number">1</span>; j &lt;= length; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt[j] = $<span class="built_in">map</span>[hm.<span class="built_in">get</span>($hash[i], <span class="number">0</span>, j)];</span><br><span class="line">            <span class="keyword">if</span> (kmp[j] != <span class="number">-1</span>) cnt[kmp[j]] -= cnt[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (uint j = <span class="number">1</span>; j &lt;= length; ++ j)</span><br><span class="line">            ans = (ans + cnt[j] * j % mod * j) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>吐槽：翻了一遍你科和武大的榜，竟然没有人做这个题，草（</p><p>再吐槽：牛客的 g++14 编译这个抛出了难以置信的 Assembler Error ↓↓，最后是 clang++ 编译过的（</p><figure><img src="https://i.loli.net/2020/07/16/q17NQnFSkxIHhu9.png" class="lazyload" data-srcset="https://i.loli.net/2020/07/16/q17NQnFSkxIHhu9.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="8W_0LU94U_I7GH9.png" /><figcaption aria-hidden="true">8W_0LU94U_I7GH9.png</figcaption></figure><p>啊这…… ICE？这太怪了（</p><h2 id="b---boundary">B - <a href="https://ac.nowcoder.com/acm/contest/5667/B">Boundary</a></h2><blockquote><p>平面上给定 n 个点的坐标，找一个圆，有如下要求：</p><ul><li>原点（0，0）在该圆的边界上</li><li>除原点外有尽可能多的点在此圆边界上</li></ul><p>问该圆的边界上除了原点之外的点的数量。</p><p>数据范围：n ≤ 2000；</p></blockquote><p>直接想到四点共圆，遍历两个点确定一个三角形——也就是圆，再遍历第三个点判断是否在这个圆上就行了，时间复杂度 O(n³)；可这就是个大暴力做法，就算跑不满也会被 2000 的数据卡掉<del>可是我 WA 了，神秘</del>；</p><p>于是思考复杂度较低的做法：若点共圆，那么它们确定的圆心相等，可以去遍历所有三角形确定的圆心然后找到聚集点……还是算了吧；除了圆心之外，同一个圆弧对应的圆周角是相等的，比起二维的坐标，一维的圆周角的众数显然更加好找，那么就可以这么做了；</p><p>但是圆弧对应的圆周角可能不在同一个圆上，还有可能出现在镜像中，所以还需要叉乘判断方向；这也许也是我上面暴力的方法出错的原因吧<del>（只考虑互补 / 相等，直接比较 |cos| 怕不是什么样的点都算进去了）</del>；</p><p>补充：听完讲题，还真有人通过中垂线找圆心做；这…… 使用分数类？有点想看这样通过的代码，找找看吧…… 啊这不用找了，eps 设为 0 才能 A，设为 1e-8 反而 A 不了，那没事了……</p><p>首先是按照标准做法，计算角度：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">unsigned</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T num, den;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">_t</span> = __int64;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">_t</span> = __int128;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    fraction() = <span class="keyword">default</span>;</span><br><span class="line">    fraction(T u, T v): num(u), den(v)</span><br><span class="line">    &#123; <span class="keyword">if</span> (!v) num = <span class="number">1</span>; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; <span class="number">0</span>) num = -u, den = -v; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> $eps = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> x)</span> </span>&#123;<span class="keyword">return</span> x &lt; -$eps ? <span class="number">-1</span> : x &gt; $eps;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T <span class="title">gcd</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? gcd(b, a) : (!b ? a : gcd(b, a % b));&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">toNumber</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">double</span>) num / den; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="keyword">const</span> fraction &amp;rhs)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> sgn(<span class="keyword">this</span>-&gt;toNumber() - rhs.toNumber());&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">equals</span><span class="params">(<span class="keyword">const</span> fraction &amp;rhs)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> den == <span class="number">0</span> || rhs.den == <span class="number">0</span> ? den == rhs.den : !compareTo(rhs);&#125;</span><br><span class="line">    <span class="function">fraction &amp;<span class="title">reduce</span><span class="params">()</span> </span>&#123; <span class="keyword">auto</span> x = gcd(num, den); num /= x, den /= x; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">atan2</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">atan2</span>(num, den);&#125;</span><br><span class="line">    <span class="function">fraction <span class="title">reciprocal</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> &#123;den, num&#125;;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> ==(<span class="keyword">const</span> fraction &amp;rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> num * rhs.den == den * rhs.num;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> fraction &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> den &amp;&amp; (!rhs.den || (<span class="keyword">_t</span>)num * rhs.den &lt; (<span class="keyword">_t</span>)den * rhs.num);&#125;</span><br><span class="line">    fraction <span class="keyword">operator</span> -() <span class="keyword">const</span> &#123;<span class="keyword">return</span> &#123;-num, den&#125;;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span> &lt;&lt;(ostream &amp;os, <span class="keyword">const</span> fraction &amp;frac)</span><br><span class="line">    &#123;<span class="keyword">if</span> (frac.den) os &lt;&lt; frac.num &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; frac.den; <span class="keyword">else</span> os &lt;&lt; <span class="string">&quot;NaN&quot;</span>; <span class="keyword">return</span> os;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Geo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> number = longs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> eps = fraction&lt;longs&gt;::$eps;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(number x)</span> </span>&#123;<span class="keyword">return</span> x &lt; -eps ? <span class="number">-1</span> : x &gt; eps;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(number a, number b)</span> </span>&#123;<span class="keyword">return</span> compareTo(a-b);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        number x, y;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">point</span>() = <span class="keyword">default</span>;</span><br><span class="line">        <span class="built_in">point</span>(number x, number y) : x(x), y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">point</span> <span class="keyword">operator</span> +(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> &#123;x + rhs.x, y + rhs.y&#125;;&#125;</span><br><span class="line">        <span class="built_in">point</span> <span class="keyword">operator</span> -(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> &#123;x - rhs.x, y - rhs.y&#125;;&#125;</span><br><span class="line">        number <span class="keyword">operator</span> *(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x * rhs.x + y * rhs.y;&#125;</span><br><span class="line">        <span class="built_in">point</span> <span class="keyword">operator</span> *(<span class="keyword">const</span> number rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> &#123;rhs * x, rhs * y&#125;;&#125;</span><br><span class="line">        <span class="built_in">point</span> <span class="keyword">operator</span> /(<span class="keyword">const</span> number rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> &#123;x / rhs, y / rhs&#125;;&#125;</span><br><span class="line">        <span class="built_in">point</span> &amp;<span class="keyword">operator</span> +=(<span class="keyword">const</span> <span class="built_in">point</span>&amp; rhs) &#123;x += rhs.x; y += rhs.y; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">        <span class="built_in">point</span> &amp;<span class="keyword">operator</span> -=(<span class="keyword">const</span> <span class="built_in">point</span>&amp; rhs) &#123;x -= rhs.x; y -= rhs.y; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">        <span class="built_in">point</span> &amp;<span class="keyword">operator</span> *=(<span class="keyword">const</span> number rhs) &#123;x *= rhs; y *= rhs; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">        <span class="built_in">point</span> &amp;<span class="keyword">operator</span> /=(<span class="keyword">const</span> number rhs) &#123;x /= rhs; y /= rhs; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> ==(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x == rhs.x &amp;&amp; y == rhs.y;&#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> !=(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> !(rhs == *<span class="keyword">this</span>);&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">number <span class="title">dot</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x * rhs.x + y * rhs.y;&#125;</span><br><span class="line">        <span class="function">number <span class="title">cross</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> rhs.y * x - rhs.x * y;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(dot(*<span class="keyword">this</span>));&#125;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">distance</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span> &amp;b)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> (*<span class="keyword">this</span> - b).length();&#125;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">distance</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span> &amp;ls, <span class="keyword">const</span> <span class="built_in">point</span> &amp;rs)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> <span class="built_in">fabs</span>((ls - *<span class="keyword">this</span>).cross(rs - *<span class="keyword">this</span>)) / ls.distance(rs);&#125;</span><br><span class="line">        <span class="function"><span class="built_in">point</span> <span class="title">normal</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> (x || y) ? *<span class="keyword">this</span> / length() : <span class="built_in">point</span>(<span class="number">0</span>, <span class="number">0</span>);&#125;</span><br><span class="line">        <span class="function"><span class="keyword">auto</span> <span class="title">angle</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">atan2</span>(y, x);&#125;</span><br><span class="line">        <span class="function"><span class="built_in">point</span> <span class="title">rotate</span><span class="params">(number a)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;number c = <span class="built_in">cos</span>(a), s = <span class="built_in">sin</span>(a); <span class="keyword">return</span> &#123;c * x - s * y, s * x + c * y&#125;;&#125;</span><br><span class="line">        <span class="function"><span class="built_in">point</span> <span class="title">perpendicular</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> &#123;-y, x&#125;;&#125;</span><br><span class="line">        <span class="function"><span class="built_in">point</span> <span class="title">symmetry</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> &#123;-x, -y&#125;;&#125;</span><br><span class="line">        <span class="function">number <span class="title">square</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x * x + y * y; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">int</span> <span class="title">sgn</span>(<span class="title">T</span> <span class="title">t</span>) &#123;</span><span class="keyword">return</span> t ? (t &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>) : t;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">point</span> = Geo::<span class="built_in">point</span>;</span><br><span class="line"><span class="keyword">using</span> frac = fraction&lt;longs&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2060</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">point</span> a[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;frac&gt; li;</span><br><span class="line"></span><br><span class="line"><span class="function">frac <span class="title">cosLemmaSquare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span> &amp;p1, <span class="keyword">const</span> <span class="built_in">point</span> &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> aa = p1.square(), bb = (p2 - p1).square(), cc = p2.square();</span><br><span class="line">    longs x = bb + cc - aa, f = sgn(x);</span><br><span class="line">    <span class="keyword">return</span> &#123;f * x * x, <span class="number">4l</span>l * bb * cc&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    longs n, ans = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i].x &gt;&gt; a[i].y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (a[i].cross(a[j]) &gt; <span class="number">0</span>)</span><br><span class="line">                li.push_back(cosLemmaSquare(a[i], a[j]));</span><br><span class="line">        sort(li.<span class="built_in">begin</span>(), li.<span class="built_in">end</span>(), [](frac &amp;a, frac &amp;b)&#123;<span class="keyword">return</span> a.compareTo(b) &lt; <span class="number">0</span>;&#125;);</span><br><span class="line">        longs len = li.<span class="built_in">size</span>(), l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; len)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> r = l;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; len &amp;&amp; li[r] == li[l]) ++ r;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, r - l + <span class="number">1</span>);</span><br><span class="line">            l = r;</span><br><span class="line">        &#125;</span><br><span class="line">        li.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果使用精准比较（“<code>&lt;</code>” 和 “<code>==</code>” 运算符），中间结果可能会爆 <code>long long</code>，所以如果在 Windows 环境下则可以考虑在合适的误差下使用浮点比较（<code>equals</code> 和 <code>compareTo</code> 方法）；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">unsigned</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">fraction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T num, den;</span><br><span class="line"></span><br><span class="line">    fraction() = <span class="keyword">default</span>;</span><br><span class="line">    fraction(T u, T v): num(u), den(v)</span><br><span class="line">    &#123; <span class="keyword">if</span> (!v) num = <span class="number">1</span>; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; <span class="number">0</span>) num = -u, den = -v; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> $eps = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sgn</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> x)</span> </span>&#123;<span class="keyword">return</span> x &lt; -$eps ? <span class="number">-1</span> : x &gt; $eps;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T <span class="title">gcd</span><span class="params">(T a, T b)</span> </span>&#123;<span class="keyword">return</span> a &lt; b ? gcd(b, a) : (!b ? a : gcd(b, a % b));&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">toNumber</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (<span class="keyword">long</span> <span class="keyword">double</span>) num / den; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="keyword">const</span> fraction &amp;rhs)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> sgn(<span class="keyword">this</span>-&gt;toNumber() - rhs.toNumber());&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">equals</span><span class="params">(<span class="keyword">const</span> fraction &amp;rhs)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> den == <span class="number">0</span> || rhs.den == <span class="number">0</span> ? den == rhs.den : !compareTo(rhs);&#125;</span><br><span class="line">    <span class="function">fraction &amp;<span class="title">reduce</span><span class="params">()</span> </span>&#123; <span class="keyword">auto</span> x = gcd(num, den); num /= x, den /= x; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> ==(<span class="keyword">const</span> fraction &amp;rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> num * rhs.den == den * rhs.num;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> fraction &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> den &amp;&amp; (!rhs.den || compareTo(rhs) &lt; <span class="number">0</span>);&#125;</span><br><span class="line">    fraction <span class="keyword">operator</span> -() <span class="keyword">const</span> &#123;<span class="keyword">return</span> &#123;-num, den&#125;;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Geo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> number = longs;</span><br><span class="line">    <span class="keyword">const</span> number eps = fraction&lt;longs&gt;::$eps;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(number x)</span> </span>&#123;<span class="keyword">return</span> x &lt; -eps ? <span class="number">-1</span> : x &gt; eps;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(number a, number b)</span> </span>&#123;<span class="keyword">return</span> compareTo(a-b);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        number x, y;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">point</span>() = <span class="keyword">default</span>;</span><br><span class="line">        <span class="built_in">point</span>(number x, number y) : x(x), y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">point</span> <span class="keyword">operator</span> +(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> &#123;x + rhs.x, y + rhs.y&#125;;&#125;</span><br><span class="line">        <span class="built_in">point</span> <span class="keyword">operator</span> -(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> &#123;x - rhs.x, y - rhs.y&#125;;&#125;</span><br><span class="line">        number <span class="keyword">operator</span> *(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x * rhs.x + y * rhs.y;&#125;</span><br><span class="line">        <span class="built_in">point</span> <span class="keyword">operator</span> *(<span class="keyword">const</span> number rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> &#123;rhs * x, rhs * y&#125;;&#125;</span><br><span class="line">        <span class="built_in">point</span> <span class="keyword">operator</span> /(<span class="keyword">const</span> number rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> &#123;x / rhs, y / rhs&#125;;&#125;</span><br><span class="line">        <span class="built_in">point</span> &amp;<span class="keyword">operator</span> +=(<span class="keyword">const</span> <span class="built_in">point</span>&amp; rhs) &#123;x += rhs.x; y += rhs.y; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">        <span class="built_in">point</span> &amp;<span class="keyword">operator</span> -=(<span class="keyword">const</span> <span class="built_in">point</span>&amp; rhs) &#123;x -= rhs.x; y -= rhs.y; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">        <span class="built_in">point</span> &amp;<span class="keyword">operator</span> *=(<span class="keyword">const</span> number rhs) &#123;x *= rhs; y *= rhs; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">        <span class="built_in">point</span> &amp;<span class="keyword">operator</span> /=(<span class="keyword">const</span> number rhs) &#123;x /= rhs; y /= rhs; <span class="keyword">return</span> *<span class="keyword">this</span>;&#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> ==(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x == rhs.x &amp;&amp; y == rhs.y;&#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> !=(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> !(rhs == *<span class="keyword">this</span>);&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">number <span class="title">dot</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x * rhs.x + y * rhs.y;&#125;</span><br><span class="line">        <span class="function">number <span class="title">cross</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> rhs.y * x - rhs.x * y;&#125;</span><br><span class="line">        <span class="function">number <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">sqrt</span>(dot(*<span class="keyword">this</span>));&#125;</span><br><span class="line">        <span class="function">number <span class="title">distance</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span> &amp;b)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> (*<span class="keyword">this</span> - b).length();&#125;</span><br><span class="line">        <span class="function">number <span class="title">distance</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span> &amp;ls, <span class="keyword">const</span> <span class="built_in">point</span> &amp;rs)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;<span class="keyword">return</span> <span class="built_in">fabs</span>((ls - *<span class="keyword">this</span>).cross(rs - *<span class="keyword">this</span>)) / ls.distance(rs);&#125;</span><br><span class="line">        <span class="function"><span class="built_in">point</span> <span class="title">normal</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> (x || y) ? *<span class="keyword">this</span> / length() : <span class="built_in">point</span>(<span class="number">0</span>, <span class="number">0</span>);&#125;</span><br><span class="line">        <span class="function">number <span class="title">angle</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="built_in">atan2</span>(y, x);&#125;</span><br><span class="line">        <span class="function"><span class="built_in">point</span> <span class="title">rotate</span><span class="params">(number a)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;number c = <span class="built_in">cos</span>(a), s = <span class="built_in">sin</span>(a); <span class="keyword">return</span> &#123;c * x - s * y, s * x + c * y&#125;;&#125;</span><br><span class="line">        <span class="function"><span class="built_in">point</span> <span class="title">perpendicular</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> &#123;-y, x&#125;;&#125;</span><br><span class="line">        <span class="function"><span class="built_in">point</span> <span class="title">symmetry</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> &#123;-x, -y&#125;;&#125;</span><br><span class="line">        <span class="function">number <span class="title">square</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x * x + y * y; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">point</span> = Geo::<span class="built_in">point</span>;</span><br><span class="line"><span class="keyword">using</span> frac = fraction&lt;longs&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2060</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">point</span> a[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;frac&gt; li;</span><br><span class="line"></span><br><span class="line"><span class="function">frac <span class="title">getSlope</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span> &amp;ll, <span class="keyword">const</span> <span class="built_in">point</span> &amp;rr = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ld = ll.square(), rd = rr.square();</span><br><span class="line">    <span class="keyword">if</span> (!ld) ld = <span class="number">1</span>; <span class="keyword">if</span> (!rd) rd = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;rr.y * ld - ll.y * rd, rr.x * ld - ll.x * rd&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    longs n, ans = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i].x &gt;&gt; a[i].y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        frac tmp = getSlope(a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            frac ff = getSlope(a[i], a[j]);</span><br><span class="line">            <span class="keyword">if</span> (ff.equals(tmp)) <span class="keyword">continue</span>;</span><br><span class="line">            li.push_back(ff);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(li.<span class="built_in">begin</span>(), li.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">auto</span> len = li.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>; l &lt; len;)</span><br><span class="line">        &#123;</span><br><span class="line">            r = l;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; len &amp;&amp; li[r].equals(li[l])) ++ r;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, r - l + <span class="number">1l</span>l);</span><br><span class="line">            l = r;</span><br><span class="line">        &#125;</span><br><span class="line">        li.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新嫖的分数类板子↑↑；这是武大仓鼠队使用圆的反演的做法，比较神奇的是这个题必须在允许误差为 0 时才可以 A。至于圆的反演，那是平面几何中的，有点像复变里的共形映射，之后应该会开篇文章专门学吧（</p><h2 id="c---cover-the-tree">C - <a href="https://ac.nowcoder.com/acm/contest/5667/C">Cover the Tree</a></h2><blockquote><p>给一颗 n 个节点的<strong>无根树</strong>，你需要给出多条链使得该树所有树边被覆盖，且链的数量尽可能少；</p><p>数据范围：n ≤ 2e5；</p></blockquote><h2 id="d---duration">D - <a href="https://ac.nowcoder.com/acm/contest/5667/D">Duration</a></h2><p>签到题，直接读入计算即可<del>但是队友白给两发草</del></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> h1 = nextInt(), m1 = nextInt(), s1 = nextInt();</span><br><span class="line">    <span class="keyword">auto</span> h2 = nextInt(), m2 = nextInt(), s2 = nextInt();</span><br><span class="line">    <span class="keyword">auto</span> $<span class="number">1</span> = h1 * <span class="number">3600</span> + m1 * <span class="number">60</span> + s1;</span><br><span class="line">    <span class="keyword">auto</span> $<span class="number">2</span> = h2 * <span class="number">3600</span> + m2 * <span class="number">60</span> + s2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">abs</span>($<span class="number">1</span> - $<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="e---exclusive-or">E - <a href="https://ac.nowcoder.com/acm/contest/5667/E">Exclusive OR</a></h2><blockquote><p>给长为 n 的数组 A，现要求你在数组中可重复的选出 i 个数字，使得这 i 个数字的异或和最大；要求你对於一组数据，输出 i ∈ [1, n] 时的答案；</p><p>数据范围：n ≤ 2e5，A ≤ 2e18；</p></blockquote><h2 id="f---fake-maxpooling">F - <a href="https://ac.nowcoder.com/acm/contest/5667/F">Fake Maxpooling</a></h2><blockquote><p>给定 n × m 的矩阵，找到其中所有 k × k 矩阵的最大值并求和；</p><p>数据范围：k ≤ n, m ≤ 5000</p></blockquote><p>一看是个二维最值，自信满满的敲了个二维 ST 表的板子然后 T 了…… 用 <code>gprof</code> 分析显示 gcd 用时 33%，ST 表构造用时 30%，花掉了大量的时间；二维 ST 表是 O(n²log²n) 的，求出 gcd 也是 O(nmlogn) 的，难怪过不了……</p><figure><img src="https://i.loli.net/2020/07/13/CrgXvceFumTtSnk.png" class="lazyload" data-srcset="https://i.loli.net/2020/07/13/CrgXvceFumTtSnk.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="NF0Q2_TXK0U5ESOA0XH.png" /><figcaption aria-hidden="true">NF0Q2_TXK0U5ESOA0XH.png</figcaption></figure><p><del>后来一看洛谷那个二维 ST 表的板子题数据规模是 100……</del></p><p>但是转念一项我那个板子与其说是二维 ST 表不如说是倍增 DP，复杂度应该只有一个 log ——生成表的那个；因为正方形大小是确定的，所以不需要保留多维数据，可以直接滚动，所以也不存在空间方面的问题…… 那果然就是 33% gcd 的错了！因为空间只有 256 MB 比较紧巴，所以 gcd 的记忆化直接在 <code>mat</code> 数组里做了，之后再遍历一波手动求 lcm 就行（</p><p>然后就过了，めでたしめでたし（<del>虽然比赛时是队友写的滑动窗口就是了</del></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">unsigned</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5005</span>;</span><br><span class="line"><span class="keyword">int</span> mat[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> longs <span class="title">gcd</span><span class="params">(longs a, longs b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) gcd(b, a);</span><br><span class="line">    <span class="keyword">if</span> (mat[a][b]) <span class="keyword">return</span> mat[a][b];</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> mat[a][b] = a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> mat[a][b] = gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> STtable2D_simple</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">log</span>[N], high[N][N];</span><br><span class="line">    uint _log;</span><br><span class="line">    <span class="keyword">int</span> row, col, sq, _max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">T</span> <span class="title">max4</span>(<span class="title">T</span> <span class="title">t1</span>, <span class="title">T</span> <span class="title">t2</span>, <span class="title">T</span> <span class="title">t3</span>, <span class="title">T</span> <span class="title">t4</span>)</span></span><br><span class="line"><span class="class">    &#123;</span> <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(t1, t2), <span class="built_in">max</span>(t3, t4)); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">import</span> = []</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= row; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= col; ++ j)</span><br><span class="line">                high[i][j] = mat[i][j];</span><br><span class="line">        _log = <span class="built_in">log</span>[sq];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(uint k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">log</span>[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (uint i = <span class="number">1</span>; i &lt;= k; ++ i)</span><br><span class="line">            <span class="built_in">log</span>[i] = <span class="built_in">log</span>[i &gt;&gt; <span class="number">1u</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(high, <span class="number">0x80</span>, <span class="keyword">sizeof</span>(high));</span><br><span class="line">        <span class="keyword">import</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">(uint a, uint b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (uint p = <span class="number">0</span>; p &lt; _log; ++ p)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i + (<span class="number">1u</span> &lt;&lt; p) &lt;= a; ++ i)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j + (<span class="number">1u</span> &lt;&lt; p) &lt;= b; ++ j)</span><br><span class="line">                    high[i][j] = max4&lt;<span class="keyword">int</span>&gt;(</span><br><span class="line">                            high[i][j],</span><br><span class="line">                            high[i + (<span class="number">1u</span> &lt;&lt; p)][j + (<span class="number">1u</span> &lt;&lt; p)],</span><br><span class="line">                            high[i + (<span class="number">1u</span> &lt;&lt; p)][j],</span><br><span class="line">                            high[i][j + (<span class="number">1u</span> &lt;&lt; p)]</span><br><span class="line">                    );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _max = max4&lt;<span class="keyword">int</span>&gt;(</span><br><span class="line">                high[x][y],</span><br><span class="line">                high[x + sq - (<span class="number">1u</span> &lt;&lt; _log)][y + sq - (<span class="number">1u</span> &lt;&lt; _log)],</span><br><span class="line">                high[x][y + sq - (<span class="number">1u</span> &lt;&lt; _log)],</span><br><span class="line">                high[x + sq - (<span class="number">1u</span> &lt;&lt; _log)][y]</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        row = n, col = m, sq = k;</span><br><span class="line">        init(k); make(n, m);</span><br><span class="line">        longs ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> $row = n - k + <span class="number">1</span>, $col = m - k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= $row; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= $col; ++ j)</span><br><span class="line">                query(i, j), ans += _max;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">            gcd(i, j);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">            mat[i][j] = i * j / mat[i][j];</span><br><span class="line">    <span class="keyword">auto</span> xx = STtable2D_simple::solve(n, m, k);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; xx &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后发现这个题目似乎并不需要“二维单调队列”，只需要一维单调队列横纵两次就可以了== 毕竟 ST 表都可以偷懒到这种程度，所以可以过也是可以过吧（</p><p>除了稳健的记忆化，将求出矩阵的 gcd 的时间变成了 O(nm) 之外，还可以使用出题人的申必方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) </span><br><span class="line">        <span class="keyword">if</span> (!Gcd[i][j]) <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k * i &lt;= n &amp;&amp; k * j &lt;= m; k ++) </span><br><span class="line">            Gcd[k * i][k * j] = k, A[k * i][k * j] = i * j * k;</span><br></pre></td></tr></table></figure><p>这也是某种筛法，只是出题人也忘记它叫什么名字了== 但是还是看起来就很稳健的记忆化搜索比较好写（</p><p>值得一提的是，在比赛的时候有不少人都是“猜测”最大值出现在左下角/右下角 10 步位置内的，也都成功 AC 了。</p><h2 id="g---greater-and-greater">G - <a href="https://ac.nowcoder.com/acm/contest/5667/G">Greater and Greater</a></h2><blockquote><p>给定长度为 n 的数组 A 以及长度为 m 的数组 B；在 A 中找到长度为 m 的子区间 S，使得对于 <span class="math inline">\(\forall i \in [1, m]\)</span> 都有 <span class="math inline">\(S_i &gt; B_i\)</span>；要求求出这样的 S 的数目；</p><p>数据范围：n ≤ 150000，m ≤ min(n, 40000)；</p></blockquote><h2 id="h---happy-triangle">H - <a href="https://ac.nowcoder.com/acm/contest/5667/H">Happy Triangle</a></h2><blockquote><p>q 次操作，可重集合中插入删除数据，在线询问对于一个数，判断集合中是否存在两个数，使得以它们为边长的线段可以组成一个非退化三角形；</p><p>数据范围：q ≤ 2e5；</p></blockquote><p>这个可重集合用 <code>multiset</code> 都可以，关键问题在于怎么样快速判断是否存在可以凑成三角形的两个数；首先我们考虑只看大小相邻的两个边长 a, b；</p><h2 id="i---interval">I - <a href="https://ac.nowcoder.com/acm/contest/5667/I">Interval</a></h2><blockquote></blockquote><h2 id="j---just-shuffle">J - <a href="https://ac.nowcoder.com/acm/contest/5667/J">Just Shuffle</a></h2><blockquote><p>给定一个长度为 n 的 1~n 的排列，要求你构造出一个置换 P，在恰好 k 次置换后将 1~n 变换为目标排列；</p><p>数据范围：n ≤ 1e5，1e8 ≤ k ≤ 1e9；</p></blockquote><h2 id="k---keyboard-free">K - <a href="https://ac.nowcoder.com/acm/contest/5667/K">Keyboard Free</a></h2><blockquote><p>给定三个半径不同的同心圆的半径，每个圆的边界上有一个动点，并且组成一个三角形；求该三角形面积的数学期望；</p><p>数据范围：r ≤ 100；</p></blockquote><h2 id="后记">后记</h2><p>听完了题解，这个小哥哥讲题就比昨天那位好多了 == 虽然也没有讲很长时间但是和昨天那进行对比高下立判（ 虽然最后摆一句没看懂私聊，结果他本人不在我在的那个群里倒也有些麻烦== 不过参考之前竞赛培训加了好友那也多半是吹水吹逼而不会去讨论正经的学术问题吧<del>可能只有我是这样的</del>（ 最后我心心念念的二维 ST 表也过了，非常的好==</p><p>可是听完直播课之后回顾一遍题目，真正会做的又只有几个题呢？道阻且长啊（</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Nowcoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nowcoder 2020 暑期多校训练 （1）</title>
      <link href="/2020/nowcoder-2020-summer-multi-1/"/>
      <url>/2020/nowcoder-2020-summer-multi-1/</url>
      
        <content type="html"><![CDATA[<p>一共 10 个题目，能做的有几个？</p><p>听完叉姐（？）讲题目<del>最速传说快于洛谷</del>，好多题目都是论文的结论题…… 队内群友对此以及讲题纷纷发表各自的高见，可大佬的关注点总是和咱菜鸡不太一样…… 咱也不知道，咱也不敢问（</p><figure><img src="https://i.loli.net/2020/07/12/Ky9h8BnAvQE4xVP.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/07/12/Ky9h8BnAvQE4xVP.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="5KVYKS6_FJQEAQJGGX5.jpg" /><figcaption aria-hidden="true">5KVYKS6_FJQEAQJGGX5.jpg</figcaption></figure><center>↑ 要被大一队友嫌弃力，乌乌 ↑</center><p>多亏这次是校队全队参加比赛，hls 已经开始撰写队内题解了，这是好的，不然我属实补不了题了（</p><h2 id="a-b-suffix-array">A : <a href="https://ac.nowcoder.com/acm/contest/5666/A">B-Suffix Array</a></h2><blockquote><p>对于字符串 <span class="math inline">\(t_1t_2...t_k\)</span>，有函数 <span class="math inline">\(B(t_1t_2...t_k) = b_1b_2...b_k\)</span> 定义如下：</p><ul><li>若存在下标 j &lt; i 使得 <span class="math inline">\(t_j = t_i\)</span>，那 <span class="math inline">\(b_i = min_{1 \leq j \lt i, t_j = t_i} i - j\)</span>；</li><li>否则，<span class="math inline">\(b_i = 0\)</span>；</li></ul><p>对于给定长为 n 字符串 s 的 n 个后缀，根据 B 函数的值进行字典序排序；字符串 s 仅由 a 和 b 构成；</p><p>数据范围：n ≤ 1e5，Σn ≤ 1e6；</p></blockquote><h2 id="b-infinite-tree">B : <a href="https://ac.nowcoder.com/acm/contest/5666/B">Infinite Tree</a></h2><blockquote><p>令 <span class="math inline">\(mindiv(n)\)</span> 为 n 大于 1 的最小因数；现对于全体正整数，在 n - <span class="math inline">\(\frac n{mindiv(n)}\)</span> 之间连边构成树；令 <span class="math inline">\(\delta (u,v)\)</span> 为节点 u v 之间的边数，给定 <span class="math inline">\(w_1...w_n\)</span>，求 <span class="math inline">\(min_u\sum^m_{i=1} w_i\delta(u,i!)\)</span>。</p><p>数据范围：1 ≤ m ≤ 1e5，0 ≤ wi ≤ 1e4，Σm ≤ 1e6；</p></blockquote><h2 id="c-domino">C : <a href="https://ac.nowcoder.com/acm/contest/5666/C">Domino</a></h2><blockquote><p>有两个 n × m 的矩阵，由 1 × 2 的砖块和 2 × 1 的砖块密铺；你可以将 2 × 2 范围内的两块相同的砖块调转方向（换成两块另一种砖块），问你需要操作多少次才能使得两个矩阵中的砖块排布一致；</p><p>数据范围：n, m ≤ 1e3，n × m ≤ 2e6；</p></blockquote><h2 id="d-quadratic-form">D : <a href="https://ac.nowcoder.com/acm/contest/5666/D">Quadratic Form</a></h2><blockquote><p>太麻烦了……</p></blockquote><h2 id="e-counting-spanning-trees">E : <a href="https://ac.nowcoder.com/acm/contest/5666/E">Counting Spanning Trees</a></h2><blockquote><p>二分图包含 X（n个节点）和 Y（m个节点）两个部分；每一个 <span class="math inline">\(x_i\)</span> 连接到了 Y 的前 <span class="math inline">\(a_i\)</span> 个节点；给定 n, m, a 和 mod，求在模 mod 意义下生成树的数量；</p><p>数据范围：1 ≤ n,m ≤ 1e5，1 ≤ mod ≤ 1e9，1 ≤ a ≤ m，Σn ≤ 1e6；</p></blockquote><h2 id="f-infinite-string-comparision">F : <a href="https://ac.nowcoder.com/acm/contest/5666/F">Infinite String Comparision</a></h2><blockquote><p>s 为字符串，定义 <span class="math inline">\(s^\infty\)</span> 为字符串 s 的无穷循环；现给定字符串 a, b，要求比较 <span class="math inline">\(a^\infty, b^\infty\)</span>；</p><p>数据范围：1 ≤ |a|, |b| ≤ 1e5，Σs ≤ 1e6；</p></blockquote><p>签到题，稍微优雅的暴力（直接比较）就可以过<del>但是我白给两发</del>；但是其实也是有正经做法的，原题解中说到：</p><blockquote><p>通过 Periodicity Lemma，仅比较前 a + b - gcd(a, b) 个字符即可判断字符串大小；</p></blockquote><p>所以，这个代码暴力的极限不是 LCM，而是定理中的 <strong>Periodicity Lemma</strong>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">unsigned</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> longs <span class="title">gcd</span><span class="params">(longs a, longs b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt; b) swap(a, b);</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b)</span><br><span class="line">        <span class="keyword">if</span> (a.length() == b.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == b) <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;=&#x27;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; b) <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;&lt;&#x27;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;&gt;&#x27;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            longs _a = a.length(), _b = b.length();</span><br><span class="line">            longs ca = <span class="number">0</span>, cb = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">            longs lim = _a + _b - gcd(_a, _b);</span><br><span class="line">            <span class="keyword">while</span> (cnt &lt; lim)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[ca] != b[cb]) <span class="keyword">break</span>;</span><br><span class="line">                ca = (ca + <span class="number">1</span>) % _a;</span><br><span class="line">                cb = (cb + <span class="number">1</span>) % _b;</span><br><span class="line">                ++ cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt == lim) <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;=&#x27;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a[ca] &lt; b[cb]) <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;&lt;&#x27;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27;&gt;&#x27;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么什么是 Periodicity Lemma 呢？</p><h3 id="关于-periodicity-lemma">关于 Periodicity Lemma</h3><p>周期引理：字符串 S 有循环节 p 和 q 并满足 p + q ≤ |S| + gcd(p, q)，那么 gcd(p, q) 也是一个循环节；</p><h4 id="在这一题里的用法">在这一题里的用法？</h4><p>显然，a 和 b 是待比较字符串（现设为 A 和 B，长度为 ∞）的循环节；我们先假设 A = B = S，那么 a 和 b 都是 S 的循环节；因为 |S| = ∞，所以 a + b - gcd(a, b) ≤ |S| 可以使用周期引理：gcd(a, b) 是 S 的循环节；因为串 gcd(a, b) 较短，它成为了循环节，则整个串显然相同；</p><p>如果 A，B 的前 a + b - gcd(a, b) 位不相同，则不能被看作是一个字符串，上述假设就失效了；这时也可以判定字符串的字典序大小，直接输出即可；</p><p>简单的说，若两个字符串相等的假设成立，那么就一定可以证明 gcd(a, b) 长度的字串是循环节，这个串的长度小于 a 和 b，且再使用引理的过程中已经判等了，所以两个串相等，假说也成立；</p><h4 id="引理证明">引理证明？</h4><p>组内大佬证明了，我学会了再发上来；</p><figure><img src="https://i.loli.net/2020/07/13/RV3OlcwbPWZAfNX.png" class="lazyload" data-srcset="https://i.loli.net/2020/07/13/RV3OlcwbPWZAfNX.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="F-Lemma-hjl.png" /><figcaption aria-hidden="true">F-Lemma-hjl.png</figcaption></figure><p>先贴另一个组内大佬的证法 ↑</p><h2 id="g-baxianguohai-gexianshentong">G : <a href="https://ac.nowcoder.com/acm/contest/5666/G">BaXianGuoHai, GeXianShenTong</a></h2><blockquote><p>太长了不翻译了……</p></blockquote><h2 id="h-minimum-cost-flow">H : <a href="https://ac.nowcoder.com/acm/contest/5666/H">Minimum-cost Flow</a></h2><blockquote><p>有一个网络，包括 n 个节点和 m 个弧边，每条边有费用 c；</p><p>进行 q 次询问，每个询问当所有边的容量为 u/v 时，将单位流量从节点 1 到节点 n 所需要的最小费用；</p><p>可行时，输出最小费用，否则输出 <code>NaN</code>；</p><p>数据范围：2 ≤ n ≤ 50，1 ≤ m ≤ 100，c, q ≤ 1e5，u, v ≤ 1e9；Σm ≤ 1e4，Σq ≤ 1e6；</p></blockquote><h2 id="i-1-or-2">I : <a href="https://ac.nowcoder.com/acm/contest/5666/I">1 or 2</a></h2><blockquote><p>一张图，有 n 个点，给定 m 条边；问可不可以选出一些边，使得第 i 个点恰好连接了 <span class="math inline">\(d_i\)</span> 条边；只需要判断是否可行，而无需输出具体选择方案。</p><p>数据规模：不超过 100 组测试数据；n ≤ 50，m ≤ 100，<span class="math inline">\(d_i \in\)</span> {1, 2}；</p></blockquote><h2 id="j-easy-integration">J : <a href="https://ac.nowcoder.com/acm/contest/5666/J">Easy Integration</a></h2><blockquote><p>求 <span class="math inline">\(\int_0^1 (x - x^2)^n dx\)</span> 在 998244353 下的模，n ≤ 1e6；不超过 1e5 组数据。</p></blockquote><p>一个计算题，因为大一队友光速推出公式所以我就直接码代码了；没想到还是有点麻烦的……</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> uint = <span class="keyword">unsigned</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) x = x * <span class="number">10</span> + ch - <span class="number">48</span>, ch = getchar();</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> longs mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> longs p = mod - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fracMod</span><span class="params">(longs a, longs b)</span>   <span class="comment">// 费马小定理法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> n = p;</span><br><span class="line">    longs ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) ans = (ans * b) % mod;</span><br><span class="line">        b = (b * b) % mod;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = (ans * a) % mod;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line">longs ans[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> init = []</span><br><span class="line">&#123;</span><br><span class="line">    longs a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (longs i = <span class="number">1</span>; i &lt; N; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        a = (a * i) % mod;</span><br><span class="line">        b = (<span class="number">2</span> * b * (<span class="number">2</span> * i + <span class="number">1</span>)) % mod;</span><br><span class="line">        ans[i] = fracMod(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    init();</span><br><span class="line">    longs n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) <span class="built_in">cout</span> &lt;&lt; ans[n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后记">后记</h2>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Nowcoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Windows 10 中使用 zsh 作为默认终端</title>
      <link href="/2020/use-zsh-in-windows-10-with-wtd-and-vscode/"/>
      <url>/2020/use-zsh-in-windows-10-with-wtd-and-vscode/</url>
      
        <content type="html"><![CDATA[<p>不能再不更新博客了，可是这段时间因为各种考试大作业课设<del>然后人又比较摸</del>所以就没有什么文章更新；这篇文章也是开了好久才慢慢的补全的==</p><p>废话不多说，既然是花里胡哨的东西那就尽快的说完==</p><p>Windows 10 终端美化还是有不少事情可以搞的：比如通过 WSL 使用美妙的 Linux 终端，比如使用美丽的 UWP 终端软件替换掉愚蠢的 Windows 自带的 conhost.exe，还比如使用某些模拟环境的终端；下面一点点讲：</p><h2 id="终端客户端">终端客户端</h2><p>推荐两个，一个是 <a href="https://www.microsoft.com/zh-cn/p/windows-terminal/9n0dx20hk701?activetab=pivot:overviewtab">Windows Terminal</a>，微软开源的美丽的 UWP 终端，另有<a href="https://www.microsoft.com/zh-cn/p/windows-terminal-preview/9n8g5rfz9xk3?activetab=pivot:overviewtab">预览版</a>下载；非预览版可以使用 <code>wt</code> 命令直接打开，预览版没试过，似乎不行；如果是自行构建的版本可以用 <code>wtd</code> 命令直接打开；然后就是 <a href="https://www.microsoft.com/zh-cn/p/fluent-terminal/9p2krlmfxf9t?activetab=pivot:overviewtab">Fluent Terminal</a>，也是开源的，现在上了 Microsoft Store；个人觉得这个比上一个好看，但是现在用的还是前者居多；</p><p>从上面的两个终端中选择一个下载安装即可，都是 UWP 应用；因为现在微软官方的终端的使用体验已经很好了，所以建议直接下载 Windows Terminal，后面的教程也全部基于这个；</p><p>补充说明：虽然不能方便的使用命令行唤起 Windows Terminal Preview，但是可以通过增加到右键菜单来方便的使用它：在 <code>C:\Users\&lt;username&gt;\AppData\Local\Microsoft\WindowsApps</code> 目录下有很多 UWP App 命令行启动的程序，Windows Terminal Preview 的启动程序也在其中：它还叫 <code>wt.exe</code>，但是并不在根目录下，很容易就可以找到；然后将注册表文件中对应的项目换成 Preview 的接口就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\wt]</span><br><span class="line">@&#x3D;&quot;Open Windows Terminal Here&quot;</span><br><span class="line">&quot;Icon&quot;&#x3D;&quot;C:\\Env\\wtp.ico&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\wt\command]</span><br><span class="line">@&#x3D;&quot;C:\\Users\\Shiroha\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe&quot;</span><br></pre></td></tr></table></figure><p>在我的电脑上，Windows Terminal Preview 的位置是 <code>C:\Users\shiroha\AppData\Local\Microsoft\WindowsApps\Microsoft.WindowsTerminalPreview_8wekyb3d8bbwe\wt.exe</code> 加上转义符号进行替换即可；图标的话也做好了，直接下载<a href="https://cdn.jsdelivr.net/gh/ymd45921/util_assets@master/resource/2020/icons/wt.ico">普通版</a>或者<a href="https://cdn.jsdelivr.net/gh/ymd45921/util_assets@master/resource/2020/icons/wtp.ico">预览版</a>的图标，放在特定位置之后修改上面的图标路径就可以了；</p><p>此外，为了保证终端可以在我们唤起菜单的目录下启动，我们需要将对应（默认）配置文件的启动目录（<code>"startingDirectory"</code>）换成 <code>null</code>；</p><h2 id="powershell-美化">PowerShell 美化</h2><p>这是微软的 shell 程序，比 cmd 先进，内置在 Windows 10 内的版本是 5.0，但是现在已经有全新的 PowerShell Core 7.0 可供下载安装了，个人建议下载一个，毕竟后面那个跨平台（）但是不下也可以，不妨碍后面的教程：</p><p>因为苹果 zsh 的终端有各种花里胡哨的东西，所以 PowerShell 也想变漂亮；在 zsh 中有一个比较厉害的插件叫做 oh-my-zsh，所以到 PowerShell 这里来就整了一个差不多的 oh-my-posh，也可以美化 PowerShell；</p><p>因为 Windows Terminal + PowerShell Core + oh my posh 已经被微软官方认定为最佳组合了，所以官方也整了一个教程教你怎么使用这个玩意了，所以可以<a href="https://docs.microsoft.com/zh-cn/windows/terminal/tutorials/powerline-setup#additional-resources">直接去看</a>（</p><h3 id="安装-powerline-字体">安装 Powerline 字体</h3><p>微软官方的 PowerLine 字体 <a href="https://github.com/microsoft/cascadia-code/releases">Cascadia Code / Cascadia Mono</a>，可以直接下载安装；</p><p>个人比较喜欢的 Menlo 字体，可以从它的<a href="https://github.com/abertsch/Menlo-for-Powerline">发布页</a>下载；</p><p>这里还有一个整合包：<a href="https://github.com/powerline/fonts">Github 仓库地址</a>，包含了绝大多数比较好看的 PL 字体，并且有安装脚本；</p><p>当然，Jetbrains 家的 Jetbrains Mono，Mozilla 家的 Fira 等等有名字体都是有 PL 版本的，可以百度自行下载；</p><p>PowerLine 字体为一些特殊形状提供支持（比如箭头啊，Git 标志啊，苹果/Ubuntu 标志啊之类的），要想在控制台上显示这些图标，必须要有 PowerLine 字体支持；</p><p>但是标准 PowerLine 字体包含的特殊图标并不多，如果需要使用包含更多图标的终端，可能需要一些 Nerd 字体（下面有讲），比如<a href="https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/Hack.zip">Hack Nerd Font</a>；</p><h3 id="安装-oh-my-posh">安装 oh my posh</h3><p>首先，你得安装 <a href="https://git-scm.com/download/win">Git for Windows</a>；</p><p>然后，在管理员状态下的 PowerShell (Core) 中运行下面的命令安装 oh my posh 及相关组件：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Install-Module</span> posh<span class="literal">-git</span> <span class="literal">-Scope</span> CurrentUser</span><br><span class="line"><span class="built_in">Install-Module</span> <span class="built_in">oh</span><span class="literal">-my</span><span class="literal">-posh</span> <span class="literal">-Scope</span> CurrentUser</span><br></pre></td></tr></table></figure><p>中途遇到询问全部选是。这可能会自动在电脑上安装包管理器 NuGet；<a href="https://github.com/dahlbyk/posh-git">Posh-Git</a> 提供了 Git 状态信息的提示，并为 Git 命令、参数、远程和分支名称等添加 tab 自动补全； <a href="https://github.com/JanDeDobbeleer/oh-my-posh">Oh-My-Posh</a> 为 PowerShell 提供主题了功能。</p><p>如果是 PowerShell Core，您还需要安装 PSReadline：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Install-Module</span> <span class="literal">-Name</span> PSReadLine <span class="literal">-Scope</span> CurrentUser <span class="literal">-Force</span> <span class="literal">-SkipPublisherCheck</span></span><br></pre></td></tr></table></figure><p>它允许在 PowerShell 中自定义命令行编辑环境；</p><p>之后使用下面的命令打开/新建一个 PowerShell 配置文件，它的作用和 Linux 中的 <code>~/.bashrc</code> 相似；</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(<span class="built_in">Test-Path</span> <span class="literal">-Path</span> <span class="variable">$PROFILE</span> )) &#123; <span class="built_in">New-Item</span> <span class="literal">-Type</span> File <span class="literal">-Path</span> <span class="variable">$PROFILE</span> <span class="literal">-Force</span> &#125;</span><br><span class="line">notepad <span class="variable">$PROFILE</span></span><br></pre></td></tr></table></figure><p>不使用路径检测，直接输入 <code>notepad $PROFILE</code> 也会直接创建一个新文件，只是会弹出对话框询问而已；</p><p>之后会用 <code>notepad</code> 打开这个配置文件，在其中加上下面的内容：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Import-Module</span> posh<span class="literal">-git</span></span><br><span class="line"><span class="built_in">Import-Module</span> <span class="built_in">oh</span><span class="literal">-my</span><span class="literal">-posh</span></span><br><span class="line"><span class="built_in">Set-Theme</span> Paradox</span><br></pre></td></tr></table></figure><p>可以自行选择主题样式，oh my posh 自带十个经典主题；官方文档中使用的是 <code>Paradox</code>，这个主题的单行版本是 <code>Agnoster</code>；显示的比较详尽的主题有 <code>Honukai</code>，oh-my-zsh 经典主题是 <code>robbyrussell</code>；还有几个比较特别的是 <code>PowerLine</code> 和 <code>Darkblood</code>；即使你没有使用 PowerLine 字体，使用经典主题 <code>robbyrussell</code> 也不会出现方块问题，这是好的。</p><h3 id="设置终端样式">设置终端样式</h3><p>我们必然要通过 Windows Terminal 来使用全新的 PowerShell；打开 Windows Terminal 的配置文件页面，增加/修改对应的配置文件：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;theme&quot;</span>: <span class="string">&quot;dark&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;profiles&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;Powershell&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;source&quot;</span> : <span class="string">&quot;Windows.Terminal.PowershellCore&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;acrylicOpacity&quot;</span> : <span class="number">0.7</span>,</span><br><span class="line">            <span class="attr">&quot;colorScheme&quot;</span> : <span class="string">&quot;Campbell&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;cursorColor&quot;</span> : <span class="string">&quot;#FFFFFD&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fontFace&quot;</span> : <span class="string">&quot;Cascadia Code PL&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;useAcrylic&quot;</span> : <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="attr">&quot;theme&quot;</span>: <span class="string">&quot;light&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;profiles&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;PowerShell&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;source&quot;</span> : <span class="string">&quot;Windows.Terminal.PowershellCore&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;acrylicOpacity&quot;</span>: <span class="number">0.7</span>,</span><br><span class="line">                <span class="attr">&quot;colorScheme&quot;</span> : <span class="string">&quot;Frost&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;cursorColor&quot;</span> : <span class="string">&quot;#000000&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;fontFace&quot;</span> : <span class="string">&quot;Cascadia Code PL&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;useAcrylic&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;schemes&quot;</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;Frost&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;background&quot;</span> : <span class="string">&quot;#FFFFFF&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;black&quot;</span> : <span class="string">&quot;#3C5712&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;blue&quot;</span> : <span class="string">&quot;#17b2ff&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;brightBlack&quot;</span> : <span class="string">&quot;#749B36&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;brightBlue&quot;</span> : <span class="string">&quot;#27B2F6&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;brightCyan&quot;</span> : <span class="string">&quot;#13A8C0&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;brightGreen&quot;</span> : <span class="string">&quot;#89AF50&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;brightPurple&quot;</span> : <span class="string">&quot;#F2A20A&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;brightRed&quot;</span> : <span class="string">&quot;#F49B36&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;brightWhite&quot;</span> : <span class="string">&quot;#741274&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;brightYellow&quot;</span> : <span class="string">&quot;#991070&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;cyan&quot;</span> : <span class="string">&quot;#3C96A6&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;foreground&quot;</span> : <span class="string">&quot;#000000&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;green&quot;</span> : <span class="string">&quot;#6AAE08&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;purple&quot;</span> : <span class="string">&quot;#991070&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;red&quot;</span> : <span class="string">&quot;#8D0C0C&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;white&quot;</span> : <span class="string">&quot;#6E386E&quot;</span>,</span><br><span class="line">                <span class="attr">&quot;yellow&quot;</span> : <span class="string">&quot;#991070&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面的是官方提供的明暗两种配色方式，只需要保证在对应的配置文件中选择了 PL 字体就可以了；</p><p>又及：我的两台电脑的 PowerShell 中 <code>ls</code> 命令均自动指向 <code>dir</code> 命令，而我的小伙伴的电脑却没有，需要手动设置或者安装 Gow 来实现（个人不太喜欢 Gow）；我不知道这是什么原因，可能某些软件安装时会自动帮你设置这些吧；此外，其他教程中有提到安装 <a href="https://chocolatey.org/">Chocolatey</a>，这是一个 Windows 包管理器，和 homebrew 很像，但是因为没有必要所以这里没有提；</p><h2 id="原生-zsh">原生 zsh</h2><p>但是比起主题受限的 PowerShell，我想可能还是 zsh 更加有吸引力；虽然 zsh 是 Linux 上的玩意，但是我想大家都用过 Git Bash —— 一个基于 MinGW64 环境的仿 Linux 环境的终端；虽然它已经很 Linux 了，但是很多功能还是被删减了；但是我们可以使用未删减的 Git SDK 来使用 zsh；</p><p>Git SDK 全称 Git for Windows SDK，是基于 MSYS2（MinGW64 + Cygwin 合体增强）的仿 Linux 环境；安装后大约会占用 4~5 GB 的磁盘空间，但是包含了完整的仿 Linux 环境：包括常用工具，完整的 GNU Complier 链以及包管理器 pacman；基本上是一套完整的集成开发环境，所以是 SDK ==</p><p>此外，虽然 Git SDK 是基于 MSYS2 的，是 Git 的超集…… 但是你仍然需要安装 Git（可能可以通过适当的配置解决），因为很多软件只认识 Git；建议安装 Git SDK 而不是 MSYS2，因为前者比后者好用（原因不明）。</p><h3 id="安装-git-sdk">安装 Git SDK</h3><p>你可以去 <a href="https://gitforwindows.org/">Git for Windows 官网</a>，拉到最下面可以看到 Git SDK 的下载；这样下载的是一个安装器，会自动从一个仓库克隆这个程序所需要的全部文件<del>但是下载速度感人</del>，即使你科学上网也不能保证一个满意的下载速度；所以个人建议直接去 <a href="https://github.com/git-for-windows/git-sdk-64">Github 仓库</a>下载 main 分支下的文件；注意的是后者解包后文件总大小小于前者，笔者安装过程中也意外发现只有后者可以在我的电脑上正常运行，所以建议直接拉取 Github 仓库；</p><p>将解压后的文件放在某个位置，并且将其目录下的 <code>usr/bin</code> 文件夹加入系统变量——因为这样用起来比较舒服，一些程序（比如 <code>zsh</code>）在全局变量空间中也能找到 MSYS2 的工具包，但是这可能会和其他类似工具比如 Gow 产生冲突，所以一般加在靠后的位置，这样就会优先使用 Windows 中的工具；</p><h3 id="安装-zsh-以及-oh-my-zsh">安装 zsh 以及 oh my zsh</h3><p>这一部分的教程好像挺多的，不再重复说明了…… 算了还是说一下吧：</p><h4 id="修改-pacman-软件包源">修改 pacman 软件包源</h4><p>在 <code>/etc/pacman.d/</code> 目录下有三个文件：<code>mirrorlist.msys</code>、<code>mirrorlist.mingw64</code> 和 <code>mirrorlist.mingw32</code>；我们可以直接在 Windows 中使用文本编辑器修改它们为国内源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">##</span><br><span class="line">## MSYS2 repository mirrorlist</span><br><span class="line">##</span><br><span class="line"></span><br><span class="line">## Primary</span><br><span class="line">## msys2.org</span><br><span class="line">Server &#x3D; http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;msys2&#x2F;msys&#x2F;$arch&#x2F;</span><br><span class="line">Server &#x3D; http:&#x2F;&#x2F;repo.msys2.org&#x2F;msys&#x2F;$arch</span><br><span class="line">Server &#x3D; http:&#x2F;&#x2F;downloads.sourceforge.net&#x2F;project&#x2F;msys2&#x2F;REPOS&#x2F;MSYS2&#x2F;$arch</span><br><span class="line">Server &#x3D; http:&#x2F;&#x2F;www2.futureware.at&#x2F;~nickoe&#x2F;msys2-mirror&#x2F;msys&#x2F;$arch&#x2F;</span><br><span class="line">Server &#x3D; https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;msys2&#x2F;msys&#x2F;$arch&#x2F;</span><br><span class="line"></span><br><span class="line">##</span><br><span class="line">## 64-bit Mingw-w64 repository mirrorlist</span><br><span class="line">##</span><br><span class="line"></span><br><span class="line">## Primary</span><br><span class="line">## msys2.org</span><br><span class="line">Server &#x3D; http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;msys2&#x2F;mingw&#x2F;x86_64&#x2F;</span><br><span class="line">Server &#x3D; http:&#x2F;&#x2F;repo.msys2.org&#x2F;mingw&#x2F;x86_64</span><br><span class="line">Server &#x3D; http:&#x2F;&#x2F;downloads.sourceforge.net&#x2F;project&#x2F;msys2&#x2F;REPOS&#x2F;MINGW&#x2F;x86_64</span><br><span class="line">Server &#x3D; http:&#x2F;&#x2F;www2.futureware.at&#x2F;~nickoe&#x2F;msys2-mirror&#x2F;x86_64&#x2F;</span><br><span class="line">Server &#x3D; https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;msys2&#x2F;mingw&#x2F;x86_64&#x2F;</span><br><span class="line"></span><br><span class="line">##</span><br><span class="line">## 32-bit Mingw-w64 repository mirrorlist</span><br><span class="line">##</span><br><span class="line"></span><br><span class="line">## Primary</span><br><span class="line">## msys2.org</span><br><span class="line">Server &#x3D; http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;msys2&#x2F;mingw&#x2F;i686&#x2F;</span><br><span class="line">Server &#x3D; http:&#x2F;&#x2F;repo.msys2.org&#x2F;mingw&#x2F;i686</span><br><span class="line">Server &#x3D; http:&#x2F;&#x2F;downloads.sourceforge.net&#x2F;project&#x2F;msys2&#x2F;REPOS&#x2F;MINGW&#x2F;i686</span><br><span class="line">Server &#x3D; http:&#x2F;&#x2F;www2.futureware.at&#x2F;~nickoe&#x2F;msys2-mirror&#x2F;i686&#x2F;</span><br><span class="line">Server &#x3D; https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;msys2&#x2F;mingw&#x2F;i686&#x2F;</span><br></pre></td></tr></table></figure><p>注意服务器的顺序，将国内服务器放在优先的位置才能保证 pacman 优先使用它；</p><p>调整之后执行 <code>pacman -Syu</code> 和 <code>pacman -Su</code> 更新源信息，首次更新可能需要重启；</p><h4 id="安装相关软件包">安装相关软件包</h4><p>首先，我们要有 zsh：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S zsh</span><br></pre></td></tr></table></figure><p>然后，我们要有 oh-my-zsh：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span></span><br><span class="line"><span class="comment"># ↑ 通过 curl 或者 通过 wget ↓</span></span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>当然，修改 host 文件，设置终端代理过于麻烦；我们可以科学上网后直接访问上述命令中的地址，获得脚本的内容后放到某个文件夹下，再使用 zsh 去执行脚本即可；</p><p>安装后脚本会在 <code>~</code> 目录下创建 <code>.oh-my-zsh</code> 目录，和 <code>~/.zshrc</code> 在同一个目录中；这个 <code>~</code> 目录对应的就是 Windows 的用户文件夹，注意不要删掉它们；如果觉得碍眼可以把它们设为系统文件 + 隐藏文件（cmd 中的 <code>attrib +s+h</code> 或者 PowerShell 中的 <code>$file.Attributes += 'hidden, system'</code>），就不会在资源管理器中看到它们了；</p><h4 id="关闭自动更新">关闭自动更新</h4><p>此外，<code>oh-my-zsh</code> 会定期的运行更新检查来从 <code>Github</code> 下载最新的更新；但是由于国内网络环境的因素，这个过程并不能流利地进行，这样就会导致在更新的时候卡在初始化终端，造成不好的体验；关闭自动更新也需要编辑 <code>~/.zshrc</code> 文件，找到 <code>DISABLE_AUTO_UPDATE</code> 项目，并取消其默认的注释：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- # DISABLE_AUTO_UPDATE=&quot;true&quot;</span></span><br><span class="line"><span class="addition">+ DISABLE_AUTO_UPDATE=&quot;true&quot;</span></span><br></pre></td></tr></table></figure><p>这样就关闭了 <code>oh-my-zsh</code> 定期的自动更新；如果需要手动更新，可以运行 <code>upgrade_oh_my_zsh</code>。</p><h4 id="设置主题">设置主题</h4><p>打开 <code>~/.zshrc</code> 文件，可以命令行用 vim 打开，也可以直接在资源管理器中打开，编辑其中的 <code>ZSH_THEME</code> 字段就可以更换它的主题，编辑 <code>plugins=(git zsh-autosuggestions)</code> 在括号中增加内容来启用插件；因为 zsh 还是借助 Windows 的 conhost 或者其他终端软件运行，所以并不需要在这个文件中修改字体；</p><p>因为 MSYS2 pacman 中的 zsh 似乎没有包含一部分插件，所以若部分插件找不到，可以在<a href="https://github.com/zsh-users">这里</a>下载，之后复制到 <code>~/.oh-my-zsh</code> 文件夹的对应位置中即可；</p><p>有一个美妙的 zsh 主题叫做 <a href="https://github.com/romkatv/powerlevel10k">powerlevel10k</a>：它比较的美观，并且使用了某些方法解决了在 Windows Terminal 这种半透明终端中 PL 展示效果不佳的问题，还提供了比较人性化的解决方案，所以建议使用它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/romkatv/powerlevel10k.git <span class="variable">$ZSH_CUSTOM</span>/themes/powerlevel10k</span><br></pre></td></tr></table></figure><p>当然也可以手动克隆之后复制到 <code>~/.oh-my-zsh/theme</code> 中；安装完成后修改 <code>~/.zshrc</code> 文件来使用这个主题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME&#x3D;&quot;powerlevel10k&#x2F;powerlevel10k&quot;</span><br></pre></td></tr></table></figure><p>之所以要加上路径，是因为 oh my zsh 通过找到 <code>.zsh</code> 文件来找到安装的主题和插件；第一次使用该主题，会自动跳转到对于这个主题的配置页面：会有一个向导根据你终端对于 PowerLine 和图标的支持帮助你选择合理的不会出现乱码的主题，并且配置向导可以快速的通过 <code>p10k configure</code> 唤起，非常方便。</p><h4 id="字体问题补充">字体问题（补充</h4><p>上面说到了只有安装 PowerLine 字体才可以显示一些美妙的图标；但是如果你跑了一遍 p10k 的配置之后就会发现，上面提到的好一部分 PL 字体并不支持显示 fontawesome 上的图标，比如那个锁就会显示成一个方块，这不太行；前几天再网上瞎jb翻的时候看到了一种字体叫做 <a href="https://www.nerdfonts.com/">Nerd Fonts</a>，有一种 <a href="https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/Hack.zip">Hack Nerd Font</a> 似乎可以很棒的兼容这些图标，所以在这里推荐一手（</p><p>实际上，除了 oh my posh，其他的终端美化都是使用打包了 Fontawesome 的 Hack 字体作为更丰富的图标支持的；如果你需要使用包含多个图标的字体，比起一般的 PowerLine 字体，还是建议来一个 Hack 字体==</p><h3 id="配置文件">配置文件</h3><p>安装完成之后，我们就要将调教好的 zsh 终端增加到工作场景中集成了：</p><p>首先不建议将任何 Powerline 终端集成到 Jetbrains 的任何 IDE 中；因为 Windows 上的 Jetbrains IDE 的终端渲染比较的奇特：主要就是行间距太大，导致显示的图标会非常不好看。</p><h4 id="集成到-windows-terminal">集成到 Windows Terminal</h4><p>默认的继承方式是通过 MSYS2 终端的启动脚本来运行 zsh：这个脚本在启动 shell 前会做许多事情，比如创建临时的系统变量空间，加载 rc 文件等，所以即使你没有将 MSYS2 的二进制文件目录加入到系统变量，shell 也能找到它们：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;profiles&quot;</span>:</span><br><span class="line">    [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;&#123;e7c16a4b-3d29-4785-bf68-ab883e837f1d&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;zsh&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;commandline&quot;</span>: <span class="string">&quot;C:/git-sdk-64-main/msys2_shell.cmd -defterm -mingw64 -no-start -here -lic \&quot;exec zsh\&quot;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fontFace&quot;</span> : <span class="string">&quot;Cascadia Code PL&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fontSize&quot;</span> : <span class="number">10</span>,</span><br><span class="line">            <span class="attr">&quot;icon&quot;</span> : <span class="string">&quot;C:/Env/DefaultIcons/WebIcon/GitBash.png&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;startingDirectory&quot;</span> : <span class="string">&quot;%USERPROFILE%&quot;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样没什么坏处，但是在博主的电脑上可能是因为系统环境变量错乱，在该脚本初始化过程中会因为大量系统变量地址映射失败而报错，并且产生巨量输出（包括使用 MinTTY 也会产生这些输出），非常的不美观；而且这些初始化工作还包括了在桌面上创建不需要的快捷方式，非常的不好；所以我们也可以将 <code>usr/bin</code> 增加到系统变量，然后配置文件设置命令行直接启动 <code>usr/bin/zsh.exe</code>，可以产生相同的效果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;profiles&quot;</span>:</span><br><span class="line">    [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;&#123;e7416a4b-3d29-4745-be68-ab883e837f1a&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;zsh&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;commandline&quot;</span>: <span class="string">&quot;C:/git-sdk-64-main/usr/bin/zsh.exe&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fontFace&quot;</span> : <span class="string">&quot;Cascadia Code PL&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fontSize&quot;</span> : <span class="number">10</span>,</span><br><span class="line">            <span class="attr">&quot;icon&quot;</span> : <span class="string">&quot;C:/Env/DefaultIcons/WebIcon/GitBash.png&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;startingDirectory&quot;</span> : <span class="string">&quot;%USERPROFILE%&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次启动依然会初始化最基本的环境，但是不会再产生大量输出了，非常完美；也避免了从 <code>msys2_shell.cmd</code> 启动可能出现的退格闪屏问题；</p><h4 id="集成到-vs-code">集成到 VS Code</h4><p>和上面一样，可以通过 <code>msys2_shell.cmd</code> 启动，也可以直接运行 <code>zsh.exe</code> 启动：</p><p>从工具栏中选择 文件 -&gt; 首选项 -&gt; 设置，打开设置页；在 功能 / 终端 中找到任何一个 在 settings.json 中编辑 按钮来打开 vscode 的配置文件；并且加上下面内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;terminal.integrated.shell.windows&quot;</span>: <span class="string">&quot;C:\\git-sdk-64-main\\msys2_shell.cmd&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;terminal.integrated.shellArgs.windows&quot;</span>: [<span class="string">&quot;-defterm&quot;</span>, <span class="string">&quot;-mingw64&quot;</span>, <span class="string">&quot;-no-start&quot;</span>, <span class="string">&quot;-here&quot;</span>, <span class="string">&quot;-lic&quot;</span>, <span class="string">&quot;cd $PWD; exec zsh&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;terminal.integrated.fontFamily&quot;</span>: <span class="string">&quot;DejaVu Sans Mono for Powerline&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的配置指定了命令行、参数以及终端字体（可以和文本编辑器使用不同的字体）；命令参数中的 <code>cd $PWD</code> 是切换到当前目录，如果报错也可以不加（似乎还是会跳转到当前目录）；在 VS Code 中也有相当数量的 PL 字体存在行间距过大的问题，似乎也可以通过调整解决；但是 <code>DejaVu Sans Mono for Powerline</code> 这款字体不存在上述问题，所以为了方便我就直接使用这款字体了；</p><p>当然，你也可以将 MSYS2 工具链增加到系统变量后直接运行 <code>zsh.exe</code>，配置文件就像下面这样：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;terminal.integrated.shell.windows&quot;</span>: <span class="string">&quot;C:\\git-sdk-64-main\\usr\\bin\\zsh.exe&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;terminal.integrated.shellArgs.windows&quot;</span>: [],</span><br><span class="line">    <span class="attr">&quot;terminal.integrated.fontFamily&quot;</span>: <span class="string">&quot;DejaVu Sans Mono for Powerline&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动后也会直接跳转到你的项目目录下，但是如果没有事先将 <code>C:\git-sdk-64-main\usr\bin\</code> 增加到系统变量中，输入部分 Linux 命令可能会提示命令未找到错误；</p><h2 id="wsl-终端美化">WSL 终端美化</h2><p>依然是安装 zsh &amp; oh my zsh，网上教程也挺多的，和在 Linux 系统中的操作一样（甚至和上述在 MSYS2 中安装的过程高度相似）所以这里就不再多说了；但是需要注意的是更改了 raw.githubusercontent.com 的 host 之后下载 oh my zsh 脚本时可能会因为证书不匹配而报错，这时可以使用 <code>wget</code> 的 <code>--no-check-certificate</code> 选项来忽略检查；<code>curl</code> 则没有找到解决方案；</p><p>另：在 Ubuntu WSL 中安装 powerlevel10k 主题时出现了无法加载 gitstatusd 的问题，在 Debian WSL 中却没有出现，原因不明，有些神秘（</p><h3 id="一些补充">一些补充</h3><p>WSL 上使用 <code>ls</code> 命令查看文件目录似乎会出现绿色背景的问题，这个 WSL 文件映射机制有关：这里有一篇<a href="https://printempw.github.io/wsl-guide/#6-6-DrvFs-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98">文章</a>讲的很好，有兴趣可以去看看，了解一波；然后这里还有一篇<a href="https://printempw.github.io/wsl-guide/#6-6-DrvFs-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98">博文</a>是说 WSL 和 Fluent Terminal 配置的，感觉有点意思，有兴趣的朋友可以去看看。</p><h2 id="我的配置文件">我的配置文件</h2><p>这里也没啥特别的内容，主要是博主个人的配置文件的备份：</p><h3 id="windows-terminal-preview">Windows Terminal Preview</h3><p>Upd. 2020-7-22</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;$schema&quot;</span>: <span class="string">&quot;https://aka.ms/terminal-profiles-schema&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;defaultProfile&quot;</span>: <span class="string">&quot;zsh&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;theme&quot;</span>: <span class="string">&quot;dark&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;profiles&quot;</span>: </span><br><span class="line">    [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;&#123;e7416a4b-3d29-4745-be68-ab883e837f1a&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;hidden&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;zsh&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;commandline&quot;</span>: <span class="string">&quot;C:/git-sdk-64-main/usr/bin/zsh.exe&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;useAcrylic&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">&quot;fontFace&quot;</span> : <span class="string">&quot;Hack Nerd Font Mono&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fontSize&quot;</span> : <span class="number">11</span>,</span><br><span class="line">            <span class="attr">&quot;foreground&quot;</span> : <span class="string">&quot;#FCFCFC&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;acrylicOpacity&quot;</span> : <span class="number">0.5</span>,</span><br><span class="line">            <span class="attr">&quot;icon&quot;</span> : <span class="string">&quot;C:/Env/DefaultIcons/WebIcon/GitBash.png&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;colorScheme&quot;</span> : <span class="string">&quot;New Campbell Plus&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;background&quot;</span>: <span class="string">&quot;#000000&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;startingDirectory&quot;</span> : <span class="literal">null</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;acrylicOpacity&quot;</span> : <span class="number">0.5</span>,</span><br><span class="line">            <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;&#123;574e775e-4f2a-5b96-ac1e-a2962a402336&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;hidden&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;PowerShell Core&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;source&quot;</span>: <span class="string">&quot;Windows.Terminal.PowershellCore&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;colorScheme&quot;</span> : <span class="string">&quot;One Half Dark&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;useAcrylic&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">&quot;fontFace&quot;</span> : <span class="string">&quot;Hack Nerd Font Mono&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fontSize&quot;</span> : <span class="number">11</span>,</span><br><span class="line">            <span class="attr">&quot;startingDirectory&quot;</span> : <span class="string">&quot;%USERPROFILE%&quot;</span></span><br><span class="line">        &#125;,    </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;&#123;58ad8b0c-3ef8-5f4d-bc6f-13e4c00f2530&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;hidden&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Debian&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;snapOnInput&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">&quot;acrylicOpacity&quot;</span> : <span class="number">0.5</span>,</span><br><span class="line">            <span class="attr">&quot;closeOnExit&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">&quot;useAcrylic&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">&quot;colorScheme&quot;</span>: <span class="string">&quot;Raspberry&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fontFace&quot;</span> : <span class="string">&quot;Hack Nerd Font Mono&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;fontSize&quot;</span> : <span class="number">11</span>,</span><br><span class="line">            <span class="attr">&quot;icon&quot;</span> : <span class="string">&quot;C:/Env/DefaultIcons/WebIcon/debian.png&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;source&quot;</span>: <span class="string">&quot;Windows.Terminal.Wsl&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;startingDirectory&quot;</span> : <span class="string">&quot;%USERPROFILE%&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已经省略自动生成的配置文件</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">&quot;schemes&quot;</span> : </span><br><span class="line">    [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;New Campbell Plus&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;background&quot;</span> : <span class="string">&quot;#0C0C0C&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;black&quot;</span> : <span class="string">&quot;#0C0C0C&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;blue&quot;</span> : <span class="string">&quot;#519DFF&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brightBlack&quot;</span> : <span class="string">&quot;#767676&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brightBlue&quot;</span> : <span class="string">&quot;#8CC4FF&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brightCyan&quot;</span> :<span class="string">&quot;#34E3E3&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brightGreen&quot;</span> : <span class="string">&quot;#8BE334&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brightPurple&quot;</span> : <span class="string">&quot;#FFBBF8&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brightRed&quot;</span> : <span class="string">&quot;#E74856&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brightWhite&quot;</span> : <span class="string">&quot;#FFFFFF&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brightYellow&quot;</span> :  <span class="string">&quot;#FFEC50&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;cyan&quot;</span> : <span class="string">&quot;#0AFCFF&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;foreground&quot;</span> : <span class="string">&quot;#CCCCCC&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;green&quot;</span> : <span class="string">&quot;#81FF0A&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;purple&quot;</span> : <span class="string">&quot;#F3A6FF&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;red&quot;</span> : <span class="string">&quot;#FF0000&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;white&quot;</span> : <span class="string">&quot;#FAFAFA&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;yellow&quot;</span> : <span class="string">&quot;#FFD000&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;One Half Dark&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;background&quot;</span> : <span class="string">&quot;#282C34&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;black&quot;</span> : <span class="string">&quot;#282C34&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;blue&quot;</span> : <span class="string">&quot;#61AFEF&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brightBlack&quot;</span> : <span class="string">&quot;#5A6374&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brightBlue&quot;</span> : <span class="string">&quot;#61AFEF&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brightCyan&quot;</span> : <span class="string">&quot;#56B6C2&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brightGreen&quot;</span> : <span class="string">&quot;#98C379&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brightPurple&quot;</span> : <span class="string">&quot;#C678DD&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brightRed&quot;</span> : <span class="string">&quot;#E06C75&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brightWhite&quot;</span> : <span class="string">&quot;#DCDFE4&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brightYellow&quot;</span> : <span class="string">&quot;#E5C07B&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;cyan&quot;</span> : <span class="string">&quot;#56B6C2&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;foreground&quot;</span> : <span class="string">&quot;#DCDFE4&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;green&quot;</span> : <span class="string">&quot;#98C379&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;purple&quot;</span> : <span class="string">&quot;#C678DD&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;red&quot;</span> : <span class="string">&quot;#E06C75&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;white&quot;</span> : <span class="string">&quot;#DCDFE4&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;yellow&quot;</span> : <span class="string">&quot;#E5C07B&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;Raspberry&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;background&quot;</span> : <span class="string">&quot;#3C0315&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;black&quot;</span> : <span class="string">&quot;#282A2E&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;blue&quot;</span> : <span class="string">&quot;#0170C5&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brightBlack&quot;</span> : <span class="string">&quot;#676E7A&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brightBlue&quot;</span> : <span class="string">&quot;#80c8ff&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brightCyan&quot;</span> : <span class="string">&quot;#8ABEB7&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brightGreen&quot;</span> : <span class="string">&quot;#B5D680&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brightPurple&quot;</span> : <span class="string">&quot;#AC79BB&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brightRed&quot;</span> : <span class="string">&quot;#BD6D85&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brightWhite&quot;</span> : <span class="string">&quot;#FFFFFD&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;brightYellow&quot;</span> : <span class="string">&quot;#FFFD76&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;cyan&quot;</span> : <span class="string">&quot;#3F8D83&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;foreground&quot;</span> : <span class="string">&quot;#FFFFFD&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;green&quot;</span> : <span class="string">&quot;#76AB23&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;purple&quot;</span> : <span class="string">&quot;#7D498F&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;red&quot;</span> : <span class="string">&quot;#BD0940&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;white&quot;</span> : <span class="string">&quot;#FFFFFD&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;yellow&quot;</span> : <span class="string">&quot;#E0DE48&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用终端：PowerShell Core、zsh、Debian WSL；</p><h3 id="wt-右键菜单">wt 右键菜单</h3><p>将下方内容复制到文本文件中，修改后缀为 <code>.reg</code> 并且双击打开安装即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\wt]</span><br><span class="line">@&#x3D;&quot;Open Windows Terminal&quot;</span><br><span class="line">&quot;Icon&quot;&#x3D;&quot;C:\\Env\\DefaultIcons\\wt.ico&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\wt\command]</span><br><span class="line">@&#x3D;&quot;C:\\Users\\Shiroha\\AppData\\Local\\Microsoft\\WindowsApps\\wt.exe&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\wtp]</span><br><span class="line">@&#x3D;&quot;Open Windows Terminal Preview&quot;</span><br><span class="line">&quot;Icon&quot;&#x3D;&quot;C:\\Env\\DefaultIcons\\wtp.ico&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Directory\Background\shell\wtp\command]</span><br><span class="line">@&#x3D;&quot;C:\\Users\\Shiroha\\AppData\\Local\\Microsoft\\WindowsApps\\Microsoft.WindowsTerminalPreview_8wekyb3d8bbwe\\wt.exe&quot;</span><br></pre></td></tr></table></figure><p>如果你希望提示文字是中文，请特别注意文件的编码方式，以避免乱码。</p><h3 id="文章更新记录">文章更新记录</h3><table><thead><tr class="header"><th>日期</th><th>更新内容</th></tr></thead><tbody><tr class="odd"><td>2020-07-12</td><td>补全文章主体内容（草</td></tr><tr class="even"><td>2020-07-21</td><td>更新了一些字体和外链</td></tr><tr class="odd"><td>2020-07-22</td><td>更新了配置文件和脚本</td></tr><tr class="even"><td>2021-06-22</td><td>更新了关闭自动更新的方法</td></tr></tbody></table><h3 id="参考资料">参考资料</h3><ul><li><a href="https://www.cnblogs.com/wswind/p/10650126.html" class="uri">https://www.cnblogs.com/wswind/p/10650126.html</a></li><li><a href="https://tmc0210.github.io/Mac%E7%9A%84%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96/#more" class="uri">https://tmc0210.github.io/Mac%E7%9A%84%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96/#more</a></li><li><a href="https://www.jianshu.com/p/67df4d3aa22d" class="uri">https://www.jianshu.com/p/67df4d3aa22d</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 折腾记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows 10 </tag>
            
            <tag> Microsoft </tag>
            
            <tag> msys2 </tag>
            
            <tag> 美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Good Bye 2019 回顾</title>
      <link href="/2020/codeforces-good-bye-2019/"/>
      <url>/2020/codeforces-good-bye-2019/</url>
      
        <content type="html"><![CDATA[<p>这场比赛的编号是 1270，可以去洛谷上搜索 CF1270X 或者去<a href="https://codeforces.com/contest/1270">官网</a>补题。</p><p>题目质量还是不错的，明明长着一副 div2 的样子却把我搞得要死== 我属实不太行（</p><figure><img src="https://i.loli.net/2020/06/15/oHzhi4Dc38eCaYK.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/06/15/oHzhi4Dc38eCaYK.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="HIQBB15UOYE1IUQ6B.jpg" /><figcaption aria-hidden="true">HIQBB15UOYE1IUQ6B.jpg</figcaption></figure><p>其实这应该算不上是什么题解，充其量就算是做题记录吧（</p><h2 id="a---card-game">A - Card Game</h2><p>签到题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, k1, k2, t, a;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k1 &gt;&gt; k2;</span><br><span class="line">        <span class="keyword">bool</span> firstWin = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (k1 --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">            <span class="keyword">if</span> (a == n) firstWin = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (k2 --) <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (firstWin ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="b---interesting-subarray">B - Interesting Subarray</h2><p>简单的在草稿纸上推一下，就会知道这不会存在越位的问题：对于数列 [A, B, C] ：如果 A-B 不行，那么 A-C 也必然不行；从另一个角度来看，也就是说，所有的可行的 (l, r) 最后一定可以转化为 (x, x+1)；所以我们可以扫一遍数组，如果元组 (i, i+1) 可以满足要求，就记录答案，最后输出即可；</p><p>现在有一种一般性的思维来考虑：设 max(a) = i，min(a) = j，那么 max(a) - min(a) ≥ k 就可以转化为 |a[i] - a[j]| ≥ |i-j|；假设一下顺序，就可以移项转化成 a[i] + i &lt; a[j] + j 或者 a[i] - i &gt; a[j] - j；这样的话就可以遍历数组求 f(x) = a[x] + x 以及 g[x] = a[x] - x；统计它们的最值，如果符合要求就输出即可；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t, n; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; a[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> ll = <span class="number">-1</span>, rr = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(a[i] - a[i - <span class="number">1</span>]) &gt; <span class="number">1</span>)</span><br><span class="line">                ll = i, rr = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ll == <span class="number">-1</span> &amp;&amp; rr == <span class="number">-1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;YES\n&quot;</span> &lt;&lt; ll &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; rr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c---make-good">C - Make Good</h2><blockquote><p>给你一个数列，它的和是 a，环和是 b；现在你要给这个序列再加上不超过 3 个数，使得新的 a' = 2b'；</p></blockquote><p>数列不重要，遍历数列知道了 a 和 b 就可以了；题目允许我们加三个数字，那么这个题目有一种很巧妙的构造方法；加法的性质我们都很熟悉，在说这个之前先简单回顾一下环加（异或）的性质：a ⊕ a = 0，a ⊕ 0 = a；也就是说我们可以通过把环和置零，将环和置为任何一个数字；所以这个题目可以这么做：</p><ul><li>先加上 b：此时，a' = a + b，b' = b ⊕ b = 0；</li><li>再加上 a + b：此时，a' = 2(a + b)，b' = 0 ⊕ (a + b) = a + b；</li></ul><p>这样就在三个数字之内实现了题目的要求：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ulongs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line">ulongs a[N], sum, x_sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t, n; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        sum = x_sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">            sum += a[i];</span><br><span class="line">            x_sum ^= a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((x_sum &lt;&lt; <span class="number">1u</span>) == sum)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; x_sum</span><br><span class="line">            &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; (x_sum + sum) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果我们只允许在序列末尾增加一个数字呢？可以实现题目的要求吗？</p><p>虽然不知道应该怎么数学证明，但是这是可以的。</p><h2 id="d---strange-device">D - Strange Device</h2><blockquote><p>交互机器有一个长度为 n 数列，每个元素互不相同；对于这个数列，你可以进行询问：</p><ul><li><code>? x1 x2 …… xk</code> ：询问包含 k 个数字的单调递增数列，xi 是原数列的下标；</li><li>交互机器返回 <code>pos val</code> ：pos 是询问序列中第 m 大的元素的下标，val 是它的值；</li></ul><p>现要求你在不超过 n 次询问中求出 m 的值，满足 m ≤ k &lt; n；</p></blockquote><p>虽然说交互机器持有了一个不为我们所知的 n 元数组，但是注意到我们求的东西和数组的值或者某个下标的值实际上没有任何关系，所以<del>可能</del>是闪光弹== 每次询问可以获得长度为 k 的元素互不相同的数组中的第 m 大的元素，为了确定这个 m 的值，一种很容易想到的策略如下：</p><ul><li>取 k + 1 数字（互不相同），对于从中取出 k 个数字的每种组合进行询问</li><li>因为互不相同，所以元素之间的关系非常单纯：只有大于和小于的区别</li><li>这样应该只会得到两种应答：一种是因为被丢弃的数字比第 m 个小，一种是因为大</li><li>可以根据这两种应答数字的相对大小来确定它们的来源，从而确定 m</li></ul><p>这样的做法要求询问 k + 1 次，数组中至少要包括 k + 1 个元素；但是题目已经贴心的安排了 k &lt; n，所以这种方法必然可以采用；事实上题目的样例输入输出就是采用的这种方法进行判定，只是 k + 1 = n 混淆视听罢了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ask cout &lt;&lt; <span class="meta-string">&quot;? &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chk cout &lt;&lt; <span class="meta-string">&quot;! &quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, k, pos, val;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; x;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> lim = k + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> m_pos = <span class="number">-1</span>, m_val = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lim; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        ask;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lim; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (j == i) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; j &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; pos &gt;&gt; val;</span><br><span class="line">        <span class="keyword">if</span> (val &gt; m_val) m_pos = pos, m_val = val;</span><br><span class="line">        ++ x[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    chk &lt;&lt; x[m_pos] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="e---divide-points">E - Divide Points</h2><blockquote><p>给你 n ≥ 2 个整数坐标，要求你将它分成两组，并且满足下面的需求：</p><ul><li>所有的点对之间连边；将两个点在同一组的边称为 A 类边，否则称为 B 类边；</li><li>不存在长度相等的 A 类边和 B 类边；即长度相等的边必须同类；</li></ul><p>确保对于所有的输入数据，存在这样的分组方法；保证输入的每个点独一无二；</p></blockquote><p>看到分组，还是和图论相关的分成两组，难以不想到二分图，并查集乌拉乌拉…… 然而遗憾的是这个题和它们没有半点关系；1e6 的数据范围和 1s 的时限让它最多只能接受 O(n√n) 的算法，所以它是个思维题（</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> uint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1050</span>;</span><br><span class="line"><span class="built_in">pair</span>&lt;uint, uint&gt; p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;uint&gt; ans;</span><br><span class="line">    uint cnt[<span class="number">2</span>][<span class="number">2</span>], &amp;p00 = cnt[<span class="number">0</span>][<span class="number">0</span>], &amp;p11 = cnt[<span class="number">1</span>][<span class="number">1</span>],</span><br><span class="line">            &amp;p01 = cnt[<span class="number">0</span>][<span class="number">1</span>], &amp;p10 = cnt[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    uint n, x, y, msk = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        p[i] = <span class="built_in">make_pair</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            ++ cnt[<span class="keyword">bool</span>(p[i].first &amp; msk)][<span class="keyword">bool</span>(p[i].second &amp; msk)];</span><br><span class="line">        <span class="keyword">if</span> (p01 + p10 &amp;&amp; p00 + p11)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">                <span class="keyword">if</span> ((p[i].first &amp; msk) ^ (p[i].second &amp; msk))</span><br><span class="line">                    ans.push_back(i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p00 + p01 &amp;&amp; p10 + p11)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">                <span class="keyword">if</span> (p[i].first &amp; msk) ans.push_back(i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> msk &lt;&lt;= <span class="number">1u</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans.<span class="built_in">size</span>() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ii : ans) <span class="built_in">cout</span> &lt;&lt; ii &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚刚发现坐标原来可以是负数，我还拿了个 <code>uint</code> 来存…… 虽然说负数坐标映射不改变其奇偶性，导致上述代码仍然可以 AC，但是无论怎么说这还是太不小心了，好歹读进来整体平移啊（</p><h2 id="f---awesome-substrings">F - Awesome Substrings</h2><blockquote><p>给一个长度为 n 的 01 字符串；现在需要求出满足条件的区间 [l, r] 的数目：区间 [l, r] 满足 r - l + 1 是区间内值为 1 的位数的倍数；</p><p>数据范围：n ≤ 2e5；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="g---subset-with-zero-sum">G - Subset with Zero Sum</h2><blockquote><p>给你一个长度为 n 的整数数组 a，下标为 1 ~ n；对于 a 中的元素有 i - n ≤ a[i] ≤ i - 1；现在要求你找出这个数组中元素集合的子集 S，集合内的元素的和为 0；可以证明对于满足这个条件的数组 a，这样的子集必然存在。</p><p>数据规模：n 不超过 1e6；</p></blockquote><p>这个题目看起来比较的奇怪：说是数组，要找的自己和却是一个和数组下标顺序没有任何关系的东西；看起来求和为 0 的子集无从保证，但是随便写几组数据发现确实存在；就……感觉这题目做不得了（</p><p>从看起来最奇怪的约束不等式入手：两个边界都有 +i 存在，可以考虑移项，得到：1 ≤ i - a[i] ≤ n；似乎和下标的范围完全一致，所以就可以建图了<del>别问我我也不知道题解怎么想的</del>：建立一个 n 个点的有向图，连边 i → i - a[i]，就得到了一个基环内向森林——每一个节点的出度为 1 的图；</p><p>这样的图有一个特性，即一定存在环；先说结论，对于这个图中的任何一个环，环上的所有节点构成的集合一定满足题目要求：即集合内点的和为 0；证明如下：</p><ul><li>由我们的建图方式可以知道，对于该图的任何一条边；起点为 i，终点为 i - a[i]；</li><li>如果形成了一个环，那么这个环上所有边的起点集和终点集完全一致，等于处于这个环上的点集；</li><li>那么，对于起点集求和一定和终点集求和相等；因为这两个集合相等；令环上点集为 S；</li><li>上述关系写成式子就是 <span class="math inline">\(\sum_{i \in S} i = \sum_{i \in S} (i - a_i)\)</span>，移项整理可得 <span class="math inline">\(\sum_{i \in S} a_i = 0\)</span>；</li></ul><p>综上所述，对于按照 i → i - a[i] 建立的图，图上任意一个环上的所有点构成的集合就满足题目要求；且这样构成的图中一定存在环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>; <span class="keyword">char</span> ch = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;<span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) f = <span class="number">-1</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;x = (x &lt;&lt; <span class="number">1</span>) + (x &lt;&lt; <span class="number">3</span>) + ch - <span class="number">48</span>; ch = getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> to[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = nextInt(), n;</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        n = nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            to[i] = i - nextInt(), vis[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">1</span>, st;</span><br><span class="line">        <span class="keyword">while</span> (!vis[now]) vis[now] = <span class="number">1</span>, now = to[now]; </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        st = now, now = to[now];</span><br><span class="line">        <span class="keyword">while</span> (now != st) ans.push_back(now), now = to[now];</span><br><span class="line">        ans.push_back(st);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (<span class="keyword">int</span>)ans.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ii : ans) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ii);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题目似乎卡了IO，同样逻辑的代码如果使用 C++ IO 的话会在第八个点几乎一定会 TLE；这种题目姑且还算是个组合题，值和下标在同一个范围内，和经典问题“没有指针的链表”的思想很像== 害也就那么回事吧（</p><h2 id="h---number-of-components">H - Number of Components</h2><blockquote><p>一个长度为 n 的元素互不相同的数组 a，映射为一张包含 n 个节点的无向图 G；映射关系为：当 i &lt; j 和 a[i] &lt; a[j] 同时成立时，认为节点 i 和 j 之间存在连边；现在将会修改数组 a 某位置的值，要求动态地维护图 G 中连通块的数目；修改次数为 q，保证修改后数组元素依然互不相同；</p><p>数据范围：n, q ≤ 5e5；1 ≤ a[i] ≤ 1e6；i ≠ j ⇔ a[i] ≠ a[j]；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="i---xor-on-figures">I - Xor on Figures</h2><blockquote><p>有一个 <span class="math inline">\(2^k × 2^k\)</span> 的矩阵 A，行列从 0 开始标号；给定长度为 t 的数列 x，y；现在你可以进行操作，操作的定义如下：</p><ul><li>操作接受三个参数：p，q，w；记 <span class="math inline">\(X = (x_i+p)\ mod\ 2^k\)</span>，<span class="math inline">\(Y = (y_i+q)\ mod\ 2^k\)</span>；</li><li>对于 <span class="math inline">\(\forall a \in X, \ b \in Y\)</span>，将使得矩阵的 <span class="math inline">\(A_{a,b} = A_{a,b} \oplus w\)</span>；</li></ul><p>现要求仅使用上述操作将矩阵 A 变为零矩阵，求最小的操作次数；</p><p>数据范围：k ≤ 9，t ≤ 99 且为奇数；</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="后记">后记</h2><p>个人认为这套题目的质量应该是非常之高的吧。题目代码量也不是很大，很多题目都是看起来麻烦但实际上是很棒的思维题，只要想到了那个点，问题就可以迎刃而解<del>可我没有数学思维真是抱歉呜呜呜呜</del>；</p><figure><img src="https://i.loli.net/2020/06/16/ugEOVrXeBC4bKdD.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/06/16/ugEOVrXeBC4bKdD.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="6CJWD08019QS4D1H33.jpg" /><figcaption aria-hidden="true">6CJWD08019QS4D1H33.jpg</figcaption></figure><p>还是得加大练习量，多遇见一些这样的有趣的题目才好啊…… 希望人没事，六月底能留下来就好了。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程：第 3 次上机实验</title>
      <link href="/2020/class-software-engineering-experiment-3/"/>
      <url>/2020/class-software-engineering-experiment-3/</url>
      
        <content type="html"><![CDATA[<p>下面是这一次的实验要求：</p><blockquote>#####<center>软件工程综合实验</center><p>一、实验名称：软件工程综合实验</p><p>二、实验目的</p><ol type="1"><li><p>掌握软件分析、设计、测试和实现基本方法</p></li><li><p>综合运用测试驱动开发和重构</p></li></ol><p>三、实验内容和要求</p><ol type="1"><li><p>开发一个机器可读的英汉词典，能获得给定英文词条的多方面信息（读音、词性、每个词义、例句等，能提供的信息越多越好），并在其他软件系统（桌面或在线词典、机器翻译系统、其他自然语言处理系统等）中使用</p></li><li><p>根据常见纸质英汉词典（如牛津高阶英汉词典等）的内容和结构，给出详细的机器可读英汉词典的功能需求</p></li><li><p>设计机器可读英汉词典的存储结构（词典需要存储在磁盘中和内存中）</p></li><li><p>设计机器可读英汉词典的接口</p></li><li><p>采用熟悉的语言（OOP优先）进行实现</p></li><li><p>采用测试驱动的开发方法进行开发</p></li><li><p>采用重构完善设计和实现</p></li></ol><p>四、实验时间</p><p>2次上机时间</p></blockquote><h2 id="实验过程">实验过程</h2><p>设计一个使用 TDD 方法的机器可读的词典。</p><h3 id="需求分析">需求分析</h3><p>从实验要求入手，对于实验要求的部分进行合理解释；</p><h4 id="词典">词典</h4><p>通过传入的字符串，在内建的数据库中搜索对应或者相关的词条；也可以对于某个特定的单词在数据库中查找它全部的相关信息（包括释义、例句以及词性）；</p><h4 id="机器可读">机器可读</h4><p>按照约定的规则向其他应用程序返回格式化的数据；比如作为一个库提供 API 给其他的程序调用，或者作为一个服务端，向对它发起请求的客户端返回合适的数据；在本次实验中，我将词典核心部分打包成 C++ 共享库，可以方便的在其他的 C++ 程序/工程中使用；</p><h4 id="存储">存储</h4><p>SQLite3 是一个轻量级的数据库，它支持全部的 SQL 特性，且数据库作为一个文件存储在本地的文件系统中；对于一个离线的字典工具，使用 SQLite3 作为数据库显然是非常的合适的。</p><h4 id="测试驱动">测试驱动</h4><p>因为涉及到数据库的操作需要验证准确性，且 C++ 没有现成的较好的 ORM 框架，所以在构筑上层程序之前，首先需要先编写和 SQLite3 API 通信的框架；每当完成一部分的时候，都应该对这个框架的方法进行测试；</p><h3 id="实现">实现</h3><p>实现的平台是： Windows 10 + CLion + MinGW + CMake，使用了 SQLite3 作为底层数据库；</p><h4 id="简介">简介</h4><p>项目分为三个部分：<a href="https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job?path=%2FeDict_executable">控制台Shell</a>，<a href="https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job?path=%2FeDict_library">C++ 共享库</a>，<a href="https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job?path=%2FeDict_libtest">共享库测试demo</a>；您可以点击这些链接来访问它们的仓库；是基于 CMake 的项目，可以跨平台编译并且运行；项目提供了 API 打开 SQLite3 词典数据库（这里，以 Kelinsi 电子词典的数据库设计作为标准），然后提供封装后的 API 来查询单词，或者获得某个确定单词的相关信息；</p><h4 id="机器可读和测试">机器可读和测试</h4><p>用户可以在自己的 C++ 工程中引入本项目生成的库文件，在本文档或头文件的引导下使用 API 打开词典数据库，并且查阅单词，对于返回的数据，项目也提供了必要的 Demo 和 API 来获得用户想要查询的信息；Shell 项目和 Demo 项目已经测试了全部的 API，保证它们可以在测试数据集中正常运行；</p><p>关于测试框架：使用 Boost.Test 对比接口查询的数据和 SQL Shell 查询的数据，但是 Git 的时候弄丢了，所以无了。现在仅剩下 Demo 项目和 Shell 项目下的 Test 文件夹下的测试用代码；</p><p>此外，编译生成的库中的 <code>hello</code> 函数，也是用来测试项目是否正确的连接到你的工程的，请多加注意；</p><h4 id="数据库设计">数据库设计</h4><p>这是 Kelinsi 电子词典数据库的表结构：</p><figure><img src="https://cdn.jsdelivr.net/gh/ymd45921/util_assets@master/post/class-SE/kelinsi.svg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ymd45921/util_assets@master/post/class-SE/kelinsi.svg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Kelinsi.svg" /><figcaption aria-hidden="true">Kelinsi.svg</figcaption></figure><p>一个单词可能有多个释义，不同的释义可能有很多条的信息（比如例句），它们通过保存彼此的主键作为自己的外键来关联到一起，是典型的关系型数据库；</p><h4 id="api-设计">API 设计</h4><p>本项目基于 SQLite3 本地数据库，基于该数据库系统的特点设计 API；以下仅列出关键的 API 的声明，如果您需要完整的 API，可以阅读项目工程中提供的 <code>eDict_library.h</code> 文件中的声明；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OPEN_DICTIONARY(path)   <span class="comment">// 打开字符串 path 规定的数据库文件，一个作用域内只能执行一次</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLOSE_DICTIONARY()      <span class="comment">// 关闭已经打开的数据库文件，必须要先打开数据库才可以关闭</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUERY_BY_KEYWORD(key)   <span class="comment">// 查找单词字符串前缀（忽略大小写）的所有单词，并且查询这些单词的编号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QUERY_BY_WORD_ID(wid)   <span class="comment">// 利用单词的编号查找一个具体单词的全部相关信息（包括全部释义）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_WORD_ID(obj)        <span class="comment">// 从 QUERY_BY_KEYWORD 返回的数组中的具体元素中获得单词 ID</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_WORD_EN(obj)        <span class="comment">// 从 QUERY_BY_KEYWORD 返回的数组中的具体元素中获得单词的英文编写</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_WORD_STAR(obj)      <span class="comment">// 从 QUERY_BY_KEYWORD 返回的数组中的具体元素中获得单词的评级字符串</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SENTENCE_CN(st)     <span class="comment">// 从 QUERY_BY_WORD_ID 返回数据的例句字段中提取具体例句的中文</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SENTENCE_EN(st)     <span class="comment">// 从 QUERY_BY_WORD_ID 返回数据的例句字段中提取具体例句的英文</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICTIONARY_IS_CONNECT   <span class="comment">// 类型是 bool : 用来验证词典文件是否已经顺利打开</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DICTIONARY_ERR_MSG      <span class="comment">// 获得电子词典上一次非致命行为异常的错误信息的 C-字符串 (const)</span></span></span><br></pre></td></tr></table></figure><p>正常的工作流程是，在开始查询之前运行 <code>OPEN_DICTIONARY(path)</code> ，并且通过 <code>DICTIONARY_IS_CONNECT</code> 确认字典数据库是否已经连接；若连接，再使用查询相关的 API 查询单词；当程序结束时，建议手动调用 <code>CLOSE_DICTIONARY()</code> 断开连接。</p><p>如果您还想使用这些代码进行更高级的操作，您可能需要了解关于这个项目的结构设计：</p><ul><li><code>orm.h</code> ：可以和 SQLite3 数据库通信，执行 SQL 语句，并且将返回的结果作为一个 <code>OBJECT</code> 对象返回；这个对象的本质上是 STL 实现的哈希表，且当前的版本不能很好地实现 <code>BLOB</code> 格式的数据的读取；</li><li><code>edict.h</code> ：是 ORM 的子类；将执行 SQL 的接口进行进一步的封装，暴露传入回调函数的接口；此外将上文 API 中规定的查询行为特化，返回基于 Kelinsi 电子词典设计的数据结构；</li></ul><p>工作开始时，可以实例化一个 <code>edict</code> 对象，你可以发现这个对象持有上述简易 API 宏所涉及的所有相关的函数；此外，你可以通过暴露的 <code>execSQL</code> 方法执行任何复杂的查询，并通过设计类型为 <code>CALLBACK</code> 的回调函数，将返回的 Meta 数据处理成为任何你想要的数据结构。切记，在工作结束后使用 <code>close</code> 方法结束对于数据库文件的占用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">database</span> &#123;</span></span><br><span class="line">    sqlite3 *db;</span><br><span class="line">    <span class="keyword">bool</span> opened;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> sqlite3 *<span class="title">getDB</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">int</span> _exec_sql(<span class="keyword">const</span> <span class="keyword">char</span> *sql, sqlite3_callback cb, <span class="keyword">void</span> *data, <span class="keyword">char</span> **err_msg);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    database();</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">database</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fileName)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">database</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;fileName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bind</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *fileName)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bind</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;fileName)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isOpened</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">META_RESULT <span class="title">execSQL</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *sql)</span></span>;</span><br><span class="line">    <span class="function">META_RESULT <span class="title">execSQL</span><span class="params">(<span class="keyword">const</span> TEXT &amp;sql)</span></span>;</span><br><span class="line"></span><br><span class="line">    ~database();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">edict</span> :</span> <span class="keyword">public</span> database &#123;</span><br><span class="line"></span><br><span class="line">    TEXT last_err_msg;</span><br><span class="line"></span><br><span class="line">    <span class="function">ITEM <span class="title">fillItem</span><span class="params">(ITEM &amp;item)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">edict</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *db_name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> database::execSQL;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">execSQL</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *sql, CALLBACK cb, <span class="keyword">void</span> *param)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">execSQL</span><span class="params">(<span class="keyword">const</span> TEXT &amp;sql, CALLBACK cb, <span class="keyword">void</span> *param)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">getLastErrorMsg</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ARRAY <span class="title">search</span><span class="params">(TEXT prefix)</span></span>;</span><br><span class="line">    <span class="function">DETAIL <span class="title">getDetail</span><span class="params">(<span class="keyword">unsigned</span> word_id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><center>↑ 上述两个类的声明（位于 <code>eDict_library.h</code> 中） ↑</center><h4 id="重构">重构</h4><p>虽然在 Shell 工程中将代码分成多个文件存放是好的，但是当要制作一个库的时候，将太多高度耦合的文件分开存放并不是一件好事，会增大用户使用的复杂度；所以打包成成品库之后，我将很多高度耦合的头文件的代码进行了融合，作为一个新的工程与原来的 Executable 工程分开；</p><p>此外，在我的代码中，一些常用的功能已经被提取成纯函数，作为单独的模块而存在；</p><h3 id="使用">使用</h3><p>关于库文件的 API，已经在上面讲过了；想要知道更多请去阅读相关头文件；</p><h4 id="excutable-项目">Excutable 项目</h4><p>从<a href="https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job?path=%2FeDict_executable">代码仓库</a>中获得代码后，使用 CMake 加载这个项目，编译可以得到可执行文件；将可执行文件和<a href="https://husteducn-my.sharepoint.com/:u:/g/personal/u201817070_hust_edu_cn/EfouJVhWBMJAr8uzEGPbKNQB0e5oOVA8hCg_j2CPOdMWEA?e=f91Pf3">电子词典数据库文件</a>放在相同的目录下，关闭杀毒软件即可查询；</p><h4 id="library-项目">Library 项目</h4><p>从<a href="https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job?path=%2FeDict_library">代码仓库</a>获取代码之后，使用 CMake 生成 .dll 文件；将这个文件以及项目目录下的 <code>sqlite3.h</code> 和 <code>edict_library.h</code> 文件放在你要使用的项目里，并且加入 Include Path（也可以忽略此步，但是这样大多数 IDE 将不能为这里的代码提供自动补全或者只智能纠错）；在编译时使用 <code>-l libedict_library.dll</code> 命令，或者（你使用 CMake 管理你的项目）在你自己的项目的 <code>CMakeList.txt</code> 中加入以下内容：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(./) <span class="comment"># 用来存放 dll 的位置</span></span><br><span class="line"><span class="keyword">add_executable</span>(main <span class="variable">$&#123;SRC_FILES&#125;</span>) <span class="comment"># 你的 build target</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(main libeDict_library.dll) </span><br></pre></td></tr></table></figure><p>如果你使用 Visual Studio 管理你的项目，你需要在解决方案的配置页面，在 C/C++ &gt; 链接器 的页面中加入这个 dll 文件。</p><p>这样，你就可以使用上述的 API 来查询符合 Kelinsi 词典表规范的电子词典数据库了；实际上，<a href="https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job?path=%2FeDict_libtest">Demo 项目</a>已经实现了这个功能，但是在使用之前，您仍然需要将<a href="https://husteducn-my.sharepoint.com/:u:/g/personal/u201817070_hust_edu_cn/EfouJVhWBMJAr8uzEGPbKNQB0e5oOVA8hCg_j2CPOdMWEA?e=f91Pf3">电子词典数据库文件</a>放在生成的可执行文件相同的目录下，并且修改文件名；</p><h4 id="win32-cmake">Win32 + CMake</h4><p>你可以下载已经编译过的<a href="https://husteducn-my.sharepoint.com/:u:/g/personal/u201817070_hust_edu_cn/Eap6_6sKg2ZErv4a3sHDAtsBtpXhCyIdrzz4HA87ccC3_g?e=vCUgqs">DLL文件</a>和<a href="https://husteducn-my.sharepoint.com/:u:/g/personal/u201817070_hust_edu_cn/EYRN51fwJ8xIjTCz9wYqt18BSOxtAhoSF6S5wZX-2fIRPQ?e=ERG3TU">头文件</a>来在 CMake 项目中使用这个程序；当然，这里也提供 kelins 电子词典的 SQLite3 <a href="https://husteducn-my.sharepoint.com/:u:/g/personal/u201817070_hust_edu_cn/EfouJVhWBMJAr8uzEGPbKNQB0e5oOVA8hCg_j2CPOdMWEA?e=f91Pf3">数据库文件</a>，可以配合上述文件以及介绍快速地在您的项目中使用。</p><h2 id="后记">后记</h2><p>通过本次的软件工程实验，我学会了使用 SQLite3 数据库框架，熟练了 CMake 对于项目管理的流程；实际操作了在现代 IDE 中的项目管理流程，一定程度上熟悉了 TDD 开发以及 C++ 测试框架，并且对于库文件开发的理解更进一步。</p><h3 id="关于源代码">关于源代码</h3><p>展示的源代码是 Library 项目的源代码，它的文件结构如下图所示：</p><figure><img src="https://i.loli.net/2020/06/11/Rx4EDA97wMeZriq.png" class="lazyload" data-srcset="https://i.loli.net/2020/06/11/Rx4EDA97wMeZriq.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="FQ1M0QMYAKNXD07Q77Y.png" /><figcaption aria-hidden="true">FQ1M0QMYAKNXD07Q77Y.png</figcaption></figure><p>其中 <code>cmake-build-debug</code> 是 CMake 生成的临时文件，可以忽略；但是作为生成的可执行文件的所在位置，如果你要运行其他两个 C++ Executable 项目的话，需要将数据库文件放在该目录下；</p><p><code>build</code> 目录是手动生成的输出位置，如果生成静态库就会得到 <code>.a</code> 文件，生成共享库文件就会得到 <code>.dll</code> 文件；其中的 <code>libedict_library.h</code> 文件就是前面可以直接下载的头文件，它包含了 SQLite3 的头文件；</p><p><code>CMakeList.txt</code> 文件记录了项目的配置信息；如果不是直接从仓库拉取项目，这个文件的内容可能需要重新配置；</p><p><code>sqlite3.c</code> 和 <code>sqlite3.h</code> 文件是 SQLite3 官方 API 的一部分，您可以从它的<a href="https://www.sqlite.org/index.html">官方网站</a>上下载，并且将它们包含在这个项目的目录中；注意，如果您下载的文件版本和仓库中的版本不一致，可能会导致运行结果和预想不一致甚至是无法编译的问题，请根据实际情况进行酌情调整；</p><p><code>library.h</code> 和 <code>library.c</code> 包含了对于底层 SQLite3 API 的封装以及面向用户的宏的声明和实现；编译后可以将这里的头文件和上面的 SQLite3 的头文件一起加入到新项目中以使用代码智能提醒；</p>]]></content>
      
      
      <categories>
          
          <category> 课业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课内作业 </tag>
            
            <tag> 实验报告 </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019 NWRRC 回顾</title>
      <link href="/2020/2019-nwrrc/"/>
      <url>/2020/2019-nwrrc/</url>
      
        <content type="html"><![CDATA[<p>虽然找到了官方网站，但是并没有找到题解文档或者是 Slide——准确的说是没有找到英文版本的，俄文版本倒是有的，甚至还有标题是英文内容是俄文的…… 下载到的标程也存疑，因为形态比较诡异，也就没有参考；</p><p>找到了就会贴出来的<del>找不到的</del>，最后还是依靠校队组织的讲题完成了这篇题解，官方的俄文题解我是不指望了（</p><p>下面就是这次的 13 个题目，我也没有做出来几个，没做出来的就先占个坑好了：</p><h2 id="a.-accurate-movement">A. Accurate Movement</h2><blockquote><p>槽里面有一个长条，一个短条，起始位置都在一侧；一次只能移动一个，要保证短条始终在长条内部，问最少需要多少次才能够将两个条都移动到槽的另一端。</p></blockquote><p>签到题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> a, b, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b &gt;&gt; n;</span><br><span class="line">    <span class="keyword">auto</span> xx = n - a;</span><br><span class="line">    <span class="keyword">auto</span> tt = xx / (b - a) + <span class="keyword">bool</span>(xx % (b - a));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; tt * <span class="number">2</span> - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="b.-bad-treap">B. Bad Treap</h2><blockquote><p>Treap，树堆，即笛卡尔树；每一个节点包含两个值 (K, V)，K 值满足二叉搜索树的性质（左二子 &lt; 树根 &lt; 右儿子），而 V 值满足堆的性质（根 &gt; 所有儿子）；</p><p>现在要构造一颗树堆，它的每个节点定义是 (x, y = sin x)；现在你希望它包含 n 个节点，且平衡性是所有 n-树堆 中最差的；你要构造出这 n 个节点的 x 值，且 x 的类型是 <code>__int32</code>。</p><p>数据范围：1 ≤ n ≤ 50000，-2³¹ ≤ x ≤ 2³¹ - 1；</p></blockquote><p>首先，”最不平衡“指的是左右子树的高度差最大；显然，一颗 n 个节点构成的 Treap 能达到的最大的高度差是 n-1：即当整棵树退化成一条链的时候；那么在什么样的情况下，这棵树会退化成一条链呢？一种很简单的情况，就是当 K 和 V 值都是单调的时候，堆的性质一定会满足，所有节点都是其父节点的左二子或是右儿子；</p><p>观察节点的函数 (K: x, V: y = sin x)：假设我们想要一个 V 随着 K 增大而增大的区间，那么这个区间可以是 x ∈ [-π/2, π/2]；但是题目要求了键 K 是 <code>__int32</code> 类型，不然我们直接将这个区间平均分配就可以了；但是另注意到，sin x 是一个周期函数，所以对于同一个 V 值，可以对应多个差距为 2kπ 的 K 值，只要这些 K 值递增且为整数，就可以构造出一个整数数列；那么现在我们想要构造一组 K = -π/2 + 2πi / T + 2kπ，使得他们都是整数且数列递增；显然，增量 δ = 2π / T + εkπ；</p><p>当然，我们可以使用暴力的方法先行求出这个 ε 的值，进而得到这个增量 δ 的值，使用下面的简单易懂的代码就可以轻松的求出在不同整数精度的情况下的增量值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> number&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">comparable</span> :</span> binary_function&lt;number, number, <span class="keyword">bool</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    number eps = <span class="number">1e-8</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(number x)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x &lt; -eps ? <span class="number">-1</span> : x &gt; eps;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">comparable</span><span class="params">(number eps)</span> : <span class="title">eps</span><span class="params">(eps)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(number a, number b)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> compareTo(a-b);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(number a, number b)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> compareTo(a-b);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">double</span> <span class="title">calcDelta</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span> precision, <span class="keyword">unsigned</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> pi = <span class="number">3.1415926535897932384626</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> dpi = <span class="number">2.0</span> * pi;</span><br><span class="line">    <span class="function">comparable&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; <span class="title">cmp</span><span class="params">(precision)</span></span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> delta = pi / count;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">10</span>) &lt;&lt; <span class="string">&quot;delta: &quot;</span> &lt;&lt; delta &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> xx = delta, ans = xx; <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cmp(ans, <span class="built_in">ceil</span>(ans))) ++ cnt, ans = xx + cnt * dpi;   <span class="comment">// unsequenced modification and access to &quot;ans&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;found: &quot;</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>, ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为题目的要求是 50000 数据范围，如果调用上述的 <code>calcDelta(1e-5, 50000)</code> 得到的是 1420，交上去会挂掉；因为 C++ 浮点数有着大家都知道的误差，所以一般来说 T 应该更大的数，比如 60000，求出的增量 710，就可以过了；此外按照 hjl 巨佬的 ppt 上的推法也可以得到相同的结果；最后代码就像下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> n; <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">710</span> * (i - <span class="number">25000</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c.-cross-stitch">C. Cross-Stitch</h2><blockquote><p><del>Cross-Stitch [n] 十字绣</del>给你一个 h 行 w 列的十字绣图案，要求使用一根线将它绣出来，并且消耗线的长度最少；输出这种绣法包含的针数（孔数），并且按照先后顺序输出线经过的点的坐标。</p><p>数据规模：1 ≤ w, h ≤ 100；</p></blockquote><p>首先，一根线绣出的意思，就是说存在一条欧拉回路连接这所有的绣边；要消耗线的长度最小，不论怎样的绣边的长度都只能是 1 或者是 √2；最短的消耗，一定是每个十字绣网格，由两条长度为 √2 的表线，和两条长度为 1 的里线组成，且包含起点和终点的网格可以节约一条里线；</p><p>因为给的十字绣图案只是表面的走线，里面的走线是可以按照一定的标准来自行连接的，经过草稿纸上的推导<del>其实是我懒得在电脑上画图了</del>，就可以知道起点和终点是可以在同一个方格里的十字上的；这样，当我们连接起点和终点作为里边的时候（这样的连接是合法的），就可以将欧拉路变成欧拉环；</p><p>严格按照 表-里-表-里 的方法绣十字绣，当所有的方格的构型是相同（两条里边上下/左右相对）时，一定存在这样的欧拉回路，将所有的绣点连接起来；所以我们可以按照这种思路建图，然后限定 表-里 交错的方法 DFS，就可以找到一个绣十字绣的顺序，它可以确保绣出这个图案并且花费线材最少；特别注意第一针必须绣表线，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>, M = N * N * <span class="number">4</span>;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[N][N];</span><br><span class="line"><span class="keyword">int</span> id[N][N], cnt = <span class="number">0</span>, vis[M];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w, next;</span><br><span class="line">    edge() = <span class="keyword">default</span>;</span><br><span class="line">    edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> next)</span><br><span class="line">            : u(u), v(v), w(w), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FWS</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> head[N * N];</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    edge ee[M * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ee[tot] = edge(u,v,w,head[u]);</span><br><span class="line">        head[u] = tot ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans.<span class="built_in">clear</span>(); cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; ++ j)</span><br><span class="line">            id[i][j] = cnt ++;</span><br><span class="line">    FWS::init(cnt + <span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FWS::addEdge(u, v, color);</span><br><span class="line">    FWS::addEdge(v, u, color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> last_color)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> cc = head[u]; cc + <span class="number">1</span>; cc = ee[cc].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[cc / <span class="number">2</span>] || ee[cc].w == last_color) <span class="keyword">continue</span>;</span><br><span class="line">        vis[cc / <span class="number">2</span>] = <span class="literal">true</span>;</span><br><span class="line">        dfs(ee[cc].v, ee[cc].w);</span><br><span class="line">        ans.push_back(ee[cc].v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>); <span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    init(n, m); <span class="keyword">int</span> sp, div = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">cin</span> &gt;&gt; (<span class="built_in">map</span>[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="string">&#x27;X&#x27;</span>) sp = id[i][j],</span><br><span class="line">                addEdge(id[i - <span class="number">1</span>][j - <span class="number">1</span>], id[i][j], <span class="number">1</span>),</span><br><span class="line">                addEdge(id[i - <span class="number">1</span>][j], id[i][j - <span class="number">1</span>], <span class="number">1</span>),</span><br><span class="line">                addEdge(id[i - <span class="number">1</span>][j], id[i][j], <span class="number">0</span>),</span><br><span class="line">                addEdge(id[i - <span class="number">1</span>][j - <span class="number">1</span>], id[i][j - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">    dfs(sp, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (ans.<span class="built_in">size</span>() - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; ii : ans) <span class="built_in">cout</span> &lt;&lt; ii % div &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ii / div &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="d.-double-palindrome">D. Double Palindrome</h2><blockquote><p>定义双回文串：一个字符串是双回文串，当且仅当它是一个回文串或两个回文串的组合；现在询问长度不超过 n 的，由大小为 k 的字符集排列组合构成的所有字符串中回文串的数量，输出答案取模。</p><p>数据规模：1 ≤ k ≤ 26 并且 1 ≤ n ≤ 1e5。</p></blockquote><p>占坑</p><h2 id="e.-equidistant">E. Equidistant</h2><blockquote><p>有 n 个城市连成一棵树，每两个相邻的城市连接的边的长为 1；现在这些城市中的一部分（或者全部）都有人要参加区域赛，问比赛场地设置在哪座城市，才可以保证所有城市的参赛者到达比赛场所需要走的路径长度一致，不存在这样的城市时输出 <code>Impossible</code>。</p></blockquote><p>没有什么特别优秀的做法，考虑暴力，但是并不是直接就暴力了——n²给卡到死；仔细思考一波，发现最多只要扫描所有的节点就一定可以找到这个点，那么就可以考虑多起点 BFS：每当一个节点到达一个节点的时候，如果深度和当前深度一致就增加一次访问次数，这样最终只需要遍历所有节点，找到是否存在被访问了 n 次的节点存在就可以了。</p><p>思路比较清晰，接下来就是实现细节的问题了；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>, M = N;</span><br><span class="line"><span class="keyword">int</span> n, m, c[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w, next;</span><br><span class="line">    edge() = <span class="keyword">default</span>;</span><br><span class="line">    edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> next)</span><br><span class="line">            : u(u), v(v), w(w), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FWS</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> head[N];</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    edge ee[M * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n = N<span class="number">-1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ee[tot] = edge(u,v,w,head[u]);</span><br><span class="line">        head[u] = tot ++;</span><br><span class="line">        ee[tot] = edge(v,u,w,head[v]);</span><br><span class="line">        head[v] = tot ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BFS</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">int</span> visit[N] &#123;<span class="number">0</span>&#125;, depth[N] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">bool</span> used[N] &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        q.push(c[i]);</span><br><span class="line">        visit[c[i]] = <span class="number">1</span>;</span><br><span class="line">        depth[c[i]] = <span class="number">1</span>;</span><br><span class="line">        used[c[i]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> found = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> top = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ii = head[top]; ~ii; ii = ee[ii].next)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> &amp;e = ee[ii];</span><br><span class="line">            <span class="keyword">if</span> (!depth[e.v] || depth[e.v] == depth[e.u] + e.w)</span><br><span class="line">            &#123;</span><br><span class="line">                visit[e.v] += visit[e.u];</span><br><span class="line">                depth[e.v] = depth[e.u] + e.w;</span><br><span class="line">                <span class="keyword">if</span> (visit[e.v] == m)</span><br><span class="line">                &#123;found = e.v; <span class="keyword">break</span>;&#125;</span><br><span class="line">                <span class="keyword">if</span> (!used[e.v])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.push(e.v);</span><br><span class="line">                    used[e.v] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (found &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    FWS::init(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        FWS::addEdge(u, v, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">    <span class="keyword">int</span> found = BFS();</span><br><span class="line">    <span class="keyword">if</span> (found &lt; <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; found &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这个题目，<a href="https://acm.ecnu.edu.cn/wiki/index.php/ICPC_2019-2020_North-Western_Russia_Regional_Contest#Problem_E">ECNU 的带佬们</a>有他们独特的想法：首先对于两个“相邻”的特殊点使用倍增 LCA 求中点，且没有终点，一定无解；之后按照 DFS 标号后，就将子树问题转化为了区间问题；虽然到头来，他也没有提供这么做的代码，但是想必也是很有趣的思路吧。</p><h2 id="f.-foreach">F. Foreach</h2><blockquote><p><del>PHP 的 foreach 模拟器</del>因为题目太长所以下面直接说意思：</p><p>有一个 PHP 数组 <code>$a</code>，你可以使用 <code>foreach</code> 遍历所有的变量，并且使用 <code>break</code> 中断循环；为了简单起见，你只能操作变量 <code>$x</code>：你可以使用两种 <code>foreach</code> 语句进行操作：</p><ul><li><p>带引用版本：将变量设置为数组中某元素的引用，你只可以使用如下的形式获得元素的引用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> ($a <span class="keyword">as</span> &amp;$x) <span class="keyword">if</span> ($x == &lt;some <span class="keyword">integer</span> value&gt;) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></li><li><p>值版本：将变量（引用的元素）设置为一个数组元素的值；同样只能使用如下形式</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> ($a <span class="keyword">as</span> $x) <span class="keyword">if</span> ($x == &lt;some <span class="keyword">integer</span> value&gt;) <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></li></ul><p>接下来题目会给你一个长度为 n 的数组 <code>$a</code>，并且指定目标状态；要求你生成将原数组转化为目标状态的代码（仅由上述两个语句构成），并在第一行输出代码行数；如果不可能生成这样的代码。输出 -1；</p><p>数据规模：数组长度 1 ≤ n ≤ 50，元素（包括原始状态和目标状态）的值 1 ≤ si, ti ≤ 100；</p></blockquote><p><del>使用谷歌生草机来学习共产主义唯一指定语言——俄语</del></p><h2 id="g.-golf-time">G. Golf Time</h2><blockquote><p>有一个宽为 w，高为 h 的球场，定义坐标系：+x 向右，+y 向上；球场内有一个 n 边形池塘，如果球到达了池塘位置就会立即下沉，输入将按照顺时针方向描述池塘边缘所有的格点；球总是朝东北方向发出，并保持匀速直线运动 (1, 1)；当球撞到了边缘，球会被无能量损失的反弹（仅改变运动方向）；现在告诉你 t 个发球点，问这个球是否可以永远的运动下去，或在落水之前运动的时间以及落水时的准确位置。</p><p>数据规模：4 ≤ w, h ≤ 5e8，4 ≤ n ≤ 1000，1 ≤ t ≤ 100；</p></blockquote><p>占坑</p><h2 id="h.-high-load-database">H. High Load Database</h2><blockquote><p>有一个数据库，里面有 n 块数据，每一块数据的大小是 ai；接下来尝试将这个大数据库分库成多个单个存储了不超过 t 数据的数据库：要求数据块的顺序保持和原数据库一致，且每一块数据一定要放在一个数据库中；进行 q 次询问，每次询问 ti，要求求出分成的数据库的数量，或者不能够实现目标。</p><p>数据规模：1 ≤ n ≤ 2e6，1 ≤ Σai ≤ 1e6，1 ≤ q ≤ 1e6，1 ≤ t ≤ Σai；</p></blockquote><p>不能分库的情况很显然，就是存在单块数据大于这个要求的数据库最大容量 t，做一下特殊处理就好了；接下来对于单次询问 t，也很容易有这样的思路：从第一块数据开始贪心的向右边数，当空间超过 t 的时候就取出最后一块数据，并且统计次数自增即可；这样对于单次询问是 O(n) 的。</p><p>但是问题是这题询问次数很多，这样复杂度就是 O(nq) 的，就会炸了；所以需要想方设法进行一些优化：注意到了询问从左向右的过程是再不断累加求和，这个过程显然可以使用前缀和优化掉；接下来得到的前缀和序列就是一个递增序列：我们每一次寻找到的当前分库存储的数据量 x' 也可以表示为 Σx + x' 的前缀和形式，这样就可以使用二分查找了；</p><p>还是应当注意一些实现细节；整体复杂度是 O(qlogn)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, a[N], q, t, inm = <span class="number">0</span>, sum[N] &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i], inm = <span class="built_in">max</span>(inm, a[i]),</span><br><span class="line">                     sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mem;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> <span class="built_in">end</span> = sum + n + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q; <span class="keyword">while</span> (q --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; inm) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Impossible&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mem.count(t)) <span class="built_in">cout</span> &lt;&lt; mem[t] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> cur = <span class="number">0</span>; cur &lt; n; -- cur)</span><br><span class="line">            &#123;</span><br><span class="line">                ++ ans;</span><br><span class="line">                cur = upper_bound(sum + cur, <span class="built_in">end</span>, sum[cur] + t) - sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; (mem[t] = ans) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这样前缀和二分就已经可以做出这个题目了：但是听了校队的 sac 巨佬的讲解之后，了解到了这种情况下还可以使用倍增来搜索前缀和数组，以快速找到下一个合理的位置；先上代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (++ cnt) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> tol = <span class="number">0</span>, bin = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (bin)</span><br><span class="line">    <span class="keyword">if</span> (l + tol + bin &gt; n || a[l + tol + bin] - a[l] &gt; t) bin &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> tol += bin, bin &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l + tol == n) <span class="keyword">break</span>;</span><br><span class="line">    l += tol;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的说就是固定左侧端点，然后使用倍增的方法（其实也就是变相的二分）来枚举段的大小；理论上的时间复杂度仍然和二分方法一样，是 O(log n) 的，但是执行起来的实际效率远高于一般二分；下面是使用这种方法构筑的本题的通过代码<del>甚至用上了六月全新的代码答题卡模板</del>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USING_STDIO 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USING_STDIO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch))&#123;<span class="keyword">if</span> (ch==<span class="string">&#x27;-&#x27;</span>) f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch))&#123;x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+ch<span class="number">-48</span>;ch=getchar();&#125;</span><br><span class="line">    <span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">long</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> number&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(number x)</span> </span>&#123;<span class="keyword">return</span> x &lt; -eps ? <span class="number">-1</span> : x &gt; eps;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> number&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(number a, number b)</span> </span>&#123;<span class="keyword">return</span> compareTo(a-b);&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], q, t;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !USING_STDIO</span></span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n; <span class="keyword">int</span> top = sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    sum[n + <span class="number">1</span>] = <span class="number">0x7fffffffffffffff</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i], top = <span class="built_in">max</span>(top, a[i]),</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; memo;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q; <span class="keyword">while</span> (q --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; top) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Impossible&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (memo[t]) <span class="built_in">cout</span> &lt;&lt; memo[t] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>, l = <span class="number">0</span>, r;</span><br><span class="line">            <span class="keyword">while</span> (++ cnt)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> off = <span class="number">0</span>, bin = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (bin)</span><br><span class="line">                    <span class="keyword">if</span> ((r = l + off + bin) &gt; n ||</span><br><span class="line">                        sum[r] - sum[l] &gt; t) bin &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> off += bin, bin &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (l + off == n) <span class="keyword">break</span>;</span><br><span class="line">                l += off;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; (memo[t] = cnt) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然不知道在其他的二分题目里面这有没有什么应用，但是在这里他就这么用上了。</p><h2 id="i.-ideal-pyramid">I. Ideal Pyramid</h2><blockquote><p>二维坐标系中有 n 个柱子，使用 (x, y, h) 来描述它们：xy 即平面坐标系中代表位置的坐标，h 代表这些柱子的高度；现在法老想要修金字塔：金字塔是一个四棱方锥，四个三角面和坐标系平面的夹角是 45°；法老希望这个金字塔覆盖了所有的柱子，同时尽可能的小，并且金字塔尖一定要是整数坐标的；要求输出 (x, y, h) 描述这个金字塔：xy 是金字塔尖的位置坐标，h 是这个金字塔的高度。</p></blockquote><p>一开始看还以为是平面二分，甚至搬出了我那丑陋的平面几何板子== 最后发现这彻头彻尾是一个超有趣的思维题（也不算吧，主要还是自己太蠢了）：我们假设在每一个柱子处建造小型金字塔，那么符合题意的金字塔一定会把这些金字塔都包含在其中，这样的话金字塔投影的正方形一定会把这些小金字塔的正方形包含在其中——大正方形包含小正方形还是很好计算的；所以我们只要把柱子转化成金字塔投影方形，然后求可以覆盖这些投影的最小正方形，然后求出这个正方形的中心坐标并且计算高度就可以了（草</p><p>特别提示：这个金字塔的投影就是边都在网格上的正方形，而不是格点菱形；就算是格点菱形依然是这个思路，只不过求包覆的大菱形的难度变大了==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">triple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, h;</span><br><span class="line">    triple(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> h) : x(x), y(y), h(h) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;triple&gt; p;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function">triple <span class="title">solution</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> uu = p[<span class="number">0</span>].y - p[<span class="number">0</span>].h,</span><br><span class="line">            dd = p[<span class="number">0</span>].y + p[<span class="number">0</span>].h,</span><br><span class="line">            ll = p[<span class="number">0</span>].x - p[<span class="number">0</span>].h,</span><br><span class="line">            rr = p[<span class="number">0</span>].x + p[<span class="number">0</span>].h;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ii : p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> uuu = ii.y - ii.h,</span><br><span class="line">                ddd = ii.y + ii.h,</span><br><span class="line">                lll = ii.x - ii.h,</span><br><span class="line">                rrr = ii.x + ii.h;</span><br><span class="line">        uu = <span class="built_in">min</span>(uu, uuu);</span><br><span class="line">        dd = <span class="built_in">max</span>(dd, ddd);</span><br><span class="line">        ll = <span class="built_in">min</span>(ll, lll);</span><br><span class="line">        rr = <span class="built_in">max</span>(rr, rrr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> xx = rr - ll, yy = dd - uu;</span><br><span class="line">    <span class="keyword">unsigned</span> length = <span class="built_in">max</span>(xx, yy);</span><br><span class="line">    <span class="keyword">if</span> (length &amp; <span class="number">1u</span>) ++ length;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span> = length &gt;&gt; <span class="number">1u</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;ll + <span class="built_in">height</span>, uu + <span class="built_in">height</span>, <span class="built_in">height</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n; <span class="keyword">int</span> x, y, h;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; h;</span><br><span class="line">        p.emplace_back(x, y, h);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> ans = n == <span class="number">1</span> ? p.front() : solution();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans.x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; ans.y &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">         &lt;&lt; ans.h &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="j.-just-the-last-digit">J. Just the Last Digit</h2><blockquote><p>现在有一个 n 个节点的图，它的每个节点的高度都是唯一的，且是 [1, n] 中的一个整数：数字越大高度越低；现在你只能从高的点到达低的点，你最开始站在最高点处；接下来给你的数据包括一组数据：记载了从每一个点（高度）到达其他点的方法数的最后一位，要求你根据这些数据还原出这个图的可达信息。</p><p>数据范围：2 ≤ n ≤ 500.</p></blockquote><p>输入数据看起来有点像入度，但其实不是；只给最后一位的数字也非常的吓人，啊这那我不会做了==</p><p>仔细观察样例一定可以发现：对于 <span class="math inline">\(a_{i,j}\)</span> ，就是从 i 点出发到达 j 点的方式数字，当 i ≤ j 的时候的数字必然是 0：这很好理解，因为我比不可能到达比我当前位置高的地方；那我们对于第 i 组数据，只需要从第 i+1 个位置开始考虑就可以了：首先就是 i+1 位置，它只可能是两个值——1 表示该点和当前点是直接连接的，0 则表示没有直接通路；因为这两个点高度差距之间不允许出现间接到达的可能，所以就可以直接得出准确信息；</p><p>接下来考虑 [i+2, n] 位置的值：根本没有办法考虑，你能得到的信息就是它定义说的那样；但是从定义出发，就这样：当我们确认 i - i+1 的路径是存在的，那么对于 x ∈ [i+2, n]，一定会有 cnt(i, x) ≥ cnt(i+1, x) ——因为 i 一定可以通过 i+1 到达这些位置，这是确定的间接到达，可以从现在的第 i 组数据中减去；</p><p>我们继续向右扫描，如果还能遇到没有被消除的，存在的 j ∈ [i+2, n]，那么它一定是 1，并且代表它和 i 是直接连接的：因为间接连接的可能性都在前面的扫描中被排除了；我们可以再如法炮制，将通过 j 间接到达的可能性全部排除；这样循环就可以填完整个数组，求出所有可能建立直接连接的边，也就是还原了图。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">550</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, <span class="built_in">map</span>[N][N], ans[N][N];</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">            <span class="built_in">map</span>[i][j] = ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            ans[i][j] = <span class="built_in">map</span>[i][j];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[i][j]) <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++ k)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">map</span>[i][k] -= <span class="built_in">map</span>[j][k];</span><br><span class="line">                <span class="keyword">while</span> (<span class="built_in">map</span>[i][k] &lt; <span class="number">0</span>) <span class="built_in">map</span>[i][k] += <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans[i][j];</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="k.-kings-children">K. King’s Children</h2><blockquote><p>国王有一个 n × m 矩阵的地图，每一个方格是地盘的最小单位；王有不超过 26 个儿子，用字母表示；每一个儿子有一个城堡，位于地图中的某个方格上：这个方格使用这个字母的大写形式标识，其他方格用 <code>.</code> 表示；现在国王要将地盘分给儿子们，分给儿子们的地盘用字母的小写形式表示；分地图有要求：所有领土必须全部分给儿子，且每个儿子得到的领土是严格的网格矩阵；此外，国王希望 <code>A</code> 儿子分到的领土尽可能的大；现在要求你将分割后的矩阵计算出来并输出。</p><p>数据范围：1 ≤ n, m ≤ 1000</p></blockquote><p>好麻烦的 DSU 题目…… 直接翻译题意就可以知道，首先我们要求出整个矩阵中 A 可以拓展的最大子矩阵，然后再拓展其他的字母，将整个矩阵填满；填充最大子矩阵可以使用很多种方法：比如悬线法，或者是单调数据结构等等，求出了 A 的最大子矩阵之后，就将矩阵剩余部分划分成了四个部分；因为其他的字母只需要扩充后填满整个矩形即可，所以不再需要跑一遍最大子矩阵了，随便使用什么乱搞的方法将矩阵填满就可以了。</p><p>这里填充其他矩阵的方法，就是对于任何一个字母，先尝试上下拓展，将整列占满，之后再尝试横向拓展；就算这一步暴力也问题不大，之后得到的结果一定是有效的。</p><p>先复习关于最大 0, 1 子矩阵的问题：当障碍点比较密集的时候可以使用<strong>悬线法</strong>，就是开三个数组，记录向上、向左、向右可以到达的最远的距离，之后再遍历整个矩阵的所有点，找到最大的值并记录即可；当然，只开一个数组更新左侧可到达的最远距离，再向上/向下探测求的原理也是一样的，只是因为少了预处理，效率变差了；至于<strong>单调栈</strong>方法，则是从上而下枚举每一行，维护该行每个位置可以向上探明的最高高度；之后对于每一行，以这个高度作为标准按照一个顺序进行一次单增栈，每次弹栈的时候更新最大面积，<a href="https://www.luogu.com.cn/blog/COLIN-GAO/solution-p4147">就像这里说的那样</a>；甚至还有神奇的<strong>并查集</strong>做法，自己去看洛谷题解了。</p><p>如果你想知道更多关于这个问题的一些信息，你可以去阅读这篇论文：<a href="https://blog.csdn.net/twtsa/article/details/8120269">传送门&gt;&gt;</a></p><p>但是和上面所说的那种最大子矩形问题不同的是，这个问题所要求的只是以确定点为重心发散的最大子矩形，暴力的话就可以了（所以这个题目只是单纯的麻烦罢了，但是没问题，我写不出来 ==）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1050</span>;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[N][N], ans[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m, pos[N][N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y; <span class="keyword">char</span> ch;</span><br><span class="line">    node(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">char</span> ch) : x(x), y(y), ch(ch) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> Ax, Ay;           </span><br><span class="line">    <span class="built_in">vector</span>&lt;node&gt; vec;     </span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; seg[N];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; (<span class="built_in">map</span>[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(pos, <span class="number">0</span>, <span class="keyword">sizeof</span> pos);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] == <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">                pos[i][j] = <span class="built_in">map</span>[i][j] - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>,</span><br><span class="line">                Ax = i, Ay = j;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">map</span>[i][j] != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                pos[i][j] = <span class="built_in">map</span>[i][j] - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>,</span><br><span class="line">                vec.emplace_back(i, j, pos[i][j] - <span class="number">1</span> + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> uu = Ax, dd = Ax;</span><br><span class="line">        <span class="keyword">if</span> (pos[Ax][j] &amp;&amp; j != Ay)</span><br><span class="line">        &#123;</span><br><span class="line">            seg[j] = <span class="built_in">make_pair</span>(uu, dd - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (uu &gt; <span class="number">1</span> &amp;&amp; !pos[uu - <span class="number">1</span>][j]) -- uu;</span><br><span class="line">        <span class="keyword">while</span> (dd + <span class="number">1</span> &lt;= n &amp;&amp; !pos[dd + <span class="number">1</span>][j]) ++ dd;</span><br><span class="line">        seg[j] = <span class="built_in">make_pair</span>(uu, dd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; outer = seg[Ay], sav;</span><br><span class="line">    <span class="keyword">int</span> al = Ay, ar = Ay, aa = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ll = Ay; ll &gt;= <span class="number">1</span>; -- ll)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> inner = outer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> rr = Ay; rr &lt;= m; ++ rr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> area = (rr - ll + <span class="number">1</span>) * (inner.second - inner.first + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (area &gt; aa)</span><br><span class="line">            &#123;</span><br><span class="line">                aa = area, al = ll, ar = rr;</span><br><span class="line">                sav = inner;</span><br><span class="line">            &#125;</span><br><span class="line">            inner.first = <span class="built_in">max</span>(inner.first, seg[rr + <span class="number">1</span>].first);</span><br><span class="line">            inner.second = <span class="built_in">min</span>(inner.second, seg[rr + <span class="number">1</span>].second);</span><br><span class="line">        &#125;</span><br><span class="line">        outer.first = <span class="built_in">max</span>(outer.first, seg[ll - <span class="number">1</span>].first);</span><br><span class="line">        outer.second = <span class="built_in">min</span>(outer.second, seg[ll - <span class="number">1</span>].second);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">            ans[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = al; j &lt;= ar; ++ j)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = sav.first; i &lt;= sav.second; ++ i)</span><br><span class="line">            ans[i][j] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    ans[Ax][Ay] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ii : vec) ans[ii.x][ii.y] = ii.ch - <span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ii : vec)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> xx = ii.x, yy = ii.y;</span><br><span class="line">        <span class="keyword">char</span> now = ii.ch;</span><br><span class="line">        <span class="keyword">if</span> (xx &lt;= sav.second &amp;&amp; xx &gt;= sav.first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> ll, rr;</span><br><span class="line">            <span class="keyword">while</span> (yy &lt; m &amp;&amp; (yy &gt; al || yy + <span class="number">1</span> &lt; al) &amp;&amp; ans[xx][yy + <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                ans[xx][++ yy] = now;</span><br><span class="line">            rr = yy, yy = ii.y;</span><br><span class="line">            <span class="keyword">while</span> (yy &gt; <span class="number">1</span> &amp;&amp; (yy &lt; ar || yy - <span class="number">1</span> &gt; ar) &amp;&amp; ans[xx][yy - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                ans[xx][-- yy] = now;</span><br><span class="line">            ll = yy;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++ xx;</span><br><span class="line">                <span class="keyword">if</span> (xx &gt; n || xx &gt; sav.second) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = ll; j &lt;= rr; ++ j) flag &amp;= ans[xx][j] == <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (flag) <span class="keyword">for</span> (<span class="keyword">int</span> j = ll; j &lt;= rr; ++ j) ans[xx][j] = now;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            xx = ii.x;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                -- xx;</span><br><span class="line">                <span class="keyword">if</span> (xx &lt; <span class="number">1</span> || xx &lt; sav.first) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = ll; j &lt;= rr; ++ j) flag &amp;= ans[xx][j] == <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (flag) <span class="keyword">for</span> (<span class="keyword">int</span> j = ll; j &lt;= rr; ++ j) ans[xx][j] = now;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> uu, dd;</span><br><span class="line">            <span class="keyword">while</span> (xx &lt; n &amp;&amp; (xx &gt; sav.second || xx + <span class="number">1</span> &lt; sav.first) &amp;&amp; ans[xx + <span class="number">1</span>][yy] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                ans[++ xx][yy] = now;</span><br><span class="line">            dd = xx, xx = ii.x;</span><br><span class="line">            <span class="keyword">while</span> (xx &gt; <span class="number">1</span> &amp;&amp; (xx &lt; sav.first || xx - <span class="number">1</span> &gt; sav.second) &amp;&amp; ans[xx - <span class="number">1</span>][yy] == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                ans[-- xx][yy] = now;</span><br><span class="line">            uu = xx;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ++ yy;</span><br><span class="line">                <span class="keyword">if</span> (yy &gt; m) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = uu; i &lt;= dd; ++ i) flag &amp;= ans[i][yy] == <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (flag) <span class="keyword">for</span> (<span class="keyword">int</span> i = uu; i &lt;= dd; ++ i) ans[i][yy] = now;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            yy = ii.y;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                -- yy;</span><br><span class="line">                <span class="keyword">if</span> (yy &lt; <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = uu; i &lt;= dd; ++ i) flag &amp;= ans[i][yy] == <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (flag) <span class="keyword">for</span> (<span class="keyword">int</span> i = uu; i &lt;= dd; ++ i) ans[i][yy] = now;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (ans[i] + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为基本上就是嗯暴力，所以代码也算不上整洁优雅==</p><h2 id="l.-lengths-and-periods">L. Lengths and Periods</h2><blockquote><p>求字符串的临界指数：字符串 w 的子串 t，是由 t 的某个前缀 p 循环 α 次得到：这里的 α 未必是整数；字符串 w 的临界指数就是最大的 α；</p><p>数据范围：|w| ≤ 2e5</p></blockquote><p>参考了<a href="https://blog.csdn.net/m0_37809890/article/details/102944248">一篇博客</a>的介绍，它提到了这个题目不能用<a href="https://vjudge.net/problem/HDU-6661">HDU6661 Acesrc and String Theory</a>的做法来做；有时间研究研究</p><h2 id="m.-managing-difficulties">M. Managing Difficulties</h2><blockquote><p>给一个长度为 n 的数组 a；要求求出这个数组中，满足 i ≤ j ≤ k 并且 <span class="math inline">\(a_k - a_j = a_j - a_i\)</span> 的不同的三元组 (i, j, k) 的数量；有不超过 10 组的测试数据；</p><p>数据范围：3 ≤ n ≤ 2000，1 ≤ <span class="math inline">\(a_i\)</span> ≤ 1e9</p></blockquote><p>另一个签到题：一个第一题一个最后一题…… 好小子，真会照顾人（</p><p>直接暴力是 n³ 的直接暴毙，所以需要优化；这就是常用的套路：暴力两个下标，寻找满足第三个下标的值是否存在，或者存在几个，然后计算个数就可以了；至于记录下标值的数量，显然可以使用稀疏数组 <code>unordered_map</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2060</span>;</span><br><span class="line"><span class="keyword">int</span> n, t, a[N];</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mmp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="number">0</span>); <span class="built_in">cout</span>.tie(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t; <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">auto</span> n1 = n - <span class="number">1</span>;</span><br><span class="line">        longs ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            ++ mmp[a[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            -- mmp[a[i]];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; ++ j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> pos = <span class="number">2</span> * a[i] - a[j];</span><br><span class="line">                ans += mmp[pos];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，你也可以使用其他的思路进行暴力；大抵复杂度都是平方等级的。</p><h2 id="后记">后记</h2><p>菜的扣脚…… 不会做题就算了，甚至还不会补题 == 我爬我爬（</p><figure><img src="https://i.loli.net/2020/05/31/2bhikTmApvfCswE.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/05/31/2bhikTmApvfCswE.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="3dfecf7637dcd426.jpg" /><figcaption aria-hidden="true">3dfecf7637dcd426.jpg</figcaption></figure><p>你已经是一个成熟的题目了，应该学会自动 AC 了 ==</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Codeforces </tag>
            
            <tag> Gym </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校队训练：个人训练 - 第 1 周</title>
      <link href="/2020/icpc-team-personal-training-1/"/>
      <url>/2020/icpc-team-personal-training-1/</url>
      
        <content type="html"><![CDATA[<p>因为摸鱼的原因，搞到现在才整理好总结…… 至少现在，尽量地把每次训练内容和成果进行总结吧。之后的个人训练就采取先随机题部分题解，后专题板子的顺序来讲解内容好了；希望人没事，希望一个月后我还活在校队里（</p><h2 id="随机练习">随机练习</h2><p>随机练习题是 Codeforces 往届的一些比赛题目，都是 div2 的；用群内巨佬神犇的话说就是没有算法的算法题。</p><h3 id="cf1236e-alice-and-the-unfair-game">CF1236E <a href="https://vjudge.net/problem/CodeForces-1236E">Alice and the Unfair Game</a></h3><blockquote><p>1 个小球，n 个盒子，m 次操作；每次操作询问 a[i] 盒子里有没有小球，若有则输；为了赢，你在每一次操作之前可以将小球从当前位置移到相邻的盒子中，在所有询问结束后还可以移动一次；</p><p>现在规定小球开始位置为 x，结束位置为 y，不同的 (x, y) 为不同的状态；问所有可能使得你胜利的状态数。</p><p>数据范围：n, m ≤ 1e5</p></blockquote><h4 id="分析">分析</h4><p>显然，从某个点出发可以到达的终点构成了一个连续的区间；所以，问题转化成从起点出发最远可达的左右端点；显然找到某一个方向的端点应该尽可能的向该方向移动，但是当向某方向前进时，会因为当前位置冲突（将要移动的目标位置将会被询问）而停止一格；</p><p>这样停留之后，相当于它反方向一格的那个格子移动过来但是没有停，所以可以直接转移过来：统计 X[i] 表示向某方向行走的时候，因障碍止步的次数；这样转移方程就可以写成 <code>X[i] = X[i±1] + 1</code>；</p><p>实际的统计方法：可以倒过来统计；设我们现在要求从起点 i 开始向右到达的最远距离，向右走会因为障碍中断 X[i] 次，那么最远可以到达的距离就是 <code>i + (1 + m) - X[i]</code>；因为是倒过来统计，所有的障碍数组的初值是 0：当遇到了 a[i] 阻碍的时候，显然，我们要为 XR[ a[i] - i ] 增加一个障碍；根据上面的讨论，这个转移关系始终成立，所以只要按照上面的转移方程进行转移就可以了。</p><p>实现上有一些策略：可以开三倍数组考虑偏移，这样不仅解决了边界问题，且因为统计的时候并不会访问这些实际不存在的盒子，所以不会对答案造成什么影响。因为是逆推，所以也不需要考虑开始的障碍：等到考虑它们的时候，它们也会使用转移方程对于相关位置进行更新。</p><p>在统计的时候，因为数组使用了偏移，需要保证边界不超过实际存在的边界。</p><h4 id="代码">代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> off = <span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], lb[<span class="number">3</span> * N], rb[<span class="number">3</span> * N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= <span class="number">1</span>; -- i)</span><br><span class="line">        &#123;</span><br><span class="line">            rb[off + a[i] - i] = rb[off + a[i] - i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            lb[off + a[i] + i] = lb[off + a[i] + i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        longs cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            cnt += <span class="built_in">min</span>(n, i + (m + <span class="number">1</span>) - rb[off + i]) - <span class="built_in">max</span>(<span class="number">1</span>, i - (m + <span class="number">1</span>) + lb[off + i]) + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="附录">附录</h4><p>这个题目如果在 Google 中查的话，还可以找到一种申必的权值线段树的做法。</p><h3 id="cf1355f-guess-divisors-count">CF1355F <a href="https://vjudge.net/problem/CodeForces-1355F">Guess Divisors Count</a></h3><blockquote><p>这是一个交互题：有一个正整数 X，你可以询问 Q，交互机器返回 gcd(Q, X)；要求在不超过 22 次询问之内，求出 X 的约数个数；只要你的猜测 a' 和实际答案满足下面两个关系的任一个就算正确：</p><ul><li><span class="math inline">\(|a - a&#39;| \leq 7\)</span></li><li><span class="math inline">\(\frac 1 2 \leq \frac a {a&#39;} \leq 2\)</span></li></ul><p>数字 X 不大于 1e9，你询问的数字 Q 不大于 1e18；</p></blockquote><h4 id="分析-1">分析</h4><p>首先，任何一个数可以按照下面的形式被唯一分解：</p><p><span class="math display">\[x = p_1^{a_1}p_2^{a_2}...p_n^{a_n}\]</span></p><p>公式中，n 是这个数字的质因数数目，<span class="math inline">\(p_i\)</span> 表示质因数，<span class="math inline">\(a_i\)</span> 表示质因数的幂次，是一个正整数。显然，这样的一个数的约数数目可以表示为：</p><p><span class="math display">\[\sigma_0(x) = Π_{i=1}^n (1 + a_i)\]</span></p><p>这也很容易证明，这样我们就可以想到询问的思路：</p><h5 id="第一层每次询问-π-p_ia_i-leq-1018且-p_ia_i1-geq-109">第一层：每次询问 <span class="math inline">\(Π p_i^{a_i} \leq 10^{18}\)</span>，且 <span class="math inline">\(p_i^{a_i+1} \geq 10^9\)</span></h5><p>这样的好处是一定可以询问出准确的约数个数——根据唯一分解定理；但是缺点就是不可能在22次之内询问结束；也就是说，仅仅凭借22次询问是不可能得到约数的准确值的。</p><h5 id="第二层考虑容错机制压缩询问次数">第二层：考虑容错机制，压缩询问次数</h5><p>既然不能做到准确的询问，那么就想办法减少询问的次数，省去不必要的询问（比如上面方法会导致大量的 1）。减少询问的思路显然是压缩对于每一个质数的幂次，让更多的素数可以压缩再一次询问中。</p><p>然后，显而易见地，我们可以找到的答案 out 一定会比真实的答案小：因为答案的误差只会来自于对部分情况的未考虑；所以，为了保证最优的状况，输出答案时可以按照 2out 输出，可以覆盖的真实答案的范围就扩展到了 [out, 4out]，更有利。</p><p>接下来，观察唯一分解定理，上面得到的 4 倍误差可以被表示为真实答案的唯一分解式中的 (1 + 1)(1 + 1) 或者 (1 + 3)；也就是说，允许两个幂次为 1 的质数没有被考虑，或者是 1 个幂次不超过 3 的质数没有被考虑；前者一定处于 <span class="math inline">\([\sqrt{10^9}, 10^9]\)</span> 的范围之内，且最多出现一个；后者一定出现在 <span class="math inline">\([ \sqrt[3]{10^9}, \sqrt{10^9} ]\)</span> 区间内，且最多出现一个；</p><p>还有没有什么可以优化的地方呢？假设我们从 2 开始尝试质数，尝试到了第 n 个质数，已经确定的约数乘积为 w 的时候：当满足 <span class="math inline">\(wp_{n+1}p_{n+2}p_{n+3} \geq 10^9\)</span> 时，就已经满足了容错规定的情况了；此外，当找到的答案比较小，或者确定答案不会很大的时候（比如没有小因数），可以直接输出 8，当实际答案在 [1, 15] 范围内都可通过。</p><h5 id="第三层实现">第三层：实现</h5><p>虽然讲踢人提供了这些思路，但是也没说一个具体的实现过程；所以最后我就直接去看的题解了。</p><h4 id="代码-1">代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ask cout&lt;&lt;<span class="meta-string">&quot;? &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chk cout&lt;&lt;<span class="meta-string">&quot;! &quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> n&gt; <span class="function"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="title">EulerSieve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> prime[n + <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">bool</span> vis[n + <span class="number">5</span>] &#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> &amp;cnt = prime[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) prime[++ cnt] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cnt &amp;&amp; (longs)i * prime[j] &lt;= n; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prime;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">triple</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> p, a;</span><br><span class="line">    longs v;</span><br><span class="line"></span><br><span class="line">    triple(<span class="keyword">int</span> p, <span class="keyword">int</span> a, longs v) : p(p), a(a), v(v) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> triple &amp;rhs) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == rhs.a) <span class="keyword">return</span> v &gt; rhs.v;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> a &lt; rhs.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    longs response, ans;</span><br><span class="line">    <span class="keyword">auto</span> p = EulerSieve&lt;<span class="number">31623</span>&gt;();</span><br><span class="line">    <span class="keyword">auto</span> cnt = p[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;triple&gt; pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i)</span><br><span class="line">            pq.push(&#123;p[i], <span class="number">1</span>, p[i]&#125;);</span><br><span class="line">        <span class="built_in">vector</span>&lt;triple&gt; used; ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">22</span>; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            used.<span class="built_in">clear</span>();</span><br><span class="line">            longs query = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (!pq.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> &amp;front = pq.top();</span><br><span class="line">                <span class="keyword">if</span> ((<span class="keyword">double</span>)query * front.v &gt; <span class="number">1e18</span>) <span class="keyword">break</span>;</span><br><span class="line">                used.push_back(front);</span><br><span class="line">                query *= front.v; pq.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            ask &lt;&lt; query &lt;&lt; <span class="built_in">endl</span>; <span class="built_in">cin</span> &gt;&gt; response;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ii : used) <span class="keyword">if</span> (response % ii.v == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans = (ans / ii.a) * ++ ii.a;</span><br><span class="line">                    ii.v *= ii.p; pq.push(ii);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        chk &lt;&lt; ans * <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> 校队 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>校队总结：树上分治</title>
      <link href="/2020/icpc-team-tree-divisor-and-conquer/"/>
      <url>/2020/icpc-team-tree-divisor-and-conquer/</url>
      
        <content type="html"><![CDATA[<p>树上分治主要是针对于树上路径问题的，一种使用分治思想解决的方法。主要分为树分治（树上点分治、边分治）以及动态树分治两个部分。</p><h2 id="点分治">点分治</h2><p>适合处理大规模的树上路径信息问题。</p><h3 id="例题">例题</h3><blockquote>#####<center><a href="https://www.luogu.com.cn/problem/P3806">luogu P3806【模板】点分治 1</a></center><p>给定一颗 n 个点的带点权树，m 次询问，每次询问给出 k，询问树上距离为 k 的点对是否存在。</p><p>n ≤ 1e5，m ≤ 100，k ≤ 1e9</p></blockquote><p>先随意选择一个节点作为根节点 rt：这样，所有完全位于其子树中的路径可以分为两种—— 一种是经过当前根节点的路径，一种是不经过当前根节点的路径；对于经过当前根节点的路径，又可以分为两种，一种是以根节点为一个端点的路径，另一种是两个端点都不为根节点的路径；而后者又可以由两条属于前者链合并得到。</p><p>因此，对于枚举的根节点 rt ：我们可以先计算在其子树中且经过该节点的路径对答案的贡献，再递归其子树对不经过该节点的路径进行求解。</p><p>对于这个题目，对于经过根节点 rt 的路径，我们先枚举其所有子节点 ch ，以 ch 为根计算 ch 子树中所有节点到 rt 的距离。记节点 i 到当前根节点 rt 的距离为 <span class="math inline">\(d_i\)</span> ， <span class="math inline">\(tf_d\)</span> 表示之前处理过的子树中是否存在一个节点 v 使得 <span class="math inline">\(d_i\)</span> = d 。若一个询问的 k 满足 <span class="math inline">\(tf_{k-d_i}\)</span> = true ，则存在一条长度为 k 的路径。在计算完 ch 子树中所连的边能否成为答案后，我们将这些新的距离加入 tf 数组中。</p><p>一般来说，清空 tf 数组不应使用 <code>memset</code>，这会导致 TLE；正确的做法是将之前使用过的位置加入一个数组中，清空的时候使用这个数里的记录值清空，才可以保证时间复杂度。</p><p>点分治过程中，每一层的所有递归过程合计对每个点处理一次，假设共递归 h 层，则总时间复杂度为 O(nh)。但是若我们每次选择子树的重心作为根节点，可以保证递归层数最少，时间复杂度为 O(nlogn)。每一次在确定根节点之前统计子树大小，并且找到一个根，使得最大子树大小最小，就找到了重心。</p><p>请注意在重新选择根节点之后一定要重新计算子树的大小，否则一点看似微小的改动就可能会使时间复杂度错误或正确性难以保证。</p><p>例题的代码（来自 OI Wiki）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, a, b, c, q[maxn], rt, siz[maxn], maxx[maxn], dist[maxn];</span><br><span class="line"><span class="keyword">int</span> cur, h[maxn], nxt[maxn], p[maxn], w[maxn];</span><br><span class="line"><span class="keyword">bool</span> tf[<span class="number">10000010</span>], ret[maxn], vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  cur++;</span><br><span class="line">  nxt[cur] = h[x];</span><br><span class="line">  h[x] = cur;</span><br><span class="line">  p[cur] = y;</span><br><span class="line">  w[cur] = z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcsiz</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  siz[x] = <span class="number">1</span>;</span><br><span class="line">  maxx[x] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = h[x]; j; j = nxt[j])</span><br><span class="line">    <span class="keyword">if</span> (p[j] != fa &amp;&amp; !vis[p[j]]) &#123;</span><br><span class="line">      calcsiz(p[j], x);</span><br><span class="line">      maxx[x] = <span class="built_in">max</span>(maxx[x], siz[p[j]]);</span><br><span class="line">      siz[x] += siz[p[j]];</span><br><span class="line">    &#125;</span><br><span class="line">  maxx[x] = <span class="built_in">max</span>(maxx[x], sum - siz[x]);</span><br><span class="line">  <span class="keyword">if</span> (maxx[x] &lt; maxx[rt]) rt = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dd[maxn], cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcdist</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  dd[++cnt] = dist[x];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = h[x]; j; j = nxt[j])</span><br><span class="line">    <span class="keyword">if</span> (p[j] != fa &amp;&amp; !vis[p[j]])</span><br><span class="line">      dist[p[j]] = dist[x] + w[j], calcdist(p[j], x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; tag;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfz</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  tf[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">  tag.push(<span class="number">0</span>);</span><br><span class="line">  vis[x] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = h[x]; j; j = nxt[j])</span><br><span class="line">    <span class="keyword">if</span> (p[j] != fa &amp;&amp; !vis[p[j]]) &#123;</span><br><span class="line">      dist[p[j]] = w[j];</span><br><span class="line">      calcdist(p[j], x);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= cnt; k++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">          <span class="keyword">if</span> (q[i] &gt;= dd[k]) ret[i] |= tf[q[i] - dd[k]];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= cnt; k++) tag.push(dd[k]), tf[dd[k]] = <span class="literal">true</span>;</span><br><span class="line">      cnt = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">while</span> (!tag.empty()) tf[tag.front()] = <span class="literal">false</span>, tag.pop();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = h[x]; j; j = nxt[j])</span><br><span class="line">    <span class="keyword">if</span> (p[j] != fa &amp;&amp; !vis[p[j]]) &#123;</span><br><span class="line">      sum = siz[p[j]];</span><br><span class="line">      rt = <span class="number">0</span>;</span><br><span class="line">      maxx[rt] = inf;</span><br><span class="line">      calcsiz(p[j], x);</span><br><span class="line">      calcsiz(rt, <span class="number">-1</span>);</span><br><span class="line">      dfz(rt, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c), add_edge(a, b, c), add_edge(b, a, c);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, q + i);</span><br><span class="line">  rt = <span class="number">0</span>;</span><br><span class="line">  maxx[rt] = inf;</span><br><span class="line">  sum = n;</span><br><span class="line">  calcsiz(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">  calcsiz(rt, <span class="number">-1</span>);</span><br><span class="line">  dfz(rt, <span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    <span class="keyword">if</span> (ret[i])</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;AYE\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;NAY\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>点分治的经典例题还有这个题目：<a href="https://www.luogu.com.cn/problem/P4178">luogu P4178 Tree</a></p><h3 id="找重心">找重心</h3><p>可以看到，找到正确的重心是保障算法复杂度的关键；首先下定义：一棵树的最大子树最小的点有一个名称，叫做重心；它有一个特点是以它为根的每一个子树的大小都不超过 n/2，这可以使用反证法来证明；正因为重心有这样的特点，所以每一次都选取重心进行递归，可以保障复杂度是 O(nlogn)。</p><p>找到子树也是依靠了这个特性：每次 DFS 整棵树，并且统计最大子树，就可以确定树的重心：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findrt</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> fa)</span></span>&#123; </span><br><span class="line">    sz[u]=<span class="number">1</span>,son[u]=<span class="number">0</span>;<span class="comment">// sz表示子树的大小，son表示点的最大子树的大小</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=Next[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> v=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(vis[v]||v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        findrt(v,u);</span><br><span class="line">        sz[u]+=sz[v];</span><br><span class="line">        son[u]=<span class="built_in">max</span>(son[u],sz[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    son[u]=<span class="built_in">max</span>(son[u],<span class="built_in">size</span>-sz[u]);</span><br><span class="line">    <span class="keyword">if</span>(son[u]&lt;mx) mx=son[u],rt=u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个过程的复杂度是 O(n) 的。</p><h3 id="分治过程">分治过程</h3><p>不同的题目可能具体实现不同，但是大概结构如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    ans+=solve(u,<span class="number">0</span>);<span class="comment">//把当前节点的答案加上去 </span></span><br><span class="line">    vis[u]=<span class="number">1</span>;<span class="comment">//把节点标记，防止陷入死循环 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=Next[i])&#123;  <span class="comment">//分别处理每一棵子树 </span></span><br><span class="line">        <span class="keyword">int</span> v=ver[i];</span><br><span class="line">        <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        ans-=solve(v,edge[i]);</span><br><span class="line">        mx=inf,rt=<span class="number">0</span>,<span class="built_in">size</span>=sz[v];<span class="comment">//把所有信息更新，递归进子树找重心，并继续分治 </span></span><br><span class="line">        findrt(v,<span class="number">0</span>);</span><br><span class="line">        divide(rt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个要提的地方是：在对于子树的 <code>findrt</code> 之前的传递全树大小的位置，直接传递了 <code>sx[v]</code>；实际上这个地方应该传递的是 <code>size=sz[v]&gt;sz[u]?totsz-sz[u]:sz[v]</code>，但是这个错误的写法在这里并不会影响算法的正确性或者复杂度。数学证明可以看这里：<a href="http://liu-cheng-ao.blog.uoj.ac/blog/2969">传送门</a></p><h2 id="动态点分治">动态点分治</h2><p>上面的点分治只可以处理静态的问题，如果问题是动态的，也就是要求待修改状态的话，上面的方法就不能直接使用了；对于动态点分治问题来说，修改的只有点权值，整棵树的结构是不变的——这意味着我们每一次进行点分时选到的重心也是不变的；又因为遍历连通块是 O(n) 的，点分治的复杂度仅和上述的递归深度相关。</p><p>“树上的动态点分治相当于序列上的线段树”</p><h3 id="点分树">点分树</h3><p>简单的说，把上面说的点分治里每一层找到的重心之间连边，就构成了一颗高度为 logn 树，也就是点分树。</p><p>官方的说，就是通过更改原树形态使树的层数变为稳定 logn 的一种重构树；是点分治过程中选择的分治中心点构成的树形结构；常用于解决与树原形态无关的带修改问题，也就是上面说的那种动态问题。</p><p>得到点分树，就可以通过点分治每次找重心的方式来对原树进行重构：将每次找到的重心与上一层的重心缔结父子关系，这样就可以形成一棵 logn 层的树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator IT;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> to, nxt, val;</span><br><span class="line"></span><br><span class="line">  Edge() &#123;&#125;</span><br><span class="line">  Edge(<span class="keyword">int</span> to, <span class="keyword">int</span> nxt, <span class="keyword">int</span> val) : to(to), nxt(nxt), val(val) &#123;&#125;</span><br><span class="line">&#125; e[<span class="number">300010</span>];</span><br><span class="line"><span class="keyword">int</span> head[<span class="number">150010</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  e[++cnt] = Edge(v, head[u], val);</span><br><span class="line">  head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> siz[<span class="number">150010</span>], son[<span class="number">150010</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">150010</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> tot, lasttot;</span><br><span class="line"><span class="keyword">int</span> maxp, root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getG</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">  siz[now] = <span class="number">1</span>;</span><br><span class="line">  son[now] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[now]; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> vs = e[i].to;</span><br><span class="line">    <span class="keyword">if</span> (vs == fa || vis[vs]) <span class="keyword">continue</span>;</span><br><span class="line">    getG(vs, now);</span><br><span class="line">    siz[now] += siz[vs];</span><br><span class="line">    son[now] = <span class="built_in">max</span>(son[now], siz[vs]);</span><br><span class="line">  &#125;</span><br><span class="line">  son[now] = <span class="built_in">max</span>(son[now], tot - siz[now]);</span><br><span class="line">  <span class="keyword">if</span> (son[now] &lt; maxp) &#123;</span><br><span class="line">    maxp = son[now];</span><br><span class="line">    root = now;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> fa;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; anc;</span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; child;</span><br><span class="line">&#125; nd[<span class="number">150010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> ntot)</span> </span>&#123;</span><br><span class="line">  tot = ntot;</span><br><span class="line">  maxp = <span class="number">0x7f7f7f7f</span>;</span><br><span class="line">  getG(now, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">int</span> g = root;</span><br><span class="line">  vis[g] = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = head[g]; i; i = e[i].nxt) &#123;</span><br><span class="line">    <span class="keyword">int</span> vs = e[i].to;</span><br><span class="line">    <span class="keyword">if</span> (vis[vs]) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = build(vs, ntot - son[vs]);</span><br><span class="line">    nd[tmp].fa = now;</span><br><span class="line">    nd[now].child.push_back(tmp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> virtroot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> u, v, val;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; val;</span><br><span class="line">    addedge(u, v, val);</span><br><span class="line">    addedge(v, u, val);</span><br><span class="line">  &#125;</span><br><span class="line">  virtroot = build(<span class="number">1</span>, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个技巧：每次用递归上一层的总大小 tot 减去上一层的点的重儿子大小，得到的就是这一层的总大小。这样求重心就只需一次 DFS 了；</p><h3 id="实现修改">实现修改</h3><p>在查询和修改的时候，我们在点分树上暴力跳父亲修改；由于点分树的深度最多是 O(nlogn) 的，这样做复杂度能得到保证。</p><p>在动态点分治的过程中，需要一个结点到其点分树上的祖先的距离等其他信息，由于一个点最多有 logn 个祖先，我们可以在计算点分树时额外计算深度或使用 LCA，预处理出这些距离或实现实时查询；因为一个结点到其点分树上的祖先的距离不一定递增，所以不能累加；除此之外，一个结点在其点分树上的祖先结点的信息中可能会被重复计算：此时我们需要消去重复部分的影响。一般的方法是对于一个连通块用两种方式记录：一个是其到分治中心的距离信息，另一个是其到点分树上分治中心父亲的距离信息。</p><h3 id="例题-1">例题</h3><blockquote>#####<center><a href="https://www.luogu.com.cn/problem/P2056">「ZJOI2007」捉迷藏</a></center><p>给定一棵有 n 个结点的树，初始时所有结点都是黑色的。你需要实现以下两种操作：</p><ol type="1"><li>反转一个结点的颜色（白变黑，黑变白）；</li><li>询问树上两个最远的黑点的距离；</li></ol><p>数据范围：n ≤ 1e5，m ≤ 5e5</p></blockquote><p>求出点分树，对于每个结点 维护两个可删堆<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>。 dist[x] 存储结点 x 代表的连通块中的所有黑点到 x 的距离信息， ch[x] 表示结点 x 在点分树上的所有儿子和它自己中的黑点到 x 的距离信息；由于本题贪心的求答案方法，且两个来自于同一子树的路径不能成为一条完成的路径，我们只在这个堆中插入其自己的值和其每个子树中的最大值；我们发现， ch[x] 中最大的两个值（如果没有两个就是所有值）的和就是分治时分支中心为 x 时经过结点 x 的最长黑端点路径。我们可以用可删堆 ans 存储所有结点的答案，这个堆中的最大值就是我们所求的答案。</p><p>我们可以根据上面的定义维护 dist[], ch[], ans 这三个可删堆：当 dist[x] 中的值发生变化时，我们也可以在 O(logn) 的时间复杂度内维护 ch[x] 和 ans。</p><p>现在我们来看一下，当我们反转一个点的颜色时， dist[x] 值会发生怎样的改变：当结点原来是黑色时，我们要进行的是删除操作；当结点原来是白色时，我们要进行的是插入操作；假如我们要反转结点 x 的颜色。对于其所有祖先 u，我们在 dist[u] 中插入或删除 dist(x, u)，并同时维护 ch[x] 和 ans 的值；特别的，我们要在 ch[x] 中插入或删除值 0。</p><p>分治树深度 logn，堆操作时间复杂度是l O(logn)，总时间复杂度是 O(nlog²n)；</p><p>例题的代码（来自 OI Wiki）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">2e9</span>;</span><br><span class="line"><span class="keyword">int</span> n, a, b, m, x, col[maxn];</span><br><span class="line"><span class="comment">// 0 off 1 on</span></span><br><span class="line"><span class="keyword">char</span> op;</span><br><span class="line"><span class="keyword">int</span> cur, h[maxn * <span class="number">2</span>], nxt[maxn * <span class="number">2</span>], p[maxn * <span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  cur++;</span><br><span class="line">  nxt[cur] = h[x];</span><br><span class="line">  h[x] = cur;</span><br><span class="line">  p[cur] = y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> rt, sum, siz[maxn], maxx[maxn], fa[maxn], dep[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calcsiz</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">  siz[x] = <span class="number">1</span>;</span><br><span class="line">  maxx[x] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = h[x]; j; j = nxt[j])</span><br><span class="line">    <span class="keyword">if</span> (p[j] != f &amp;&amp; !vis[p[j]]) &#123;</span><br><span class="line">      calcsiz(p[j], x);</span><br><span class="line">      siz[x] += siz[p[j]];</span><br><span class="line">      maxx[x] = <span class="built_in">max</span>(maxx[x], siz[p[j]]);</span><br><span class="line">    &#125;</span><br><span class="line">  maxx[x] = <span class="built_in">max</span>(maxx[x], sum - siz[x]);</span><br><span class="line">  <span class="keyword">if</span> (maxx[x] &lt; maxx[rt]) rt = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">heap</span> &#123;</span></span><br><span class="line">  <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; A, B;  <span class="comment">// heap=A-B</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; A.push(x); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; B.push(x); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!B.empty() &amp;&amp; A.top() == B.top()) A.pop(), B.pop();</span><br><span class="line">    <span class="keyword">return</span> A.top();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!B.empty() &amp;&amp; A.top() == B.top()) A.pop(), B.pop();</span><br><span class="line">    A.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">top2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = top(), ret;</span><br><span class="line">    pop();</span><br><span class="line">    ret = top();</span><br><span class="line">    A.push(t);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> A.<span class="built_in">size</span>() - B.<span class="built_in">size</span>(); &#125;</span><br><span class="line">&#125; dist[maxn], ch[maxn], ans;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f, <span class="keyword">int</span> d, heap&amp; y)</span> </span>&#123;</span><br><span class="line">  y.insert(d);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = h[x]; j; j = nxt[j])</span><br><span class="line">    <span class="keyword">if</span> (p[j] != f &amp;&amp; !vis[p[j]]) dfs(p[j], x, d + <span class="number">1</span>, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  vis[x] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = h[x]; j; j = nxt[j])</span><br><span class="line">    <span class="keyword">if</span> (!vis[p[j]]) &#123;</span><br><span class="line">      rt = <span class="number">0</span>;</span><br><span class="line">      maxx[rt] = inf;</span><br><span class="line">      sum = siz[p[j]];</span><br><span class="line">      calcsiz(p[j], <span class="number">-1</span>);</span><br><span class="line">      calcsiz(rt, <span class="number">-1</span>);</span><br><span class="line">      fa[rt] = x;</span><br><span class="line">      dfs(p[j], <span class="number">-1</span>, <span class="number">1</span>, dist[rt]);</span><br><span class="line">      ch[x].insert(dist[rt].top());</span><br><span class="line">      dep[rt] = dep[x] + <span class="number">1</span>;</span><br><span class="line">      pre(rt);</span><br><span class="line">    &#125;</span><br><span class="line">  ch[x].insert(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (ch[x].<span class="built_in">size</span>() &gt;= <span class="number">2</span>)</span><br><span class="line">    ans.insert(ch[x].top() + ch[x].top2());</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (ch[x].<span class="built_in">size</span>())</span><br><span class="line">    ans.insert(ch[x].top());</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LCA</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> dep[maxn], lg[maxn], fa[maxn][<span class="number">20</span>];</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = h[x]; j; j = nxt[j])</span><br><span class="line">      <span class="keyword">if</span> (p[j] != f) dep[p[j]] = dep[x] + <span class="number">1</span>, fa[p[j]][<span class="number">0</span>] = x, dfs(p[j], x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) lg[i] = lg[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= lg[n]; j++)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i][j] = fa[fa[i][j - <span class="number">1</span>]][j - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[x] &gt; dep[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">int</span> k = dep[y] - dep[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; k; k = k / <span class="number">2</span>, i++)</span><br><span class="line">      <span class="keyword">if</span> (k &amp; <span class="number">1</span>) y = fa[y][i];</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    k = dep[x];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lg[k]; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">      <span class="keyword">if</span> (fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i];</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">dist</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> dep[x] + dep[y] - <span class="number">2</span> * dep[query(x, y)]; &#125;</span><br><span class="line">&#125; lca;</span><br><span class="line"><span class="keyword">int</span> d[maxn][<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b), add_edge(a, b), add_edge(b, a);</span><br><span class="line">  lca.init();</span><br><span class="line">  rt = <span class="number">0</span>;</span><br><span class="line">  maxx[rt] = inf;</span><br><span class="line">  sum = n;</span><br><span class="line">  calcsiz(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">  calcsiz(rt, <span class="number">-1</span>);</span><br><span class="line">  pre(rt);</span><br><span class="line">  <span class="comment">// for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,fa[i]);printf(&quot;\n&quot;);</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j; j = fa[j]) d[i][dep[i] - dep[j]] = lca.dist(i, j);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">  <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot; %c&quot;</span>, &amp;op);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="string">&#x27;G&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ans.<span class="built_in">size</span>())</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans.top());</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">      <span class="keyword">if</span> (!col[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch[x].<span class="built_in">size</span>() &gt;= <span class="number">2</span>) ans.erase(ch[x].top() + ch[x].top2());</span><br><span class="line">        ch[x].erase(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ch[x].<span class="built_in">size</span>() &gt;= <span class="number">2</span>) ans.insert(ch[x].top() + ch[x].top2());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; fa[i]; i = fa[i]) &#123;</span><br><span class="line">          <span class="keyword">if</span> (ch[fa[i]].<span class="built_in">size</span>() &gt;= <span class="number">2</span>)</span><br><span class="line">            ans.erase(ch[fa[i]].top() + ch[fa[i]].top2());</span><br><span class="line">          ch[fa[i]].erase(dist[i].top());</span><br><span class="line">          dist[i].erase(d[x][dep[x] - dep[fa[i]]]);</span><br><span class="line">          <span class="keyword">if</span> (dist[i].<span class="built_in">size</span>()) ch[fa[i]].insert(dist[i].top());</span><br><span class="line">          <span class="keyword">if</span> (ch[fa[i]].<span class="built_in">size</span>() &gt;= <span class="number">2</span>)</span><br><span class="line">            ans.insert(ch[fa[i]].top() + ch[fa[i]].top2());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch[x].<span class="built_in">size</span>() &gt;= <span class="number">2</span>) ans.erase(ch[x].top() + ch[x].top2());</span><br><span class="line">        ch[x].insert(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (ch[x].<span class="built_in">size</span>() &gt;= <span class="number">2</span>) ans.insert(ch[x].top() + ch[x].top2());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x; fa[i]; i = fa[i]) &#123;</span><br><span class="line">          <span class="keyword">if</span> (ch[fa[i]].<span class="built_in">size</span>() &gt;= <span class="number">2</span>)</span><br><span class="line">            ans.erase(ch[fa[i]].top() + ch[fa[i]].top2());</span><br><span class="line">          <span class="keyword">if</span> (dist[i].<span class="built_in">size</span>()) ch[fa[i]].erase(dist[i].top());</span><br><span class="line">          dist[i].insert(d[x][dep[x] - dep[fa[i]]]);</span><br><span class="line">          ch[fa[i]].insert(dist[i].top());</span><br><span class="line">          <span class="keyword">if</span> (ch[fa[i]].<span class="built_in">size</span>() &gt;= <span class="number">2</span>)</span><br><span class="line">            ans.insert(ch[fa[i]].top() + ch[fa[i]].top2());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      col[x] ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个经典的例题：<a href="https://www.luogu.com.cn/problem/P6329">洛谷 P6329 【模板】点分树 | 震波</a></p><h2 id="边分治">边分治</h2><p>边分治和点分治一样属于树分治的一部分，和点分治也有足够的相似之处：选取一条边，将树尽量均匀地分为两个部分；但是相比于点分治，边分治对于与度数相关的问题有着很大的优势，同时边分治也是解决树上最优化问题的一种重要的算法。</p><p>但是这样存在一个问题：当一棵树是有多个大小相近的子树的时候<del>比如菊花图</del>，复杂度就会变差：</p><figure><img src="https://i.loli.net/2020/05/25/eWd2vDwSirVcOug.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/25/eWd2vDwSirVcOug.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="tree-divide1.png" /><figcaption aria-hidden="true">tree-divide1.png</figcaption></figure><center>↑ 菊花图 ↑</center><p>在这种情况下，无论怎么划分复杂度都会变成 O(n²)；考虑到如果根节点的孩子减少的话，就可以缓解这种压力，最优的树型就是二叉树；所以可以重构这颗树，利用插入虚点的方法将一颗多叉树转化为二叉树从而保证分治的复杂度 O(nlogn) ；但是因为插入了 O(n) 个虚点，最多会引入两倍的常数。</p><p>这种重构树的建树方法和线段树的建树很像；新插入的虚点维护的数据可以根据题目要求来确定——比如当统计路径长度时，将原边边权赋为 1, 将新建的边边权赋为 0 即可；几乎所有的点分治的题边分都能做，但是常数上有差距。</p><p>至于分治的过程，和点分治依然是相似的：每次分治时找到一条分治中心边，使这条边两端的两个联通块中较大的一个尽量小；在以分治中心边为界限分开而得到的两个连通块中，统计路径经过分治中心边的答案；然后将分治中心边断开，递归分治中心边两端的两个联通块。</p><h3 id="找中心边">找中心边</h3><p>和点分治非常相似：通过统计一条边的两侧的子树的大小，找到较大的一侧子树大小最小的边；在递归的时候应当将当前的中心边打上删除标记，以避免统计错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">findct</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    siz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = gra[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = gra[i].to;</span><br><span class="line">        <span class="keyword">if</span>(del[i &gt;&gt; <span class="number">1</span>] || v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        findct(v, u);</span><br><span class="line">        siz[u] += siz[v];</span><br><span class="line">        <span class="keyword">int</span> vsiz = <span class="built_in">std</span>::<span class="built_in">max</span>(siz[v], sum - siz[v]);</span><br><span class="line">        <span class="keyword">if</span>(vsiz &lt; ctsiz) &#123;</span><br><span class="line">            ct = i;</span><br><span class="line">            ctsiz = vsiz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的 <code>sum</code> 是调用该函数时设置的当前连通块的大小。</p><h3 id="树重构">树重构</h3><p>重构树的递归过程是：先重构子树，再将重构完成的子树们二分连接到虚点上，效果大概如下图所示：</p><figure><img src="https://i.loli.net/2020/05/25/cCqyZPiLXNgphfI.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/25/cCqyZPiLXNgphfI.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="tree-divide2.png" /><figcaption aria-hidden="true">tree-divide2.png</figcaption></figure><p>下面是一种参考的树重构的实现方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rebuild</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = heado[u]; ~i; i = grao[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = grao[i].to, w = grao[i].w;</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ff) &#123;</span><br><span class="line">            addedge(u, v, w);</span><br><span class="line">            addedge(v, u, w);</span><br><span class="line">            ff = u;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> k = ++n;</span><br><span class="line">            addedge(ff, k, <span class="number">0</span>);</span><br><span class="line">            addedge(k, ff, <span class="number">0</span>);</span><br><span class="line">            addedge(k, v, w);</span><br><span class="line">            addedge(v, k, w);</span><br><span class="line">            ff = k;</span><br><span class="line">        &#125;</span><br><span class="line">        rebuild(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上面的实现并不是边分治中重构树的唯一选择；大可采用其他的实现来完成这项工作。</p><h3 id="例题-2">例题</h3><blockquote>#####<center><a href="https://www.luogu.org/problemnew/show/SP2666">SP2666 QTREE4 - Query on a tree IV</a></center><p>给定一棵 n 个点的带边权的树，点从 1 到 n 编号；每个点可能有两种颜色：黑或白；一开始所有的点都是白色的；定义 dist(a, b) 为 a-b 路径上的权值之和；可以进行操作：</p><ul><li><code>C a</code>：反转 a 点的颜色；</li><li><code>A</code>：查询 dist(a, b) 的最大值，a b 都是白色，且可相同；</li></ul><p>查询时若树上无白色点，输出 <code>They have disappeared.</code>；N, Q ≤ 1e5，边权c ∈ [-1e3, 1e3]。</p></blockquote><p>当然，这个题目也可以使用点分治来做；但是这里使用边分治的方法来解决：在中心边位置维护两个堆，分别表示左右子树的各个白点距离；单独维护每个分治结构的答案，就可以在一个统计最大值的时候顺带把子分治结构的最大值也计算进来，这样询问的时候只需要询问根分支结构的答案即可；</p><p>在加点的的过程中，记录下这个点会影响到的堆的数据：变白要把这个点放进堆里，变黑只需要打标记；在每一次更新答案的时候，从堆顶把黑点全部删除；如果用数组或者 vector 来存的话，这个更新要根据倒序，因为倒序才是分治结构从底向根的顺序。</p><p>参考代码（Code by KSkun, 2018/3）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">fgc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">100000</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">    <span class="keyword">return</span> p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, <span class="number">1</span>, <span class="number">100000</span>, <span class="built_in">stdin</span>), p1 == p2) ? EOF : *p1++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">readint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">register</span> LL res = <span class="number">0</span>, neg = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">char</span> c = fgc();</span><br><span class="line">    <span class="keyword">while</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;-&#x27;</span>) neg = <span class="number">-1</span>;</span><br><span class="line">        c = fgc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        res = res * <span class="number">10</span> + c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        c = fgc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res * neg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isop</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c == <span class="string">&#x27;A&#x27;</span> || c == <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">readop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>(!isop(c = fgc()));</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200005</span>, INF = <span class="number">2e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, q, col[MAXN], ans;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, w, nxt;</span><br><span class="line">&#125; gra[MAXN &lt;&lt; <span class="number">1</span>], grao[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAXN], heado[MAXN], ecnt, ecnto;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    gra[ecnt] = Edge &#123;v, w, head[u]&#125;; head[u] = ecnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedgeo</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    grao[ecnto] = Edge &#123;v, w, heado[u]&#125;; heado[u] = ecnto++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rebuild</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = heado[u]; ~i; i = grao[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = grao[i].to, w = grao[i].w;</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ff) &#123;</span><br><span class="line">            addedge(u, v, w);</span><br><span class="line">            addedge(v, u, w);</span><br><span class="line">            ff = u;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> k = ++n;</span><br><span class="line">            col[k] = <span class="number">1</span>;</span><br><span class="line">            addedge(ff, k, <span class="number">0</span>);</span><br><span class="line">            addedge(k, ff, <span class="number">0</span>);</span><br><span class="line">            addedge(k, v, w);</span><br><span class="line">            addedge(v, k, w);</span><br><span class="line">            ff = k;</span><br><span class="line">        &#125;</span><br><span class="line">        rebuild(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> del[MAXN &lt;&lt; <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> ct, ctsiz, sum;</span><br><span class="line"><span class="keyword">int</span> siz[MAXN], msz[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calsiz</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    siz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = gra[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = gra[i].to;</span><br><span class="line">        <span class="keyword">if</span>(del[i &gt;&gt; <span class="number">1</span>] || v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        calsiz(v, u);</span><br><span class="line">        siz[u] += siz[v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">findct</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = gra[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = gra[i].to;</span><br><span class="line">        <span class="keyword">if</span>(del[i &gt;&gt; <span class="number">1</span>] || v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        findct(v, u);</span><br><span class="line">        <span class="keyword">int</span> vsiz = <span class="built_in">std</span>::<span class="built_in">max</span>(siz[v], sum - siz[v]);</span><br><span class="line">        <span class="keyword">if</span>(vsiz &lt; ctsiz) &#123;</span><br><span class="line">            ct = i;</span><br><span class="line">            ctsiz = vsiz;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DisData</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, d;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> DisData &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> d &lt; rhs.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">priority_queue</span>&lt;DisData&gt; s[MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NodeData</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> bel, side, dis;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;NodeData&gt; ndata[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">caldis</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> d, <span class="keyword">int</span> t, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!col[u]) &#123;</span><br><span class="line">        s[t][l].push(DisData &#123;u, d&#125;); ndata[u].push_back(NodeData &#123;t, l, d&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = head[u]; ~i; i = gra[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = gra[i].to, w = gra[i].w;</span><br><span class="line">        <span class="keyword">if</span>(del[i &gt;&gt; <span class="number">1</span>] || v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        caldis(v, u, d + w, t, l);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mx[MAXN], lch[MAXN], rch[MAXN], ctw[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!s[p][<span class="number">0</span>].empty() &amp;&amp; col[s[p][<span class="number">0</span>].top().u]) s[p][<span class="number">0</span>].pop();</span><br><span class="line">    <span class="keyword">while</span>(!s[p][<span class="number">1</span>].empty() &amp;&amp; col[s[p][<span class="number">1</span>].top().u]) s[p][<span class="number">1</span>].pop();</span><br><span class="line">    <span class="keyword">if</span>(s[p][<span class="number">0</span>].empty() || s[p][<span class="number">1</span>].empty()) mx[p] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> mx[p] = s[p][<span class="number">0</span>].top().d + ctw[p] + s[p][<span class="number">1</span>].top().d;</span><br><span class="line">    <span class="keyword">if</span>(lch[p]) mx[p] = <span class="built_in">std</span>::<span class="built_in">max</span>(mx[p], mx[lch[p]]);</span><br><span class="line">    <span class="keyword">if</span>(rch[p]) mx[p] = <span class="built_in">std</span>::<span class="built_in">max</span>(mx[p], mx[rch[p]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    calsiz(u, <span class="number">0</span>);</span><br><span class="line">    ct = <span class="number">-1</span>; ctsiz = INF; sum = siz[u]; findct(u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(ct == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x = gra[ct].to, y = gra[ct ^ <span class="number">1</span>].to;</span><br><span class="line">    del[ct &gt;&gt; <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> t = ++cnt;</span><br><span class="line">    ctw[t] = gra[ct].w;</span><br><span class="line">    caldis(x, <span class="number">0</span>, <span class="number">0</span>, t, <span class="number">0</span>); caldis(y, <span class="number">0</span>, <span class="number">0</span>, t, <span class="number">1</span>);</span><br><span class="line">    lch[t] = divide(x); rch[t] = divide(y); </span><br><span class="line">    update(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setwhite</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = ndata[u].<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        NodeData d = ndata[u][i];</span><br><span class="line">        s[d.bel][d.side].push(DisData &#123;u, d.dis&#125;);</span><br><span class="line">        update(d.bel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">setblack</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = ndata[u].<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        NodeData d = ndata[u][i];</span><br><span class="line">        update(d.bel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ut, vt, wt;</span><br><span class="line"><span class="keyword">char</span> op;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(heado, <span class="number">-1</span>, <span class="keyword">sizeof</span>(heado));</span><br><span class="line">    n = readint();</span><br><span class="line">    <span class="keyword">int</span> white = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ut = readint(); vt = readint(); wt = readint();</span><br><span class="line">        addedgeo(ut, vt, wt);</span><br><span class="line">        addedgeo(vt, ut, wt);</span><br><span class="line">    &#125;</span><br><span class="line">    rebuild(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    divide(<span class="number">1</span>);</span><br><span class="line">    q = readint();</span><br><span class="line">    <span class="keyword">while</span>(q--) &#123;</span><br><span class="line">        op = readop();</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!white) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;They have disappeared.&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(white == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, mx[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ut = readint(); </span><br><span class="line">            col[ut] ^= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(col[ut]) &#123;</span><br><span class="line">                setblack(ut);</span><br><span class="line">                white--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                setwhite(ut);</span><br><span class="line">                white++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不只是这个题目，很多的点分治的问题都可以使用边分治解决，这里就不贴其他题了。</p><h2 id="推荐题目">推荐题目</h2><p>除了文章中出现的讲解了的和没讲解的例题之外，还可以做一做下面这些题目：</p><ul><li><a href="https://www.luogu.org/problemnew/show/P2664#sub">洛谷 P2664 树上游戏</a></li><li><a href="https://www.luogu.com.cn/problem/P3345">洛谷 P3345 [ZJOI2015]幻想乡战略游戏</a></li><li><a href="https://www.luogu.com.cn/problem/P3241">洛谷 P3241 [HNOI2015]开店</a></li></ul><p>推荐的题目参考了网络上的资料。</p><h2 id="参考资料">参考资料</h2><p>因为这篇文章参考了大量其他巨佬神犇的博客和资料，所以基本上没有什么原创性可言；借物表如下：</p><ul><li><a href="https://oi-wiki.org/graph/tree-divide/" class="uri">https://oi-wiki.org/graph/tree-divide/</a></li><li><a href="https://www.cnblogs.com/bztMinamoto/p/9489473.html" class="uri">https://www.cnblogs.com/bztMinamoto/p/9489473.html</a></li><li><a href="https://oi-wiki.org/graph/dynamic-tree-divide/" class="uri">https://oi-wiki.org/graph/dynamic-tree-divide/</a></li><li><a href="https://www.cnblogs.com/HocRiser/p/8505627.html" class="uri">https://www.cnblogs.com/HocRiser/p/8505627.html</a></li><li><a href="https://www.cnblogs.com/Khada-Jhin/p/10154994.html" class="uri">https://www.cnblogs.com/Khada-Jhin/p/10154994.html</a></li><li><a href="https://ksmeow.moe/edge_based_divide_and_conquer/" class="uri">https://ksmeow.moe/edge_based_divide_and_conquer/</a></li></ul><p>都是因为 DDL，理解万岁，理解万岁（</p><section class="footnotes" role="doc-endnotes"><hr /><ol><li id="fn1" role="doc-endnote"><p>比起朴素堆只能删除堆顶元素，还可以删除其他元素；一般是使用一个临时堆存储暂时不在堆顶但是需要删除的元素，当这些元素到达堆顶的时候再一并弹出。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 校队讲义 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> 校队 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程：第 2 次上机实验</title>
      <link href="/2020/class-software-engineering-experiment-2/"/>
      <url>/2020/class-software-engineering-experiment-2/</url>
      
        <content type="html"><![CDATA[<p>下面是这一次的实验要求：</p><blockquote>#####<center>系统建模实验</center><p>一、实验名称：系统建模实验</p><p>二、实验目的</p><ol type="1"><li><p>理解多视角系统建模思想和技术</p></li><li><p>掌握常见UML建模图形。</p></li></ol><p>三、实验内容和要求</p><ol type="1"><li><p>对你使用和熟悉的一个系统进行上下文、结构、行为和交互建模</p></li><li><p>建模不需要是整个系统，重点是建模角度</p></li><li><p>为了方便理解建模结果，给出必要的背景或上下文描述</p></li><li><p>使用用例图+脚本、顺序图、活动图、类图或包图、状态图</p></li></ol></blockquote><h2 id="实验过程">实验过程</h2><p>系统建模是一个开发系统抽象模型的过程，每个模型表示系统的不同方面或角度，其意味着用某种图形符号表示系 统，常见的图形符号基于 UML 。</p><p>UML 建模最主要的五个图是用例图、静态结构、序列图、状态机图和活动图。当然也包含了一些其他的例如数据库表示图，只是使用没有前面五种图常见；下面的内容根据 Java 大作业 todo-list 工程绘制：</p><h3 id="活动图上下文建模">活动图（上下文建模）</h3><p>对于一个任务清单程序，它的基本功能就如下所示：</p><figure><img src="https://i.loli.net/2020/05/24/QauMyGmISjfov8c.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/24/QauMyGmISjfov8c.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="活动图.png" /><figcaption aria-hidden="true">活动图.png</figcaption></figure><p>将这些功能使用 UML 的方法绘制成流程图，那就是活动图了。</p><h3 id="静态结构模型类图">静态结构模型（类图）</h3><p>设计好了功能之后，就要根据设计的功能设计模型了；将程序中的关键概念抽象成类，并梳理之间的关系，就得到了静态结构模型：</p><figure><img src="https://i.loli.net/2020/05/24/jHDqEkyrnpzmfa3.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/24/jHDqEkyrnpzmfa3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="静态结构.png" /><figcaption aria-hidden="true">静态结构.png</figcaption></figure><p>将一些概念进行泛化聚合，就可以得到上图。</p><h3 id="行为模型">行为模型</h3><p>描述行为模型主要有两种图：</p><ul><li><p>数据驱动建模（数据流图）</p><p>UML不支持数据流图。原因是DFD关注的是系统功能而不识别系统对象。然而，因为数据驱动系统在业务中太常用了，所有 UML2.0引入了与数据流图类似的活动图。在UML中也用时序图表示系统处理序列。</p></li><li><p>事件驱动建模（状态图）</p><p>状态图表示系统状态和引起状态改变的事件。状态图不表示系统中的数据流，但可能包括在每一状态在每一状态中所执行运 算的附加信息。</p></li></ul><p>对于 todo-list 程序，总结得到的状态机图可以根据展示的页面的逻辑来划分：</p><figure><img src="https://i.loli.net/2020/05/24/XLTQ7RHlJK6YFmZ.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/24/XLTQ7RHlJK6YFmZ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="状态图.png" /><figcaption aria-hidden="true">状态图.png</figcaption></figure><p>页面分为编辑页面和显示页面，再加上其后的存储进程，就成了这个工程的三个状态。</p><h3 id="交互模型时序图">交互模型（时序图）</h3><p>交互即用户交互，与用户输入输出有关；有可能是正在开发的系统与其他系统之间的或是系统各部分之间的交互。为用户交互建模主要是因为它有助于我们识别用户需求。为系统间的交互建模应将重点放在可能产生的交流问题上。为系统各部分之 间的交互建模有助于我们分析所提出的系统结构能否实现系统所需的功能及其可靠性。</p><p>交互模型在 UML 体系中主要使用两种图来表示：</p><ul><li>用例建模：该方法主要用来为系统与外部参与者（用户或其他系统）之间的交互建模。</li></ul><figure><img src="https://i.loli.net/2020/05/24/Dg2EmFq368NBrns.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/24/Dg2EmFq368NBrns.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="用例图.png" /><figcaption aria-hidden="true">用例图.png</figcaption></figure><p>上面的就是用例图。</p><ul><li><p>时序图：该方法用来为系统各部分之间的交互建模；尽管也包括一些外部因素。</p><figure><img src="https://i.loli.net/2020/05/24/RypuwEf6bKix5QI.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/24/RypuwEf6bKix5QI.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="顺序图.png" /><figcaption aria-hidden="true">顺序图.png</figcaption></figure></li></ul><h2 id="实验总结">实验总结</h2><p>通过这次实验，我理解了多视角系统建模思想和技术，掌握了基本常见的UML建模图形；通过对一个之前工程系统进行上下文、结构、行为和交互建模，更一步加深了对建模的理解。</p>]]></content>
      
      
      <categories>
          
          <category> 课业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课内作业 </tag>
            
            <tag> 实验报告 </tag>
            
            <tag> 软件工程 </tag>
            
            <tag> UML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华东师范大学“游族杯”全国高校程序设计网络挑战赛（2020.5）</title>
      <link href="/2020/ECNU-yoozoo-cup-2020/"/>
      <url>/2020/ECNU-yoozoo-cup-2020/</url>
      
        <content type="html"><![CDATA[<p>——爬就爬，我自己能爬的，我最会爬了</p><p>开始之前先挂上比赛链接，题目下载链接和可能会有的官方题解的链接：</p><p>比赛链接：<a href="https://acm.ecnu.edu.cn/contest/273/" class="uri">https://acm.ecnu.edu.cn/contest/273/</a><br />问题集（PDF）：<a href="https://acm.ecnu.edu.cn/contest/273/statements/">官方下载</a> 或者 <a href="https://cdn.jsdelivr.net/gh/ymd45921/util_assets@master/post/ECNU-Yoozoo-2020/problem.pdf">备份下载</a><br />官方题解：<a href="https://acm.ecnu.edu.cn/drive/s/ew7a4tkAaGWNcXd/download">官方下载</a> 或者 <a href="https://cdn.jsdelivr.net/gh/ymd45921/util_assets@master/post/ECNU-Yoozoo-2020/Solutions.pdf">备份下载</a></p><p>就不说结果了，说了实在是太丢人了</p><figure><img src="https://i.loli.net/2020/05/23/MEU4bTQqKJuRpzV.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/05/23/MEU4bTQqKJuRpzV.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="GW_UNHLLRG6_JNOP_T8I7.jpg" /><figcaption aria-hidden="true">GW_UNHLLRG6_JNOP_T8I7.jpg</figcaption></figure><p>傻逼就傻逼，下面是这次的题目：</p><h2 id="amateur-chess-players">Amateur Chess Players</h2><p>前面哔哔了一堆国际象棋但是结果和国际象棋没有任何关系（</p><blockquote><p>8×8的棋盘上，摆着 n 个白子，m 个黑子；白子先动：操作可以消除一条直线上的所有的子，这个直线可以不是横平竖直对角线；问谁的子先销完。</p></blockquote><p>签到题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m; <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= m) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Quber CC&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cuber QQ&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读错题目属实害人，第一题必然不可能是计算几何。</p><h2 id="binary-string">Binary String</h2><p>这是一个交互题，给人一种既视感感觉在某年区域赛见过差不多的题目：</p><blockquote><p>程序构造了一个长度 n 的二进制字符串，您可以向交互机器发起 1024 次请求，格式如下：</p><ul><li><code>? &lt;binary string shorter than n&gt;</code> ：询问这个字符串是不是程序构造的字符串的<strong>子序列</strong>，是返回 1，否返回 0；如果询问格式不正确将返回 -1 并且 WA。</li><li><code>! &lt;binary string with n bits&gt;</code> ：询问这个字符串是否是程序构造的字符串，交互机器将立刻退出并且返回评测结果。</li></ul><p>交互程序会先输入字符串的长度 n，随后您可以进行询问，并且获得验证：切记您需要预留 1 次请求的机会用来提交答案，也就是询问最多 1023 次。n 小于 1000；</p></blockquote><p>比较有趣，但是题目也不像上次那个交互题那样猜测次数提供了一个指示。</p><p><del>看了题解才发现原来这是所有的题目里官方难度评价最高的一个题目吗（</del></p><p>首先，因为是询问子串，使用二分的方法询问 0 或者是 1 的数量是很容易想到的，因为这两个数量是零和的，所以只需要询问其中一种就可以了；之后就是二进制字符串的一种惯用的猜测方法：向一种数字种插入另一种数字；因为子序列还是遵循了原序列的顺序的，所以可以一直向一个指定的数字的左侧插入另一个数字：这个过程也可以二分的；最后总复杂度是 O(nlogn)；</p><p>具体的说，我们假设有 n 个 0，m 个 1；我们向 0 中插入 1，需要使用这种方法来测试：</p><ul><li>首先，我们将 n 个 0 摆放在一起，这一定是一个正确的子序列；</li><li>然后，我们从左向右遍历 0：在第 1 个 0 的左侧插入 1，这个插入的 1 的数量可以在 [0, m] 中二分；</li><li>找到插入数量 x 之后，尝试在第 1-2 个 0 之间插入 1，在 [0, m-x] 的范围内二分数量；</li><li>直到处理到 m - Σx = 0 或者处理完所有的 0 之后，将剩余的未使用 1 全部补在字符串的末尾；</li></ul><p>这样就可以写出代码了。<del>又是一个读错了题目然后xjb做的题目</del></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代码 RE 了，正在调试中</span><br></pre></td></tr></table></figure><p>事实证明这题目哪里有那么麻烦嘛== 都是读错了题目的锅（</p><h2 id="coronavirus-battle">Coronavirus Battle</h2><p>一个图论题目。</p><blockquote><p>有一个三维空间，其中有 n 个白细胞；病毒总会从 (-x, -y, -z) 的方向进攻：一个白细胞 (x, y, z) 可以存活，只有当存在一个白细胞 (x₀, y₀, z₀)，满足 x₀ ≤ x &amp;&amp; y₀ ≤ y &amp;&amp; z₀ ≤ z 且 x₀ &lt; x || y₀ &lt; y || z₀ &lt; z 成立的时候；如果存在这样的细胞，那么这个细胞去世，其他细胞存活；否则，所有没有保护的细胞都将去世；</p><p>如果所有的白细胞都死了，那么游戏结束；你需要输出在游戏结束前病毒攻击的轮数，并输出一个数列 a：其中 ai 表示第 i 个白细胞存活的轮数。</p><p>输入的数据是白细胞个数 n ≤ 1e5，以及种子 k1，k2：可以用给定的随机数生成器生成这些白细胞的坐标，种子和生成的白细胞位置坐标的范围是 <code>unsigned long long</code> 的。</p></blockquote><h2 id="decay-of-signals">Decay of Signals</h2><blockquote><p>给一颗 n 个节点的无向树，每一个节点上有一个权值 ai，每一条边的长度为 1；假设从节点 u 到节点 v 的最短路，这样定义一条最短路径的“值”： <span class="math display">\[s = \frac {Π_{i=1}^m a_{p_i}} {m}\]</span> m 是这条最短路经过的边数，<span class="math inline">\(p_i\)</span>表示这些边；<span class="math inline">\(a_{p_i}\)</span>表示这些边在这条路径中的终点的权值，即<span class="math inline">\(a_u\)</span>没有被包含在其中；现在要求求出全树中这个 s 值最小的最短路，并且分数形式输出这个 s 值。</p></blockquote><h2 id="even-degree">Even Degree</h2><h2 id="find--type-f--or--type-d">Find / -type f -or -type d</h2><p>所以说为什么要多此一举呢（</p><blockquote><p>给定 n 个字符串，描述了 n 个绝对路径；问在这个文件系统中存在的 *.eoj 文件的数量；</p><p>数据规模：n ≤ 1e5，绝对路径字符串的总长度不会超过 1e6</p></blockquote><h2 id="geralt-of-rivia">Geralt of Rivia</h2><h2 id="heat-pipes">Heat Pipes</h2><blockquote><p>现在有一些温室和热管，热管的作用是保证它所连接的两个温室的温差等于 1 度；现在告诉你温室和热管的布局，要求你设计一种温度设定方法，让这些温室的温度可以覆盖一个区间内所有的温度（整数）。</p><p>一共有 t 组测试数据：每一组包含温室数量 n，热管数量 m，温度区间 [a, b]，以及用来描述热管情况的 m 行，每行包括两个整数，指明热管连接的两个温室。</p><p>数据规模：N ≤ 2000，M ≤ 50000，a ≤ b ≤ n；N, M 指的是所有测试用例的 n, m 的和</p></blockquote><h2 id="idiotic-suffix-array">Idiotic Suffix Array</h2><p>首先你需要了解后缀数组——当然不了解也不是做不了：</p><blockquote><p>给了一个后缀数组的代码，可以用来生成后缀数组 SA；然后告诉你一个长度 n，告诉你一个数组 k，要求构造一个长度为 n 的仅由小写字母构成的字符串，根据它构造出的后缀数组满足 <code>SA[k - 1] == 0</code>；此外这个字符串的所有后缀中，第 k 个后缀的字典序排列最小。</p></blockquote><h2 id="后记">后记</h2>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> EOJ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>厦门大学程序设计大赛月赛（5月，同步赛）</title>
      <link href="/2020/XMU-icpc-month-2020-5/"/>
      <url>/2020/XMU-icpc-month-2020-5/</url>
      
        <content type="html"><![CDATA[<p>按照之前做题目的惯例，在开始之前先摆个链接：</p><p>比赛链接： <a href="https://ac.nowcoder.com/acm/contest/5759#description" class="uri">https://ac.nowcoder.com/acm/contest/5759#description</a></p><p>官方题解： <a href="https://ac.nowcoder.com/discuss/428597?type=101&amp;order=0&amp;pos=4&amp;page=1&amp;channel=-1&amp;source_id=1_101" class="uri">https://ac.nowcoder.com/discuss/428597?type=101&amp;order=0&amp;pos=4&amp;page=1&amp;channel=-1&amp;source_id=1_101</a></p><p><del>至于官方题解，因为不算是公开比赛，所以还没有找到；如果找到了会挂在这里的。</del>已经找到了</p><p>啊这啊这，半个月不做算法题目了，真就什么都不会了呗== 再过几天校队还要再次排位刷人，啊这……</p><figure><img src="https://i.loli.net/2020/05/17/grDuo1bhYOavcZy.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/05/17/grDuo1bhYOavcZy.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Z94XW8MDFSI4NBN_H9H.jpg" /><figcaption aria-hidden="true">Z94XW8MDFSI4NBN_H9H.jpg</figcaption></figure><p>希望人没事== 得赶紧地把空窗期补回来了。</p><p>这次比赛一共有五个题目，但是比赛时长五个小时；从同步赛的榜单来看，除了第一的 AK 爷之外，其他的过题数量都小于 3；这至少证明了这场比赛具有一定的难度<del>不适合萌新从空窗期恢复</del>的性质。</p><p>补完了题感觉就没有那么难了…… 啊这，还是自己太鸡儿菜了；每个思路基本都是有道理的，只不过是真的不会写代码== 吐了吐了，希望能好起来吧（</p><h2 id="环鸽的chong"><a href="https://ac.nowcoder.com/acm/contest/5759/A">环鸽的CHONG</a></h2><blockquote><p>定义“好序列”指的是这个序列存在至少一个元素与这个序列的其他任何元素都不同；</p><p>给定一个长度小于 2e5 的序列，要求判断它的所有子串是否都是“好序列”。</p><p>*原题说是唯一一个元素，但是仔细思考应该还是至少一个元素。</p></blockquote><p>这题整第一个直接把我给读傻了，而且作为第一题有着极高的尝试数== 所以没做出来我人就傻了（</p><p>但是也不能说是毫无思路：一个数字一旦不能使它所在的序列的好序列，那一定是因为它在这个序列中还有一个一样的数字；所以显然需要预处理一个数字左右两端最近的相同数字的位置；接下来考虑这个左右位置的区间 [L, R]：假设这个数字的位置是 M，那么可以确定的是 [L, M] - [M, R] 一定都是好序列。</p><p>这样就可以进行分治：找到了唯一的 M，就可以确保一个端点来自 M 两侧的区间是“好序列”；接下来只需要考虑两个端点都在一侧的区间的情况：此时问题已经被 M 划分成了子问题，可以重复上述方法，直到子串长度为 1；</p><p>两种情况可以特判：若全序列不存在一个唯一的 M，又或者序列中存在连续的区间，那么这个序列一定不是符合要求的序列。这可以在扫描过程中直接判断出来。</p><p>此外，如果从两头出发向中间寻找，最坏情况就是在序列中间找到唯一值，可以证明复杂度是 O(nlogn)。</p><p>这样我们就可以写出 DFS 的分治搜索的代码了。</p><h3 id="我的代码">我的代码</h3><p>根据上面的分析：首先特判，如果发现两个连续的数字直接俯冲；随后标记位置，使用 map 是 O(nlogn) 的，将每一个在区间内无重复的点作为分治点，将区间分为两个区间继续处理，直到区间大小缩为 2；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> longd = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> ulongs = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], pre[N], nex[N];</span><br><span class="line"><span class="keyword">bool</span> cannot = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dcDFS</span><span class="params">(<span class="keyword">int</span> ll, <span class="keyword">int</span> rr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ll &gt;= rr) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">auto</span> ii = ll;</span><br><span class="line">    <span class="keyword">while</span> (ii &lt;= rr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre[ii] &lt; ll &amp;&amp; nex[ii] &gt; rr)</span><br><span class="line">            <span class="keyword">return</span> dcDFS(ll, ii - <span class="number">1</span>) &amp;&amp; dcDFS(ii + <span class="number">1</span>, rr);</span><br><span class="line">        ++ ii;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">0</span>; <span class="keyword">const</span> <span class="keyword">int</span> tail = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">if</span> (a[i] == a[i - <span class="number">1</span>]) cannot = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mp[a[i]])</span><br><span class="line">        &#123;</span><br><span class="line">            pre[i] = mp[a[i]];</span><br><span class="line">            nex[mp[a[i]]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> pre[i] = <span class="number">0</span>;</span><br><span class="line">        mp[a[i]] = i; nex[i] = tail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cannot) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;fuchong&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        cannot = !dcDFS(<span class="number">1</span>, n);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (cannot ? <span class="string">&quot;fuchong&quot;</span> : <span class="string">&quot;chong&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然数字可以很大，但是总数有限，所以还是可以使用 map <del>日常当作稀疏数组使用</del></p><h2 id="环鸽的数列"><a href="https://ac.nowcoder.com/acm/contest/5759/B">环鸽的数列</a></h2><blockquote><p>有一个长度为 n 的数列 a，以及一个无限长的递推数列 F；对于 F &gt; 2，它满足 <span class="math inline">\(F_n = 3F_{n-1} + 2F_{n-2}\)</span>，此外，有<span class="math inline">\(F_1 = 1,\  F_3 = 3\)</span>；对于数列 a，要求实现下列区间操作：</p><ul><li>对于有效区间 [l, r]，对于任意 l ≤ i ≤ r，<span class="math inline">\(a_i\)</span> 加上 <span class="math inline">\(F_{i-l+1}\)</span>；</li><li>对于有效区间 [l, r]，对于任意 l ≤ i ≤ r，对 <span class="math inline">\(a_i\)</span> 求和并且取模；</li></ul><p>要求对于给定的请求序列，输出所有上述第二种请求的结果。</p></blockquote><p>首先，看到是区间操作，大脑第一反应是想到线段树；线段树如果加上了懒惰标记，做乘法或者修改其值，想必也是可以的吧；但是问题是这个题目加上的不是一般值，是一个数列；所以使得这个题目变得麻烦了起来，也就是所谓的“代码量多”；但是虽然这样，本质上还是一个带懒惰标记的线段树上的区间修改。</p><p><del>啊这，但是为什么这题公开赛下 A 的数量最少啊……虽然我也写代码写了好久，那没事了（</del></p><p>首先从递推公式下手：既然是递推公式，肯定有办法写成矩阵方式；首先从给定值的两种情况入手，可以推导出 F₀ = 0；然后经过简单的推导，可以得到下面的两种矩阵表达形式：</p><p><span class="math display">\[\begin {bmatrix}F_{n+1} &amp; 2F_n \\\\F_n &amp; 2F_{n-1} \\\\\end {bmatrix} = \begin {bmatrix}F_n &amp; 2F_{n-1} \\\\F_{n-1} &amp; 2F_{n-2} \\\\\end{bmatrix} \cdot\begin {bmatrix}3 &amp; 2\\\\1 &amp; 0\end {bmatrix}\]</span></p><p>代码里采用的是这一种形式，当然也可以采用下面这种：</p><p><span class="math display">\[\begin {bmatrix}F_{n+1} &amp; F_n \\\\0 &amp; 0 \\\\\end {bmatrix} = \begin {bmatrix}F_n &amp; F_{n-1} \\\\0 &amp; 0 \\\\\end{bmatrix} \cdot\begin {bmatrix}3 &amp; 1\\\\2 &amp; 0\end {bmatrix}\]</span></p><p><del>啊这，这矩阵又不能正常显示，我吐了我吐了== 又得找时间修（这转义就有些离谱==</del></p><p>最后的代码采用的是上述第一种表达式，原因请看下面的分析——第二种也可以用只是会麻烦许多（</p><p>啊等等，别介，这样一来，这个题目是不是不用矩阵乘法也可以？矩阵乘法的意义何在？</p><figure><img src="https://i.loli.net/2020/05/19/ts5Urb3GKAa8HiV.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/05/19/ts5Urb3GKAa8HiV.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1BWR9RSVN472XJIE03LP.jpg" /><figcaption aria-hidden="true">1BWR9RSVN472XJIE03LP.jpg</figcaption></figure><center>↑ 椿姐的凝视 ↑</center><p>啊这，这…… 这不太行——笔者写代码的时候为数不多的已提交代码都是使用了矩阵乘法，所以一定是哪里出现了一些误会；先放着不管我们继续说（</p><p>然后首先预处理一下数列在范围内的值和前缀和，就可以开始构筑线段树部分了；懒惰标记在这里的使用方式是这样子的：首先，线段树建立两个，一个就是标准意义上的线段树，统计了每个区间节点的和，并且叶子节点是具体的数组成员；另外建立一个空的 lazy 树，用来存放一些标记。</p><p>当读取到指令需要加上一个数列的时候（假设需要加上数列的区间是 [l, r]），可以确定的是这个区间的总和会增加 <span class="math inline">\(\sum_{i=1}^{r-l+1} F_i\)</span>，每一个真正的节点加上的值可以通过和 l 的相对定位求出来；为了省事，我们直接这样操作：加上值的时候，在懒惰树上操作，当节点区间被待处理区间完整覆盖的时候，就直接在这个区间上加上这段数列的和（因为已经预处理过，所以可以快速得出），并且在懒惰节点中记录这个节点的首值；</p><p>众所周知，一般的懒惰标记的线段树的区间修改是所有区间加上同一个值——总之是进行同一个操作，然后当需要使用子节点的时候，再将这个操作应用到子节点上；但是因为本次加上的是一个数列，所以这样的操作大概是不可行的（当然，你的懒惰节点也可以是一个数组，记录每一次修改的首值下标，这样也是可以的）；但是现在就体现使用矩阵的优势了：首先，上述矩阵表达式 1 的开始的情况是矩阵 I₂（有的书上将单位矩阵记作 E）；所有的矩阵都是通过乘一个相同的变换矩阵得到的，记变换矩阵为 B，则整个矩阵序列可以看成是 {~, I₂, B, B², B³, ...}，这样即使懒惰标记节点只是记录了这个区间多次修改的矩阵和，使用一个可以容易的计算出的位置偏移（下标做差）得到 B^n，由于矩阵乘法的性质，相乘就可以得到位移过的矩阵的和；</p><p>那么如何修改子节点的值呢？因为矩阵乘法性质，懒惰节点记录的本质是偏移；再加上子区间的大小非常的好求，求出子区间的大小之后乘以偏移就可以得到目标区间的修改值；</p><h3 id="我的代码-1">我的代码</h3><p>使用上述矩阵表达式一，写出的代码是下面这样：可能有一些问题，因为理论上更加亲民的 GNU g++ 14 在线跑出了和本地 CLion C++ 14 不一样的结果，但是一般来说不太行的 clang++ 11 却AC了；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> longd = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> ulongs = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> longs INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> longs mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> n&gt; <span class="class"><span class="keyword">struct</span> <span class="title">matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    longs m[n][n];</span><br><span class="line"></span><br><span class="line">    matrix() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">longs &amp;<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">unsigned</span> i, <span class="keyword">unsigned</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    matrix <span class="keyword">operator</span>+(<span class="keyword">const</span> matrix&lt;n&gt; &amp;rhs) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        matrix&lt;n&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">                res.m[i][j] = (m[i][j] + rhs.m[i][j]) % mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    matrix &amp;<span class="keyword">operator</span>+=(<span class="keyword">const</span> matrix&lt;n&gt; &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">                m[i][j] = (m[i][j] + rhs.m[i][j]) % mod;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    matrix <span class="keyword">operator</span>-(<span class="keyword">const</span> matrix&lt;n&gt; &amp;rhs) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        matrix&lt;n&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">                res.m[i][j] = (m[i][j] - rhs.m[i][j] + mod) % mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    matrix <span class="keyword">operator</span>-=(<span class="keyword">const</span> matrix&lt;n&gt; &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">                m[i][j] = (m[i][j] - rhs.m[i][j] + mod) % mod;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> matrix&lt;n&gt; &amp;rhs) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        matrix&lt;n&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j) res.m[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; ++ k)</span><br><span class="line">                    res.m[i][j] = (res.m[i][j] + m[i][k] * rhs.m[k][j] % mod) % mod;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> mat = matrix&lt;<span class="number">2</span>&gt;;</span><br><span class="line">longs a[N];</span><br><span class="line">mat sum[N], p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p[<span class="number">1</span>](<span class="number">0</span>, <span class="number">0</span>) = p[<span class="number">1</span>](<span class="number">1</span>, <span class="number">1</span>) = <span class="number">1</span>;</span><br><span class="line">    p[<span class="number">1</span>](<span class="number">0</span>, <span class="number">1</span>) = p[<span class="number">1</span>](<span class="number">1</span>, <span class="number">0</span>) = <span class="number">0</span>;</span><br><span class="line">    sum[<span class="number">1</span>] = p[<span class="number">1</span>]; mat xx;</span><br><span class="line">    xx(<span class="number">0</span>, <span class="number">0</span>) = <span class="number">3</span>, xx(<span class="number">0</span>, <span class="number">1</span>) = <span class="number">2</span>, xx(<span class="number">1</span>, <span class="number">0</span>) = <span class="number">1</span>, xx(<span class="number">1</span>, <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * xx;</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + p[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> segTree</span><br><span class="line">&#123;</span><br><span class="line">    mat tree[N &lt;&lt; <span class="number">2</span>], lazy[N &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">upMerge</span><span class="params">(<span class="keyword">unsigned</span> root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tree[root] = tree[root &lt;&lt; <span class="number">1u</span>] + tree[root &lt;&lt; <span class="number">1u</span> ^ <span class="number">1u</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">downSplit</span><span class="params">(<span class="keyword">unsigned</span> root, <span class="keyword">unsigned</span> l, <span class="keyword">unsigned</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> mid = (l + r) &gt;&gt; <span class="number">1u</span>;</span><br><span class="line">        lazy[root &lt;&lt; <span class="number">1u</span>] += lazy[root];</span><br><span class="line">        lazy[root &lt;&lt; <span class="number">1u</span> ^ <span class="number">1u</span>] += lazy[root] * p[mid + <span class="number">2</span> - l];</span><br><span class="line">        tree[root &lt;&lt; <span class="number">1u</span>] += sum[mid - l + <span class="number">1</span>] * lazy[root];</span><br><span class="line">        tree[root &lt;&lt; <span class="number">1u</span> ^ <span class="number">1u</span>] += (sum[r - l + <span class="number">1</span>] - sum[mid - l + <span class="number">1</span>]) * lazy[root];</span><br><span class="line">        <span class="built_in">memset</span>(lazy[root].m, <span class="number">0</span>, <span class="keyword">sizeof</span>(lazy[root].m));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">unsigned</span> root, <span class="keyword">unsigned</span> l, <span class="keyword">unsigned</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(lazy[root].m, <span class="number">0</span>, <span class="keyword">sizeof</span>(lazy[root].m));</span><br><span class="line">        tree[root] = lazy[root];</span><br><span class="line">        <span class="keyword">if</span> (l == r) tree[root](<span class="number">0</span>, <span class="number">0</span>) = a[l];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> mid = (l + r) &gt;&gt; <span class="number">1u</span>;</span><br><span class="line">            build(root &lt;&lt; <span class="number">1u</span>, l, mid);</span><br><span class="line">            build(root &lt;&lt; <span class="number">1u</span> ^ <span class="number">1u</span>, mid + <span class="number">1</span>, r);</span><br><span class="line">            upMerge(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">unsigned</span> root, <span class="keyword">unsigned</span> l, <span class="keyword">unsigned</span> r,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> ll, <span class="keyword">unsigned</span> rr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ll &lt;= l &amp;&amp; r &lt;= rr)</span><br><span class="line">        &#123;</span><br><span class="line">            lazy[root] += p[l - ll + <span class="number">1</span>];</span><br><span class="line">            tree[root] += sum[r - ll + <span class="number">1</span>] - sum[l - ll];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            downSplit(root, l, r);</span><br><span class="line">            <span class="keyword">auto</span> mid = (l + r) &gt;&gt; <span class="number">1u</span>;</span><br><span class="line">            <span class="keyword">if</span> (mid &gt;= ll) update(root &lt;&lt; <span class="number">1u</span>, l, mid, ll, rr);</span><br><span class="line">            <span class="keyword">if</span> (mid &lt; rr) update(root &lt;&lt; <span class="number">1u</span> ^ <span class="number">1u</span>, mid + <span class="number">1</span>, r, ll, rr);</span><br><span class="line">            upMerge(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">longs <span class="title">query</span><span class="params">(<span class="keyword">unsigned</span> root, <span class="keyword">unsigned</span> l, <span class="keyword">unsigned</span> r,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> ll, <span class="keyword">unsigned</span> rr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ll &lt;= l &amp;&amp; r &lt;= rr) <span class="keyword">return</span> tree[root](<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        downSplit(root, l, r);</span><br><span class="line">        <span class="keyword">auto</span> mid = (l + r) &gt;&gt; <span class="number">1u</span>;</span><br><span class="line">        longs ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid &gt;= ll) ans = (ans + query(root &lt;&lt; <span class="number">1u</span>, l, mid, ll, rr)) % mod;</span><br><span class="line">        <span class="keyword">if</span> (mid &lt; rr) ans = (ans + query(root &lt;&lt; <span class="number">1u</span> ^ <span class="number">1u</span>, mid + <span class="number">1</span>, r, ll, rr)) % mod;</span><br><span class="line">        <span class="keyword">return</span> (ans % mod + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    preProcess();</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    segTree::build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> op, ll, rr;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op &gt;&gt; ll &gt;&gt; rr;</span><br><span class="line">        <span class="keyword">if</span> (ll &gt; rr) swap(ll, rr);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) segTree::update(<span class="number">1</span>, <span class="number">1</span>, n, ll, rr);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; segTree::query(<span class="number">1</span>, <span class="number">1</span>, n, ll, rr) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>啊这，线代白给不可取== 果然数学题还是数学一点的好啊；我们来欣赏一下标准答案的说法：</p><ul><li>由特征方程 <span class="math inline">\(\alpha^2 = 3\alpha + 2\)</span> 解出特征根 $=  {2} $；</li><li>使用待定系数法得到通项公式：$ F_n =  {} (( {2})^n + ( {2})^n) $；</li><li>暴力测试得到 17 的二次剩余 473844410，处理两个模意义下的特征根；</li></ul><p>所以可以用两颗线段树维护区间加等比数列、区间求和的操作；懒标记记录首项，应用到区间的时候直接更新为等比数列求和；标记的合并可以直接相加，但是要预处理两个特征根的 1~n 次方。</p><p>所以说矩阵还是不是必须的== 啊这就这（</p><h2 id="环鸽不会x点"><a href="https://ac.nowcoder.com/acm/contest/5759/C">环鸽不会X点</a></h2><p>本轮的签到题；下面是题面：</p><blockquote><p>问一个数 n 能不能和 k 个正偶数和 k 个正奇数的和相等；</p></blockquote><p>最小的正奇数是 1；最小的正偶数是 2；也就是说 k 个正奇数和 k 个正偶数的和一定大于 3k；此外，对任何一个整数加上一个偶数不会改变这个数的奇偶性，所以 n - 3k 必然应当是一个偶数，且大于等于 0；</p><h3 id="我的代码-2">我的代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> longd = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> ulongs = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t, n, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        n -= k;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ((n &gt;= <span class="number">2</span> * k &amp;&amp; n % <span class="number">2</span> == <span class="number">0</span>) ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然实现的和上面分析中所说的不太一致，但是基本就是这么一回事。</p><h2 id="小c的棋王之路"><a href="https://ac.nowcoder.com/acm/contest/5759/D">小C的棋王之路</a></h2><p>这竟然是一个板子题==</p><blockquote><p>首先，有一个大小为 n 的整数数组，记每一个元素为 A[i]；你可以对这个数组进行下面的区间操作：</p><ul><li>将 [l, r] 区间里的数字每一个都加上 k；</li><li>将 [l, r] 区间里的数字每一个都乘以 k；</li><li>将 [l, r] 区间里的数字修改为 k；</li><li>在数组的最后增加一个数字，值为 k；</li></ul><p>除了进行这些操作，还需要在任何时候在线查询一个区间内所有数字的和；此外所有运算在模 p 意义下。</p></blockquote><p>如果使用线段树，那就需要动态开点线段树了；这我不太会 == 但是这个题还可以用另一种简单粗暴的数据结构来解决，也就是这个题目的板子：珂朵莉树（老司机树，ODT）；</p><p>这显然是一个自创的数据结构，但是有点非常的显著：仅仅使用 STL 和简单的代码实现就可以达到一个不错的平均复杂度；但是缺点是这些修改必须是随机的，如果不是随机的话这个数据结构将会退化的很惨；不过参考其他博客的带佬们的说法，似乎一般出题人并不会卡掉这种做法，但是还是有可能所以需要注意；</p><p>ODT，使用 STL set 实现，可以达到复杂度 O(nlog²n)，对于区间修改是一种取巧的数据结构；它使用 set 将每一个节点（区间节点）以及它们的值存储起来：当需要修改一些值的时候，就将已经有的区间拆开，修改后重新插入 set 中；如果需要修改一个区间的值的时候，也只需要将这些区间的节点取出，合并成一个区间并置相同的值，再作为新节点插入到 set 中；查找节点全程使用 <code>lower_bound</code> / <code>upper_bound</code>，所以实现起来基本就和上面的描述那样顺畅<del>所以我超喜欢珂朵莉</del>。</p><p>当然，听了上面的描述，你应该也很容易发现这珂朵莉树其实根本算不上是一棵树：它其实只有一层父子关系，找到对应区间的子节点使用的方法是二分查找；所以想要在这个节点后面加一个新节点也是非常轻松，只需要在 set 的尾部加入新节点就可以了。</p><p>至于初始化 ODT，只需要把所有的数字作为一个单个区间插入 set 就可以了，复杂度 O(nlogn)；啊这完全就是乱搞嘛 == 这要是没有大量的区间设置操作合并区间的话，简直就是直接暴毙的节奏啊（</p><h3 id="我的代码-3">我的代码</h3><p>使用 <code>split</code> 函数拆分节点区间，使用 <code>assign</code> 合并区间节点；仅有区间设置 k 的操作使用了 <code>assign</code>；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> longd = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> ulongs = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ODT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="keyword">mutable</span> T val;</span><br><span class="line"></span><br><span class="line">        node(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">const</span> T &amp;v) : l(l), r(r), val(v) &#123;&#125;</span><br><span class="line">        node(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">const</span> T &amp;&amp;v) : l(l), r(r), val(v) &#123;&#125;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node&lt;T&gt; &amp;rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> l &lt; rhs.l;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> number = longs;</span><br><span class="line">    <span class="keyword">using</span> iter = <span class="built_in">set</span>&lt;node&lt;number&gt;&gt;::iterator;</span><br><span class="line">    <span class="keyword">using</span> func = <span class="keyword">void</span> (*) (iter &amp;, <span class="keyword">void</span> *);</span><br><span class="line">    <span class="built_in">set</span>&lt;node&lt;number&gt;&gt; odt;</span><br><span class="line"></span><br><span class="line">    <span class="function">iter <span class="title">split</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = odt.lower_bound(node&lt;number&gt;(x, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span> (it != odt.<span class="built_in">end</span>() &amp;&amp; it -&gt; l == x) <span class="keyword">return</span> it;</span><br><span class="line">        <span class="keyword">const</span> number v = (-- it) -&gt; val;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> l = it -&gt; l, r = it -&gt; r;</span><br><span class="line">        odt.erase(it);</span><br><span class="line">        odt.insert(node&lt;number&gt;(l, x - <span class="number">1</span>, v));</span><br><span class="line">        <span class="keyword">return</span> odt.insert(node&lt;number&gt;(x, r, v)).first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">assign</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, number v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> rr = split(r + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> ll = split(l);</span><br><span class="line">        odt.erase(ll, rr);</span><br><span class="line">        odt.insert(node&lt;number&gt;(l, r, v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, func todo, <span class="keyword">void</span> *param)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> rr = split(r + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> ll = split(l);</span><br><span class="line">        <span class="keyword">for</span> (; ll != rr; ++ ll) todo(ll, param);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func add = [](iter &amp;it, <span class="keyword">void</span> *para)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> number value = *(number*)para;</span><br><span class="line">        it-&gt;val = (it-&gt;val + value) % p;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    func mul = [](iter &amp;it, <span class="keyword">void</span> *para)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> number value = *(number*)para;</span><br><span class="line">        it-&gt;val = (it-&gt;val * value) % p;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    longs _sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    func sum = [](iter &amp;it, <span class="keyword">void</span> *para)</span><br><span class="line">    &#123;</span><br><span class="line">        _sum = (_sum + it-&gt;val * (it-&gt;r - it-&gt;l + <span class="number">1</span>)) % p;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; p;</span><br><span class="line">    longs x, tail = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        ODT::odt.insert(ODT::node&lt;longs&gt;(i, i, x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> last = ODT::node&lt;longs&gt;(tail, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">    ODT::odt.insert(last);</span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> op, l, r;</span><br><span class="line">        longs k;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">        <span class="keyword">switch</span> (op)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">                ODT::<span class="built_in">run</span>(l, r, ODT::add, &amp;k);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">                ODT::<span class="built_in">run</span>(l, r, ODT::mul, &amp;k);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r &gt;&gt; k;</span><br><span class="line">                ODT::assign(l, r, k);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">                <span class="keyword">auto</span> it = ODT::odt.lower_bound(last);</span><br><span class="line">                ODT::odt.erase(it);</span><br><span class="line">                ODT::odt.insert(ODT::node&lt;longs&gt;(tail, tail, k));</span><br><span class="line">                last = ODT::node&lt;longs&gt;(++ tail, <span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">                ODT::odt.insert(last);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; l &gt;&gt; r;</span><br><span class="line">                ODT::_sum = <span class="number">0</span>;</span><br><span class="line">                ODT::<span class="built_in">run</span>(l, r, ODT::sum, &amp;k);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; ODT::_sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别注意：当<code>switch</code>语句中需要新建变量或者特别长的时候，要使用花括号包覆；</p><h2 id="兰德索尔的瞭望塔"><a href="https://ac.nowcoder.com/acm/contest/5759/E">兰德索尔的瞭望塔</a></h2><p>一个计算几何的题目。</p><blockquote><p>给定了一个二维坐标系，已知原点和 x 坐标轴上的一个确定点；此外，还给了第一象限中的 n 个点；</p><p>现要求你从 n 个点中选出一些点，这些点中的每一个点和 原点 - 确定点 构成三角形，要求形成的三角形是严格的互相嵌套——每个三角形和其他三角形除了 原点 - 确定点 共有之外没有其他任何的公共边或者交点；问最多可以在给定的点集中选出多少点。</p><p>保证给出的第一象限的点不重复（</p></blockquote><p>在这之前：这个题目和之前做过的“汉诺塔拼盘”，“看星星”（只记得大概的题目名字了）很像——包含关系的成立取决于两个维度，需要同时满足才可以包含，寻找包含关系的最大值。</p><p>这种题目满嘴跑火车还是不可取，所以要有图；把题面里给的样例的一张图搬过来：</p><figure><img src="https://i.loli.net/2020/05/20/I3fhEztJuRPMc62.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/20/I3fhEztJuRPMc62.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="999991351_1589784561169_30097379256A480B09E6D5A8DF2B6B26.png" /><figcaption aria-hidden="true">999991351_1589784561169_30097379256A480B09E6D5A8DF2B6B26.png</figcaption></figure><p>因为是共有边 OA，所以如果 △OCA 包含了 △OBA，那么一定有 ∠BOA &lt; ∠COA 和 ∠BAO &lt; ∠CAO 同时成立；如果用斜率来表示，那就是 |k(OC)| &gt; |k(OB)| 和 |k(AC)| &gt; |k(AB)| 同时成立。这两个三角形就在图中可以轻松的看出来，对于一般的两个这样的三角形也一定是这样吧。</p><p>一种最简单的方法就是：因为斜率具有上述的关系，所以可以对于所有在第一象限内的点 X，分别按照 k(OX) 和 k(AX) 进行排序，并对排序得到的两个序列寻找最长公共子序列——显然，这个子序列的长度就是答案；当然，实现的时候也可以只排序一次，并再增长这个序列的时候判定另一个斜率是否符合标准。</p><p>当然，你也可以像<a href="https://ac.nowcoder.com/discuss/428597?type=101&amp;order=0&amp;pos=4&amp;page=1&amp;channel=-1&amp;source_id=1_101">标准答案</a>那样，使用权值线段树来维护以满足要求；具体做法如下：</p><ul><li>所有点按照到原点的极角排序，将另一个角的值排序后离散化</li><li>建立维护最大值的权值线段树，每一个节点维护一个区间内的节点的最大答案</li><li>更新答案时：查找区间节点中的最大值并且单点修改</li></ul><p>需要注意极角相同时的情况；因为感觉太过麻烦这一回就不写这种做法的代码了，请参考官方题解。</p><h3 id="我的代码-4">我的代码</h3><p>根据斜率寻找最长公共子序列：按照 OX 斜率排序后的向量，如果 AX 的斜率更加有优势就更新；直到所有的向量都扫描完之后，整个序列的大小就是答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> longd = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> ulongs = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Geo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> number = <span class="keyword">int</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        number x, y;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">point</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">point</span>(number x, number y) : x(x), y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">point</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> &#123;x + rhs.x, y + rhs.y&#125;; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">point</span> <span class="keyword">operator</span>-(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> &#123;x - rhs.x, y - rhs.y&#125;; &#125;</span><br><span class="line"></span><br><span class="line">        number <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> x * rhs.x + y * rhs.y; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">point</span> <span class="keyword">operator</span>*(<span class="keyword">const</span> number rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> &#123;rhs * x, rhs * y&#125;; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">point</span> <span class="keyword">operator</span>/(<span class="keyword">const</span> number rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> &#123;x / rhs, y / rhs&#125;; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">point</span> &amp;<span class="keyword">operator</span>+=(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs)</span><br><span class="line">        &#123;</span><br><span class="line">            x += rhs.x;</span><br><span class="line">            y += rhs.y;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">point</span> &amp;<span class="keyword">operator</span>-=(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs)</span><br><span class="line">        &#123;</span><br><span class="line">            x -= rhs.x;</span><br><span class="line">            y -= rhs.y;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">point</span> &amp;<span class="keyword">operator</span>*=(<span class="keyword">const</span> number rhs)</span><br><span class="line">        &#123;</span><br><span class="line">            x *= rhs;</span><br><span class="line">            y *= rhs;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">point</span> &amp;<span class="keyword">operator</span>/=(<span class="keyword">const</span> number rhs)</span><br><span class="line">        &#123;</span><br><span class="line">            x /= rhs;</span><br><span class="line">            y /= rhs;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> x == rhs.x &amp;&amp; y == rhs.y; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(rhs == *<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">number <span class="title">dot</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x * rhs.x + y * rhs.y; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">number <span class="title">cross</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> rhs.y * x - rhs.x * y; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">number <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sqrt</span>(dot(*<span class="keyword">this</span>)); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">number <span class="title">distance</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span> &amp;b)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (*<span class="keyword">this</span> - b).length(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">number <span class="title">distance</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span> &amp;ls, <span class="keyword">const</span> <span class="built_in">point</span> &amp;rs)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">fabs</span>((ls - *<span class="keyword">this</span>).cross(rs - *<span class="keyword">this</span>)) / ls.distance(rs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">point</span> <span class="title">normal</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (x || y) ? *<span class="keyword">this</span> / length() : <span class="built_in">point</span>(<span class="number">0</span>, <span class="number">0</span>); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">number <span class="title">angle</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">atan2</span>(y, x); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">point</span> <span class="title">rotate</span><span class="params">(number a)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            number c = <span class="built_in">cos</span>(a), s = <span class="built_in">sin</span>(a);</span><br><span class="line">            <span class="keyword">return</span> &#123;c * x - s * y, s * x + c * y&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">point</span> <span class="title">perpendicular</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> &#123;-y, x&#125;; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="built_in">point</span> <span class="title">symmetry</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> &#123;-x, -y&#125;; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs) <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> ll = <span class="number">1l</span>l * y * rhs.x;</span><br><span class="line">            <span class="keyword">auto</span> rr = <span class="number">1l</span>l * x * rhs.y;</span><br><span class="line">            <span class="keyword">return</span> ll &lt; rr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> <span class="built_in">point</span> &amp;rhs) <span class="keyword">const</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> ll = <span class="number">1l</span>l * y * rhs.x;</span><br><span class="line">            <span class="keyword">auto</span> rr = <span class="number">1l</span>l * x * rhs.y;</span><br><span class="line">            <span class="keyword">return</span> ll &gt; rr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, upto, dp[N];</span><br><span class="line">Geo::<span class="built_in">point</span> p[N], v[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary</span><span class="params">(<span class="keyword">const</span> Geo::<span class="built_in">point</span> &amp;now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ll = <span class="number">1</span>, rr = upto, res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> ii = Geo::<span class="built_in">point</span>(m - now.x, -now.y);</span><br><span class="line">    <span class="keyword">while</span> (ll &lt;= rr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = ll + rr &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (v[mid] &lt; ii) res = mid, ll = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> rr = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> pp = Geo::<span class="built_in">point</span>(m, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; p[i].x &gt;&gt; p[i].y;</span><br><span class="line">        sort(p + <span class="number">1</span>, p + <span class="number">1</span> + n, greater&lt;Geo::<span class="built_in">point</span>&gt;());</span><br><span class="line">        upto = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = binary(p[i]) + <span class="number">1</span>;</span><br><span class="line">            v[dp[i]] = pp - p[i];</span><br><span class="line">            upto = <span class="built_in">max</span>(upto, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; upto &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>binary</code> 函数用来找到斜率可以更新的位置；但是最终 <code>dp</code> 数组内的向量未必可以指示实际选出的点，这点还请多加注意。</p><h2 id="后记">后记</h2><p>虽然做的时候很痛苦，但是补题的时候却没有什么没学过的知识点…… 这不太行== 我已经不会做题力（</p><p>还有一大堆没有做的题目等着我去补，呜呼！</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Nowcoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程：第 1 次上机实验</title>
      <link href="/2020/class-software-engineering-experiment-1/"/>
      <url>/2020/class-software-engineering-experiment-1/</url>
      
        <content type="html"><![CDATA[<p>本次实验的要求如下：</p><blockquote><p><strong>实验名称</strong>： 重构实验</p><p><strong>实验目的</strong>：</p><ol type="1"><li><p>理解重构在软件开发中的作用</p></li><li><p>熟悉常见的代码环味道和重构方法</p></li></ol><p><strong>实验内容和要求</strong>：</p><ol type="1"><li><p>阅读：Martin Fowler 《重构-改善既有代码的设计》</p></li><li><p>掌握你认为最常见的8种代码坏味道及其重构方法</p></li><li><p>从你过去写过的代码或 Github 等开源代码库上寻找这8种坏味道，并对代码进行重构</p></li></ol></blockquote><p>简单的说就是总结出 8 中“坏味道”，并且给出样例；</p><h2 id="重复代码">重复代码</h2><p>它可能出现在下面的三种情况中；每种情况有对应的改正方法：</p><ul><li><p>同一个类的两个函数含有相同的表达式</p><p>建立一个新方法，将重复的代码提取出来，再在重复代码的地方调用这个新方法；</p></li><li><p>同一个互为兄弟的子类内出现</p><p>建立一个新方法提取重复代码，并且将这个新方法放到这两个类的超类中；如果代码只是相似而不完全相同，可以提取成方法，并构建成模板供调用；如果代码完成了相同的功能，但是实现方法不同，则选出较优的那个提取成方法，以供调用。</p></li><li><p>两个毫不相关的类</p><p>创建一个新类，以保存两者共有的代码提取出的方法；</p></li></ul><p>下面的样例说明了在同一个类中的重复代码的重构情况</p><h3 id="实例">实例</h3><p>下面，在某类中有两个需要随机数的地方，需要使用 C++ 随机数生成器得到随机数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function">uniform_real_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">dm</span> <span class="params">(<span class="number">1</span>, <span class="number">65536</span>)</span></span>;</span><br><span class="line">    random_device rd;</span><br><span class="line">    <span class="function">default_random_engine <span class="title">rm</span><span class="params">(rd())</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> seed = dm(rm);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function">uniform_real_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">dm</span> <span class="params">(<span class="number">0</span>, <span class="number">255</span>)</span></span>;</span><br><span class="line">    random_device rd;</span><br><span class="line">    <span class="function">default_random_engine <span class="title">rm</span><span class="params">(rd())</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> r = dm(rm);</span><br><span class="line">    <span class="keyword">auto</span> g = dm(rm);</span><br><span class="line">    <span class="keyword">auto</span> b = dm(rm);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++ 随机数生成器初始化是一个非常麻烦的工作，但是却是一个确定的事情；可以将这些代码提取到一个公共的随机数生成器生成器函数中，用函数生成符合要求的随机数生成器，使得代码更加清晰；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">createRandomMachine</span><span class="params">(<span class="keyword">int</span> lb, <span class="keyword">int</span> rb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lb &gt; rb) swap(lb, rb);</span><br><span class="line">    <span class="function">uniform_real_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">dm</span> <span class="params">(lb, rb)</span></span>;</span><br><span class="line">    random_device rd;</span><br><span class="line">    <span class="function">default_random_engine <span class="title">rm</span><span class="params">(rd())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> [=]()<span class="keyword">mutable</span>&#123;<span class="keyword">return</span> dm(rm);&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">random</span> = createRandomMachine(<span class="number">1</span>, <span class="number">65536</span>);</span><br><span class="line">    <span class="keyword">auto</span> seed = <span class="built_in">random</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">random</span> = createRandomMachine(<span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line">    <span class="keyword">auto</span> r = <span class="built_in">random</span>();</span><br><span class="line">    <span class="keyword">auto</span> g = <span class="built_in">random</span>();</span><br><span class="line">    <span class="keyword">auto</span> b = <span class="built_in">random</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就完成了重构；代码更加的简洁，而且<code>random()</code>的调用方式也符合 C 语言的使用习惯。</p><h2 id="超长函数">超长函数</h2><p>每当需要使用注释说明函数每一步在干什么时，就将需要说明的步骤写进独立函数中，并以其用途命名；根据不同情况，可能需要做到下面的不同的程度：</p><ul><li>一般来说，只需要将代码按照步骤提取成方法就可以了；</li><li>如果有大量参数和临时变量，考虑使用查询替换临时变量；查询时，构造参数对象或保留整个对象可以简化查询函数的参数列表；</li><li>若临时变量/参数仍然很多，可以使用方法对象来代替方法——将方法构成一个新类，保有计算需要的信息，提供一个方法接口来完成函数的工作（比如<code>operator()</code>）；</li></ul><p>对于存在条件表达式和循环的情况，可以分解条件表达式：将循环体、或者时不同的分支提取成为不同的函数；主函数只控制分支流向，每个分支的具体工作交给独立函数完成。</p><h3 id="实例-1">实例</h3><p>比如一个需要创建子进程的函数，使用<code>fork</code>函数的返回值来判断当前所处进程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">forkNewProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...pre-process</span></span><br><span class="line">    <span class="keyword">pid_t</span> son = fork();</span><br><span class="line">    <span class="keyword">if</span> (son)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> ppid = getppid();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;父親進程： pid = &quot;</span> &lt;&lt; getpid() &lt;&lt; <span class="string">&quot; ppid = &quot;</span> &lt;&lt; ppid &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;父親的兒子： pid = &quot;</span> &lt;&lt; son &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> ppid = getppid();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;兒子進程： pid = &quot;</span> &lt;&lt; getpid() &lt;&lt; <span class="string">&quot; ppid = &quot;</span> &lt;&lt; ppid &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;兒子的父親： pid = &quot;</span> &lt;&lt; ppid &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// ...post-process</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然分支不长，但是当不同进程需要做的事情明显不同，且包括很多行代码的时候，这样写就会非常的不优雅；根据上面提到的分解表达式方法，我们可以对上述的代码做出如下重构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fatherProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ppid = getppid();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;父親進程： pid = &quot;</span> &lt;&lt; getpid() &lt;&lt; <span class="string">&quot; ppid = &quot;</span> &lt;&lt; ppid &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;父親的兒子： pid = &quot;</span> &lt;&lt; son &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sonProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ppid = getppid();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;兒子進程： pid = &quot;</span> &lt;&lt; getpid() &lt;&lt; <span class="string">&quot; ppid = &quot;</span> &lt;&lt; ppid &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;兒子的父親： pid = &quot;</span> &lt;&lt; ppid &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">forkNewProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...pre-process</span></span><br><span class="line">    <span class="keyword">pid_t</span> son = fork();</span><br><span class="line">    son ? fatherProcess() : sonProcess();</span><br><span class="line">    <span class="comment">// ...post-process</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，当父子进程的工作更多，更复杂的时候，也能保证一定程度的可读性。</p><h2 id="过大的类">过大的类</h2><p>若类中的实例变量过多，一般可以通过提取新类（组件）或创建子类解决；若代码较多，也可以提取共用“接口”，将类对于这些方法的使用具体到接口中；</p><p>特别地，如果这是一个 GUI 类（组件），可能要将业务数据和需要这些数据的方法放到一个处理业务的类中，从视图类中分离；视图类对于业务类实现观察者模式，仅保留视图必需的数据，并且和业务对象保持同步；</p><h3 id="实例-2">实例</h3><p>在前端框架 React 的实际使用过程中，上述对于 GUI 类的描述则是一种比较常见的设计模式：即聪明组件和傻瓜组件的设计模式；</p><p>比如一个 React 组件，它的工作是从后台的 API 请求一个笑话，并且将它显示在用户的主页上；它可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">export default class JokeTeller extends React.Component &#123;</span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    joke: null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;img src&#x3D;&#123;SmileFace&#125; &#x2F;&gt;</span><br><span class="line">      &#123;joke || &#39;loading...&#39; &#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    fetch(&#39;https:&#x2F;&#x2F;icanhazdadjoke.com&#x2F;&#39;,</span><br><span class="line">      &#123;headers: &#123;&#39;Accept&#39;: &#39;application&#x2F;json&#39;&#125;&#125;</span><br><span class="line">    ).then(response &#x3D;&gt; &#123;</span><br><span class="line">      return response.json();</span><br><span class="line">    &#125;).then(json &#x3D;&gt; &#123;</span><br><span class="line">      this.setState(&#123;joke: json.joke&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为只是将一个笑话显示在页面上，所以就算这么写也并没有什么；但是当这个组件需要显示的内容非常的复杂（即<code>render</code>函数很大很长），并且需要从后端获得大量数据的时候，就会得到一个长的离谱的类；但是，我们可以使用上述的重构思想对这个类进行重构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const JokeShower &#x3D; (&#123;value&#125;) &#x3D;&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;img src&#x3D;&#123;SmileFace&#125; &#x2F;&gt;</span><br><span class="line">      &#123;value || &#39;loading...&#39; &#125;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default class JokerGetter extends React.Component &#123;</span><br><span class="line">  state &#x3D; &#123;</span><br><span class="line">    joke: null</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;JokeShower value&#x3D;&#123;this.state.joke&#125; &#x2F;&gt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    fetch(&#39;https:&#x2F;&#x2F;icanhazdadjoke.com&#x2F;&#39;,</span><br><span class="line">      &#123;headers: &#123;&#39;Accept&#39;: &#39;application&#x2F;json&#39;&#125;&#125;</span><br><span class="line">    ).then(response &#x3D;&gt; &#123;</span><br><span class="line">      return response.json();</span><br><span class="line">    &#125;).then(json &#x3D;&gt; &#123;</span><br><span class="line">      this.setState(&#123;joke: json.joke&#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就将 React 组件类中的一个很长的部分——也就是渲染函数直接单立出去，避免了类既包含太多的渲染结构，也包含了大量的业务逻辑；至于观察者模式，React 框架已经帮我们做好了一切。</p><h2 id="引入空对象">引入空对象</h2><p>当代码中的多项操作需要检查一个对象是不是空对象（如果是空对象，则使用默认配置）的时候，可以为该类创建一个空对象的子类，或者创建一个包含默认设置的静态空对象；</p><p>使用一个具体的对象代替空对象，可以使得代码运行的更安全，避免意外情况的出现；</p><h3 id="实例-3">实例</h3><p>比如下面这个函数，它接受一个可以是空的对象，并对它进行操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> request = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handle = <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    res ??= &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> data = res.data ?? &#123;<span class="attr">err</span> : <span class="string">&#x27;system.1001&#x27;</span>&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以预先定义空对象，保证操作对象的函数永远获得的是一个存在的对象——当然这个对象可能实际上是一个没有意义的空对象；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nullObject = &#123;</span><br><span class="line">    data : &#123;</span><br><span class="line">        err : <span class="string">&#x27;system.1001&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> request = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> res ?? nullObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handle = <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> data = res.data;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以使得代码运行更加的安全，并且也避免了大量的判空工作。</p><h2 id="狎昵关系">狎昵关系</h2><p>当两个类过分的关注彼此的私有域，可以进行如下重构：</p><ul><li>可以移动方法、私有域来划清界限</li><li>可以就共同部分提取成一个新的公共类</li><li>可以使用隐藏委托来传递这些信息</li><li>使用以委托取代继承的方法来回避类的继承带来的问题</li></ul><p>下面的实例使用了移动私有域的方法回避了两个类过于亲近的关系。</p><h3 id="实例-4">实例</h3><p>下面是一个 C++ 图的类型，它使用了一个边的类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w, next;</span><br><span class="line">    edge() = <span class="keyword">default</span>;</span><br><span class="line">    edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> next)</span><br><span class="line">            : u(u), v(v), w(w), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N, <span class="keyword">int</span> M&gt; <span class="class"><span class="keyword">class</span> <span class="title">FWS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> head[N];</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    edge ee[M*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    FWS(<span class="keyword">int</span> n = N<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ee[tot] = edge(u,v,w,head[u]);</span><br><span class="line">        head[u] = tot ++;</span><br><span class="line">        ee[tot] = edge(v,u,w,head[v]);</span><br><span class="line">        head[v] = tot ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foreach</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">const</span> function&lt;<span class="keyword">bool</span>(edge&amp;)&gt;&amp; func)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = head[st]; ~c; c = ee[c].next)</span><br><span class="line">            <span class="keyword">if</span> (!func(ee[c])) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>edge 类的 next 域完全就是为了图 FWS 类进行遍历，不应当放在 edge 类中；所以可以对于上述的代码做出如下的重构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    edge() = <span class="keyword">default</span>;</span><br><span class="line">    edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w) : u(u), v(v), w(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N, <span class="keyword">int</span> M&gt; <span class="class"><span class="keyword">class</span> <span class="title">FWS</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> head[N];</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    edge ee[M*<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> next[M*<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    FWS(<span class="keyword">int</span> n = N<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ee[tot] = edge(u,v,w,head[u]);</span><br><span class="line">        head[u] = tot ++;</span><br><span class="line">        ee[tot] = edge(v,u,w,head[v]);</span><br><span class="line">        head[v] = tot ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foreach</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">const</span> function&lt;<span class="keyword">bool</span>(edge&amp;)&gt;&amp; func)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = head[st]; ~c; c = next[c])</span><br><span class="line">            <span class="keyword">if</span> (!func(ee[c])) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就避免了方法<code>FWS::foreach</code>频繁的访问 edge 类的私有成员变量 next；</p><h2 id="基本类型偏执">基本类型偏执</h2><p>很多时候，在小任务上使用小对象是一件好事；但是这经常被人们忽视。具体的做法如下：</p><ul><li>可以将原本单独存在的数据值替换为对象</li><li>如果想要替换的数据值是类型码而它不影响行为，可以使用类来替换类型码</li><li>如果有与类型码相关的条件表达式，可以替换为子类或状态</li><li>如果多个字段经常共同存在，则可以提取出新公共类</li><li>如果参数列表中出现了基本类型数据，尝试替换成对象</li><li>如果从数组中挑选数据，可以使用对象来替换数组</li></ul><p>下面的实例介绍了一种常见的数据结构的重构过程；</p><h3 id="实例-5">实例</h3><p>并查集是一个很常见的数据结构；最简单的并查集可以使用一个数组和简单的递归函数实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFather</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p[x] == x ? x : p[x] = getFather(p[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要使用多个并查集，这样就显得非常乱：毕竟在<code>getFather</code>之外的函数看来，p只不过是一个一般的数组。尽管<code>getFather</code>只是做了一些微小的工作，但是这并不妨碍我们将它重构成一个类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> N&gt; ufs</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">ufs()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++ i) p[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getFather</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span>* p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p[x] == x ? x : p[x] = getFather(p[x]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当使用并查集的时候，只需要构建一个这个的对象，也避免了大量的未知数组创建；</p><h2 id="参数列过长">参数列过长</h2><p>有的函数可能会带着一个长长的参数列表，以至于调用的时候甚至还需要换行；对于这种情况，可以对这个函数进行重构；具体的重构方法包括：</p><ul><li>如果向已有的对象发出一条请求就可以取代一个参数，那应该使用方法替代参数</li><li>可以将来自于同一个对象的参数用所属的对象进行替换</li><li>如果某些数据缺乏合理的对象归属，可以为它们创建一个参数对象</li></ul><p>但是特殊情况下，比如明显不希望这些参数之间产生某些联系，也可以将这些数据按照单独的参数处理。</p><h3 id="实例-6">实例</h3><p>比如下面的代码，它是一个函数的声明；该函数接受很多的参数，来生成一个符合参数要求的注册表文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">createClsidRegFileDefault</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span>* file_path,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span>* app_name,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span>* clsid_main,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span>* default_icon,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span>* inproc_server,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span>* clasid_instance = <span class="literal">nullptr</span>,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">char</span>* exec_options = <span class="literal">nullptr</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>我们将它的参数列表提取成一个文件对象，那么这个函数的工作仅仅是将这个对象“文件化”，可以作为对象的成员函数（方法）；重构之后如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">clsidFile</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span>* default_icon;</span><br><span class="line"><span class="keyword">char</span>* app_name;</span><br><span class="line"><span class="keyword">char</span>* clsid_main;</span><br><span class="line"><span class="keyword">char</span>* inproc_server;</span><br><span class="line"><span class="keyword">char</span>* clasid_instance;</span><br><span class="line"><span class="keyword">char</span>* exec_option;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...constructor</span></span><br><span class="line">    <span class="comment">// ...getter &amp; setter</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">createRegFile</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* file_path)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为文件路径并不是一个 CLSID 注册表项的固有成员，可以在调用的时候指定；故予以保留。</p><h2 id="数据泥团">数据泥团</h2><p>当在很多地方看到相同的三四项数据，例如两个类中相同的字段或是许多函数签名中相同的参数的时候，可以找出数据以字段形式出现的地方，将它们提取到公共类中；再缩减参数列表。</p><p>当删掉众多数据中的一项，如果有数据失去类意义，那么这意味着需要产生新对象（类）。</p><h3 id="实例-7">实例</h3><p>比如下面的一些排序函数的声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basketSort</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">unsigned</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binaryInsertSort</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">unsigned</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">unsigned</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">unsigned</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">unsigned</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">unsigned</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">unsigned</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">unsigned</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">unsigned</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">randomQuickSort</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">unsigned</span> length)</span></span>;</span><br></pre></td></tr></table></figure><p>因为所有的排序方法都是对于一个数组而言的；如果需要对一个数组使用不同的方法排序，可以将这些相同的参数提取到一个类中，并且将这些方法移动成为方法；具体重构方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sorter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>* <span class="built_in">array</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> length;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...constructor</span></span><br><span class="line">    <span class="comment">// ...getter &amp; setter</span></span><br><span class="line">    </span><br><span class="line">    <span class="function">Sorter&amp; <span class="title">bind</span><span class="params">(<span class="keyword">int</span>* <span class="built_in">array</span>, <span class="keyword">unsigned</span> length)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">basketSort</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">binaryInsertSort</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">countSort</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">radixSort</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">randomQuickSort</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以将一个数组作为任务对象化，之后对这个任务对象使用不同的排序方法；最后使用 getter 获得排序的结果（当然，这里是直接在绑定的数组上进行操作）。</p><h2 id="体会">体会</h2><p>很多代码都可以采用更好的设计模式、重构策略进行重构；但是策略也不是万金油：很多时候采用较长/较短的类，使用参数列表还是参数对象，更多是取决于项目属性，数据意义，而不是所谓的策略；</p>]]></content>
      
      
      <categories>
          
          <category> 课业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课内作业 </tag>
            
            <tag> 实验报告 </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统原理：第 1 次上机实验报告</title>
      <link href="/2020/class-FoDOS-experiment-1/"/>
      <url>/2020/class-FoDOS-experiment-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>操作系统原理的上机实验的报告一共有四个，其他的报告的地址是：</p><p>第一次：<a href="https://shiraha.cn/2020/class-FoDOS-experiment-1/" class="uri">https://shiraha.cn/2020/class-FoDOS-experiment-1/</a><br />第二次：<a href="https://shiraha.cn/2020/class-FoDOS-experiment-2/" class="uri">https://shiraha.cn/2020/class-FoDOS-experiment-2/</a><br />第三次：<a href="https://shiraha.cn/2020/class-FoDOS-experiment-3/" class="uri">https://shiraha.cn/2020/class-FoDOS-experiment-3/</a><br />第四次：<a href="https://shiraha.cn/2020/class-FoDOS-experiment-4/" class="uri">https://shiraha.cn/2020/class-FoDOS-experiment-4/</a></p></blockquote><h2 id="front-matter">Front-matter</h2><p>本次实验的所有源代码可以在<a href="https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job?path=%2Fosnmb%2Fexp" class="uri">https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job?path=%2Fosnmb%2Fexp</a> 查看到。</p><h2 id="实验要求">实验要求</h2><p>本次上机实验的实验要求如下：</p><blockquote>#####<center>《操作系统原理》第一次上机实验</center><p><strong>一、实验目的</strong></p><ol type="1"><li>理解操作系统生成的概念和过程；</li><li>理解操作系统两类用户界面（操作界面，系统调用）概念；</li></ol><p><strong>二、实验内容</strong></p><ol type="1"><li>在 Ubuntu 或其他 Linux 平台环境下裁剪和编译 Linux 内核，并启用新的内核。</li><li>在 Ubuntu 或其他 Linux 平台为 Linux 内核增加 1-3 个新 的系统调用，并启用新的内核，编写一个应用程序测试新增加的系 统调用是否能正确工作。</li><li>在 Windows 环境下，编写一个批处理程序（算命大 师.bat），程序运行后，输入：出生年月日（例如 2000-07-31）。系 统输出相应的属相和星座，例如：你属兔， 狮子座。要求：输入进 行合法性检查，能循环接收用户的输入，直到输入 q 或 Q 就退出。</li></ol></blockquote><p>要求一、二在上机前自己做过了，本次实验报告只简述实验过程和贴图。要求三完成了简单的 Bat 版本和 Powershell 的复杂版本。</p><h2 id="实验内容">实验内容</h2><ol type="1"><li>在 Ubuntu 或其他 Linux 平台环境下裁剪和编译 Linux 内核，并启用新的内核。</li><li>在 Ubuntu 或其他 Linux 平台为 Linux 内核增加 1-3 个新 的系统调用，并启用新的内核，编写一个应用程序测试新增加的系 统调用是否能正确工作。</li><li>在 Windows 环境下，编写一个批处理程序（算命大 师.bat），程序运行后，输入：出生年月日（例如 2000-07-31）。系 统输出相应的属相和星座，例如：你属兔， 狮子座。要求：输入进 行合法性检查，能循环接收用户的输入，直到输入 q 或 Q 就退出。</li></ol><p>第一、第二个实验的内容原文来自本博客：<a href="https://shiraha.cn/2019/Linux-FoDOS-experiment-dian/" class="uri">https://shiraha.cn/2019/Linux-FoDOS-experiment-dian/</a>，选择的 Linux 平台是 Arch Linux。<br />第三个实验的内容原文来自本博客：<a href="https://shiraha.cn/2020/class-FoDOS-experiment-bat-programming/" class="uri">https://shiraha.cn/2020/class-FoDOS-experiment-bat-programming/</a>，这篇文章只包括了 Powershell 的脚本的实验过程。</p><h2 id="实验过程">实验过程</h2><p>下面是对于每一个任务的原理和过程的简述：为了遵循实际实验的最佳顺序，讲述顺序为实验二、实验一、实验三（实验二的完成本身需要实验一的工作</p><h3 id="增加系统调用">增加系统调用</h3><p>总的来说，增加最简单的系统调用主要分为 增加新函数 -&gt; 增加新声明 -&gt; 将新调用增加到系统调用注册表 三个步骤。复制一份下载的纯净内核文件，修改其中的<code>include/uapi/asm-generic/unistd.h</code>和<code>include/linux/syscalls.h</code>两个头文件来增加系统调用的函数。</p><p>进入系统调用注册表的目录<code>arch/x86/entry/syscalls</code>，根据要安装的操作系统位数修改其下的<code>tbl</code>文件，注册增加的系统调用。特别注意不应该与已经存在的系统调用的编号冲突，这点在后面增加宏的时候再次重复。</p><p>使用vim打开系统调用的实现的源文件<code>kernel/sys.c</code>来增加刚才增加的函数的实现。如果要增加的是在内核缓冲区打印消息这种最简单的系统调用，则它可以是下面这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">void</span> <span class="title">sys_shirohashow</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;Shiroha do your best!&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;\n@Edit by Shiroha on 2019-11-15.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就增加了一个系统调用函数<code>sys_shirohashow</code>的实现。完成之后还要在<code>include/uapi/asm-generic/unistd.h</code>增加宏。这个系统调用的含义是在内核缓冲区（用户程序不可以实现的功能）打印一条消息，需要使用<code>dmesg -c</code>命令清除所有缓冲区日志来查看。</p><p><code>dmesg</code>命令主要有下面三个用途：</p><ul><li>列出所有检测到的硬件</li><li>输出指定行数的日志</li><li>清空dmesg缓冲区日志</li></ul><p>这里主要就是使用了第三个功能，用来检查<code>printk</code>的输出结果。</p><p>此外，上述函数体的修饰符<code>asmlinkage</code>宏确保了这个函数使用堆栈传递参数；所有的系统调用函数都应该使用这个进行修饰。</p><p>添加完实现之后还需要在<code>unistd.h</code>文件中增加这个函数的声明。这个文件在 Arch 中的位置是<code>include/uapi/asm-generic/unistd.h</code>；我们使用 Vim 打开它并在末尾增加：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shirohashow 765</span></span><br><span class="line">__SYSCALL(__NR_shirohashow,sys_shirohashow)</span><br></pre></td></tr></table></figure><p>765 是这个系统调用的编号，选取它的原因是因为 346/283 被其他系统调用占用了而它没有。需要确认一个系统调用编号是否已经被占用，可以打开系统调用注册表进行确认（比如<code>syscall_64.tbl</code>，可以使用<code>find</code>指令找到这个文件所在目录）。</p><p>还有一处需要增加声明的地方是<code>include/linux/syscalls.h</code>；打开这个文件并且增加标准的 C 函数声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">void</span> <span class="title">sys_shirohashow</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>这个文件应该有注释表明了这个函数实现所在的位置，建议遵循规则增加到注释<code>kernel/sys.c</code>的区域。</p><p>将修改过的内核和纯净内核使用<code>diff -Naur</code>生成差异补丁，再使用<code>patch</code>命令应用到纯净内核上。使用<code>make -j6</code>进行多线程编译。当然你也可以直接在修改的内核上直接编译，patch 一次纯属娱乐，没太多实际意义。当然也可以作为对于<code>patch</code>指令的熟悉。</p><p>编译成功后执行安装，并将必要的文件复制到特定的地方之后更新grub的引导信息，就完成了内核的应用。应用新内核将会在下一个任务的实验过程中较为详细的介绍。</p><p>应用新内核之后，在运行新内核的操作系统上写C程序，调用增加的系统调用，就可以看到我们在内核中编写的程序可以成功运行了。随后通过一些方法（对于<code>printk</code>，就是使用<code>dmesg -c</code>查看内核缓冲区）验证实验结果。对于上述步骤增加的系统调用，提供一个示例 C 程序用于测试：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/reg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    syscall(<span class="number">765</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后执行，应该就可以在内核缓冲区中看到输出的鼓励话语了。</p><h3 id="编译内核">编译内核</h3><p>实验背景：使用 Hyper-V （第二代） 虚拟机平台，安装 Arch Linux。已经下载好了对应版本的 Linux 官方的纯净内核源代码文件。</p><p>从官网上下载的内核已经提供了编译的配置文件，甚至还提供了一个比较图形化的<code>menuconfig</code>页面，提供了较为可视化的 .config 文件的生成方法。因为我们只是在一般的 PC 上安装新 Linux 内核，所以不需要进行特别的裁剪和配置，使用缺省配置就好：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcat /proc/config.gz &gt; .config</span><br></pre></td></tr></table></figure><p>复制得到 .config 文件之后还建议修改文件中的<code>CONFIG_LOCALVERSION</code>的值，避免将要编译的内核文件覆盖当前内核文件。生成了 config 文件之后就可以使用<code>make -jx</code>开始多线程编译了。建议 x 取值和计算机所持有的物理核心数相同以获得最大编译速度。</p><p>安装新编译生成的新内核的步骤可以简单归纳为：安装内核模块 -&gt; 复制内核文件 -&gt; 制作initramfs镜像 -&gt; 复制System.map -&gt; 生成新的启动引导。</p><p>安装内核模块可以使用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make modules_install </span><br></pre></td></tr></table></figure><p>这条命令会将编译好的模块安装到主目录 /lib/modules 下。这样，会使得这些模块独立于虚拟机原有内核的模块。</p><p>复制内核文件可以使用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于32位(i686)内核：</span></span><br><span class="line">sudo cp -v arch/x86/boot/bzImage /boot/vmlinuz-linux53</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于64位(x86_64)内核：</span></span><br><span class="line">sudo cp -v arch/x86_64/boot/bzImage /boot/vmlinuz-linux53</span><br></pre></td></tr></table></figure><p>将内核编译完成生成的bzImage（较大的压缩的内核映像，使用gzip压缩）文件复制到<code>/boot</code>目录下。</p><p>制作initramfs（初始内存盘）镜像可以通过复制并且修改mkinitcpio（一个创建initramfs的脚本）preset，这样就可以通过官方内核一样的方式生成自定义内核的initramfs镜像。复制之后需要使用vim修改这个文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/mkinitcpio.d/linux.preset /etc/mkinitcpio.d/linux53.preset</span><br><span class="line">sudo vi /etc/mkinitcpio.d/linux53.preset</span><br></pre></td></tr></table></figure><p>打开linux53.preset文件之后，修改部分字段使得它与新的自定义内核所匹配。需要修改的字段如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/mkinitcpio.d/linux53.preset</span></span><br><span class="line"></span><br><span class="line">ALL_kver=<span class="string">&quot;/boot/vmlinuz-linux53&quot;</span></span><br><span class="line">default_image=<span class="string">&quot;/boot/initramfs-linux53.img&quot;</span></span><br><span class="line">fallback_image=<span class="string">&quot;/boot/initramfs-linux53-fallback.img&quot;</span></span><br></pre></td></tr></table></figure><p>修改并保存之后执行<code>sudo mkinitcpio -p linux53</code>就可以使用官方内核生成的方式生成自定义内核的initramfs镜像。</p><p>复制System.map的步骤可能不是必须的。如果虚拟机的/boot挂载到的分区的文件系统是<code>ext4</code>格式。就需要将解压目录下的System.map文件复制到/boot中，并且创建/boot/System.map，将新建的System.map软链接到复制到其中的System.map中。需要执行的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo touch /boot/System.map</span><br><span class="line">sudo cp System.map /boot/System.map-MyKernel</span><br><span class="line">sudo ln -sf /boot/System.map-Mykernel /boot/System.map</span><br></pre></td></tr></table></figure><p>但是由于本次使用的虚拟机的 boot 分区挂载的分区是<code>vfat</code>文件系统的，无需也不必创建软链接；所以本次上机实验中这一步实际并没有去做。</p><p>最后需要更新更新 grub 引导的配置信息。在安装了 grub 之后，使用命令<code>grub-mkconfig -o /boot/grub/grub.cfg</code>可以生成grub默认的配置信息。它会自动地将刚添加的内核增加到启动配置中。在Ubuntu这种系统中，这个命令被包装成了<code>update-grub</code>或其他形式。因为本次实验使用的是 Arch 发行版，所以需要完整的命令。</p><p>最后使用 <code>reboot</code> 指令重启虚拟机，通过安装的 <code>screenfetch</code> 工具来获取当前的系统信息，就可以发现系统的内核信息已经更新了，实验完成。在 Arch 中，需要使用系统默认的包管理工具 <code>pacman</code> 安装 <code>screenfetch</code>。</p><h3 id="脚本编写">脚本编写</h3><p>分析实验要求，绘制程序执行流程图：</p><figure><img src="https://i.loli.net/2020/03/16/pFu5hKJ7RobmX46.png" class="lazyload" data-srcset="https://i.loli.net/2020/03/16/pFu5hKJ7RobmX46.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="流程图" /><figcaption aria-hidden="true">流程图</figcaption></figure><p>接下来就是使用一些具体的脚本语言实现这个设计了。</p><p>对于 Powershell 脚本，可以使用的“库”有很多，实现也就可以更加的花哨一些。单就读取用户输入方面们就有很多的方案可供选择：可以使用Powershell原生的<code>Read-Host</code>，也可以使用框架提供的GUI窗口；甚至还可以使用 Visual Basic 的窗口。</p><p>得益于 Powershell 脚本功能的强大，我们可以定义一个函数完成对于日期合法性的判断。最后根据用户输入的日期进行一些处理，得到输出的字符串即可。为了节约篇幅，这里省略了一些预先声明的，和处理日期生成输出字符串相关的一些变量的初始化（以省略号代替）。使用框架提供的输入窗口获取用户输入的源代码如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Add-Type</span> <span class="literal">-AssemblyName</span> System.Windows.Forms</span><br><span class="line"><span class="built_in">Add-Type</span> <span class="literal">-AssemblyName</span> System.Drawing</span><br><span class="line"></span><br><span class="line">[<span class="built_in">int</span>[]] <span class="variable">$days</span> = <span class="number">29</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span></span><br><span class="line"><span class="variable">$dayIsIllegal</span> = <span class="string">&quot;The days you input is illegal. try again&quot;</span></span><br><span class="line">[<span class="built_in">string</span>[]] <span class="variable">$months</span> = ...</span><br><span class="line">[<span class="built_in">string</span>[]] <span class="variable">$iiyokoiyo</span> = <span class="selector-tag">@</span>(...)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isLunar</span> <span class="params">([int] <span class="variable">$y</span>)</span> </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$y</span> % <span class="number">4</span>) &#123;<span class="keyword">return</span> <span class="string">&#x27;False&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="keyword">if</span>(<span class="variable">$y</span> % <span class="number">400</span>) &#123;<span class="keyword">return</span> <span class="string">&#x27;True&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="keyword">if</span>(<span class="variable">$y</span> % <span class="number">100</span>) &#123;<span class="keyword">return</span> <span class="string">&#x27;False&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="keyword">return</span> <span class="string">&#x27;True&#x27;</span>&#125;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$form</span> = <span class="built_in">New-Object</span> System.Windows.Forms.Form</span><br><span class="line">    <span class="variable">$form</span>.Text = <span class="string">&#x27;Birthday input form&#x27;</span></span><br><span class="line">    <span class="variable">$form</span>.Size = <span class="built_in">New-Object</span> System.Drawing.Size(<span class="number">300</span>,<span class="number">200</span>)</span><br><span class="line">    <span class="variable">$form</span>.StartPosition = <span class="string">&#x27;CenterScreen&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$okButton</span> = <span class="built_in">New-Object</span> System.Windows.Forms.Button</span><br><span class="line">    <span class="variable">$okButton</span>.Location = <span class="built_in">New-Object</span> System.Drawing.Point(<span class="number">65</span>,<span class="number">120</span>)</span><br><span class="line">    <span class="variable">$okButton</span>.Size = <span class="built_in">New-Object</span> System.Drawing.Size(<span class="number">75</span>,<span class="number">23</span>)</span><br><span class="line">    <span class="variable">$okButton</span>.Text = <span class="string">&#x27;OK&#x27;</span></span><br><span class="line">    <span class="variable">$okButton</span>.DialogResult = [<span class="type">System.Windows.Forms.DialogResult</span>]::OK</span><br><span class="line">    <span class="variable">$form</span>.AcceptButton = <span class="variable">$okButton</span></span><br><span class="line">    <span class="variable">$form</span>.Controls.Add(<span class="variable">$okButton</span>)</span><br><span class="line"></span><br><span class="line">    <span class="variable">$cancelButton</span> = <span class="built_in">New-Object</span> System.Windows.Forms.Button</span><br><span class="line">    <span class="variable">$cancelButton</span>.Location = <span class="built_in">New-Object</span> System.Drawing.Point(<span class="number">160</span>,<span class="number">120</span>)</span><br><span class="line">    <span class="variable">$cancelButton</span>.Size = <span class="built_in">New-Object</span> System.Drawing.Size(<span class="number">75</span>,<span class="number">23</span>)</span><br><span class="line">    <span class="variable">$cancelButton</span>.Text = <span class="string">&#x27;Cancel&#x27;</span></span><br><span class="line">    <span class="variable">$cancelButton</span>.DialogResult = [<span class="type">System.Windows.Forms.DialogResult</span>]::Cancel</span><br><span class="line">    <span class="variable">$form</span>.CancelButton = <span class="variable">$cancelButton</span></span><br><span class="line">    <span class="variable">$form</span>.Controls.Add(<span class="variable">$cancelButton</span>)</span><br><span class="line"></span><br><span class="line">    <span class="variable">$label</span> = <span class="built_in">New-Object</span> System.Windows.Forms.Label</span><br><span class="line">    <span class="variable">$label</span>.Location = <span class="built_in">New-Object</span> System.Drawing.Point(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">    <span class="variable">$label</span>.Size = <span class="built_in">New-Object</span> System.Drawing.Size(<span class="number">280</span>,<span class="number">20</span>)</span><br><span class="line">    <span class="variable">$label</span>.Text = <span class="string">&#x27;Input your Birthday as YYYY-MM-DD&#x27;</span></span><br><span class="line">    <span class="variable">$form</span>.Controls.Add(<span class="variable">$label</span>)</span><br><span class="line"></span><br><span class="line">    <span class="variable">$textBox</span> = <span class="built_in">New-Object</span> System.Windows.Forms.TextBox</span><br><span class="line">    <span class="variable">$textBox</span>.Location = <span class="built_in">New-Object</span> System.Drawing.Point(<span class="number">10</span>,<span class="number">40</span>)</span><br><span class="line">    <span class="variable">$textBox</span>.Size = <span class="built_in">New-Object</span> System.Drawing.Size(<span class="number">260</span>,<span class="number">20</span>)</span><br><span class="line">    <span class="variable">$form</span>.Controls.Add(<span class="variable">$textBox</span>)</span><br><span class="line"></span><br><span class="line">    <span class="variable">$form</span>.Topmost = <span class="variable">$true</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$form</span>.Add_Shown(&#123;<span class="variable">$textBox</span>.Select()&#125;)</span><br><span class="line">    <span class="variable">$result</span> = <span class="variable">$form</span>.ShowDialog()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$result</span> <span class="operator">-eq</span> [<span class="type">System.Windows.Forms.DialogResult</span>]::OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$x</span> = <span class="variable">$textBox</span>.Text</span><br><span class="line">        <span class="string">&quot;Your input: &quot;</span>+<span class="variable">$x</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$x</span> <span class="operator">-eq</span> <span class="string">&#x27;q&#x27;</span> <span class="operator">-or</span> <span class="variable">$x</span> <span class="operator">-eq</span> <span class="string">&#x27;Q&#x27;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;Exting ...&quot;</span></span><br><span class="line">            <span class="keyword">exit</span></span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="built_in">int</span>[]] <span class="variable">$data</span> = <span class="variable">$x</span>.Split(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$data</span>.Count <span class="operator">-ne</span> <span class="number">3</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Write-Host</span> <span class="literal">-ForegroundColor</span> RED <span class="string">&quot;The String you input is not refer to a date.&quot;</span></span><br><span class="line">            <span class="keyword">continue</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$data</span>[<span class="number">0</span>] <span class="operator">-lt</span> <span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Write-Host</span> <span class="literal">-ForegroundColor</span> YELLOW <span class="string">&quot;You cannot born before AC. try again&quot;</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$data</span>[<span class="number">1</span>] <span class="operator">-lt</span> <span class="number">1</span> <span class="operator">-or</span> <span class="variable">$data</span>[<span class="number">1</span>] <span class="operator">-gt</span> <span class="number">12</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Write-Host</span> <span class="literal">-ForegroundColor</span> RED <span class="string">&quot;The month is illegal. try again&quot;</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$lunar</span> = isLunar <span class="variable">$data</span>[<span class="number">0</span>]</span><br><span class="line">        <span class="variable">$month</span> = <span class="variable">$data</span>[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$lunar</span> <span class="operator">-eq</span> <span class="string">&#x27;True&#x27;</span> <span class="operator">-and</span> <span class="variable">$data</span>[<span class="number">1</span>] <span class="operator">-eq</span> <span class="number">2</span>) &#123;<span class="variable">$month</span> = <span class="number">0</span>&#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$data</span>[<span class="number">2</span>] <span class="operator">-lt</span> <span class="number">1</span> <span class="operator">-or</span> <span class="variable">$data</span>[<span class="number">2</span>] <span class="operator">-gt</span> <span class="variable">$days</span>[<span class="variable">$month</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Write-Host</span> <span class="literal">-ForegroundColor</span> RED <span class="variable">$dayIsIllegal</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Write-Host</span> <span class="literal">-ForegroundColor</span> YELLOW <span class="string">&quot;PROOVE STRAT:&quot;</span></span><br><span class="line">        <span class="string">&quot;You born in &quot;</span>+<span class="variable">$months</span>[<span class="variable">$data</span>[<span class="number">1</span>]]+<span class="string">&quot;, which means &quot;</span>+<span class="variable">$data</span>[<span class="number">1</span>]+<span class="string">&quot;, and there is &quot;</span>+<span class="variable">$iiyokoiyo</span>[<span class="variable">$data</span>[<span class="number">1</span>]]</span><br><span class="line">        <span class="string">&quot;You born at &quot;</span>+<span class="variable">$data</span>[<span class="number">2</span>]+<span class="string">&quot;, and there is &quot;</span>+<span class="variable">$iiyokoiyo</span>[<span class="variable">$data</span>[<span class="number">2</span>]]</span><br><span class="line">        <span class="built_in">Write-Host</span> <span class="literal">-ForegroundColor</span> GREEN <span class="string">&quot;Q.E.D. You are HonMono No Yaju Senpai ! &quot;</span></span><br><span class="line"></span><br><span class="line">        pause</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用原生的<code>Read-Host</code>获取用户输入也是一种选择；下面是使用<code>Read-Host</code>获得用户输入的部分代码（和上面代码不同的部分）：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$x</span> = <span class="built_in">Read-Host</span> <span class="string">&quot;Please input your birthday as YYYY-MM-DD &quot;</span></span><br><span class="line">    <span class="string">&quot;Your input: &quot;</span>+<span class="variable">$x</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$x</span> <span class="operator">-eq</span> <span class="string">&quot;&quot;</span>) &#123;<span class="string">&quot;You input nothing, try again.&quot;</span>&#125;</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    pause</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码如果对于 Powershell 不甚了解的话则难以理解其中的一些部分，这是因为 Powershell 基于 .NET 框架，提供了很多 Windows 的原生接口。如果是相对低级的 bat 批处理程序，代码就会更加的简洁易懂。下面的代码是使用 bat 脚本语法书写的“算命大师”。和上面的 ps1 脚本不同，仅执行任务要求的星座、属性计算（使用分支语句实现），并且没有复杂的日期判断：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">title</span> 算命帶師</span><br><span class="line">:scanf</span><br><span class="line"><span class="built_in">set</span> /p input=輸入出生日期（按照YYYYMMDD格式）</span><br><span class="line"><span class="built_in">set</span> &quot;year=<span class="variable">%input:~0,4%</span>&quot;</span><br><span class="line"><span class="built_in">set</span> &quot;<span class="built_in">md</span>=<span class="variable">%input:~4,4%</span>&quot;</span><br><span class="line"><span class="built_in">set</span> /a mod=<span class="variable">%year%</span><span class="variable">%%1</span>2</span><br><span class="line"><span class="built_in">set</span> hint=您輸入的日期格式不太正確，請重試</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="variable">%input%</span> <span class="keyword">EQU</span> &quot;Q&quot; <span class="keyword">exit</span></span><br><span class="line"><span class="keyword">if</span> <span class="variable">%input%</span> <span class="keyword">EQU</span> &quot;q&quot; <span class="keyword">exit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="variable">%md%</span> <span class="keyword">LEQ</span> <span class="number">0099</span> (<span class="built_in">echo</span> <span class="variable">%hint%</span> </span><br><span class="line"><span class="keyword">goto</span> scanf)</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%md%</span> <span class="keyword">GEQ</span> <span class="number">0132</span> (<span class="keyword">if</span> <span class="variable">%md%</span> <span class="keyword">LEQ</span> <span class="number">0200</span> (<span class="built_in">echo</span> <span class="variable">%hint%</span></span><br><span class="line"><span class="keyword">goto</span> scanf) )</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%md%</span> <span class="keyword">GEQ</span> <span class="number">0229</span> (<span class="keyword">if</span> <span class="variable">%md%</span> <span class="keyword">LEQ</span> <span class="number">0300</span> (<span class="built_in">echo</span> <span class="variable">%hint%</span></span><br><span class="line"><span class="keyword">goto</span> scanf) )</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%md%</span> <span class="keyword">GEQ</span> <span class="number">0332</span> (<span class="keyword">if</span> <span class="variable">%md%</span> <span class="keyword">LEQ</span> <span class="number">0400</span> (<span class="built_in">echo</span> <span class="variable">%hint%</span></span><br><span class="line"><span class="keyword">goto</span> scanf) )</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%md%</span> <span class="keyword">GEQ</span> <span class="number">0431</span> (<span class="keyword">if</span> <span class="variable">%md%</span> <span class="keyword">LEQ</span> <span class="number">0500</span> (<span class="built_in">echo</span> <span class="variable">%hint%</span></span><br><span class="line"><span class="keyword">goto</span> scanf) )</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%md%</span> <span class="keyword">GEQ</span> <span class="number">0532</span> (<span class="keyword">if</span> <span class="variable">%md%</span> <span class="keyword">LEQ</span> <span class="number">0600</span> (<span class="built_in">echo</span> <span class="variable">%hint%</span></span><br><span class="line"><span class="keyword">goto</span> scanf) )</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%md%</span> <span class="keyword">GEQ</span> <span class="number">0631</span> (<span class="keyword">if</span> <span class="variable">%md%</span> <span class="keyword">LEQ</span> <span class="number">0700</span> (<span class="built_in">echo</span> <span class="variable">%hint%</span></span><br><span class="line"><span class="keyword">goto</span> scanf) )</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%md%</span> <span class="keyword">GEQ</span> <span class="number">0732</span> (<span class="keyword">if</span> <span class="variable">%md%</span> <span class="keyword">LEQ</span> <span class="number">0800</span> (<span class="built_in">echo</span> <span class="variable">%hint%</span></span><br><span class="line"><span class="keyword">goto</span> scanf) )</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%md%</span> <span class="keyword">GEQ</span> <span class="number">0832</span> (<span class="keyword">if</span> <span class="variable">%md%</span> <span class="keyword">LEQ</span> <span class="number">0900</span> (<span class="built_in">echo</span> <span class="variable">%hint%</span></span><br><span class="line"><span class="keyword">goto</span> scanf) )</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%md%</span> <span class="keyword">GEQ</span> <span class="number">0931</span> (<span class="keyword">if</span> <span class="variable">%md%</span> <span class="keyword">LEQ</span> <span class="number">1000</span> (<span class="built_in">echo</span> <span class="variable">%hint%</span></span><br><span class="line"><span class="keyword">goto</span> scanf) )</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%md%</span> <span class="keyword">GEQ</span> <span class="number">1032</span> (<span class="keyword">if</span> <span class="variable">%md%</span> <span class="keyword">LEQ</span> <span class="number">1100</span> (<span class="built_in">echo</span> <span class="variable">%hint%</span></span><br><span class="line"><span class="keyword">goto</span> scanf) )</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%md%</span> <span class="keyword">GEQ</span> <span class="number">1131</span> (<span class="keyword">if</span> <span class="variable">%md%</span> <span class="keyword">LEQ</span> <span class="number">1200</span> (<span class="built_in">echo</span> <span class="variable">%hint%</span></span><br><span class="line"><span class="keyword">goto</span> scanf) )</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%md%</span> <span class="keyword">GEQ</span> <span class="number">1232</span> (<span class="built_in">echo</span> <span class="variable">%hint%</span></span><br><span class="line"><span class="keyword">goto</span> scanf)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="variable">%mod%</span> <span class="keyword">EQU</span> <span class="number">0</span> <span class="built_in">echo</span> 你属猴</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%mod%</span> <span class="keyword">EQU</span> <span class="number">1</span> <span class="built_in">echo</span> 你属鸡</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%mod%</span> <span class="keyword">EQU</span> <span class="number">2</span> <span class="built_in">echo</span> 你属狗</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%mod%</span> <span class="keyword">EQU</span> <span class="number">3</span> <span class="built_in">echo</span> 你属猪</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%mod%</span> <span class="keyword">EQU</span> <span class="number">4</span> <span class="built_in">echo</span> 你属鼠</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%mod%</span> <span class="keyword">EQU</span> <span class="number">5</span> <span class="built_in">echo</span> 你属牛</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%mod%</span> <span class="keyword">EQU</span> <span class="number">6</span> <span class="built_in">echo</span> 你属虎</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%mod%</span> <span class="keyword">EQU</span> <span class="number">7</span> <span class="built_in">echo</span> 你属兔</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%mod%</span> <span class="keyword">EQU</span> <span class="number">8</span> <span class="built_in">echo</span> 你属龙</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%mod%</span> <span class="keyword">EQU</span> <span class="number">9</span> <span class="built_in">echo</span> 你属蛇</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%mod%</span> <span class="keyword">EQU</span> <span class="number">10</span> <span class="built_in">echo</span> 你属马</span><br><span class="line"><span class="keyword">if</span> <span class="variable">%mod%</span> <span class="keyword">EQU</span> <span class="number">11</span> <span class="built_in">echo</span> 你属羊</span><br><span class="line"><span class="built_in">echo</span> 而且是</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> &quot;<span class="variable">%md%</span>&quot; <span class="keyword">LEQ</span> &quot;<span class="number">0119</span>&quot; <span class="built_in">echo</span> 魔蝎座</span><br><span class="line"><span class="keyword">if</span> &quot;<span class="variable">%md%</span>&quot; <span class="keyword">GEQ</span> &quot;<span class="number">0120</span>&quot; <span class="keyword">if</span> &quot;<span class="variable">%md%</span>&quot; <span class="keyword">LEQ</span> &quot;<span class="number">0218</span>&quot; <span class="built_in">echo</span> 水瓶座</span><br><span class="line"><span class="keyword">if</span> &quot;<span class="variable">%md%</span>&quot; <span class="keyword">GEQ</span> &quot;<span class="number">0219</span>&quot; <span class="keyword">if</span> &quot;<span class="variable">%md%</span>&quot; <span class="keyword">LEQ</span> &quot;<span class="number">0320</span>&quot; <span class="built_in">echo</span> 双鱼座</span><br><span class="line"><span class="keyword">if</span> &quot;<span class="variable">%md%</span>&quot; <span class="keyword">GEQ</span> &quot;<span class="number">0321</span>&quot; <span class="keyword">if</span> &quot;<span class="variable">%md%</span>&quot; <span class="keyword">LEQ</span> &quot;<span class="number">0419</span>&quot; <span class="built_in">echo</span> 白羊座</span><br><span class="line"><span class="keyword">if</span> &quot;<span class="variable">%md%</span>&quot; <span class="keyword">GEQ</span> &quot;<span class="number">0420</span>&quot; <span class="keyword">if</span> &quot;<span class="variable">%md%</span>&quot; <span class="keyword">LEQ</span> &quot;<span class="number">0520</span>&quot; <span class="built_in">echo</span> 金牛座</span><br><span class="line"><span class="keyword">if</span> &quot;<span class="variable">%md%</span>&quot; <span class="keyword">GEQ</span> &quot;<span class="number">0521</span>&quot; <span class="keyword">if</span> &quot;<span class="variable">%md%</span>&quot; <span class="keyword">LEQ</span> &quot;<span class="number">0621</span>&quot; <span class="built_in">echo</span> 双子座</span><br><span class="line"><span class="keyword">if</span> &quot;<span class="variable">%md%</span>&quot; <span class="keyword">GEQ</span> &quot;<span class="number">0622</span>&quot; <span class="keyword">if</span> &quot;<span class="variable">%md%</span>&quot; <span class="keyword">LEQ</span> &quot;<span class="number">0722</span>&quot; <span class="built_in">echo</span> 巨蟹座</span><br><span class="line"><span class="keyword">if</span> &quot;<span class="variable">%md%</span>&quot; <span class="keyword">GEQ</span> &quot;<span class="number">0723</span>&quot; <span class="keyword">if</span> &quot;<span class="variable">%md%</span>&quot; <span class="keyword">LEQ</span> &quot;<span class="number">0822</span>&quot; <span class="built_in">echo</span> 狮子座</span><br><span class="line"><span class="keyword">if</span> &quot;<span class="variable">%md%</span>&quot; <span class="keyword">GEQ</span> &quot;<span class="number">0823</span>&quot; <span class="keyword">if</span> &quot;<span class="variable">%md%</span>&quot; <span class="keyword">LEQ</span> &quot;<span class="number">0922</span>&quot; <span class="built_in">echo</span> 处女座</span><br><span class="line"><span class="keyword">if</span> &quot;<span class="variable">%md%</span>&quot; <span class="keyword">GEQ</span> &quot;<span class="number">0923</span>&quot; <span class="keyword">if</span> &quot;<span class="variable">%md%</span>&quot; <span class="keyword">LEQ</span> &quot;<span class="number">1023</span>&quot; <span class="built_in">echo</span> 天秤座</span><br><span class="line"><span class="keyword">if</span> &quot;<span class="variable">%md%</span>&quot; <span class="keyword">GEQ</span> &quot;<span class="number">1024</span>&quot; <span class="keyword">if</span> &quot;<span class="variable">%md%</span>&quot; <span class="keyword">LEQ</span> &quot;<span class="number">1122</span>&quot; <span class="built_in">echo</span> 天蝎座</span><br><span class="line"><span class="keyword">if</span> &quot;<span class="variable">%md%</span>&quot; <span class="keyword">GEQ</span> &quot;<span class="number">1123</span>&quot; <span class="keyword">if</span> &quot;<span class="variable">%md%</span>&quot; <span class="keyword">LEQ</span> &quot;<span class="number">1222</span>&quot; <span class="built_in">echo</span> 射手座</span><br><span class="line"><span class="keyword">if</span> &quot;<span class="variable">%md%</span>&quot; <span class="keyword">GEQ</span> &quot;<span class="number">0321</span>&quot; <span class="keyword">if</span> &quot;<span class="variable">%md%</span>&quot; <span class="keyword">LEQ</span> &quot;<span class="number">0419</span>&quot; <span class="built_in">echo</span> 白羊座</span><br><span class="line"><span class="keyword">if</span> &quot;<span class="variable">%md%</span>&quot; <span class="keyword">GEQ</span> &quot;<span class="number">1222</span>&quot; <span class="built_in">echo</span> 魔蝎座</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> scanf</span><br></pre></td></tr></table></figure><p>bat可以取出字符串的一部分为变量赋值，然后再对变量的值进行判断。运行之后应该就可以看到结果了。</p><h2 id="实验结果">实验结果</h2><p>这里是任务完成后的截图或其他证明。</p><p><strong>任务一：增加系统调用</strong></p><p>执行实验过程中的实例代码，使用<code>dmesg -c</code>命令可以获得以下输出：</p><figure><img src="https://i.loli.net/2020/03/08/Ph31fzT67LRHUqs.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/03/08/Ph31fzT67LRHUqs.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="屏幕截图_61_.jpg" /><figcaption aria-hidden="true">屏幕截图_61_.jpg</figcaption></figure><p>可以看到已经在内核缓冲区输出了系统调用中的字符串了。</p><p><strong>任务二：安装新内核</strong></p><p>下图是安装新内核之后使用<code>screenfetch</code>命令看到的输出：</p><figure><img src="https://i.loli.net/2020/03/08/ySPFAD9TOmkUj7l.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/03/08/ySPFAD9TOmkUj7l.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="屏幕截图_33_.jpg" /><figcaption aria-hidden="true">屏幕截图_33_.jpg</figcaption></figure><p>内核版本已经由默认的 5.3.4 变成了 5.3.10，说明新内核已经成功使用了。</p><p><strong>任务三：脚本编程</strong></p><p>使用<code>Read-Host</code>的 Powershell 脚本：</p><figure><img src="https://i.loli.net/2020/03/16/hIzPvTaZx9YSLuA.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/03/16/hIzPvTaZx9YSLuA.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="__OWFP_BLXG_A2FQFD_I3ZE.jpg" /><figcaption aria-hidden="true">__OWFP_BLXG_A2FQFD_I3ZE.jpg</figcaption></figure><p>使用 .NET 框架提供窗口的 Powershell 脚本：</p><figure><img src="https://i.loli.net/2020/05/13/QvNWAkzdPR2hlBM.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/13/QvNWAkzdPR2hlBM.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1_3_1.png" /><figcaption aria-hidden="true">1_3_1.png</figcaption></figure><p>输入内容后会得到和第一张图一样的输出。需要特别注意的是：一般的家用版本的 Windows 10 自带的 Powershell 是不允许直接加载<code>ps1</code>脚本的，需要先行修改运行策略。修改的脚本如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-ExecutionPolicy -Scope CurrentUser RemoteSigned</span><br></pre></td></tr></table></figure><p>最后是 BAT 批处理脚本“算命大师”的运行结果：</p><figure><img src="https://i.loli.net/2020/05/13/4VKE8CQbrk6U5dA.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/13/4VKE8CQbrk6U5dA.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1_3_0.png" /><figcaption aria-hidden="true">1_3_0.png</figcaption></figure><p>可以看到基本功能已经实现并且正常工作。</p><h2 id="体会">体会</h2><p>通过这次实验，我熟悉了Linux内核的应用过程，对Linux命令的理解更进一步；更加生动的理解了系统调用的概念以及Linux操作系统从POST开始之后的启动过程；熟悉了 Powershell 脚本编程，以及基于这项技术的简单开发和部分 .NET API 的使用；</p><p>对于受众较小的 Arch Linux 操作系统，比起在网络上漫无目的的查找论坛、博客，不如认真研读官方文档的 trouble-shooting 以及对一些问题可能原因的分析和解释。不仅可以对解决问题带来更加精准的帮助，还可以拓宽我们看待问题的视野。</p>]]></content>
      
      
      <categories>
          
          <category> 课业 </category>
          
          <category> 操作系统 </category>
          
          <category> Windows </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 课内作业 </tag>
            
            <tag> 实验报告 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统原理：第 3 次上机实验报告</title>
      <link href="/2020/class-FoDOS-experiment-3/"/>
      <url>/2020/class-FoDOS-experiment-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>操作系统原理的上机实验的报告一共有四个，其他的报告的地址是：</p><p>第一次：<a href="https://shiraha.cn/2020/class-FoDOS-experiment-1/" class="uri">https://shiraha.cn/2020/class-FoDOS-experiment-1/</a><br />第二次：<a href="https://shiraha.cn/2020/class-FoDOS-experiment-2/" class="uri">https://shiraha.cn/2020/class-FoDOS-experiment-2/</a><br />第三次：<a href="https://shiraha.cn/2020/class-FoDOS-experiment-3/" class="uri">https://shiraha.cn/2020/class-FoDOS-experiment-3/</a><br />第四次：<a href="https://shiraha.cn/2020/class-FoDOS-experiment-4/" class="uri">https://shiraha.cn/2020/class-FoDOS-experiment-4/</a></p></blockquote><h2 id="front-matter">Front-matter</h2><p>本次实验的所有源代码可以在<a href="https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job?path=%2Fosnmb%2Fexp" class="uri">https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job?path=%2Fosnmb%2Fexp</a> 查看到。</p><h2 id="实验要求">实验要求</h2><p>本次上机实验的实验要求如下：</p><blockquote>#####<center>《操作系统原理》第三次上机实验</center><p><strong>一、实验目的</strong></p><ol type="1"><li>理解线程/进程的通信机制和编程；</li><li>理解线程/进程的死锁概念和如何解决死锁；</li></ol><p><strong>二、实验内容</strong></p><ol type="1"><li>在 Ubuntu 或 Fedora 环境创建一对父子进程，使用共享内存的方式实现进程间的通信。父进程提供数据（1-100，递增），子进程读出来并显示</li><li>（考虑信号通信机制）在 Ubuntu 或 Fedora 环境创建父子 2 个进程 A，B。进程 A 不断获取用户从键盘输入的字符串或整数，通过信号机制传给进程 B。如果输入的是字符串，进程 B 将其打印出来；如果输入的是整数，进程 B 将其累加起来，并输出该数和累加和。当累加和大于 100 时结束子进程，子进程输出“My work done！”后结束，然后父进程也结束。</li><li>在 windows 环境使用创建一对父子进程，使用管道（pipe）的方式实现进程间的通信。父进程提供数据（1-100，递增），子进程读出来并显示。</li><li>（考虑匿名管道通信）在 windows 环境下创建将 CMD 控制台程序封装为标准的 windows 窗口程序。</li><li>在 windows 环境下，利用高级语言编程环境（限定为 VS 环境或 VC 环境或QT）调用 CreateThread 函数哲学家就餐问题的演示。要求：<ol type="1"><li>提供死锁的解法和非死锁的解法；</li><li>有图形界面直观显示哲学家取筷子，吃饭，放筷子，思考等状态。</li><li>为增强结果的随机性，各个状态之间的维持时间采用随机时间，例如100ms-500ms 之间。</li></ol></li></ol><p>在上述任务中： [1,3,4]中任意 1 题和第2,5 题，共计 3 道题。</p></blockquote><p>我选择了 1、2、5 三个题目。</p><h2 id="实验内容">实验内容</h2><ol type="1"><li>在 Ubuntu 或 Fedora 环境创建一对父子进程，使用共享内存的方式实现进程间的通信。父进程提供数据（1-100，递增），子进程读出来并显示</li><li>（考虑信号通信机制）在 Ubuntu 或 Fedora 环境创建父子 2 个进程 A，B。进程 A 不断获取用户从键盘输入的字符串或整数，通过信号机制传给进程 B。如果输入的是字符串，进程 B 将其打印出来；如果输入的是整数，进程 B 将其累加起来，并输出该数和累加和。当累加和大于 100 时结束子进程，子进程输出“My work done！”后结束，然后父进程也结束。</li><li>在 windows 环境下，利用高级语言编程环境（限定为 VS 环境或 VC 环境或QT）调用 CreateThread 函数哲学家就餐问题的演示。要求：<ol type="1"><li>提供死锁的解法和非死锁的解法；</li><li>有图形界面直观显示哲学家取筷子，吃饭，放筷子，思考等状态。</li><li>为增强结果的随机性，各个状态之间的维持时间采用随机时间，例如100ms-500ms 之间。</li></ol></li></ol><h2 id="实验过程">实验过程</h2><p>下面是对于每一个任务的原理和过程的简述：</p><h3 id="共享内存">共享内存</h3><p>共享内存就是允许两个不相关的进程访问的同一个逻辑内存，是在两个正在运行的进程之间共享和传递数据的一种方式。进程之间共享的内存通常为同一段物理内存，并且可以将同一段共享内存连接到进程自己的地址空间中，所有进程都可以访问共享内存中的数据，并且可以进行修改；所做的改动将立即影响到可访问该共享内存的所有的其他进程。</p><p>共享内存并未提供同步机制；如果需要，可以配合其他机制（如信号量机制，需要使用 sem 家族的函数）来控制其他进程对于共享内存的同步访问。</p><p>在 Linux 下创建一个区域作为共享内存，需要用到 shm 系列函数；它们定义在<code>sys/shm.h</code>中，可以直接引入。在本次实验中，需要使用的这个系列的函数有：</p><p><code>shmget</code>函数：可以用来创建共享内存区域；声明式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><p>它所接受的参数的含义如下：</p><ol type="1"><li>标识共享内存的键值；当它取<code>IPC_PRIVATE</code>，或取 0 但是在第三个参数中设置了<code>IPC_PRIVATE</code>标志的时候，会创建一块新共享内存；当然也可以指定一个其他值，作为该 IPC 对象的名字，存储在<code>ipc_perm</code>结构中。因为在实际生产环境中难以约定一个唯一的键值，所以可以设置为<code>IPC_PRIVATE</code>让操作系统指定。</li><li>指定了共享内存的长度；实际获得的空间总是系统页面大小的倍数，因为 Linux 总是以页作为内存分配调度的最小单位。</li><li>是共享内存读写权限的标志；和在 Linux 中打开文件的权限标志是一样的，例如：当地一个参数指定的内存不存在的时候创建并打开，需要设置<code>IPC_CREAT</code>位；对应的还有<code>IPC_EXCL</code>，它仅在第一个参数指定的内存不存在时才可以正常创建打开；对于读写指定的标志时<code>SHM_R</code>和<code>SHM_W</code>，当然也可以直接用数字，比如 0660、0666、0644 等。</li></ol><p>这个函数如果出现错误会返回 -1，并且设置<code>errno</code>位；否则返回与第一个参数key相关的共享内存标识符，可以用于后续对于这块共享内存的处理。</p><p>创建共享内存之后，还需要对它进行访问，这需要<code>shmat</code>函数；at 是 attach 的意思；它的声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">const</span> <span class="keyword">void</span> *shm_addr, <span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><p>它所接受的参数的含义如下：</p><ol type="1"><li>共享内存的标识符，是<code>shmget</code>的返回值；</li><li>指定当前进程下映射到共享内存的地址；当这个值取 0，表示让操作系统选择共享内存所在的地址，这样操作系统将会自动为映射分配一块内存；如果这里制定了地址，还需要预先处理分配内存。映射地址可能不是整页，将根据第三个参数的值决定内存是否取整页。</li><li>标志位参数；如果指定了<code>SHM_RDONLY</code>，共享内存将被映射为只读的；如果指定<code>SHM_RND</code>，则将内存大小设定为页面的尺寸。</li></ol><p>如果成功，该函数将返回在当前进程的内存空间中，共享内存的映射地址；否则返回 -1，并且设置<code>errno</code>。</p><p>如果当前进程不再需要访问共享内存，则可以使用<code>shmdt</code>函数，dt 指 detach；该函数会使得共享内存和当前进程分离，但并不删除共享内存，只是当前进程无法访问；它的声明是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span>;</span><br></pre></td></tr></table></figure><p>接受的参数是共享内存映射到当前进程的指针地址，也就是<code>shmat</code>函数调用成功的返回值；该函数调用成功返回 0，否则返回 -1.</p><p><code>shmctl</code>可以用来控制共享内存，ctl 指的是control，和<code>semctl</code>一样；它的声明式是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id, <span class="keyword">int</span> command, struct shmid_ds *buf)</span></span>;</span><br></pre></td></tr></table></figure><p>它接受的参数的意义是这样的：</p><ol type="1"><li><p>是共享内存的标识符；是<code>shmget</code>的返回值；</p></li><li><p>代表将要采取的操作：取<code>IPC_STAT</code>代表尝试获得共享内存当前的关联值，将该值存入第三个参数指向的<code>shmid_ds</code>结构中；取<code>IPC_SET</code>代表尝试设置共享内存当前的关联值，当线程有足够的权限操作时就将第三个参数指向的结构中的值设置为当前共享内存的关联值；取<code>IPC_RMID</code>代表删除当前共享内存段，但是并不是立即删除，只是给它加上待删标志，直到所有的进程都和它断开连接后才会真正的删除。</p></li><li><p>指向<code>shmid_ds</code>结构的指针；它包含了共享内存模式和访问权限。它至少包含了下面的这些成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">uid_t</span> shm_perm.uid;</span><br><span class="line">    <span class="keyword">uid_t</span> shm_perm.gid;</span><br><span class="line">    <span class="keyword">mode_t</span> shm_perm.mode;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>返回 0 表示执行成功，否则返回 -1 并设置<code>errno</code>值。</p><p>这样，我们就可以通过使用这些函数建立共享内存供两个进程使用了。进程随时修改内存，并设置标志供其他进程读取；若另一个进程正在操作内存，那么可以设置标志位，让另一个进程进入阻塞状态直到标志位被放开。</p><h3 id="多线程传递数据">多线程传递数据</h3><p>考虑使用管道在进程之间通信；进程之间的管道通信具有下面的特点：</p><ul><li>管道只允许有血缘关系的进程之间通信——比如父子进程</li><li>管道的通信是单向的——如果需要双向通信，可以开设多个管道</li><li>管道内部保证同步机制——这保证了访问数据的一致性</li><li>管道和进程共存——进程关闭则端口关闭，所有进程关闭则管道销毁</li><li>管道通信是字节流——可以用来传输字节流数据</li></ul><p>管道包含两端，一个是读端，一个是写端；如果要创建的管道是匿名管道pipe（除此之外还有有名管道FIFO），则可以使用定义在<code>unistd.h</code>中的<code>pipe</code>函数创建。<code>pipe</code>函数的声明是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>接受的参数是一个包含两个整数的数组，是一个out参数：如果函数调用成功，将会在这个数组中存入两个文件标识符，表示了新创建的通道的读端和写端——[0]是读端，[1]是写端。管道对于进程而言就是一个打开的文件，可以使用<code>read</code>和<code>write</code>函数进行文件操作。如果函数成功执行将返回 0，否则返回 -1.</p><p>一般创建父子进程之间的匿名管道的步骤是：</p><ul><li>父进程创建一个匿名管道，得到管道两端的文件标识符</li><li>父进程使用<code>fork</code>创建子进程，子进程复制了父亲的文件标识符变量</li><li>父进程关闭一段，子进程关闭另一端（使用<code>close</code>）</li></ul><p>管道的实现是一个环形队列：数据从管道的一端流入，另一端流出，就实现了进程之间的通信</p><p>不论是什么方式进行的进程间通信，本质上都是不同进程可以看到一份同样的资源——在内核中开辟的一块缓冲区。不同的通信方式的区别只是这份公共资源提供的方式。既然管道本质是内核空间的缓冲区，它就有一个容量上限：这可以通过写端持续写入，读端不读取且不关闭读端来获得。</p><p>管道信息传输还存在特殊情况：</p><ol type="1"><li>读端开启，但是不读取；写端持续写入——当缓冲区被写满之后再次<code>write</code>会导致管道阻塞，直到管道有空位置时才可以继续写入；</li><li>写端开启，但是不写入；读端持续读入——当缓冲区无数据可读的时候再次<code>read</code>会导致管道阻塞，直到管道有新数据时才可以继续读取；</li><li>写端关闭，读端持续读入——当缓冲区无数据可读的时候会读取到<code>EOF</code>；</li><li>读端关闭，写端持续写入——当缓冲区写满之后会产生信号<code>SIGPIPE</code>，导致进程中止；</li></ol><p>简单地说，就是缓冲区占满会导致异常。</p><p>这样，我们就可以使用管道来进行进程间的通信，并且按照要求实现了。传输数据时可以在传输前判断输入的字符串的性质，随后提前通过管道传递一个信号给另一个进程说明数据类型，再传递数据。</p><p>在这个任务里，我在父亲进程中首先尝试对于读入的字符串进行转换：若不能完全转换为数字，则输入是字符串，先传递信号 0，再传递字符串占用的空间（<code>(strlen(s)+1)*sizeof(char)</code>）和字符串；否则，传递信号 1 之后再传递整形的大小，最后传递整数；子进程先通过读取的信号判断输出的方法，再通过读到的大小从管道里读取相应大小的字节流，执行对应的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (id &gt; <span class="number">0</span>)                 <span class="comment">// 這是父親進程</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">close</span>(rt[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, msg;</span><br><span class="line">    <span class="keyword">char</span> s[BUF_SIZE];</span><br><span class="line">    <span class="keyword">char</span> *sign;</span><br><span class="line">    <span class="keyword">int</span> flag, res;</span><br><span class="line">    <span class="built_in">write</span>(fd[<span class="number">1</span>], &amp;cnt, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">while</span> (cnt ++ &lt; <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;正在等待用戶的輸入……（輸入不要超過 &quot;</span></span><br><span class="line">             &lt;&lt; BUF_SIZE - <span class="number">1</span> &lt;&lt; <span class="string">&quot; 個字符）&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;父親進程收到了用戶輸入： &quot;</span> &lt;&lt; s &lt;&lt; <span class="built_in">flush</span>;</span><br><span class="line">        msg = (<span class="keyword">int</span>)strtol(s, &amp;sign, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span> (sign - s == <span class="built_in">strlen</span>(s))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;，您輸入的是一個數字&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">write</span>(fd[<span class="number">1</span>], &amp;flag, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">            <span class="built_in">write</span>(fd[<span class="number">1</span>], &amp;INT, <span class="keyword">sizeof</span>(INT));</span><br><span class="line">            <span class="built_in">write</span>(fd[<span class="number">1</span>], &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;，您輸入的是一個字符串&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">int</span> SIZE = CHAR * <span class="built_in">strlen</span>(s) + CHAR;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">write</span>(fd[<span class="number">1</span>], &amp;flag, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">            <span class="built_in">write</span>(fd[<span class="number">1</span>], &amp;SIZE, <span class="keyword">sizeof</span>(SIZE));</span><br><span class="line">            <span class="built_in">write</span>(fd[<span class="number">1</span>], s, SIZE);</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(SLEEP_TIME);</span><br><span class="line">        <span class="keyword">ssize_t</span> siz = <span class="built_in">read</span>(rt[<span class="number">0</span>], &amp;res, <span class="keyword">sizeof</span>(res));</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;收到子進程的信號： &quot;</span> &lt;&lt; res &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; siz &lt;&lt; <span class="string">&quot;)\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (~res &amp;&amp; res &lt;= TIME_MAX) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (res == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;收到來自子進程的信號，父親進程即將退出……&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;父親進程的工作完成了，即將退出……&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="number">0</span>)           <span class="comment">// 如果這是子進程</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">close</span>(rt[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> msg, j = <span class="number">0</span>, <span class="built_in">size</span>, flag, sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ss[BUF_SIZE];</span><br><span class="line">    <span class="built_in">read</span>(fd[<span class="number">0</span>], &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> offset = msg;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;子進程已經初始化，offset值是： &quot;</span> &lt;&lt; offset &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt; TIME_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">read</span>(fd[<span class="number">0</span>], &amp;flag, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">        <span class="keyword">ssize_t</span> s = <span class="built_in">read</span>(fd[<span class="number">0</span>], &amp;<span class="built_in">size</span>, <span class="keyword">sizeof</span>(<span class="built_in">size</span>));</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;消息的大小是： &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;，消息的類型是 &quot;</span></span><br><span class="line">             &lt;&lt; (flag ? <span class="string">&quot;int(&quot;</span> : <span class="string">&quot;string(&quot;</span>) &lt;&lt; <span class="built_in">size</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">read</span>(fd[<span class="number">0</span>], &amp;msg, <span class="keyword">sizeof</span>(msg));</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;收到了來自父親進程的消息： &quot;</span> &lt;&lt; msg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            sum += msg;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;纍加值當前已經纍計了： &quot;</span> &lt;&lt; sum</span><br><span class="line">                 &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; SUM_MAX &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= SUM_MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;纍加值達到要求，程序子進程退出……&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                j = <span class="number">-1</span>;</span><br><span class="line">                <span class="built_in">write</span>(rt[<span class="number">1</span>], &amp;j, <span class="keyword">sizeof</span>(j));</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">read</span>(fd[<span class="number">0</span>], ss, <span class="built_in">size</span>);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;收到了來自父親進程的消息： &quot;</span> &lt;&lt; ss &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++ j;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;這是子進程處理的第 &quot;</span> &lt;&lt; j &lt;&lt; <span class="string">&quot; 條消息&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">write</span>(rt[<span class="number">1</span>], &amp;j, <span class="keyword">sizeof</span>(j));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的是关于功能的具体实现的片段。包括了关闭管道的端口，缓冲区字符串类型判断和字节流信息传递。</p><h3 id="哲学家问题">哲学家问题</h3><blockquote><p>因为没有合适的素材，所以没有做图形界面，改用文件输出了。</p></blockquote><p>实现的伪代码已经在幻灯片里提到了，这里就不再展开详述了。</p><p>关于这个问题导致的死锁情况的分析：当一个哲学家已经拿起了左手边的筷子，准备拿起右手边筷子的时候，发现右手边的筷子被占用了，就会陷入阻塞，等待右手边的筷子释放后才能活动；但是于此同时，左边的那位哲学家可能也因为缺少右手边的筷子而陷入阻塞；这样推导下去就可能导致所有的哲学家陷入阻塞，即所谓死锁。</p><p>分析问题，发现该问题满足了死锁产生的四个条件：</p><ol type="1"><li>互斥条件：一个资源每次只能被一个线程/进程使用。</li><li>请求与保持条件：一个线程/进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：线程/进程已获得的资源，在未使用完之前，不能强行剥夺。</li><li>循环等待条件：若干线程/进程之间形成一种头尾相接的循环等待资源关系。</li></ol><p>解决死锁通常的思路是预防-避免-检测：具体的做法就是设置资源获取的协议，动态决定是否赋予资源，并且设定专门的机构来外力破坏死锁，使进程回复。</p><p>对于这种情况，避免死锁可以使用资源有序分配的方法来解决：首先我们通过交换第 0 号哲学家的左右手筷子的编码，这样就可以导致所有的哲学家左手的筷子编号都比右手的筷子编号大，破坏了上述死锁发生条件的循环等待条件，就通过预防的方式避免了死锁。</p><p>除此之外，当然可以从其他角度入手：使用信号量限制同时吃面条的人数，或者让哲学家等待之前先释放已经拿到的筷子，都可以解决这个死锁的问题。</p><p>至于程序的实现，可以采用 Windows 自带的 <code>CreateThread</code>函数和信号量机制；API 在之前的上机实验报告中已经提到过了，这里就不再赘述。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">philosopher</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> rm = randomMachine(<span class="number">100</span>, <span class="number">500</span>);</span><br><span class="line">    <span class="keyword">int</span> id = ++ cnt_id;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span> out = FILE_NAME + to_string(id) + TXT;</span><br><span class="line">    <span class="function">ofstream <span class="title">fout</span><span class="params">((PATH + out).c_str())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!fout)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;哲學家 &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;： 文件打開失敗！程序即將退出……&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> time, cnt = <span class="number">0</span>;</span><br><span class="line">    HANDLE right, left;</span><br><span class="line">    left = OpenSemaphore(SEMAPHORE_ALL_ACCESS, FALSE, chop[LeftHand]);</span><br><span class="line">    right = OpenSemaphore(SEMAPHORE_ALL_ACCESS, FALSE, chop[RightHand]);</span><br><span class="line">    <span class="keyword">while</span> (cnt ++ &lt;= TIME_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        time = rm();</span><br><span class="line">        fout &lt;&lt; getNowTime() &lt;&lt; <span class="string">&quot;： 哲學家 &quot;</span> &lt;&lt; id</span><br><span class="line">             &lt;&lt; <span class="string">&quot; 思考了 &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        Sleep(time);</span><br><span class="line">        time = rm();</span><br><span class="line">        fout &lt;&lt; getNowTime() &lt;&lt; <span class="string">&quot;： 哲學家 &quot;</span> &lt;&lt; id</span><br><span class="line">             &lt;&lt; <span class="string">&quot; 休息了 &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        Sleep(time);</span><br><span class="line">        WaitForSingleObject(left, INFINITE);</span><br><span class="line">        fout &lt;&lt; getNowTime() &lt;&lt; <span class="string">&quot;： 哲學家 &quot;</span> &lt;&lt; id</span><br><span class="line">             &lt;&lt; <span class="string">&quot; 拿起了左手邊的筷子 &quot;</span> &lt;&lt; LeftHand &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        WaitForSingleObject(right, INFINITE);</span><br><span class="line">        fout &lt;&lt; getNowTime() &lt;&lt; <span class="string">&quot;： 哲學家 &quot;</span> &lt;&lt; id</span><br><span class="line">             &lt;&lt; <span class="string">&quot; 拿起了右手邊的筷子 &quot;</span> &lt;&lt; RightHand  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        time = rm();</span><br><span class="line">        fout &lt;&lt; getNowTime() &lt;&lt; <span class="string">&quot;： 哲學家 &quot;</span> &lt;&lt; id</span><br><span class="line">             &lt;&lt; <span class="string">&quot; 用餐了 &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        Sleep(time);</span><br><span class="line">        ReleaseSemaphore(left, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">        fout &lt;&lt; getNowTime() &lt;&lt; <span class="string">&quot;： 哲學家 &quot;</span> &lt;&lt; id</span><br><span class="line">             &lt;&lt; <span class="string">&quot; 放下了左手邊的筷子 &quot;</span> &lt;&lt; LeftHand &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        ReleaseSemaphore(right, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">        fout &lt;&lt; getNowTime() &lt;&lt; <span class="string">&quot;： 哲學家 &quot;</span> &lt;&lt; id</span><br><span class="line">             &lt;&lt; <span class="string">&quot; 放下了右手邊的筷子 &quot;</span> &lt;&lt; RightHand  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;模擬測試達到最大次數，進程將要退出……&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout.<span class="built_in">close</span>();</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是单个哲学家进程的进程函数，被<code>CreateThread</code>函数创建多个同样的进程。</p><h2 id="实验结果">实验结果</h2><p>这里是任务完成后的截图或其他证明。</p><p><strong>任务一：共享内存</strong></p><p>下面是在 WSL 终端下执行代码的部分输出：</p><figure><img src="https://i.loli.net/2020/05/13/CujbrGdmfED8xHW.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/13/CujbrGdmfED8xHW.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="3_1.png" /><figcaption aria-hidden="true">3_1.png</figcaption></figure><p>编译源代码并执行之后，终端会先输出父亲进程的输出，随后自动输出儿子进程的输出。效果如上图所示。</p><p><strong>任务二：管道通信</strong></p><p>在 WSL-CLion 环境下执行源代码可以获得以下输出：绿色代表<code>stdin</code>，白色代表<code>stdout</code>，红色代表<code>stderr</code>。</p><figure><img src="https://i.loli.net/2020/05/13/WJa7R8iOpymb3ke.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/13/WJa7R8iOpymb3ke.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="3_2.png" /><figcaption aria-hidden="true">3_2.png</figcaption></figure><p>子进程受到信息之后可以对于数字进行累加，并且正常输出父进程传入的字符串；当达到累加目标后，通过另一个管道向父亲进程发送终止信号，程序父进程退出而不是继续等待输入。</p><p><strong>任务三：哲学家就餐</strong></p><p>这是五个哲学家向不同文件输出日志中的一个的部分：</p><figure><img src="https://i.loli.net/2020/05/13/DyoubQRPO2Cdhjs.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/13/DyoubQRPO2Cdhjs.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="3_5.png" /><figcaption aria-hidden="true">3_5.png</figcaption></figure><p>每条日志之前包含了时间轴，可以使用其他程序处理成一个文件。</p><h2 id="体会">体会</h2><p>通过本次操作系统原理的上机实验，我更加熟练了在之前的实验中使用的在 Windows / Linux 平台上的多线程编程的能力。并了解到了使用一些方法可以实现在进程之中通信，对于内存空间和通信机制有了更加深刻的理解。可以使用所学的 API 完成在进程之间的简单通信。</p><p>哲学家就餐问题的模拟过程，让我亲身体会了从死锁产生的原因入手想方设法避免死锁产生的过程，更加深了我对于死锁产生的条件以及针对于这些条件的一些解决措施的理解和感受。</p>]]></content>
      
      
      <categories>
          
          <category> 课业 </category>
          
          <category> 操作系统 </category>
          
          <category> Windows </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 课内作业 </tag>
            
            <tag> 实验报告 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统原理：第 4 次上机实验报告</title>
      <link href="/2020/class-FoDOS-experiment-4/"/>
      <url>/2020/class-FoDOS-experiment-4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>操作系统原理的上机实验的报告一共有四个，其他的报告的地址是：</p><p>第一次：<a href="https://shiraha.cn/2020/class-FoDOS-experiment-1/" class="uri">https://shiraha.cn/2020/class-FoDOS-experiment-1/</a><br />第二次：<a href="https://shiraha.cn/2020/class-FoDOS-experiment-2/" class="uri">https://shiraha.cn/2020/class-FoDOS-experiment-2/</a><br />第三次：<a href="https://shiraha.cn/2020/class-FoDOS-experiment-3/" class="uri">https://shiraha.cn/2020/class-FoDOS-experiment-3/</a><br />第四次：<a href="https://shiraha.cn/2020/class-FoDOS-experiment-4/" class="uri">https://shiraha.cn/2020/class-FoDOS-experiment-4/</a></p></blockquote><h2 id="front-matter">Front-matter</h2><p>本次实验的所有源代码可以在<a href="https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job?path=%2Fosnmb%2Fexp" class="uri">https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job?path=%2Fosnmb%2Fexp</a> 查看到。</p><h2 id="实验要求">实验要求</h2><p>本次上机实验的实验要求如下：</p><blockquote>#####<center>《操作系统原理》第二次上机实验</center><p><strong>一、实验目的</strong></p><ol type="1"><li>理解页面淘汰算法原理，编写程序演示页面淘汰算法；</li><li>验证 Linux 虚拟地址转化为物理地址的机制；</li><li>理解和验证程序运行局部性的原理；</li></ol><p><strong>二、实验内容</strong></p><ol type="1"><li>在 Windows 环境下编写一个程序，模拟实现 OPT, FIFO, LRU 等页面淘汰算法。可以使用数组模拟内存，数组中的元素模拟为指令或数据。写不同方式的程序去访问数组来模拟 CPU 访问内存的情况。分析运算结果，在分配不同的物理块情况下， 各算法的缺页情况有什么规律？可以 <code>srand()</code> 和 <code>rand()</code> 等函数定义和产生“指令”序列，然后将指令序列变换成相应的页地址流，并针对不同的算法计算出相应的命中率。 例如，实验中可以产生 320 条“指令”，每个“虚拟页”存放 10 条指令。 进程分配的页框是 4（可变，例如 32）。<ol start="2" type="1"><li>在 Linux 环境下，编写一个小程序，获取该程序中的某个变量的虚拟地址，虚拟页号，页内偏移地址，物理页框号，页内偏移地址，物理地址，并将它们打 印出来。建议使用 /proc/pid/pagemap 技术。</li></ol></li><li>在 Windows 环境下，编写一个函数（特点：比较耗时，比如大型的多维数组读写），用不同的方法测试其所花费的时间。在不同环境下比较其时间是否不同，并分析其含义。测量时间的函数请 baidu。</li></ol><p>实验指南：参考网络，课件等。</p></blockquote><h2 id="实验内容">实验内容</h2><ol type="1"><li>在 Windows 环境下编写一个程序，模拟实现 OPT, FIFO, LRU 等页面淘汰算法。可以使用数组模拟内存，数组中的元素模拟为指令或数据。写不同方式的程序去访问数组来模拟 CPU 访问内存的情况。分析运算结果，在分配不同的物理块情况下， 各算法的缺页情况有什么规律？可以 <code>srand()</code> 和 <code>rand()</code> 等函数定义和产生“指令”序列，然后将指令序列变换成相应的页地址流，并针对不同的算法计算出相应的命中率。 例如，实验中可以产生 320 条“指令”，每个“虚拟页”存放 10 条指令。 进程分配的页框是 4（可变，例如 32）。</li><li>在 Linux 环境下，编写一个小程序，获取该程序中的某个变量的虚拟地址，虚拟页号，页内偏移地址，物理页框号，页内偏移地址，物理地址，并将它们打 印出来。建议使用 /proc/pid/pagemap 技术。</li><li>在 Windows 环境下，编写一个函数（特点：比较耗时，比如大型的多维数组读写），用不同的方法测试其所花费的时间。在不同环境下比较其时间是否不同，并分析其含义。测量时间的函数请 baidu。</li></ol><h2 id="实验过程">实验过程</h2><p>下面是对于每一个任务的原理和过程的简述：</p><h3 id="算法模拟">算法模拟</h3><p>要想完成这个任务，有两个问题需要解决：应该怎么模拟内存和指令？这些算法应该怎么实现？</p><p>现代计算机采用的大多是段页式内存管理，可以平衡达到不错的性能，这里就不展开详细介绍了（毕竟还要扯到好多别的东西）。简单的建模大概就是：我们有一个物理内存，按照页框分好了页。这里先不管那些用来维护这些信息的辅助空间，只关注存储了实际数据的空间；因为内存算法的目的就是让小内存尽可能运行需要内存较多的程序，所以还要有一个虚拟内存空间：它至少比物理内存要大；此外抽象每条指令都是需要内存中的一个确定页面的数据——这也没有什么问题，当然这个内存是虚拟内存。</p><p>这样，我们就可以开设代表物理内存的数组，并且存储了一些虚拟内存中的数据页面；假设所有的指令（毕竟二进制的情况下，指令就是数据，数据也是指令；为了模型更加清晰和直观，我们将命令和数据分离；假设所有指令都占用极小内存并且不占用数据段，数据分页并载入数据段的虚拟内存空间）都是需要数据段的某一页数据；那么，当指令需要的数据页面在物理空间内时命中，否则缺页。</p><p>接下来就是算法部分了。首先是 OPT：它代表着理想中的最佳情况，在现实计算机中不可能被达成。这是因为它的实现过程中，需要“预知未来”的指令才可以做出最优判断，有些动态规划的思想。称它为“离线算法”比较合适，但是在现实计算机的“强制要求在线”的环境下，并不能实现这样的算法。</p><p>OPT 本质上在替换物理内存中的虚拟页的时候，会根据对未来指令的“观测”，找到当前物理内存中持有的距离下次调用最久远的内存页进行替换——这样做的最优性是显然的。在实现的过程中，我们可以开设一个长度等于指令全长度的数组，从后向前进行一次扫描，将每一个指令的下一次执行的时间戳记录下来；开始模拟后只需要对数组进行 O(1) 访问就可以知道下一次调用该页面的时间戳了。</p><p>FIFO 就显得非常的简单粗暴：它认为所有的数据页面被指令访问到的机会是“均等”的——这样就可以得到一个显然的结论，即先进入内存（被访问）的内存页下次被指令使用的可能性更小，所以在替换的时候会优先的替换掉这些先进入物理内存的数据页面。</p><p>FIFO 的实现也非常的简单：我们假设将数据载入内存的时候是按某个顺序进行的，在替换的过程中我们只需要遵循这个顺序找到下一个要被替换掉的内存块就可以了；具体的说是开一个静态变量记录上次置换的页面的物理页框编号，之后的替换就是对于这个页框增加一就可以了。</p><p>LRU 是这几个算法中最为平衡的一个算法：不仅具有可行性，而且也可以保证较好的命中率；此外基于这个算法还可以进行一些数据结构上的调整，增加优先级和队列的设计，让它的命中率更高（当然，相对的运算代价也会增大）。但是因为这次上机实验没有要求，这里就不再赘述了。和 FIFO 不同，LRU 算法认为如果一个内存页面在最近被访问过，那么它在较短时间内被再次访问的概率会比其他页面更高。所以相对地，需要淘汰的页面是物理内存中最久没有被访问过的页面。这样的算法其实更加符合人们的生活常识，事实上它确实在一般情况下可以带来比起 FIFO 算法更高的命中率。</p><p>在 LRU 实现的过程中，我们可以维护一个链表——它维持了当前物理内存中所有的页面；每当需要卸载一个页面的时候，我们从队尾取出一个物理页框，将它与新数据页置换；当载入一个新的数据页的时候，我们将它放入的物理页框作为一个节点加入到链表的队首；当访问一个物理内存中已经载入的页面的时候，我们将它从链表中原位置取出，并放置在链表队首。</p><p>根据上面的分析，我们可以显然得出这个链表占用的空间（长度）不会超过物理内存页框的数量，所以为了避免开节点/删节点频繁的内存访问，可以使用“对象池”技术进行优化。但是在我公开的代码里，我为了更加直观的展现这个过程，并没有采用这种设计模式。</p><p>在算法正确性测试的过程中，我特别采用了<code>&#123;7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1&#125;</code>这组数据；这是来源于网络上的<a href="https://blog.csdn.net/qq_37283570/article/details/79063441">参考资料</a>中的数据，该博主给出了这组数据在这三种算法下的内存快照以供对比，可以验证我的算法的正确性。</p><figure><img src="https://i.loli.net/2020/05/12/ZMDWi4bnCcjd9oP.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/12/ZMDWi4bnCcjd9oP.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="4_1.png" /><figcaption aria-hidden="true">4_1.png</figcaption></figure><p>可以在实验结果部分看到完整的程序输出。</p><p>在验证完正确性之后，为了方便之后的测试，我将整个测试流程提出作为接口；在我的源代码中可以看到它的定义以及使用方法，这里不再赘述；为了测试不同的算法在不同的物理内存/虚拟内存比率下的缺页率，我调用了这个接口创建了一组测试，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dword institute[<span class="number">400</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> opt = new_process(i * <span class="number">4</span>, <span class="number">32</span>, <span class="number">320</span>, institute, OPT, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">auto</span> fifo = new_process(i * <span class="number">4</span>, <span class="number">32</span>, <span class="number">320</span>, institute, FIFO);</span><br><span class="line">    <span class="keyword">auto</span> lru = new_process(i * <span class="number">4</span>, <span class="number">32</span>, <span class="number">320</span>, institute, LRU);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;物理内存 &quot;</span> &lt;&lt; i * <span class="number">4</span> &lt;&lt; <span class="string">&quot;，虚拟内存 32，命中率：\t&quot;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;\t\tOPT = &quot;</span> &lt;&lt; opt</span><br><span class="line">         &lt;&lt; <span class="string">&quot;\t\tFIFO = &quot;</span> &lt;&lt; fifo</span><br><span class="line">         &lt;&lt; <span class="string">&quot;\t\tLRU = &quot;</span> &lt;&lt; lru</span><br><span class="line">         &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将这段代码粘贴到公开的源代码的指定位置进行测试，可以获得输出。</p><h3 id="检查-linux-变量">检查 Linux 变量</h3><p>本任务的实验原理在操作系统原理的课堂上都有介绍，这里不再详细介绍；大体步骤是：</p><ul><li>使用<code>getpagesize</code>获得系统设定的页框大小，将指针类型转换为<code>ulong</code>获得虚拟地址；</li><li>虚拟地址整除页面大小可以得到虚拟页框号，取余数可以得到页框内的偏移地址；</li><li>打开<code>/proc/self/pagemap</code>文件，找到对应项的起始位置，读取并记录该值；</li><li>取上一步获得的项值的 0-55 位，其意义是变量的物理页框号，加上偏移地址就是物理地址；</li></ul><p>将上述的过程写成 C++ 代码并输出指定的结果，本任务就完成了。</p><p>源代码已经公开，实验结果请参见“实验结果”部分。</p><h3 id="检查函数运行时间">检查函数运行时间</h3><p>对于 Windows 平台，C++ 环境下，测量时间的方法可以分为以下三类：</p><ul><li>C++ 标准库提供的方法：<code>time</code>、<code>clock</code>、<code>std::chrono</code></li><li>Windows 提供的系统调用：<code>QueryPerformanceCounter</code>、<code>GetTickCount</code>、<code>timeGetTime</code></li><li>硬件平台提供的指令：<code>__asm&#123;_emit 0x0F;_emit 0x31;&#125;</code></li></ul><p>内联汇编比较的不靠谱，<code>timeGetTime</code>所需要的<code>WinMM.Lib</code>甚至不被包含在基础的 Windows SDK 内；所以选择剩下的五种方法予以实现。</p><p>源代码已经公开，实验结果请参见“实验结果”部分。</p><h2 id="实验结果">实验结果</h2><p>这里是任务完成后的截图或其他证明，包含一些对实验结果的解释。</p><p><strong>任务一：内存淘汰算法</strong></p><p>这是测试数据使用三种算法执行后内存快照的输出，可以确保算法的正确性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br></pre></td><td class="code"><pre><span class="line">D:\Workspaces\ClionProjects\osnmb\cmake-build-debug\osnmb.exe</span><br><span class="line">實驗： Windows 下的頁面淘汰算法模擬</span><br><span class="line"></span><br><span class="line">基礎測試：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">最佳置換算法（OPT）：</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理幀虛擬頁載入時間最後使用</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 0 條指令進行内存訪問： 虛擬頁[7]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0] * 700</span><br><span class="line">物理頁[1]   INVALIDINVALIDINVALID</span><br><span class="line">物理頁[2]   INVALIDINVALIDINVALID</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 1 條指令進行内存訪問： 虛擬頁[0]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   700</span><br><span class="line">物理頁[1] * 011</span><br><span class="line">物理頁[2]   INVALIDINVALIDINVALID</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 2 條指令進行内存訪問： 虛擬頁[1]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   700</span><br><span class="line">物理頁[1]   011</span><br><span class="line">物理頁[2] * 122</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 3 條指令進行内存訪問： 虛擬頁[2]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0] * 233</span><br><span class="line">物理頁[1]   011</span><br><span class="line">物理頁[2]   122</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 4 條指令進行内存訪問： 虛擬頁[0]狀態：命中</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   233</span><br><span class="line">物理頁[1] * 014</span><br><span class="line">物理頁[2]   122</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 5 條指令進行内存訪問： 虛擬頁[3]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   233</span><br><span class="line">物理頁[1]   014</span><br><span class="line">物理頁[2] * 355</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 6 條指令進行内存訪問： 虛擬頁[0]狀態：命中</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   233</span><br><span class="line">物理頁[1] * 016</span><br><span class="line">物理頁[2]   355</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 7 條指令進行内存訪問： 虛擬頁[4]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   233</span><br><span class="line">物理頁[1] * 477</span><br><span class="line">物理頁[2]   355</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 8 條指令進行内存訪問： 虛擬頁[2]狀態：命中</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0] * 238</span><br><span class="line">物理頁[1]   477</span><br><span class="line">物理頁[2]   355</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 9 條指令進行内存訪問： 虛擬頁[3]狀態：命中</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   238</span><br><span class="line">物理頁[1]   477</span><br><span class="line">物理頁[2] * 359</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 10 條指令進行内存訪問： 虛擬頁[0]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   238</span><br><span class="line">物理頁[1] * 01010</span><br><span class="line">物理頁[2]   359</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 11 條指令進行内存訪問： 虛擬頁[3]狀態：命中</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   238</span><br><span class="line">物理頁[1]   01010</span><br><span class="line">物理頁[2] * 3511</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 12 條指令進行内存訪問： 虛擬頁[2]狀態：命中</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0] * 2312</span><br><span class="line">物理頁[1]   01010</span><br><span class="line">物理頁[2]   3511</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 13 條指令進行内存訪問： 虛擬頁[1]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   2312</span><br><span class="line">物理頁[1]   01010</span><br><span class="line">物理頁[2] * 11313</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 14 條指令進行内存訪問： 虛擬頁[2]狀態：命中</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0] * 2314</span><br><span class="line">物理頁[1]   01010</span><br><span class="line">物理頁[2]   11313</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 15 條指令進行内存訪問： 虛擬頁[0]狀態：命中</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   2314</span><br><span class="line">物理頁[1] * 01015</span><br><span class="line">物理頁[2]   11313</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 16 條指令進行内存訪問： 虛擬頁[1]狀態：命中</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   2314</span><br><span class="line">物理頁[1]   01015</span><br><span class="line">物理頁[2] * 11316</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 17 條指令進行内存訪問： 虛擬頁[7]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0] * 71717</span><br><span class="line">物理頁[1]   01015</span><br><span class="line">物理頁[2]   11316</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 18 條指令進行内存訪問： 虛擬頁[0]狀態：命中</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   71717</span><br><span class="line">物理頁[1] * 01018</span><br><span class="line">物理頁[2]   11316</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 19 條指令進行内存訪問： 虛擬頁[1]狀態：命中</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   71717</span><br><span class="line">物理頁[1]   01018</span><br><span class="line">物理頁[2] * 11319</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">命中率： 0.55</span><br><span class="line"></span><br><span class="line">隊列置換算法（FIFO）：</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理幀虛擬頁載入時間最後使用</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 0 條指令進行内存訪問： 虛擬頁[7]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0] * 700</span><br><span class="line">物理頁[1]   INVALIDINVALIDINVALID</span><br><span class="line">物理頁[2]   INVALIDINVALIDINVALID</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 1 條指令進行内存訪問： 虛擬頁[0]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   700</span><br><span class="line">物理頁[1] * 011</span><br><span class="line">物理頁[2]   INVALIDINVALIDINVALID</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 2 條指令進行内存訪問： 虛擬頁[1]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   700</span><br><span class="line">物理頁[1]   011</span><br><span class="line">物理頁[2] * 122</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 3 條指令進行内存訪問： 虛擬頁[2]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0] * 233</span><br><span class="line">物理頁[1]   011</span><br><span class="line">物理頁[2]   122</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 4 條指令進行内存訪問： 虛擬頁[0]狀態：命中</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   233</span><br><span class="line">物理頁[1] * 014</span><br><span class="line">物理頁[2]   122</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 5 條指令進行内存訪問： 虛擬頁[3]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   233</span><br><span class="line">物理頁[1] * 355</span><br><span class="line">物理頁[2]   122</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 6 條指令進行内存訪問： 虛擬頁[0]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   233</span><br><span class="line">物理頁[1]   355</span><br><span class="line">物理頁[2] * 066</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 7 條指令進行内存訪問： 虛擬頁[4]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0] * 477</span><br><span class="line">物理頁[1]   355</span><br><span class="line">物理頁[2]   066</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 8 條指令進行内存訪問： 虛擬頁[2]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   477</span><br><span class="line">物理頁[1] * 288</span><br><span class="line">物理頁[2]   066</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 9 條指令進行内存訪問： 虛擬頁[3]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   477</span><br><span class="line">物理頁[1]   288</span><br><span class="line">物理頁[2] * 399</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 10 條指令進行内存訪問： 虛擬頁[0]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0] * 01010</span><br><span class="line">物理頁[1]   288</span><br><span class="line">物理頁[2]   399</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 11 條指令進行内存訪問： 虛擬頁[3]狀態：命中</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   01010</span><br><span class="line">物理頁[1]   288</span><br><span class="line">物理頁[2] * 3911</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 12 條指令進行内存訪問： 虛擬頁[2]狀態：命中</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   01010</span><br><span class="line">物理頁[1] * 2812</span><br><span class="line">物理頁[2]   3911</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 13 條指令進行内存訪問： 虛擬頁[1]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   01010</span><br><span class="line">物理頁[1] * 11313</span><br><span class="line">物理頁[2]   3911</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 14 條指令進行内存訪問： 虛擬頁[2]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   01010</span><br><span class="line">物理頁[1]   11313</span><br><span class="line">物理頁[2] * 21414</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 15 條指令進行内存訪問： 虛擬頁[0]狀態：命中</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0] * 01015</span><br><span class="line">物理頁[1]   11313</span><br><span class="line">物理頁[2]   21414</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 16 條指令進行内存訪問： 虛擬頁[1]狀態：命中</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   01015</span><br><span class="line">物理頁[1] * 11316</span><br><span class="line">物理頁[2]   21414</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 17 條指令進行内存訪問： 虛擬頁[7]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0] * 71717</span><br><span class="line">物理頁[1]   11316</span><br><span class="line">物理頁[2]   21414</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 18 條指令進行内存訪問： 虛擬頁[0]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   71717</span><br><span class="line">物理頁[1] * 01818</span><br><span class="line">物理頁[2]   21414</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 19 條指令進行内存訪問： 虛擬頁[1]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   71717</span><br><span class="line">物理頁[1]   01818</span><br><span class="line">物理頁[2] * 11919</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">命中率： 0.25</span><br><span class="line"></span><br><span class="line">最近最久未使用置換算法（LRU）：</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理幀虛擬頁載入時間最後使用</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 0 條指令進行内存訪問： 虛擬頁[7]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0] * 700</span><br><span class="line">物理頁[1]   INVALIDINVALIDINVALID</span><br><span class="line">物理頁[2]   INVALIDINVALIDINVALID</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 1 條指令進行内存訪問： 虛擬頁[0]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   700</span><br><span class="line">物理頁[1] * 011</span><br><span class="line">物理頁[2]   INVALIDINVALIDINVALID</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 2 條指令進行内存訪問： 虛擬頁[1]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   700</span><br><span class="line">物理頁[1]   011</span><br><span class="line">物理頁[2] * 122</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 3 條指令進行内存訪問： 虛擬頁[2]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0] * 233</span><br><span class="line">物理頁[1]   011</span><br><span class="line">物理頁[2]   122</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 4 條指令進行内存訪問： 虛擬頁[0]狀態：命中</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   233</span><br><span class="line">物理頁[1] * 014</span><br><span class="line">物理頁[2]   122</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 5 條指令進行内存訪問： 虛擬頁[3]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   233</span><br><span class="line">物理頁[1]   014</span><br><span class="line">物理頁[2] * 355</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 6 條指令進行内存訪問： 虛擬頁[0]狀態：命中</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   233</span><br><span class="line">物理頁[1] * 016</span><br><span class="line">物理頁[2]   355</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 7 條指令進行内存訪問： 虛擬頁[4]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0] * 477</span><br><span class="line">物理頁[1]   016</span><br><span class="line">物理頁[2]   355</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 8 條指令進行内存訪問： 虛擬頁[2]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   477</span><br><span class="line">物理頁[1]   016</span><br><span class="line">物理頁[2] * 288</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 9 條指令進行内存訪問： 虛擬頁[3]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   477</span><br><span class="line">物理頁[1] * 399</span><br><span class="line">物理頁[2]   288</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 10 條指令進行内存訪問： 虛擬頁[0]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0] * 01010</span><br><span class="line">物理頁[1]   399</span><br><span class="line">物理頁[2]   288</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 11 條指令進行内存訪問： 虛擬頁[3]狀態：命中</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   01010</span><br><span class="line">物理頁[1] * 3911</span><br><span class="line">物理頁[2]   288</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 12 條指令進行内存訪問： 虛擬頁[2]狀態：命中</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   01010</span><br><span class="line">物理頁[1]   3911</span><br><span class="line">物理頁[2] * 2812</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 13 條指令進行内存訪問： 虛擬頁[1]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0] * 11313</span><br><span class="line">物理頁[1]   3911</span><br><span class="line">物理頁[2]   2812</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 14 條指令進行内存訪問： 虛擬頁[2]狀態：命中</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   11313</span><br><span class="line">物理頁[1]   3911</span><br><span class="line">物理頁[2] * 2814</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 15 條指令進行内存訪問： 虛擬頁[0]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   11313</span><br><span class="line">物理頁[1] * 01515</span><br><span class="line">物理頁[2]   2814</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 16 條指令進行内存訪問： 虛擬頁[1]狀態：命中</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0] * 11316</span><br><span class="line">物理頁[1]   01515</span><br><span class="line">物理頁[2]   2814</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 17 條指令進行内存訪問： 虛擬頁[7]狀態：缺頁</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   11316</span><br><span class="line">物理頁[1]   01515</span><br><span class="line">物理頁[2] * 71717</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 18 條指令進行内存訪問： 虛擬頁[0]狀態：命中</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0]   11316</span><br><span class="line">物理頁[1] * 01518</span><br><span class="line">物理頁[2]   71717</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">第 19 條指令進行内存訪問： 虛擬頁[1]狀態：命中</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">物理頁[0] * 11319</span><br><span class="line">物理頁[1]   01518</span><br><span class="line">物理頁[2]   71717</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">命中率： 0.4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">自定義測試：</span><br><span class="line"></span><br><span class="line">您可以使用源代碼中的 new_process 函數進行自定義測試。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">實驗結束，程式將退出……</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>执行了实验过程的测试之后，可以得到如下的输出：</p><figure><img src="https://i.loli.net/2020/05/12/q3XSdFDkAyvmn4x.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/12/q3XSdFDkAyvmn4x.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="4_1_1.png" /><figcaption aria-hidden="true">4_1_1.png</figcaption></figure><p>可以看到 FIFO 算法的命中率是高于 LRU 的；对这种情况可以进行合理的解释之一是随机生成的指令不能代表实际指令的执行情况，并不具有实际指令频繁访问关键页面的特性，而更加的趋向于“均等”，从而导致了 FIFO 的算法的实验测试值高于 LRU 算法。</p><p>此外，即使物理内存和虚拟内存相等的情况下，命中率也无法达到 100%，是因为实验开始时内存被初始化为空，此时对任何页面的访问都是缺页的；这个极限值的大小取决于虚拟内存和指令条数的比例。</p><p><strong>任务二：获得 Linux 变量的地址</strong></p><p>在 WSL-CLion 环境下执行实验过程中描述并已经实现的代码，得到如下结果：</p><figure><img src="https://i.loli.net/2020/05/12/sHgI2KRkhueYT5l.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/12/sHgI2KRkhueYT5l.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="4_2_0.png" /><figcaption aria-hidden="true">4_2_0.png</figcaption></figure><p>在 WSL 原生环境下执行代码，得到如下结果：</p><figure><img src="https://i.loli.net/2020/05/12/BgAOqUmjGQxNiVJ.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/12/BgAOqUmjGQxNiVJ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="4_2_1.png" /><figcaption aria-hidden="true">4_2_1.png</figcaption></figure><p>检查<code>errno</code>值之后，发现进程无法打开<code>/proc/pid/pagemap</code>文件；考虑到 WSL 实现的机制是将 Linux 程序的进程作为 Windows 进程挂载，可能没有包括这个部分的模拟。遂在同学的 Ubuntu 笔记本设备上执行代码，得到了如下的结果：</p><figure><img src="https://i.loli.net/2020/05/12/4wfc2Mvp6WNGynE.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/05/12/4wfc2Mvp6WNGynE.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="4_2_2.jpg" /><figcaption aria-hidden="true">4_2_2.jpg</figcaption></figure><p>这说明了代码可以正常工作；也说明了 WSL 并不能和 Linux 等量齐观，进一步地加深了我对于 Windows 和 Linux 操作系统之间的差距的直观认知。</p><p><strong>任务三：检查函数运行时间</strong></p><p>五种方法分别是：标准库 <code>time</code> 函数、标准库 <code>clock</code> 函数、标准库 <code>chrono</code> 命名空间、Windows 的 <code>QueryPerformanceCounter</code> 函数、Windows 的 <code>GetTickCount</code> 函数。</p><figure><img src="https://i.loli.net/2020/05/12/nZfw6ctKIghYu7z.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/12/nZfw6ctKIghYu7z.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="4_3.png" /><figcaption aria-hidden="true">4_3.png</figcaption></figure><p>可以看出第一种方法的准确度非常差。事实上 <code>time</code> 函数的精确度只到秒，而其他的方法的精确度都大于毫秒；出现这样的结果也在意料之中。</p><h2 id="体会">体会</h2><p>通过本次上机实验，我了解了更多的 C++ 中的计时方法，拓宽了自己的视野；手动实现了经典的内存调度的页面置换（淘汰）算法，增进了自己对于三种经典算法的理解，也加深了对于内存调度优化这一概念的理解和认知。内存调度算法实际上也是将一些算法的思想融会贯通的产物；本次的实验还增进了我对于这些内存调度算法背后的算法思想有了更加深刻的认知。</p><p>此外，LRU 算法还有很多的优化方法，更加的拓宽了我的视野，让我更加的了解了当代计算机操作系统的一些实现方法；LRU 算法还广泛的利用于用户分层等多个生活中常见的生产场景中，增强了我对于这些抽象算法的理解，带来了更加直观的感受。</p><p>此外，在解决任务二程序在 WSL 上运行出现问题的问题的时候，我阅读了一些 API 相关的文档，加深了自己对于这些函数在 Linux 操作系统中运行过程的理解。</p>]]></content>
      
      
      <categories>
          
          <category> 课业 </category>
          
          <category> 操作系统 </category>
          
          <category> Windows </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 课内作业 </tag>
            
            <tag> 实验报告 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统原理：第 2 次上机实验报告</title>
      <link href="/2020/class-FoDOS-experiment-2/"/>
      <url>/2020/class-FoDOS-experiment-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>操作系统原理的上机实验的报告一共有四个，其他的报告的地址是：</p><p>第一次：<a href="https://shiraha.cn/2020/class-FoDOS-experiment-1/" class="uri">https://shiraha.cn/2020/class-FoDOS-experiment-1/</a><br />第二次：<a href="https://shiraha.cn/2020/class-FoDOS-experiment-2/" class="uri">https://shiraha.cn/2020/class-FoDOS-experiment-2/</a><br />第三次：<a href="https://shiraha.cn/2020/class-FoDOS-experiment-3/" class="uri">https://shiraha.cn/2020/class-FoDOS-experiment-3/</a><br />第四次：<a href="https://shiraha.cn/2020/class-FoDOS-experiment-4/" class="uri">https://shiraha.cn/2020/class-FoDOS-experiment-4/</a></p></blockquote><h2 id="front-matter">Front-matter</h2><p>本次实验的所有源代码可以在<a href="https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job?path=%2Fosnmb%2Fexp" class="uri">https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job?path=%2Fosnmb%2Fexp</a> 查看到。</p><h2 id="实验要求">实验要求</h2><p>本次上机实验的实验要求如下：</p><blockquote>#####<center>《操作系统原理》第二次上机实验</center><p><strong>一、实验目的</strong></p><ol type="1"><li>理解操作系统线程的概念和应用编程过程；</li><li>理解线程的同步概念和编程；</li></ol><p><strong>二、实验内容</strong></p><ol type="1"><li>在 Ubuntu 或 Fedora 环境使用 fork 函数创建一对父子进程，分别输出各自的进程号和提示信息串。</li><li>在 Ubuntu 或 Fedora 环境使用 pthread_create 函数创建 2 个线程 A 和 B。线程 A 在屏幕上用 while 循环顺序递增地输出 1-1000 的自然数；线程 B 在屏幕上用 while 循环顺序递减地输出 1000-1 之间的自然数。为避免输出太快，每隔 0.5 秒输出一个数。</li><li>在 windows 环境下，利用高级语言编程环境（限定为 VS 环境或 VC 环境）调用 CreateThread 函数实现（2）的功能。</li><li>在 windows 环境下，利用高级语言编程环境（限定为 VS 环境或 VC 环境）调用 CreateThread 函数和相关的同步函数，模拟实现“生产者-消费者”问题。</li><li>在 windows 环境下，利用高级语言编程环境（限定为 VS 环境或 VC 环境）调用 CreateThread 函数实现“并发地画圆和画方”。圆的中心，半径，颜色，正方形的中心，边长，颜色等参数自己确定，合适就行。圆和正方形的边界上建议取 720 个点。为直观展示绘制的过程，每个点绘制后睡眠 0.2 秒~0.5 秒。</li><li>在 windows 环境下，利用高级语言编程环境（限定为 VS 环境或 VC 环境）调用 CreateThread 函数实现“文件拷贝小工具”。功能如下：</li><li>具有一个编辑框，让用户任意指定源目录或文件</li><li>具有一个编辑框，让用户任意指定目的目录或文件</li><li>具有“开始拷贝”按钮</li><li>具有“停止拷贝”按钮</li><li>具有显示拷贝进度的 label，当为目录拷贝时以文件数来统计进度，当为文件拷贝时以字节数来统计进度。</li></ol><p>以上六个题目中，选择四个完成（1,2 中任意 1 题和 3,4,5 或 3,4,6 共计 4 道题）；</p></blockquote><p>我选择了 1、2、3、4、5 五个题目。</p><h2 id="实验内容">实验内容</h2><ol type="1"><li>在 Ubuntu 或 Fedora 环境使用 fork 函数创建一对父子进程，分别输出各自的进程号和提示信息串。</li><li>在 Ubuntu 或 Fedora 环境使用 pthread_create 函数创建 2 个线程 A 和 B。线程 A 在屏幕上用 while 循环顺序递增地输出 1-1000 的自然数；线程 B 在屏幕上用 while 循环顺序递减地输出 1000-1 之间的自然数。为避免输出太快，每隔 0.5 秒输出一个数。</li><li>在 windows 环境下，利用高级语言编程环境（限定为 VS 环境或 VC 环境）调用 CreateThread 函数实现（2）的功能。</li><li>在 windows 环境下，利用高级语言编程环境（限定为 VS 环境或 VC 环境）调用 CreateThread 函数和相关的同步函数，模拟实现“生产者-消费者”问题。</li><li>在 windows 环境下，利用高级语言编程环境（限定为 VS 环境或 VC 环境）调用 CreateThread 函数实现“并发地画圆和画方”。圆的中心，半径，颜色，正方形的中心，边长，颜色等参数自己确定，合适就行。圆和正方形的边界上建议取 720 个点。为直观展示绘制的过程，每个点绘制后睡眠 0.2 秒~0.5 秒。</li></ol><h2 id="实验过程">实验过程</h2><p>下面是对于每一个任务的原理和过程的简述：</p><h3 id="父子进程">父子进程</h3><p>在 Linux 中，可以使用 C 语言函数式的系统调用 <code>getpid</code>获得当前进程的 ID，可以使用<code>getppid</code>获得可能存在的父亲进程 ID。为了存储这些函数返回的中间值，可能还需要引入<code>sys/type.h</code>。</p><p>系统调用<code>fork</code>可以复制当前的进程并创建一个一样的进程，子进程的控制流从调用该函数的位置开始；它的返回值可能有如下三种情况：</p><ul><li>在父亲进程中，该函数返回子进程的 pid。</li><li>在孩子进程中，该函数返回 0.</li><li>出现错误时，该函数设置 <code>errno</code> 位并且返回负值。</li></ul><p>一般来说<code>fork</code>函数是不会出错的，它仅会在两种情况下出错：要不是当前的进程数已经达到了系统规定的上限，这时<code>errno</code>的值被设置为<code>EAGAIN</code>；要不是系统内存不足，这时<code>errno</code>的值被设置为<code>ENOMEM</code>。</p><p>正因为<code>fork</code>函数的返回值有着上面所说的特性，所以可以在不同的进程内使用它的返回值来判断当前所属的进程是父亲还是孩子。</p><p>这些函数定义在<code>unistd.h</code>头文件中；在 VC++6.0 中，可以在 <code>process.h</code>中找到。</p><p>这样，实验任务的核心代码就可以这么写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> son = fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (son)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> ppid = getppid();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;父親進程： pid = &quot;</span> &lt;&lt; getpid() &lt;&lt; <span class="string">&quot; ppid = &quot;</span> &lt;&lt; ppid &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;父親的兒子： pid = &quot;</span> &lt;&lt; son &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> ppid = getppid();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;兒子進程： pid = &quot;</span> &lt;&lt; getpid() &lt;&lt; <span class="string">&quot; ppid = &quot;</span> &lt;&lt; ppid &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;兒子的父親： pid = &quot;</span> &lt;&lt; ppid &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (son ? <span class="string">&quot;父親進程&quot;</span> : <span class="string">&quot;兒子進程&quot;</span>) &lt;&lt; <span class="string">&quot;死了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>返回值不为 0，就是父亲进程，否则就是儿子进程。在这个实验里这样做就够了。</p><h3 id="创建线程---linux">创建线程 - Linux</h3><p>在Linux环境下创建线程使用的系统调用是<code>pthread_create</code>，它定义在<code>pthread.h</code>中；声明是下面这样子的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">pthread_t</span> *<span class="keyword">restrict</span> tidp,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *restrict_attr,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">void</span> *(*start_rtn)(<span class="keyword">void</span> *),</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span> *<span class="keyword">restrict</span> arg</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>每个参数的含义是这样的：</p><ol type="1"><li>是新创建的线程ID指向的内存单元，也就是指向线程<a href="http://baike.baidu.com/view/390932.htm">标识符</a>的指针；这是一个out属性，该函数为它赋值为创建的新进程的标识符；利用这个标识符可以做一些其他的事情。</li><li>用来设置线程的属性。默认值为<code>NULL</code>，我们一般也直接使用默认值。</li><li>新创建的程序要运行的函数首址，也就是一个函数指针。这个函数必须接受一个 <code>void*</code>指针作为参数，并返回一个<code>void*</code>作为返回值。当然，你也可以强制类型转换。</li><li>是上面那个函数运行需要的参数，当然是一个<code>void*</code>指针。</li></ol><p>一般来说，调用此函数时应当避免传入会被其它线程修改的变量作为参数。一般都是先<code>memcpy</code>之后再将复制品的首地址作为参数传入。此外，第二个参数缺省的时候创建的线程是非分离属性的，这意味着它结束的时候，它所占用的系统资源并没有真正的释放。只有使用<code>pthread_join</code>返回后，或者这个线程指定为分离属性时，才可以保证线程占用的资源被释放。</p><p>此外，还可以使用<code>pthread_join</code>函数获得线程函数的返回值，它的声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pthread_join __P (<span class="keyword">pthread_t</span> __th, <span class="keyword">void</span> **__thread_return);</span><br></pre></td></tr></table></figure><p>它可以用来等待一个线程的结束并且获得返回值：第一个参数是线程标识符，也就是上面<code>pthread_create</code>函数通过第一个参数传出的标识符；第二个参数是线程函数的返回值指针的指针，是一个out属性。</p><p>这个函数是一个阻塞函数，如果某线程调用此函数等待另一个线程，那么该线程将持续阻塞直到被等待的线程结束并给出返回值；函数返回后，被等待线程的资源被收回，返回 0；如果此函数出错，将会返回错误号。</p><p>综上所述，本题的核心代码可以这么写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span> sign_A, sign_B;</span><br><span class="line">parameter para_A = &#123;<span class="number">114514</span>&#125;,</span><br><span class="line">          para_B = &#123;<span class="number">1919810</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pthread_create(&amp;sign_A, <span class="literal">nullptr</span>,</span><br><span class="line">        <span class="keyword">reinterpret_cast</span>&lt;func&gt;(threadA), &amp;para_A))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;綫程 A 創建失敗，程序退出……&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pthread_create(&amp;sign_B, <span class="literal">nullptr</span>,</span><br><span class="line">                   <span class="keyword">reinterpret_cast</span>&lt;func&gt;(threadB), &amp;para_B))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;綫程 B 創建失敗，程序退出……&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> *res_A, *res_B;</span><br><span class="line">pthread_join(sign_A, &amp;res_A);</span><br><span class="line">pthread_join(sign_B, &amp;res_B);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>*)res_A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>*)res_B &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">exit</span>(EXIT_SUCCESS);</span><br></pre></td></tr></table></figure><p><code>threadA</code>和<code>threadB</code>并没有定义为上述参数类型的函数；但是因为参数、返回值的大小是一致的，可以安全的使用强制类型转换转为指定类型的函数。</p><p>此外，因为<code>pthread</code>并不是Linux系统的默认库，所以如果使用命令行编译，需要加上编译指令<code>-lpthread</code>来链接相关的库；如果您使用 CMake 管理您的项目，还需要在 CMakeList.txt 中加上下面的内容：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_compile_options</span>(-lpthread)</span><br><span class="line"><span class="keyword">find_package</span>(Threads REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main Threads::Threads)</span><br></pre></td></tr></table></figure><p>其中，main 是你的项目目标名，可以在这个文档中找到。</p><h3 id="创建线程---windows">创建线程 - Windows</h3><p>在Windows中创建子进程需要用到<code>CreateThread</code>函数；在不使用CRT库的情况下，一般需要通过这个函数创建新进程；并使用<code>WaitForMultipleObjects</code>或者<code>WaitForSingleObject</code>等待线程的结束；使用<code>GetExitCodeThread</code>获得线程函数的返回值；并且使用<code>CloseHandle</code>关闭创建的线程对象。</p><p><code>CreateThread</code>函数定义在<code>processthreadsapi.h</code>中，但是我们只需要通过引入<code>windows.h</code>来引入就好了；这个函数的声明式是下面这个样子的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  LPSECURITY_ATTRIBUTES  lpThreadAttributes,   </span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      SIZE_T                 dwStackSize,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  LPVOID                 lpParameter,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      DWORD                  dwCreationFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_opt_ LPDWORD                lpThreadId</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>一共接受六个参数，它们的含义如下：</p><ol type="1"><li>表示线程内核对象的安全属性，一般使用<code>NULL</code>表示采用默认值：不可以被子线程继承</li><li>设置新线程的初始栈大小(B)，0 表示和调用线程相同（默认1MB）；因为Windows会根据需要自动延长栈空间，所以一般传入 0 就好了。</li><li>指向线程函数的指针，函数类型是 <code>function&lt;DWORD WINAPI (LPVOID&gt;</code>，多个线程可以共用一个函数；实际函数也可以不接受参数不返回，也可强制转换为<code>LPTHREAD_START_ROUTINE</code>类型使用。</li><li>传递给上面函数的参数，是<code>void*</code>类型；一般指向结构体，或者传入<code>NULL</code>表示不传参。</li><li>线程标志，用来控制新线程的创建：0 表示创建后立即调度，<code>CREATE_SUSPENDED</code>表明创建后立即挂起，直到函数<code>ResumeThread</code>被调用；还有一些其他的可选值。</li><li>是一个out属性，用来保存新线程的 ID。</li></ol><p>当线程创建成功时，函数返回一个表示新线程对象的HANDLE；否则返回false。</p><p>虽然此函数有很多更推荐的替代，比如<code>BeginThread</code>；但是这里直接使用它就够了。</p><p><code>WaitForSingleObject</code>函数用来等待线程：当指定线程（对象）处于有信号状态或者等待时间结束的状态时，此函数会返回；它的声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WaitForSingleObject</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  HANDLE hHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwMilliseconds</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数是指向对象的HANDLE，第二个参数是等待的时间；这个函数使得当前线程进入等待状态，直到它返回；只可以等待HANDLE指定的那个支持被通知/未通知的内核对象，等待时间由第二个参数指定，一般使用<code>INFINITE</code>作为等待无穷时间；但是如果等待对象永远不改变状态，那么调用线程将不会被唤醒，但是也不会浪费CPU时间。</p><p>若对象变为已通知状态，则函数返回<code>WAIT_OBJECT_0</code>；若等待时间超过了设定的时间，返回<code>WAIT_TIMEOUT</code>；若函数错误（比如将一个无效句柄传给了它），则返回<code>WAIT_FAILED</code>，此时可以用<code>GetLastError</code>获得详细信息。</p><p><code>WaitForMultipleObjects</code>则和上面的函数很像，但是可以同时等待多个内核对象，它的声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WaitForMultipleObjects</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">DWORD dwCount,</span></span></span><br><span class="line"><span class="function"><span class="params">   CONST HANDLE *phObjects,</span></span></span><br><span class="line"><span class="function"><span class="params">   BOOL fWaitAll,</span></span></span><br><span class="line"><span class="function"><span class="params">   DWORD dwMilliseconds</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>它的四个参数的含义如下：</p><ol type="1"><li>需要让此函数等待的内核对象数量，范围在[1, MAXIMU M_WAIT_OBJECTS]内。</li><li>是内核对象HANDLE的数组，也就是数组第一个对象的指针。</li><li>表示此函数的工作方式：<code>TRUE</code>表示所有对象变为已通知状态后才返回；<code>FALSE</code>状态表示任一个对象状态变为已通知之后就返回。</li><li>等待时间，和<code>WaitForSingleObject</code>中的第二个参数一样。</li></ol><p>使用的限制也和上面的函数大体相同。</p><p><code>GetExitCodeThread</code>可以用于获取一个已经退出/中止的的线程对象的退出代码。比起说“获取”，“检查”应该更加合适：它不同于上面的两个等待的函数会使得调用线程进入等待状态，当它发现待检查的线程对象仍然活动的时候，它就会立即退出，而不阻塞当前进程（所以循环的调用这个函数是一种阻塞的等待）。它的声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL   <span class="title">GetExitCodeThread</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HANDLEhThread,                </span></span></span><br><span class="line"><span class="function"><span class="params">LPDWORD lpExitCode              </span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数是指向线程对象的HANDLE；第二个对象是一个out属性，用来储存线程结束的代码或返回值。返回值仅表示该函数是否调用成功，并不代表线程对象是否已经中止。</p><p>若检查的HANDLE代表的线程仍然在运行，那么这个函数会为第二个参数赋值<code>STILL_ACTIVE</code>；否则将函数的返回值赋值给它；一个危险的状况是，当函数返回值就是<code>STILL_ACTIVE</code>时，此函数会失效。因为<code>LPDWORD</code>大小有限，所以线程函数的返回值最好是一个指向结构体的指针。</p><p>最后，因为Windows中，线程执行完毕中止后线程对象仍然存在，所以需要使用<code>CloseHandle</code>手动关闭句柄。这个函数的声明式是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CloseHandle</span><span class="params">(HANDLE hObject)</span></span>;</span><br></pre></td></tr></table></figure><p>参数是一个用来表示已经打开的对象（包括线程）的HANDLE；返回值仅表示函数执行成功与否，返回<code>FALSE</code>时可以通过<code>GetLastError</code>来获得错误原因。</p><p>这个函数实质的工作就是减少该内核对象的引用次数 1，而不是直接关闭对象——当一个对象引用计数为 0 或进程结束时会自动被操作系统回收，所以可能存在调用该函数后系统对象仍然存在以至于泄露的情况。</p><p>综上所述，已经理清楚在Windows中一个线程的生老病死的全过程；所以核心代码可以这么写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">parameter para_A = &#123;<span class="number">114514</span>&#125;, para_B = &#123;<span class="number">1919810</span>&#125;;</span><br><span class="line"></span><br><span class="line">HANDLE hThread[<span class="number">2</span>];</span><br><span class="line">DWORD exitCode[<span class="number">2</span>];</span><br><span class="line">DWORD threadId[<span class="number">2</span>];</span><br><span class="line">WINBOOL <span class="built_in">close</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!(hThread[<span class="number">0</span>] = CreateThread(</span><br><span class="line">        <span class="literal">nullptr</span>, <span class="number">0</span>, threadA,</span><br><span class="line">        (LPVOID)&amp;para_A, <span class="number">0</span>,</span><br><span class="line">        &amp;threadId[<span class="number">0</span>]</span><br><span class="line">)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;進程 A 創建失敗，程序即將退出……&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;進程 A 創建成功，進程ID是 &quot;</span> &lt;&lt; threadId[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (!(hThread[<span class="number">1</span>] = CreateThread(</span><br><span class="line">        <span class="literal">nullptr</span>, <span class="number">0</span>, threadB,</span><br><span class="line">        (LPVOID)&amp;para_B, <span class="number">0</span>,</span><br><span class="line">        &amp;threadId[<span class="number">1</span>]</span><br><span class="line">)))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;進程 B 創建失敗，程序即將退出……&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;進程 B 創建成功，進程ID是 &quot;</span> &lt;&lt; threadId[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">WaitForMultipleObjects(<span class="number">2</span>, hThread, <span class="literal">true</span>, INFINITE);</span><br><span class="line">GetExitCodeThread(hThread[<span class="number">0</span>], &amp;exitCode[<span class="number">0</span>]);</span><br><span class="line">GetExitCodeThread(hThread[<span class="number">1</span>], &amp;exitCode[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (exitCode[<span class="number">0</span>] == STILL_ACTIVE ||</span><br><span class="line">    exitCode[<span class="number">1</span>] == STILL_ACTIVE)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;進程仍在意料之外的運行，程序即將退出……&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    CloseHandle(hThread[<span class="number">0</span>]);</span><br><span class="line">    CloseHandle(hThread[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">close</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>*)exitCode[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>*)exitCode[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实额外的检查内核对象状态在这里没啥意义……毕竟出了错也只能<code>EXIT(EXIT_FAILURE)</code>。</p><h3 id="生产者---消费者">生产者 - 消费者</h3><p>关于生产者-消费者问题：又称为有限缓冲问题。两个线程，也就是生产者和消费者线程公用同一个固定大小的缓冲区；生产者会向其中放入数据，消费者会从中取出数据；需要保证的是生产者在缓冲区满后不会再继续加入数据，消费者在缓冲区空的时候不会继续取出数据，并且回避出现死锁的情况。这里我们使用信号量机制来实现这个问题的模拟。</p><p>显然，缓冲区可以看作这个问题的临界区；而Windows引入提供了专门的临界区对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CRITICAL_SECTION cs;<span class="comment">//声明临界区对象</span></span><br><span class="line">InitializeCriticalSection(&amp;cs);<span class="comment">//初始化临界区对象 </span></span><br><span class="line">EnterCriticalSection(&amp;cs);<span class="comment">//进入临界区</span></span><br><span class="line">LeaveCriticalSection(&amp;cs);<span class="comment">//离开临界区</span></span><br></pre></td></tr></table></figure><p>此外，Windows还有定义了的信号量相关的函数，可用来模拟信号量完成对于临界资源的 P-V 操作：</p><p><code>CreateSemaphore</code>函数可以创建一个信号量，并且返回用来代表它的HANDLE：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateSemaphore</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,  </span></span></span><br><span class="line"><span class="function"><span class="params">  LONG lInitialCount,   </span></span></span><br><span class="line"><span class="function"><span class="params">  LONG lMaximumCount,  </span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpName   </span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure><p>它接受的参数的含义是这样的：</p><ol type="1"><li>代表了信号量的属性；设置为<code>NULL</code>时取默认值</li><li>信号量的初始值，要求在[0, lpMaximumCount]范围内；=0时信号量默认处于 unsignal 状态，否则为 signal 状态。</li><li>代表信号量可到达的最大值，必须为正数。</li><li>信号量的名字，是 C 字符串；字符串的长度不能超过<code>MAX_PATH</code>，设置为<code>NULL</code>表示无名信号量；如果传入的字符串已经代表了一个信号量，则直接打开它。</li></ol><p>函数调用成功后将返回新建信号量的 HANDLE。</p><p><code>OpenSemaphore</code>函数可以打开一个已经存在的信号量，它的声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">OpenSemaphore</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  DWORD dwDesiredAccess,   </span></span></span><br><span class="line"><span class="function"><span class="params">  BOOL bInheritHandle,   </span></span></span><br><span class="line"><span class="function"><span class="params">  LPCTSTR lpName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>这个函数接受的参数的含义是这样的：</p><ol type="1"><li>描述了对于信号量的访问权限；<code>SEMAPHORE_ALL_ACCESS</code>，表示可对信号量执行尽可能多的操作；<code>SEMAPHORE_MODIFY_STATE</code>，表示允许使用<code>ReleaseSemaphore</code>释放信号量，以修改信号量；<code>SYNCHRONIZE</code>，表示用等待函数异步的等待信号量变为signal状态。</li><li>表示信号量的可继承性；<code>TRUE</code>表示该 HANDLE 可以被继承。</li><li>信号量的名字，是 C 字符串；</li></ol><p>由上述参数描述可以看出，这个函数只可以用来打开一个有名字的信号量。</p><p>此外，还有上面描述中提及的用于释放信号量的函数<code>ReleaseSemaphore</code>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ReleaseSemaphore</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">    HANDLE hSemaphore,       </span></span></span><br><span class="line"><span class="function"><span class="params">    LONG lReleaseCount,      </span></span></span><br><span class="line"><span class="function"><span class="params">    LPLONG lpPreviousCount   </span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>第一个参数是要操作的信号量的 HANDLE；第二个参数是要在此信号量中释放的数量；第三个参数是一个out参数，用来存储操作前信号量的数量，如果不需要也可以传入<code>NULL</code>；</p><p>当信号量使用完毕之后，它也要像其他的内核对象那样使用<code>CloseHandle</code>函数关闭 HANDLE。</p><p>综上所述，我们可以使用信号量的释放模拟问题中的V操作，使用对于信号量 HANDLE 的等待作为问题中的P操作，就可以模拟这个问题了。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> COUNT_THREAD = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> COUNT_BUFFER = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> WAIT_TIME = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> SLEEP_SHORT = <span class="number">600</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> SLEEP_LONG = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> MAX_DEPTH = <span class="number">10086</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">createRandomMachine</span><span class="params">(<span class="keyword">int</span> lb, <span class="keyword">int</span> rb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lb &gt; rb) swap(lb, rb);</span><br><span class="line">    <span class="function">uniform_real_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">dm</span> <span class="params">(lb, rb)</span></span>;</span><br><span class="line">    random_device rd;</span><br><span class="line">    <span class="function">default_random_engine <span class="title">rm</span><span class="params">(rd())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> [=]()<span class="keyword">mutable</span>&#123;<span class="keyword">return</span> dm(rm);&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sleep Sleep</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> null nullptr</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fout cout</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lpParam</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">int</span> *buf, *ft, *bk;</span><br><span class="line">    CRITICAL_SECTION *cs;</span><br><span class="line">    <span class="keyword">int</span> *flag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getNowTime</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SYSTEMTIME now;</span><br><span class="line">    GetLocalTime(&amp;now);</span><br><span class="line">    <span class="built_in">string</span> date;</span><br><span class="line">    date.append(to_string(now.wYear));</span><br><span class="line">    date.append(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    date.append(to_string(now.wMonth));</span><br><span class="line">    date.append(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">    date.append(to_string(now.wDay));</span><br><span class="line">    <span class="keyword">return</span> date + <span class="string">&quot; &quot;</span> + to_string(now.wHour) + <span class="string">&#x27;:&#x27;</span></span><br><span class="line">           + to_string(now.wMinute) + <span class="string">&#x27;:&#x27;</span></span><br><span class="line">           + to_string(now.wSecond) + <span class="string">&#x27;:&#x27;</span></span><br><span class="line">           + to_string(now.wMilliseconds);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">producer</span><span class="params">(LPVOID para)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = (lpParam*) para;</span><br><span class="line">    <span class="keyword">int</span> &amp;front = *p-&gt;ft, &amp;back = *p-&gt;bk, number, &amp;flag = *p-&gt;flag;</span><br><span class="line">    HANDLE FULL = OpenSemaphore(SEMAPHORE_ALL_ACCESS, <span class="literal">false</span>, <span class="string">&quot;full&quot;</span>);</span><br><span class="line">    HANDLE EMPTY = OpenSemaphore(SEMAPHORE_ALL_ACCESS, <span class="literal">false</span>, <span class="string">&quot;empty&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span> rm = p-&gt;id == <span class="number">1</span> ?</span><br><span class="line">              createRandomMachine(<span class="number">1000</span>, <span class="number">1999</span>) :</span><br><span class="line">              createRandomMachine(<span class="number">2000</span>, <span class="number">2999</span>);</span><br><span class="line">    <span class="comment">// ofstream fout;</span></span><br><span class="line">    <span class="keyword">int</span> time = MAX_DEPTH;</span><br><span class="line">    <span class="keyword">while</span> (time --)</span><br><span class="line">    &#123;</span><br><span class="line">        number = rm();</span><br><span class="line">        WaitForSingleObject(EMPTY, INFINITE);</span><br><span class="line">        EnterCriticalSection(p-&gt;cs);</span><br><span class="line">        p-&gt;buf[back] = number;</span><br><span class="line">        fout &lt;&lt; getNowTime() &lt;&lt; <span class="string">&quot;： 生產者 &quot;</span> &lt;&lt; p-&gt;id &lt;&lt; <span class="string">&quot; 生產了物品 &quot;</span></span><br><span class="line">             &lt;&lt; p-&gt;buf[back] &lt;&lt; <span class="string">&quot;，在緩衝池的 &quot;</span> &lt;&lt; back &lt;&lt; <span class="string">&quot; 位置放入。&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        ++ flag;</span><br><span class="line">        back = (back + <span class="number">1</span>) % COUNT_BUFFER;</span><br><span class="line">        LeaveCriticalSection(p-&gt;cs);</span><br><span class="line">        ReleaseSemaphore(FULL, <span class="number">1</span>, null);</span><br><span class="line">        sleep(SLEEP_SHORT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">consumer</span><span class="params">(LPVOID para)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> p = (lpParam*) para;</span><br><span class="line">    <span class="keyword">int</span> &amp;front = *p-&gt;ft, &amp;back = *p-&gt;bk, &amp;flag = *p-&gt;flag;</span><br><span class="line">    HANDLE FULL = OpenSemaphore(SEMAPHORE_ALL_ACCESS, <span class="literal">false</span>, <span class="string">&quot;full&quot;</span>);</span><br><span class="line">    HANDLE EMPTY = OpenSemaphore(SEMAPHORE_ALL_ACCESS, <span class="literal">false</span>, <span class="string">&quot;empty&quot;</span>);</span><br><span class="line">    <span class="comment">// ofstream fout;</span></span><br><span class="line">    <span class="keyword">int</span> time = MAX_DEPTH;</span><br><span class="line">    <span class="keyword">while</span> (time --)</span><br><span class="line">    &#123;</span><br><span class="line">        WaitForSingleObject(FULL, INFINITE);</span><br><span class="line">        EnterCriticalSection(p-&gt;cs);</span><br><span class="line">        ++ flag;</span><br><span class="line">        fout &lt;&lt; getNowTime() &lt;&lt; <span class="string">&quot;： 消费者 &quot;</span> &lt;&lt; p-&gt;id &lt;&lt; <span class="string">&quot; 使用了物品 &quot;</span></span><br><span class="line">             &lt;&lt; p-&gt;buf[back] &lt;&lt; <span class="string">&quot;，从緩衝池的 &quot;</span> &lt;&lt; back &lt;&lt; <span class="string">&quot; 位置取出。&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        front = (front + <span class="number">1</span>) % COUNT_BUFFER;</span><br><span class="line">        LeaveCriticalSection(p-&gt;cs);</span><br><span class="line">        ReleaseSemaphore(EMPTY, <span class="number">1</span>, null);</span><br><span class="line">        sleep(SLEEP_LONG);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WIN32</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;實驗： Windows 下的生產者-消費者問題&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    lpParam lp[COUNT_THREAD];</span><br><span class="line">    CRITICAL_SECTION section;</span><br><span class="line">    HANDLE semaphore[<span class="number">2</span>], hThread[COUNT_THREAD];</span><br><span class="line">    DWORD threadId[COUNT_THREAD];</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">buffer</span>[COUNT_BUFFER], ft = <span class="number">0</span>, bk = <span class="number">0</span>, flag = <span class="number">-1</span>;</span><br><span class="line">    InitializeCriticalSection(&amp;section);</span><br><span class="line">    semaphore[<span class="number">0</span>] = CreateSemaphore(null, <span class="number">0</span>, COUNT_BUFFER, <span class="string">&quot;full&quot;</span>);</span><br><span class="line">    semaphore[<span class="number">1</span>] = CreateSemaphore(null, COUNT_BUFFER, COUNT_BUFFER, <span class="string">&quot;empty&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> cnt_p = <span class="number">0</span>, cnt_c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; COUNT_THREAD; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        lp[i] = &#123;++ (i &gt;= <span class="number">2</span> ? cnt_c : cnt_p), <span class="built_in">buffer</span>,</span><br><span class="line">                 &amp;ft, &amp;bk, &amp;section, &amp;flag&#125;;</span><br><span class="line">        <span class="keyword">auto</span> func = i &gt;= <span class="number">2</span> ? consumer : producer;</span><br><span class="line">        hThread[i] = CreateThread</span><br><span class="line">                (</span><br><span class="line">                        null, <span class="number">0</span>, func,</span><br><span class="line">                        (LPVOID)&amp;lp[i], <span class="number">0</span>,</span><br><span class="line">                        &amp;threadId[i]</span><br><span class="line">                );</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;進程 &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; 已經創建，進程ID是 &quot;</span> &lt;&lt; threadId[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    WaitForMultipleObjects(COUNT_THREAD, hThread, <span class="literal">true</span>, WAIT_TIME);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;模擬層數達到限制，程式即將退出……&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;這個程序需要在Windows環境下才可以正常運行的，請檢查運行平臺&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="画圆画方">画圆画方</h3><p>根据上面的任务中了解到的 Windows 环境下创建进程所需要的知识，我们仅需要定义好画圆和画方的函数，作为进程函数传给<code>CreateThread</code>函数就可以了。这部分的函数我使用了 Easy X 图形库完成。它只支持在 Visual Studio / Visual C++ 环境下使用。在使用前你可能需要去 <a href="https://easyx.cn/">Easy X 官网</a>上去下载它最新的安装包安装后才可以正常编译该源代码。</p><p>下面是画圆和画方的线程函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">drawSquare</span><span class="params">(LPVOID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">180</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        putpixel(<span class="number">50</span> + i, <span class="number">50</span>, WHITE);</span><br><span class="line">        Sleep(SLEEP_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">180</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        putpixel(<span class="number">50</span> + <span class="number">180</span>, <span class="number">50</span> + i, WHITE);</span><br><span class="line">        Sleep(SLEEP_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">180</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        putpixel(<span class="number">50</span> + <span class="number">180</span> - i, <span class="number">50</span> + <span class="number">180</span>, WHITE);</span><br><span class="line">        Sleep(SLEEP_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">180</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        putpixel(<span class="number">50</span>, <span class="number">50</span> + <span class="number">180</span> - i, WHITE);</span><br><span class="line">        Sleep(SLEEP_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">drawCircle</span><span class="params">(LPVOID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> position_x = [](<span class="keyword">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">350</span> + <span class="number">100</span> * <span class="built_in">cos</span>(-PI / <span class="number">2</span> + (<span class="keyword">double</span>)((i * PI) / <span class="number">360</span>));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> position_y = [](<span class="keyword">int</span> i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">140</span> + <span class="number">100</span> * <span class="built_in">sin</span>(-PI / <span class="number">2</span> + (<span class="keyword">double</span>)((i * PI) / <span class="number">360</span>));</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">720</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        putpixel(position_x(i), position_y(i), WHITE);</span><br><span class="line">        Sleep(SLEEP_TIME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验时只需要将它们分别交给两个线程执行就可以了。</p><h2 id="实验结果">实验结果</h2><p>这里是任务完成后的截图或其他证明。</p><p><strong>任务一：父子进程</strong></p><figure><img src="https://i.loli.net/2020/05/12/DuCtNq1jVbU9pZ6.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/12/DuCtNq1jVbU9pZ6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2_1.png" /><figcaption aria-hidden="true">2_1.png</figcaption></figure><p><strong>任务二：多线程 - Linux</strong></p><figure><img src="https://i.loli.net/2020/05/12/rXZVFetPYbf83mv.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/12/rXZVFetPYbf83mv.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2_2.png" /><figcaption aria-hidden="true">2_2.png</figcaption></figure><p><strong>任务三：多线程 - Windows</strong></p><figure><img src="https://i.loli.net/2020/05/12/j2bkWA9N5TDai4v.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/12/j2bkWA9N5TDai4v.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2_3.png" /><figcaption aria-hidden="true">2_3.png</figcaption></figure><p><strong>任务四：生产者 - 消费者</strong></p><figure><img src="https://i.loli.net/2020/05/12/Olu92yUZripKM7X.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/12/Olu92yUZripKM7X.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2_4.png" /><figcaption aria-hidden="true">2_4.png</figcaption></figure><p><strong>任务五：画圆画方</strong></p><figure><img src="https://i.loli.net/2020/05/12/NWAFsQwB61mEXP3.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/12/NWAFsQwB61mEXP3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2_5.png" /><figcaption aria-hidden="true">2_5.png</figcaption></figure><h2 id="体会">体会</h2><p>通过本次的操作系统原理实验，我熟悉了在 Linux 上和 Windows 上和线程相关的一些函数的使用；熟练了面向操作系统的编程，可以将一些基本的功能需求使用多线程技术实现。从同一个功能在 Linux 和 Windows 平台上实现的不同，进一步地体会了两个操作系统之间的差异。</p><p>实验的过程中也遇到了一些看起来不太容易解释的问题，这说明要想学好面向操作系统的多线程编程，仅仅了解函数的声明式是远远不够的。除了表面的 API 调用之外，还应该更多的去了解函数内部的构造以及实现原理。在处理这些问题的过程中，加深了我对这些原理的理解。</p>]]></content>
      
      
      <categories>
          
          <category> 课业 </category>
          
          <category> 操作系统 </category>
          
          <category> Windows </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 课内作业 </tag>
            
            <tag> 实验报告 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法分析与设计：实验4实验报告</title>
      <link href="/2020/class-algorithm-experiment-report-4/"/>
      <url>/2020/class-algorithm-experiment-report-4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前三次实验的链接是：<a href="https://shiraha.cn/2020/class-algorithm-experiment-report-1-3/" class="uri">https://shiraha.cn/2020/class-algorithm-experiment-report-1-3/</a></p><p>这次实验的代码也在：<a href="https://dev.azure.com/Pure-Asahi/2020_Spring_In_Class_Job" class="uri">https://dev.azure.com/Pure-Asahi/2020_Spring_In_Class_Job</a></p></blockquote><h2 id="实验四最短路算法">实验四：最短路算法</h2><p>实验要求如下：</p><blockquote>#####<center>实验四：单源最短路径和全点对最短路径算法</center><p><strong>一、实验目的</strong> 掌握复杂数据结构的存储和操作方法,实现图的搜索。</p><p><strong>二、实验条件</strong> 计算机及程序语言开发平台（如 C、C++、Java、Matlab 等）。</p><p><strong>三、实验内容及要求</strong></p><ul><li>描述并实现单源最短路径算法，显示在下图上的运算结果 <img src="https://i.loli.net/2020/05/05/p4WGfwYvdsc1LPl.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/05/p4WGfwYvdsc1LPl.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="0ILCRWV_JPT9YMQ9AY~O5L.png" /></li><li>描述并实现全点对最短路径算法，显示在下图上的运算结果 <img src="https://i.loli.net/2020/05/05/CuKjphqFHoZYknt.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/05/CuKjphqFHoZYknt.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="8_BFK_UFOO~RD6_KVH_XGB5.png" /></li></ul><p><strong>四、思考题</strong> - 全点对最短路径算法动态规划算法范式 - 图的存储方式和运算效率之间的关系</p></blockquote><h3 id="实验分析">实验分析</h3><p>下面分析两个任务可以采用的算法。</p><h4 id="单源最短路算法">单源最短路算法</h4><p>主要有 Bellman-Ford 算法、DAG 算法、Dijkstra算法。</p><p>Bellman-Ford 算法的主要思想即是对所有的边进行 V-1 次的遍历，每次对 每一条边执行一次缩短操作，缩短操作的核心就是判断 d[v] &gt; d[u] + w(u, v)，如果是的话则更新 d[v],否则不变。算法结 束后还需要进行回路检测，如果存在负回路则返回 false，否则返回真，该算法较为简单，运行开销函数是 O(VE)。基于这个算法还有中国教授进行队列优化的SPFA算法，在一般情况下效率高于 Bellman-Ford 算法，但是最坏不会差于 Bellman-Ford 算法。</p><p>DAG 算法是针对图为有向无环图的特殊情况，显然它要求没有回路。这个算法首先需要对图进行拓扑排序，完成后再进行初始化，再根据拓扑排序的顶点顺序对邻接边进行 缩短操作，缩短操作同方法一。如果排序过程中出现不需要的边，只要更新父节点即可。运行时间开销是 O(V+E)，但是该算法限制较大，只能在图又这种特殊性质的情况下才可以使用。但是也可以使用 Tarjan 缩点，对于每个SCC内部再求最短路之后再使用这个算法，这样的话效率就不能保证了。</p><p>Dijkstra 算法要求不存在负权值的边，首先把所有节点压入队列 Q 中，然后每次让节点权值最小的节点出队，然后对其临接节点执行缩短操作，Q 为空时即结束。时间复杂度是 O(V*lgV+E)。实际实现的时候，可以使用堆进行贪心优化，使得实现的算法速度更快。</p><h4 id="全点对最短路径算法">全点对最短路径算法</h4><p>可以进行n次单源最短路径算法，也可以进行动态规划。</p><p>进行n次单源最短路径算法并不经济。单源最短路算法的复杂度大多和 E 相关，但是 E 的上限可以是 V²。当待解决问题的图是一个稠密图的时候，n次单源最短路径算法将会退化到 O(V³·logV) 甚至是 O(V⁴)，这是非常不好的。</p><p>动态规划法对于稠密图而言是很好的，唯一的缺点是会占用一定的空间：通过建立一个V*V的数组进行递推得到答案。这样做的正确性在于：最短路径的部分路径必然是最短的。因此，通过多个最短部分路径就可以找到全路径的最小值，每一个找到的部分最短路径也是它端点的最短值，没有进行重复的查找，时间复杂度是 O(V³)。经典的实现就是 Floyd 算法，它就是 O(V³) 的。</p><h3 id="算法实现">算法实现</h3><p>首先，我们将图的边描述出来；点的编号从 1 开始，{u, v, w} 代表从 u 出发到达 v 的边，边权是 w。</p><p>单源最短路径的图可以这样描述：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1 2 6  </span><br><span class="line">1 4 7 </span><br><span class="line">2 3 5</span><br><span class="line">2 5 -4</span><br><span class="line">2 4 8</span><br><span class="line">3 2 -2</span><br><span class="line">4 3 -3</span><br><span class="line">4 5 9</span><br><span class="line">5 1 2</span><br><span class="line">5 3 7</span><br></pre></td></tr></table></figure><p>起点是点 1.</p><p>全点对最短路径的图可以这样描述：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">1 3 8</span><br><span class="line">1 5 -4</span><br><span class="line">2 4 1</span><br><span class="line">2 5 7</span><br><span class="line">3 2 4</span><br><span class="line">4 1 2</span><br><span class="line">4 3 -5</span><br><span class="line">5 4 6</span><br></pre></td></tr></table></figure><p>上述数据将作为算法实现的输入。</p><p>对于单源最短路问题，因为题目所给的图包含负边权，所以不能够使用堆优化的Dijkstra算法，因此实现为使用了队列优化的SPFA算法。因为图并不算是稠密图，使用链式前向星存储图。使用<code>memset</code>可以设置的可加和的最大值<code>0x3f3f3f3f3f3f3f3f</code>作为INF值。</p><p>这里是链式前向星的简单实现，由于C++特性避免动态分配内存，限制了最大顶点数为100：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">    edge() = <span class="keyword">default</span>;</span><br><span class="line">    edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> next)</span><br><span class="line">        :u(u), v(v), w(w), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fws</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> head[N + <span class="number">1</span>]&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> tot&#123;&#125;;</span><br><span class="line">    edge ee[(N + <span class="number">1</span>) * (N + <span class="number">1</span>) * <span class="number">2</span>]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    fws() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span> head);</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        ee[tot] = edge(u, v, w, head[u]);</span><br><span class="line">        head[u] = tot ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">edge &amp;<span class="title">getEdge</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ee[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后就是最短路的核心算法SPFA的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> *<span class="title">spfa</span><span class="params">(fws &amp;graph, <span class="keyword">int</span> start, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; <span class="number">0</span> || start &gt; n) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">auto</span> *ans = <span class="keyword">new</span> <span class="keyword">long</span> <span class="keyword">long</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; heap;</span><br><span class="line">    <span class="keyword">bool</span> visit[N + <span class="number">1</span>] &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    heap.push(start);</span><br><span class="line">    visit[start] = <span class="literal">true</span>;</span><br><span class="line">    ans[start] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!heap.empty()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> now = heap.front();</span><br><span class="line">        heap.pop();</span><br><span class="line">        visit[now] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ii = graph.head[now]; ~ii; ii = graph.getEdge(ii).next)</span><br><span class="line">            <span class="keyword">if</span> (ans[now] + graph.getEdge(ii).w &lt; ans[graph.getEdge(ii).v]) &#123;</span><br><span class="line">                ans[graph.getEdge(ii).v] = ans[now] + graph.getEdge(ii).w;</span><br><span class="line">                <span class="keyword">if</span> (!visit[graph.getEdge(ii).v]) &#123;</span><br><span class="line">                    heap.push(graph.getEdge(ii).v);</span><br><span class="line">                    visit[graph.getEdge(ii).v] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次搜索到邻接的边的时候，就观察它是否能缩短到达新边终点的距离；如果可以，那就对这个节点进行进一步松弛，将它加入队列；执行结果可以看后面。</p><p>对于全点对最短路问题，可以使用矩阵记录每两个顶点之间的最短路径，并且使用 Floyd 算法完成最短路径的计算。下面是核心的 Floyd 算法实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> **<span class="title">floyd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> **graph, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="keyword">new</span> <span class="keyword">long</span> <span class="keyword">long</span>*[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        a[i] = <span class="keyword">new</span> <span class="keyword">long</span> <span class="keyword">long</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(a[i], <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++ k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">                a[i][j] = <span class="built_in">std</span>::<span class="built_in">min</span>(</span><br><span class="line">                        <span class="built_in">std</span>::<span class="built_in">min</span>(a[i][j], a[i][k] + a[k][j]),</span><br><span class="line">                        <span class="built_in">std</span>::<span class="built_in">min</span>(graph[i][j], graph[i][k] + graph[k][j])</span><br><span class="line">                );</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Floyd 算法的核心思想就是上面说到的动态规划。</p><p>上述的两个算法输入样例后的输出如下：</p><figure><img src="https://i.loli.net/2020/05/05/oxHrJ27FMkN4d89.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/05/oxHrJ27FMkN4d89.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="KNJaS4KXVZTGXQU6R2IY_W.png" /><figcaption aria-hidden="true">KNJaS4KXVZTGXQU6R2IY_W.png</figcaption></figure><p>显然，这些答案是正确的。</p><h3 id="思考题">思考题</h3><h4 id="全点对最短路径算法动态规划算法范式">全点对最短路径算法动态规划算法范式</h4><p><strong>Step1</strong>：描述最优解的结构特征：最短路径的部分路径必然是最短的</p><p><strong>Step2</strong>：定义最优解决方案的递归形式 <span class="math display">\[\begin{cases}m = 0: l_{i,j}^{(0)} = \begin{cases}0 ,&amp; i = j \\∞ ,&amp; i \ne j\end{cases}\\m \ge 1:l_{i,j}^{(m)} = min_{1\le k\le n} \ l_{i,k}^{(m-1)}+w_{k,j}\end{cases}\]</span> <strong>Step3</strong>：以自底向上的方式计算优解决方案的值：从最多只有 0 条边开始，一直计算到最多有 V-1 条边结束</p><p><strong>Step4</strong>：从计算信息构造出优解决方案 由于不必计算所有 L(m)，而且如果没有负回路,可以得到： L(m) = L(n - 1) 对所有 m &gt;= n – 1 成立,所以我们可以通过下式计算： <span class="math display">\[L^{(2n)} = W^{2n} = W^n \cdot W^n\]</span></p><h4 id="图的存储方式和运算效率之间的关系">图的存储方式和运算效率之间的关系</h4><p>选择合适的数据结构，当然可以提高运算的效率；比如若采用矩阵的方式存储边集，如果在边不密集的情况下，那么有很多的空间将被浪费；除此之外，当遍历矩阵时，会有很多的无效遍历；所以对于稀疏图而言，链式前向星将是一种更加有效的方法：既不会很浪费空间（甚至在很多情况下比邻接矩阵还要节约空间），也可以很快的遍历；对于存在双向边的图而言，使用链式前向星还可以方便的通过<code>^1</code>找到边的反向边，还可以直接顺序遍历所有的边，从而为很多算法做好了基础。</p><p>在绝大多数的情况下，如果不是图比较稠密或者使用 Floyd 这种必须要使用矩阵存边的算法的时候，使用链式前向星存图是最优解。</p><h3 id="后记">后记</h3><p>最后一次的算法比较板子，没什么代码量。最短路是很基础的算法了，但是很多思想都可以在其他的地方使用。即使是最短路算法的题目，也可以出的非常花哨。</p>]]></content>
      
      
      <categories>
          
          <category> 课业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课内作业 </tag>
            
            <tag> 算法 </tag>
            
            <tag> C++ </tag>
            
            <tag> 实验报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>点分治 &amp; 动态点分治 - 学习笔记</title>
      <link href="/2020/learn-point-dc-on-tree-and-dynamic-point-dc/"/>
      <url>/2020/learn-point-dc-on-tree-and-dynamic-point-dc/</url>
      
        <content type="html"><![CDATA[<p>开始之前首先是题单：这些题目都是洛谷上的，非常的友好（指访问上）；如果你有什么觉得不错的点分治的题目也可以评论告诉我，我去康康==</p><blockquote><h5 id="点分治">点分治</h5><ul><li>洛谷 P2634 [国家集训队]聪聪可可： <a href="https://www.luogu.com.cn/problem/P2634">立即前往&gt;&gt;</a></li><li>洛谷 P3806 【模板】点分治1： <a href="https://www.luogu.com.cn/problem/P3806">立即前往&gt;&gt;</a></li><li>洛谷 P4178 Tree： <a href="https://www.luogu.com.cn/problem/P4178">立即前往&gt;&gt;</a></li><li>洛谷 P2664 树上游戏： <a href="https://www.luogu.com.cn/problem/P2664">立即前往&gt;&gt;</a></li><li>洛谷 P4149 [IOI2011]Race： <a href="https://www.luogu.com.cn/problem/P4149">立即前往&gt;&gt;</a></li><li>洛谷 P2305 [NOI2014]购票： <a href="https://www.luogu.com.cn/problem/P2305">立即前往&gt;&gt;</a></li><li>洛谷 P2993 [FJOI2014]最短路径树问题： <a href="https://www.luogu.com.cn/problem/P2993">立即前往&gt;&gt;</a></li><li>洛谷 P4292 [WC2010]重建计划： <a href="https://www.luogu.com.cn/problem/P4292">立即前往&gt;&gt;</a></li></ul><h5 id="动态点分治">动态点分治</h5><ul><li>洛谷 P2056 [ZJOI2007]捉迷藏： <a href="https://www.luogu.com.cn/problem/P2056">立即前往&gt;&gt;</a></li><li>洛谷 P3345 [ZJOI2015]幻想乡战略游戏： <a href="https://www.luogu.com.cn/problem/P3345">立即前往&gt;&gt;</a></li><li>洛谷 P3241 [HNOI2015]开店： <a href="https://www.luogu.com.cn/problem/P3241">立即前往&gt;&gt;</a></li><li>洛谷 P3676 小清新数据结构题： <a href="https://www.luogu.com.cn/problem/P3676">立即前往&gt;&gt;</a></li><li>洛谷 P3920 [WC2014]紫荆花之恋： <a href="https://www.luogu.com.cn/problem/P3920">立即前往&gt;&gt;</a></li></ul><h5 id="其他补充">其他补充</h5><ul><li><em>弹幕装填中……</em></li></ul></blockquote><p>因为我很屑，不能保证一次把上边的题目做完，所以需要吊在开头时刻警醒自己==</p><p>那么接下来开始本篇文章的正文内容：</p><h2 id="背景">背景</h2><p>点分治是图论中一种树上分治的算法。树分治主要又有两种：点分治和边分治，还有一种以这个为思想的分治树。这里的点分治就是这篇文章要讨论的点分治。</p><p>有些题目看起来像是可以使用树上动规，但是却很难使用数组去维护它所需要的信息，这种题目往往需要点分治来解决。通过直接统计或者加上数据结构维护，就可以统计之前不好统计一些的东西。</p><p>顾名思义，点分治是一种分治，还是在点上的分治。每次把无根树拆成子树，递归进行处理，最后通过计算贡献的方式将计算结果合并，得到最终整个树的答案。</p><h2 id="点分治-1">点分治</h2><p>刚才也说了，点分治是分治，需要递归的处理子树。事实上代码里也是成块成块的DFS。显然，这样的递归的时间受到它最大的子树的大小的影响：比如极端情况下，链的递归时间复杂度是O(n²)。但是比起一般的搜索，点分治在拆分之前会优先寻找无根树的重心，将它作为根进行递归。</p><blockquote><p><strong>树的重心</strong>： 以重心为此无根树的根，这棵树的最大子树最小。若全树的大小为n，以重心为根时的每一个子树的大小都不超过n/2（可使用反证法证明）。</p></blockquote><p>如果每次递归都是寻找树的重心进行，那么递归层数一定是最优的。所以本质上，点分治是优化的暴力，在合并过程还会用到容斥原理的思想。点分治每次递归都选择重心作为分治点，问题规模上界降低到原来的1/2，使得整体的复杂度降低到O(nlogn)。</p><p>接下来通过解最经典的点分治的题目<a href="https://www.luogu.com.cn/problem/P4178">洛谷 P4178 Tree</a>，来详细说明点分治的每一个过程。建议看下面的内容之前先去读个题，或者拉到后面看完这个题的题解。</p><h3 id="求树的重心">求树的重心</h3><p>知道了重心好，那么怎么找到这个最优的分治点呢？暴力找：DFS的话可以在O(n)的时间里找到。<code>findRoot</code>函数可以找到一颗无根树的重心，将无根树转化为有根树，利用递归统计子树大小。这里的代码和后面的代码都使用了前向星存树，使用了<code>FWS</code>的一些经典变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">size</span>[u] = <span class="number">1</span>; <span class="keyword">int</span> maxPart = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = head[u]; ~c; c = ee[c].next)</span><br><span class="line">    &#123;</span><br><span class="line">        edge&amp; e = ee[c]; <span class="keyword">int</span>&amp; v = e.v;</span><br><span class="line">        <span class="keyword">if</span> (v == father || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        findRoot(v, u);</span><br><span class="line">        <span class="built_in">size</span>[u] += <span class="built_in">size</span>[v];             </span><br><span class="line">        maxPart = <span class="built_in">max</span>(maxPart, <span class="built_in">size</span>[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    maxPart = <span class="built_in">max</span>(maxPart, _sum - <span class="built_in">size</span>[u]);</span><br><span class="line">    <span class="keyword">if</span> (maxPart &lt; _part) setRoot(u, maxPart);</span><br><span class="line">    <span class="keyword">return</span> _root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的函数中：<code>size[u]</code>表示以u在当前递归的顺序下作为根节点的子树的大小（节点数量）；<code>maxPart</code>用来记录当前已经找到的最大子树；<code>_sum</code>保存了当前查找重心的全树的大小；<code>_part</code>和<code>_root</code>用来暂存结果：重心节点的编号和它的max-part，使用宏<code>setRoot</code>更新。</p><p>因为整个树是无根树，所以子树大小也只是“当前递归的顺序下作为根节点”意义上的。也就是说，虽然这个点可能是被递归调用的，father是有意义的节点；但是因为是无根树，节点u的“当前递归的顺序下“的父节点以及其他兄弟节点，也可以被看作u的一颗子树——这棵子树的大小就使用容斥原理进行计算：sum - size[u]。</p><p>显然，你的顶层调用（非递归调用）是为了寻找一整颗树的重心：你需要将<code>_sum</code>初始化为这棵树的大小、<code>_part</code>初始化为无穷大、<code>_root</code>初始化为不存在的节点，然后才能开始搜索。我写了宏<code>cleanRoot</code>来完成这项工作。</p><h3 id="从重心开始分治">从重心开始分治</h3><p>我们知道了重心，那么就可以以重心作为分治点开始分治递归了。虽然具体的分治函数要取决于问你的模型，但是分治函数具有相似的特点。对于这个题目，我们做出的分治是：对于每颗树，只考虑经过它的根的路径；其他的路径因为一定会经过子树的根，所以作为子问题分治。</p><p>这里贴的代码仅针对这道题目：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dc</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ans += <span class="built_in">process</span>(u, <span class="number">0</span>);<span class="comment">////////////////////////</span></span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = head[u]; ~c; c = ee[c].next)</span><br><span class="line">    &#123;</span><br><span class="line">        edge &amp;e = ee[c]; <span class="keyword">int</span> &amp;v = e.v;</span><br><span class="line">        <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        ans -= <span class="built_in">process</span>(v, e.w);<span class="comment">////////////////////</span></span><br><span class="line">        cleanRoot(<span class="built_in">size</span>[v]);</span><br><span class="line">        <span class="keyword">auto</span> root = findRoot(v, u);</span><br><span class="line">        dc(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两行用斜杠标记的部分是本题特殊的地方；一般的核心分治函数的大概结构就像上面这样。<code>process</code>是本题中用来计算答案的函数；宏<code>cleanRoot</code>用来重置root信息。</p><p>对于本题，<code>process</code>函数可以求出当前树中所有子节点到根节点的距离。我们先看它出现的两行：第一次出现不难理解，要求出经过根节点的路径，必然要先求出这些”半路径“进行组合；但是第二次出现却显得有些莫名其妙。</p><p>首先我们考虑下面的树：</p><figure><img src="https://i.loli.net/2020/04/23/PKYNE9bfSoQ13yr.png" class="lazyload" data-srcset="https://i.loli.net/2020/04/23/PKYNE9bfSoQ13yr.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1126418-20180317225729674-1956875804.png" /><figcaption aria-hidden="true">1126418-20180317225729674-1956875804.png</figcaption></figure><p>第一行的process会求出这些半边："A"、"A - B"、"A - B - D"、"A - B - E"、"A - C"、"A - C - F"——准确的说是将它们的长度可重复的存进数组。根据分析，接下来只要将它们俩俩组合，就可以得到分析的”通过树根的路径“。但是显然，"A - B - D"、"A - B - E"组合得到的"D - B - A - B - E"并不是一条合法路径。</p><p>究其原因，是因为参加组成的两条”半边“都来自于A的同一颗子树B。所以，最直接的方法，就是对于每颗子树单独统计来自它的到根的边的贡献，将它们从答案中减去。因为此时求的仍然是到根A的距离，但是DFS从B开始，所以统计得到到B的长度都应该加上"A - B"的边长。</p><p>这样利用容斥原理，最终在这次分治中对答案造成的贡献，就是分析中要求的”经过根节点的路径“。对于这个节点，总的时间复杂度是O(nlogn)。非常好。</p><p>那么接下来的分治的时间复杂度要怎么保证呢？这个时候，应该再次意识到这是一颗无根树——将一个节点算完之后，它的子树之间就互不影响了。对于它的每颗子树，我们都可以当作一个新问题——找到重心保证最优递归深度，然后继续分治。又因为重心的子树的大小不超过全树的一半，每次寻找重心的递归深度上界是logn，因此整体复杂度是O(nlog²n)。</p><p>能看到上面的代码的后半部分就是：首先重置并且寻找子树的重心，然后对子树启动分治。</p><h3 id="子树找重心">子树找重心</h3><p>因为子树完全和全树是同样的问题，所以可以采用同样的流水线：先初始化root，再从子树的”第一个端点“——也就是直接和上一轮的重心相连的节点开始找到重心，然后启动分治。</p><p>这里有一个问题：最开始，对于全树而言，<code>_sum = n</code>并没有什么问题。但是对于子树来说，<code>_sum == size[u]</code>真的成立吗？因为是无根树，子树中直接连接上轮重心的节点未必是本轮这颗子树的重心：这导致本轮处理的传入的树的总点数可能并不正确。我先列出正确的式子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-_sum = <span class="built_in">size</span>[v];</span><br><span class="line">+ _sum = <span class="built_in">size</span>[v] &gt; <span class="built_in">size</span>[u] ? _sum - <span class="built_in">size</span>[u] : <span class="built_in">size</span>[v]</span><br></pre></td></tr></table></figure><p>要想知道之前设置为<code>size[v]</code>对不对，我们首先要知道size是怎么来的：这里传入的<code>size[v]</code>，准确的定义是”本轮中与上一轮的重心相连的点，以上轮的根为根（父节点）的子树大小“。因为是无根树，我们已经知道了”根“可能并不是”重心“，于是就有可能出现下图所示的情况：</p><figure><img src="https://i.loli.net/2020/04/23/6wxeVr4mSRlZoJ1.png" class="lazyload" data-srcset="https://i.loli.net/2020/04/23/6wxeVr4mSRlZoJ1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="RYH4YJ_5YN_XTMNHS2TD80K.png" /><figcaption aria-hidden="true">RYH4YJ_5YN_XTMNHS2TD80K.png</figcaption></figure><p>上一轮的根为v，重心为u：此时若对重心u的子树v进行寻根，很显然<code>size[v]</code>并不是子树的大小。当本轮的根（起始搜索点）和上轮的根在上轮的重心的同一颗子树中的时候，<code>size[v]</code>是错误的值，应当修正。</p><p>但是这个错误真的影响这个算法的复杂度或正确性吗？我们先回顾一下我们的寻找重心的方式：从本轮的”根“开始DFS，并且计算子树大小；将传入的全树大小与以自身为根的子树大小的差作为”根方向“的子树的大小，从而计算最大子树的大小。</p><p>结论是不影响的，所以大可不必写麻烦的代码。数学证明可以去看这篇文章：<a href="http://liu-cheng-ao.blog.uoj.ac/blog/2969">传送门</a></p><h3 id="算法流程">算法流程</h3><p>总结一下上面的内容，可知针对于无根树的点分治算法一共分为三步：</p><ul><li>找到当前全树的重心，并以该重心作为分治点</li><li>启动分治，并且调用解题/计算函数处理当前树的整体</li><li>找到每一颗子树的重心，作为子问题发起新的分治</li></ul><p>难点就在解题/计算函数的设计。一般而言，点分治适合处理树上简单路径的问题，但是也不止于此。很多题目通过巧妙的构造计算函数，也可以使用点分治快速解决。至于分治的设计：处理树上简单路径的时候，往往将树上的路径分为经过当前分治点的和不经过分治点的两种类型：第一类在本次分治时使用其他函数处理，第二类作为子问题递归处理。</p><h2 id="动态点分治-1">动态点分治</h2><h2 id="刷题记录">刷题记录</h2><p>这里刷题的顺序可能和上面的题单顺序不一样，请明察（</p><h3 id="洛谷-p4178-tree"><a href="https://www.luogu.com.cn/problem/P4178">洛谷 P4178 Tree</a></h3><p>文　明　起　源（大雾； 这里只介绍点分治做法</p><blockquote><p>给定一颗n个节点的有边权树，求树上两点距离小于等于k的点对数量。</p><p>数据规模：N = 4e4，边权小于1000，K = 2e4</p></blockquote><p>虽然上面讲点分治已经非常仔细的介绍了，这里就简单的进行一下分析：</p><p>显然这个题目没办法用简单的DFS来统计——那应该怎么在DFS中统计树中符合条件的路径数量？一般的DFS对于这种树上路径统计的问题是苦手的。</p><p>假设我们已经找到了全树重心root。对于全树中的路径，我们把它分为两类：第一类经过了root，另一类没经过。显然，后者一定完全在t的某棵子树里面，而前者不在。也就是说，答案 = 经过root的路径的答案 + root的所有子树的子问题的答案；对于子问题，直接递归，只需要考虑第一类答案即可。</p><p>第一类答案是通过根节点的路径长度。这种长度显然可以拆成两条从根节点出发的简单路径的长度和，然而从根节点出发的简单路径的长度是很容易DFS得到的。对于一棵树，可以将从根节点出发得到的所有路径长度存进数组里，然后将它们两两匹配，就可以得到第一类路径。</p><p>这里还存在隐含的问题：若两条简单路径来自于根的同一颗子树，则它们组成的路径含有重边，是无效的；对于这种情况，我们依然可以利用容斥思想：仅统计子树中的节点到根的简单路径，将这些简单路径的贡献从答案中剔除，剩下的就都是来自不同子树的简单路径的贡献了。</p><p>统计完一棵树中所有路径长度之后，可以利用双指针的策略来获得所有满足要求的匹配的数量。至此，我们知道这样的实现步骤：</p><ul><li>DC主操作：统计全树合法匹配，对每一棵子树利用容斥减去来自同子树的贡献</li><li>计算函数：DFS计算全树所有节点到根的距离，并且存入特定数组</li><li>统计函数：利用双指针的技巧，统计出计算函数求出的路径的合法对数，并返回DC主操作</li></ul><p>这样，就可以修改模板解出这个题目了。具体实现请看下面的全部代码。</p><h4 id="代码">代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w, next;</span><br><span class="line">    edge() = <span class="keyword">default</span>;</span><br><span class="line">    edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> next)</span><br><span class="line">            : u(u), v(v), w(w), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e4</span>+<span class="number">5</span>, M = N;</span><br><span class="line"><span class="keyword">int</span> n, k, ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FWS</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> head[N];</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    edge ee[M * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ee[tot] = edge(u,v,w,head[u]);</span><br><span class="line">        head[u] = tot ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> PointDC</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>[N];            <span class="comment">// size统计整个子树大小</span></span><br><span class="line">    <span class="keyword">bool</span> vis[N];            <span class="comment">// 记录子树是否已经被分治处理过</span></span><br><span class="line">    <span class="keyword">int</span> _sum;               <span class="comment">// 记录将要分治的子树大小，以计算另一个子树的大小</span></span><br><span class="line">    <span class="keyword">int</span> _root;              <span class="comment">// findRoot中用来临时记录找到的重心</span></span><br><span class="line">    <span class="keyword">int</span> _part;              <span class="comment">// findRoot当前找到的重心的maxPart</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> path[N], cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span>(*calculate)(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>) = [](<span class="keyword">int</span> u, <span class="keyword">int</span> father, <span class="keyword">int</span> distance)</span><br><span class="line">    &#123;</span><br><span class="line">        path[cnt ++] = distance;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = head[u]; ~c; c = ee[c].next)</span><br><span class="line">        &#123;</span><br><span class="line">            edge&amp; e = ee[c]; <span class="keyword">int</span>&amp; v = e.v;</span><br><span class="line">            <span class="keyword">if</span> (v == father || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            calculate(v, u, distance + e.w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> cleanRoot = [](<span class="keyword">int</span> <span class="built_in">size</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _root = <span class="number">0</span>; _part = inf;</span><br><span class="line">        _sum = <span class="built_in">size</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> setRoot = [](<span class="keyword">int</span> u, <span class="keyword">int</span> maxPart)</span><br><span class="line">    &#123;</span><br><span class="line">        _part = maxPart;</span><br><span class="line">        _root = u;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">bool</span>) * (n + <span class="number">1</span>));</span><br><span class="line">        setRoot(<span class="number">0</span>, inf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> father)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">size</span>[u] = <span class="number">1</span>; <span class="keyword">int</span> maxPart = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = head[u]; ~c; c = ee[c].next)</span><br><span class="line">        &#123;</span><br><span class="line">            edge&amp; e = ee[c]; <span class="keyword">int</span>&amp; v = e.v;</span><br><span class="line">            <span class="keyword">if</span> (v == father || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            findRoot(v, u);</span><br><span class="line">            <span class="built_in">size</span>[u] += <span class="built_in">size</span>[v];             <span class="comment">// 统计子树大小，以找到最大子树</span></span><br><span class="line">            maxPart = <span class="built_in">max</span>(maxPart, <span class="built_in">size</span>[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        maxPart = <span class="built_in">max</span>(maxPart, _sum - <span class="built_in">size</span>[u]);</span><br><span class="line">        <span class="keyword">if</span> (maxPart &lt; _part) setRoot(u, maxPart);</span><br><span class="line">        <span class="keyword">return</span> _root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> distance)</span>        <span class="comment">// 双指针做法</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cnt = <span class="number">0</span>; calculate(u, <span class="number">0</span>, distance);</span><br><span class="line">        <span class="keyword">int</span> _ans = <span class="number">0</span>, l = <span class="number">0</span>, r = cnt - <span class="number">1</span>;</span><br><span class="line">        sort(path, path + cnt);</span><br><span class="line">        <span class="keyword">for</span> (;; ++l)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (r != <span class="number">-1</span> &amp;&amp; path[l] + path[r] &gt; k) -- r;</span><br><span class="line">            <span class="keyword">if</span> (r &lt; l) <span class="keyword">break</span>;</span><br><span class="line">            _ans += r - l + <span class="number">1</span>;<span class="comment">// 这个区间都可以和l配对</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dc</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ans += <span class="built_in">process</span>(u, <span class="number">0</span>);</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = head[u]; ~c; c = ee[c].next)</span><br><span class="line">        &#123;</span><br><span class="line">            edge &amp;e = ee[c]; <span class="keyword">int</span> &amp;v = e.v;</span><br><span class="line">            <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            ans -= <span class="built_in">process</span>(v, e.w);<span class="comment">// 只需要来自不同子树的配对</span></span><br><span class="line">            cleanRoot(<span class="built_in">size</span>[v]);</span><br><span class="line">            <span class="keyword">auto</span> root = findRoot(v, u);</span><br><span class="line">            dc(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solution</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        cleanRoot(n);</span><br><span class="line">        <span class="keyword">auto</span> root = findRoot(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        dc(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> addEdge = [&amp;](<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span><br><span class="line">    &#123;</span><br><span class="line">        FWS::addedge(u, v, w);</span><br><span class="line">        FWS::addedge(v, u, w);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// freopen(R&quot;(D:\shiroha\Downloads\P4178_1.in)&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n; <span class="keyword">int</span> u, v, w;</span><br><span class="line">    FWS::init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        addEdge(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">    PointDC::solution();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans - n &lt;&lt; <span class="built_in">endl</span>;        <span class="comment">// 答案不包括单点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题目似乎还有其他的解法，但是这里就不赘述了。</p><h3 id="洛谷-p3806-模板点分治1"><a href="https://www.luogu.com.cn/problem/P3806">洛谷 P3806 【模板】点分治1</a></h3><p>我做的第一个点分治的题目<del>（毕竟是模板</del></p><blockquote><p>给定一颗 n 个节点的有边权树，询问树上距离为 k 的点对是否存在，询问 m 次。</p><p>N = 1e4，M ≤ 100，边权小于1e4，K = 1e7</p></blockquote><p>和上一个题非常相似，只不过询问的东西变成了是否等于 k，并且询问的次数变多了。</p><p>每询问一次就找一次显然不太合算，反正题目也没有要求强制在线，可以一次读入所有的请求，然后离线处理所有的答案，最后统一输出。</p><p>和上一题一样，这一题也可以用一个DFS将全树/某一子树所有可能出现的到根节点的距离求出来。但是这一次如果像上一题那样求出所有的和，想必是不太划算的。为判断长度为k的边是否存在，每次扫完一颗子树之后，就求出询问长度对这次求出的路径长度的差，并记录。之后如果扫描到的长度恰好存在相等的”差“的记录，就说明它一定可以和之前子树中出现的某条路径组合成满足要求长度的边。</p><p>这是一种比较巧妙的做法：不仅避免了两条路径同源的问题，还避免了求出所有的路径和查找。记录这些”差“，可以采用访问是O(1)的桶。</p><p>注意到题目中说到询问的最大值是K，那么就可以使用K作为桶的大小：不论是超过K的边还是超过K的”差“的记录，一定不会对答案造成贡献，可以直接忽视。事实上，内存限制也不允许我们开太大的桶。</p><h4 id="代码-1">代码</h4><p>其实这才是我做的最早的一个点分治的题目，有些风格和现在的不一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w, next;</span><br><span class="line">    edge() = <span class="keyword">default</span>;</span><br><span class="line">    edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> next)</span><br><span class="line">            : u(u), v(v), w(w), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>, M = N;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, queries[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FWS</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> head[N];</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    edge ee[M*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ee[tot] = edge(u,v,w,head[u]);</span><br><span class="line">        head[u] = tot ++;</span><br><span class="line">        ee[tot] = edge(v,u,w,head[v]);</span><br><span class="line">        head[v] = tot ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> PointDC</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> maxPart[N];         <span class="comment">// subtree记录最大子树</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>[N];            <span class="comment">// size统计整个子树大小</span></span><br><span class="line">    <span class="keyword">bool</span> vis[N];            <span class="comment">// 记录子树是否已经被分治处理过</span></span><br><span class="line">    <span class="keyword">int</span> sum;                <span class="comment">// 记录将要分治的子树大小，以计算另一个子树的大小</span></span><br><span class="line">    <span class="keyword">int</span> _root;              <span class="comment">// findRoot中用来临时记录找到的重心</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> buf = <span class="number">1e7</span>;    <span class="comment">// 标记距离的桶大小：询问的上限</span></span><br><span class="line">    <span class="keyword">bool</span> has[buf+<span class="number">5</span>];        <span class="comment">// 到根距离为i的路径是否存在</span></span><br><span class="line">    <span class="keyword">int</span> rem[N];             <span class="comment">// 记录全树中可能出现的路径长度；[0]记录实际长度</span></span><br><span class="line">    <span class="keyword">int</span> dis[N];             <span class="comment">// 记录节点到子树根的距离</span></span><br><span class="line">    <span class="keyword">int</span> can[N];             <span class="comment">// calculate中，和cnt一起用来临时记录出现过的距离</span></span><br><span class="line">    <span class="keyword">int</span>* _query;            <span class="comment">// 离线算法：记录的询问</span></span><br><span class="line">    <span class="keyword">int</span> _count;             <span class="comment">// 离线算法：询问的数量</span></span><br><span class="line">    <span class="keyword">bool</span> test[N];           <span class="comment">// 离线算法：用来标记i号询问的结果</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">bool</span>) * (n + <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">memset</span>(has, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">bool</span>) * (n + <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">memset</span>(test, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">bool</span>) * (n + <span class="number">1</span>));</span><br><span class="line">        _query = ::queries;</span><br><span class="line">        _count = ::m;</span><br><span class="line">        _root = <span class="number">0</span>;</span><br><span class="line">        rem[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> father)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">size</span>[u] = <span class="number">1</span>; maxPart[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">using</span> FWS::head; <span class="keyword">using</span> FWS::ee;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = head[u]; ~c; c = ee[c].next)</span><br><span class="line">        &#123;</span><br><span class="line">            edge&amp; e = ee[c]; <span class="keyword">int</span>&amp; v = e.v;</span><br><span class="line">            <span class="keyword">if</span> (v == father || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            findRoot(v, u);</span><br><span class="line">            <span class="built_in">size</span>[u] += <span class="built_in">size</span>[v];             <span class="comment">// 统计子树大小，以找到最大子树</span></span><br><span class="line">            maxPart[u] = <span class="built_in">max</span>(maxPart[u], <span class="built_in">size</span>[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        maxPart[u] = <span class="built_in">max</span>(maxPart[u], sum - <span class="built_in">size</span>[u]);</span><br><span class="line">        <span class="keyword">if</span> (maxPart[u] &lt; maxPart[_root])</span><br><span class="line">            <span class="keyword">return</span> _root = u;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> _root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">distance</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> father)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        rem[++rem[<span class="number">0</span>]] = dis[u];             <span class="comment">// 标记当前树根的距离</span></span><br><span class="line">        <span class="keyword">using</span> FWS::head; <span class="keyword">using</span> FWS::ee;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = head[u]; ~c; c = ee[c].next)</span><br><span class="line">        &#123;</span><br><span class="line">            edge &amp;e = ee[c]; <span class="keyword">int</span> &amp;v = e.v;</span><br><span class="line">            <span class="keyword">if</span> (v == father || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            dis[v] = dis[u] + e.w;</span><br><span class="line">            distance(v, u);                 <span class="comment">// 递归地查找子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">using</span> FWS::head; <span class="keyword">using</span> FWS::ee;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = head[u]; ~c; c = ee[c].next)</span><br><span class="line">        &#123;</span><br><span class="line">            edge&amp; e = ee[c]; <span class="keyword">int</span>&amp; v = e.v;</span><br><span class="line">            <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            rem[<span class="number">0</span>] = <span class="number">0</span>; dis[v] = e.w;</span><br><span class="line">            distance(v, u);                 <span class="comment">// 计算该子树中点到顶点u的距离</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rem[<span class="number">0</span>]; j; --j)    <span class="comment">// rem记录了该子树所有点到u距离</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= _count; ++ k)</span><br><span class="line">                    <span class="keyword">if</span> (_query[k] &gt;= rem[j])</span><br><span class="line">                        test[k] |= has[_query[k] - rem[j]];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = rem[<span class="number">0</span>]; j; --j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (rem[j] &gt; buf) <span class="keyword">continue</span>; <span class="comment">// 针对：超出询问范围，忽略</span></span><br><span class="line">                can[++cnt] = rem[j];</span><br><span class="line">                has[rem[j]] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i)     <span class="comment">// 处理完子树后，清空标记</span></span><br><span class="line">            has[can[i]] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dc</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vis[u] = has[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        calculate(u);                       <span class="comment">// 查找子树u中的“第一类路径”</span></span><br><span class="line">        <span class="keyword">using</span> FWS::head; <span class="keyword">using</span> FWS::ee;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = head[u]; ~c; c = ee[c].next)</span><br><span class="line">        &#123;</span><br><span class="line">            edge&amp; e = ee[c]; <span class="keyword">int</span>&amp; v = e.v;</span><br><span class="line">            <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            sum = <span class="built_in">size</span>[v];                  <span class="comment">// 顶层查找子树重心调用</span></span><br><span class="line">            maxPart[_root = <span class="number">0</span>] = ::INF;</span><br><span class="line">            <span class="keyword">int</span> root = findRoot(v, <span class="number">0</span>);</span><br><span class="line">            dc(root);                       <span class="comment">// 分治：进而处理子树</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solution</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        maxPart[_root] = sum = n;          <span class="comment">// 初始化：查找全树重心</span></span><br><span class="line">        <span class="keyword">int</span> root = findRoot(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        dc(root);                           <span class="comment">// 开始分治</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    freopen(R&quot;(D:\shiroha\Downloads\P3806_7.in)&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    FWS::init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        FWS::addedge(u,v,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; queries[i];</span><br><span class="line">    PointDC::solution();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (PointDC::test[i] ?</span><br><span class="line">                 <span class="string">&quot;AYE&quot;</span> : <span class="string">&quot;NAY&quot;</span>)</span><br><span class="line">             &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释还算比较详细吧，我觉得光看代码应该就很好懂了。</p><h3 id="洛谷-p2634-国家集训队聪聪可可"><a href="https://www.luogu.com.cn/problem/P2634">洛谷 P2634 [国家集训队]聪聪可可</a></h3><p>实际上这题的最优复杂度是树上DP，可以O(n)解出来。</p><blockquote><p>给一个有n个节点的带边权树，问树上长度可以被3整除的路径数量和全部树上路径数量的比值，并以约分后的分数的形式输出答案。</p><p>数据范围：N = 2e4</p></blockquote><p>和前面几个题不一样，本题统计的是树上路径长度可以被3整除的路径数量。我们可以参考上面题目的做法：将树上路径分成两类——其中第一类路径可以通过两个不同源的”半边“组合得到。因为模3的余数只有三种情况，得到长度可以被3整除的路径只有两种情况：余0和余0组合或者余1和余2组合。我们可以统计当前子树中到根距离模3分别为0、1、2的路径数量，按照上述规则进行组合，得到第一类路径的数量。</p><p>因为组合路径不能同源，可以使用和上面第一题一样的容斥原理分别排除子树的同源贡献。因为我们只考虑对于3的模，所以读入边权时就取模，可以避免可能会出现的边权爆int的情况。</p><p>求出了全树中，路径长度模3为0的数量之后，意识到全树的边的数量就是n*n。然后求出总边数和符合要求的路径数量的gcd，约去后输出就是答案。</p><h4 id="代码-2">代码</h4><p>因为这是讲点分治的文章，树形DP做法就不贴了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w, next;</span><br><span class="line">    edge() = <span class="keyword">default</span>;</span><br><span class="line">    edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> next)</span><br><span class="line">            : u(u), v(v), w(w), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4e4</span>+<span class="number">5</span>, M = N;</span><br><span class="line"><span class="keyword">int</span> n, ans = <span class="number">0</span>, cnt[<span class="number">3</span>], dis[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FWS</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> head[N];</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    edge ee[M * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ee[tot] = edge(u,v,w,head[u]);</span><br><span class="line">        head[u] = tot ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FWS::addedge(u, v, w);</span><br><span class="line">    FWS::addedge(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> PointDC</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>[N];            <span class="comment">// size统计整个子树大小</span></span><br><span class="line">    <span class="keyword">bool</span> vis[N];            <span class="comment">// 记录子树是否已经被分治处理过</span></span><br><span class="line">    <span class="keyword">int</span> _sum;               <span class="comment">// 记录将要分治的子树大小，以计算另一个子树的大小</span></span><br><span class="line">    <span class="keyword">int</span> _root;              <span class="comment">// findRoot中用来临时记录找到的重心</span></span><br><span class="line">    <span class="keyword">int</span> _part;              <span class="comment">// findRoot当前找到的重心的maxPart</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> dfs = <span class="keyword">void</span>(*)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">    dfs search = [](<span class="keyword">int</span> u, <span class="keyword">int</span> father)</span><br><span class="line">    &#123;</span><br><span class="line">        ++ cnt[dis[u]];</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = head[u]; ~c; c = ee[c].next)</span><br><span class="line">        &#123;</span><br><span class="line">            edge&amp; e = ee[c]; <span class="keyword">int</span>&amp; v = e.v;</span><br><span class="line">            <span class="keyword">if</span> (v == father || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            dis[v] = (dis[u] + e.w) % <span class="number">3</span>;</span><br><span class="line">            search(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> cleanRoot = [](<span class="keyword">int</span> <span class="built_in">size</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _root = <span class="number">0</span>; _part = inf;</span><br><span class="line">        _sum = <span class="built_in">size</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> setRoot = [](<span class="keyword">int</span> u, <span class="keyword">int</span> maxPart)</span><br><span class="line">    &#123;</span><br><span class="line">        _part = maxPart;</span><br><span class="line">        _root = u;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">bool</span>) * (n + <span class="number">1</span>));</span><br><span class="line">        setRoot(<span class="number">0</span>, inf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> father)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">size</span>[u] = <span class="number">1</span>; <span class="keyword">int</span> maxPart = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = head[u]; ~c; c = ee[c].next)</span><br><span class="line">        &#123;</span><br><span class="line">            edge&amp; e = ee[c]; <span class="keyword">int</span>&amp; v = e.v;</span><br><span class="line">            <span class="keyword">if</span> (v == father || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            findRoot(v, u);</span><br><span class="line">            <span class="built_in">size</span>[u] += <span class="built_in">size</span>[v];</span><br><span class="line">            maxPart = <span class="built_in">max</span>(maxPart, <span class="built_in">size</span>[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        maxPart = <span class="built_in">max</span>(maxPart, _sum - <span class="built_in">size</span>[u]);</span><br><span class="line">        <span class="keyword">if</span> (maxPart &lt; _part) setRoot(u, maxPart);</span><br><span class="line">        <span class="keyword">return</span> _root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> distance)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">        dis[u] = distance;</span><br><span class="line">        search(u, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> cnt[<span class="number">0</span>] * cnt[<span class="number">0</span>] + cnt[<span class="number">1</span>] * cnt[<span class="number">2</span>] * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dc</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ans += calculate(u, <span class="number">0</span>);</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = head[u]; ~c; c = ee[c].next)</span><br><span class="line">        &#123;</span><br><span class="line">            edge &amp;e = ee[c]; <span class="keyword">int</span> &amp;v = e.v;</span><br><span class="line">            <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            ans -= calculate(v, e.w);</span><br><span class="line">            cleanRoot(<span class="built_in">size</span>[v]);</span><br><span class="line">            <span class="keyword">auto</span> root = findRoot(v, u);</span><br><span class="line">            dc(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solution</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        cleanRoot(n);</span><br><span class="line">        <span class="keyword">auto</span> root = findRoot(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        dc(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n; FWS::init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        addEdge(u, v, w % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PointDC::solution();</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">int</span> tot = n * n,</span><br><span class="line">        xx = gcd(tot, ans);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (ans / xx) &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; (tot / xx) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和万物起源Tree一样，统计长度模3不同余数的路径数量再组装成”第一类路径“，递归处理”第二类路径“。</p><h3 id="洛谷-p4149-ioi2011race"><a href="https://www.luogu.com.cn/problem/P4149">洛谷 P4149 [IOI2011]Race</a></h3><p>题面言简意赅</p><blockquote><p>给一棵树，每条边有权。求一条简单路径，权值和等于k，且边的数量最小；<strong>点从0开始编号</strong>；若不存在这样的路径，输出-1；否则，输出这样的路径包含的边数。</p><p>数据范围：N = 2e5，K = 1e6，边权不超过K。</p></blockquote><p>这题要是用树形DP：设 f[i][j] 是以i为根的子树中长度为j的路径最小边数，那光是空间复杂度就已经是 N*K 的爆炸水准了，更不必说还要手动转移填满它的时间；所以使用点分治来做：</p><p>和前面求等于k的书上路径一样：使用桶存储之前开的子树中找到的长度，并且使用另一个桶维护每一种路径长度在已经搜索过的子树中出现的最少边数。在查找子树的过程中，利用当前的边的长度和桶维护的信息更新答案的最小值即可；用树规一点的说法，就是 f[j] 表示以重心为根的子树中长度为j的路径最小边数：在分治点DFS更新该数组，并顺便使用和为k的第一类路径去更新ans即可。</p><p>综上所述：使用点分治解决此题，空间复杂度是 O(K)，时间复杂度 O(nlogn)。</p><p>需要注意的是：因为询问有上限K，所以桶开到K就可以了；此外，当前搜索过程中距离已经大于k的情况，可以直接剪枝返回。</p><h4 id="代码-3">代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> longs INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w, next;</span><br><span class="line">    edge() = <span class="keyword">default</span>;</span><br><span class="line">    edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> next)</span><br><span class="line">            : u(u), v(v), w(w), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">5</span>, M = N;</span><br><span class="line"><span class="keyword">int</span> n, k, ans = inf;</span><br><span class="line">longs dis[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FWS</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> head[N];</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    edge ee[M * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ee[tot] = edge(u,v,w,head[u]);</span><br><span class="line">        head[u] = tot ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FWS::addedge(u, v, w);</span><br><span class="line">    FWS::addedge(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> PointDC</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>[N];</span><br><span class="line">    <span class="keyword">bool</span> vis[N];</span><br><span class="line">    <span class="keyword">int</span> _sum;</span><br><span class="line">    <span class="keyword">int</span> _root;</span><br><span class="line">    <span class="keyword">int</span> _part;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> dfs = <span class="keyword">void</span>(*)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> buf = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> rem[N], path[N], cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len[buf], _now;</span><br><span class="line">    <span class="keyword">int</span> used[buf], has[buf];</span><br><span class="line"></span><br><span class="line">    dfs distance = [](<span class="keyword">int</span> u, <span class="keyword">int</span> father)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> nowPath = _now + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (dis[u] &lt;= k)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">min</span>(ans, nowPath + len[k - dis[u]]);</span><br><span class="line">            rem[++ cnt] = dis[u];</span><br><span class="line">            path[cnt] = nowPath;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = head[u]; ~c; c = ee[c].next)</span><br><span class="line">        &#123;</span><br><span class="line">            edge &amp;e = ee[c]; <span class="keyword">const</span> <span class="keyword">int</span> v = e.v;</span><br><span class="line">            <span class="keyword">if</span> (vis[v] || v == father) <span class="keyword">continue</span>;</span><br><span class="line">            dis[v] = dis[u] + e.w;</span><br><span class="line">            _now = nowPath; distance(v, u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> cleanRoot = [](<span class="keyword">int</span> <span class="built_in">size</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _root = <span class="number">0</span>; _part = inf;</span><br><span class="line">        _sum = <span class="built_in">size</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> setRoot = [](<span class="keyword">int</span> u, <span class="keyword">int</span> maxPart)</span><br><span class="line">    &#123;</span><br><span class="line">        _part = maxPart;</span><br><span class="line">        _root = u;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">bool</span>) * (n + <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">memset</span>(len, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(len));</span><br><span class="line">        <span class="built_in">memset</span>(has, <span class="number">0</span>, <span class="keyword">sizeof</span>(has));</span><br><span class="line">        len[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        setRoot(<span class="number">0</span>, inf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> father)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">size</span>[u] = <span class="number">1</span>; <span class="keyword">int</span> maxPart = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = head[u]; ~c; c = ee[c].next)</span><br><span class="line">        &#123;</span><br><span class="line">            edge&amp; e = ee[c]; <span class="keyword">int</span>&amp; v = e.v;</span><br><span class="line">            <span class="keyword">if</span> (v == father || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            findRoot(v, u);</span><br><span class="line">            <span class="built_in">size</span>[u] += <span class="built_in">size</span>[v];</span><br><span class="line">            maxPart = <span class="built_in">max</span>(maxPart, <span class="built_in">size</span>[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        maxPart = <span class="built_in">max</span>(maxPart, _sum - <span class="built_in">size</span>[u]);</span><br><span class="line">        <span class="keyword">if</span> (maxPart &lt; _part) setRoot(u, maxPart);</span><br><span class="line">        <span class="keyword">return</span> _root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dis[u] = used[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = head[u]; ~c; c = ee[c].next)</span><br><span class="line">        &#123;</span><br><span class="line">            edge &amp;e = ee[c]; <span class="keyword">const</span> <span class="keyword">int</span> v = e.v;</span><br><span class="line">            <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            dis[v] = e.w; cnt = _now = <span class="number">0</span>;</span><br><span class="line">            distance(v, u);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = cnt; j; -- j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!has[rem[j]])</span><br><span class="line">                &#123;</span><br><span class="line">                    used[++ used[<span class="number">0</span>]] = rem[j];</span><br><span class="line">                    has[rem[j]] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                len[rem[j]] = <span class="built_in">min</span>(len[rem[j]], path[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = used[<span class="number">0</span>]; i; -- i)</span><br><span class="line">        &#123;</span><br><span class="line">            len[used[i]] = inf;</span><br><span class="line">            has[used[i]] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dc</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vis[u] = <span class="literal">true</span>; calculate(u);</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = head[u]; ~c; c = ee[c].next)</span><br><span class="line">        &#123;</span><br><span class="line">            edge &amp;e = ee[c]; <span class="keyword">int</span> &amp;v = e.v;</span><br><span class="line">            <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            cleanRoot(<span class="built_in">size</span>[v]);</span><br><span class="line">            <span class="keyword">auto</span> root = findRoot(v, u);</span><br><span class="line">            dc(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solution</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        cleanRoot(n);</span><br><span class="line">        <span class="keyword">auto</span> root = findRoot(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        dc(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    freopen(R&quot;(D:\shiroha\Downloads\P4149_2.in)&quot;, &quot;r&quot;, stdin);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k; FWS::init();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        addEdge(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    PointDC::solution();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (ans &gt;= inf ? <span class="number">-1</span> : ans) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本还是套板子：只是注意到顶点从0开始，需要修改<code>PointDC::solution</code>里查找重心的起点。</p><h3 id="洛谷-p2664-树上游戏"><a href="https://www.luogu.com.cn/problem/P2664">洛谷 P2664 树上游戏</a></h3><p>和上面的裸的树上路径长度不同，这题就麻烦一些了：</p><blockquote><p>一颗有 n 个节点的无边权树，每个节点有一个标号为 ci 的颜色；定义 s(i, j) 是树上路径 i - j 上出现的不同颜色种数；此外定义 sum(i) ： <span class="math display">\[sum(i) = \sum_{j = 1}^n s(i, j)\]</span> 求出这棵树的所有 sum(i)；数据范围：N = 1e5.</p></blockquote><p>虽然，这种数据规模可以接受 nlogn，处理树上点对且单次询问的问题，一定是点分治；使用点分治通常的分治方法，问题集中到如何使用 O(n) 时间处理子树中“第一类路径”对答案的贡献。</p><p>对于树上的分治点：我们可以统计从它出发可到达的所有节点和它自身之间形成的路径对答案的贡献，也可以统计经过它的路径对于路径端点的贡献；两种都是属于第一类路径；对自己的贡献比较好统计，dfs的时候加和就行；接下来考虑如何统计第二类的贡献。</p><p>先说一个显而易见的结论：对于树中节点 i，若它的颜色在从它到当前树根（分治点）的路径中第一次出现，那么所有和 i 的LCA为根的节点（也就是根节点以及根节点的其他子树的节点）都可以和 i 的子树中的节点 j 形成“第一类路径”；在不考虑其他子树中出现相同颜色的情况下，i 的颜色会对这些点的答案产生 size[i] 的贡献（size[i] 条不同的路径，每条路径贡献1个颜色点）。</p><p>上面的内容也可以这么说：因为要求的是全部路径（所有点对），所以显然要考虑贡献；我们先考虑“半边”第一类路径，也就是从根出发到子树中的点组成的点对：那么如果点 i 的颜色在根到 i 中第一次出现，那么 i 和 i 的子树中所有点都会因为这个颜色而导致 s 值加 1——这一点贡献是 i 的颜色带来的。</p><p>然后就是遍历子树，分子树考虑：首先采用同样的DFS将当前子树的颜色的贡献从总贡献中减去；然后考虑这颗子树中的一个点，令这个点到当前根上的路径中的不同颜色数是<code>colors</code>，<code>other</code>表示当前树出了该子树之外的其他部分的点数，X是这个点到根的路径上不包括根的颜色的贡献之和；对于这些已经出现过的颜色，在它们作为子树根的时候必然已经考虑过了，所以先从总贡献中减去；这样就可以考虑对于子树节点的贡献了。</p><p>简单的说，在某点作为分治点时，统计了从它出发到它的所有子节点形成的“半边”对自己的sum产生的贡献：因为根的颜色的贡献只能是自己产生，所以要剪掉这个颜色的贡献，加上因为自己拥有这个颜色而导致的这个颜色的贡献加成size[u]；接下来，要考虑所有的子树的根出发向上经过本分治点对这些子树的根节点产生的贡献——半边已经确定，就是分治点到子树根的链上的颜色，另半边的颜色贡献已经使用total维护，当然，这里要减去那个已经确定的半边上有的颜色带来的贡献。这样，分治点的“第一类路径”就处理完了。</p><p>应当注意的是，sum只考虑起点和终点，并不考虑经过的点：这和分治的“第一类路径”的定义不太一致；这里主要是将每一个点的“第一类路径”分成对分治点下探对自身的影响和对于子树节点上探的影响。</p><p>综上所述，我们可以在每一层分治的分治点这么做：</p><ul><li>执行DFS.count：统计转化为以分治点为根的有根树的各子树的大小，并统计上面结论里说的贡献（记录到contrib数组），以及这些贡献的和（total）；</li><li>考虑分治点下探对分治点带来的贡献：<code>total - contrib[.c] + size</code></li><li>枚举子树，考虑子树节点上探经过分治点带来的贡献：<ul><li>执行DFS.disContrib，消除当前子树自身对颜色带来的贡献；</li><li>执行DFS.update，加算贡献更新子树节点的答案；</li><li>执行DFS.reContrib，回复第一步扣除的子树影响，为其他子树所用；</li></ul></li><li>清空颜色贡献数组：本层分治处理完成，返回dc进行下一步的分治</li></ul><p>如果你还是觉得上面说的不太清楚，可以看看下面的代码。</p><h3 id="代码-4">代码</h3><p>这里贴出的是使用点分治在 O(nlogn) 的时间内解决的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w, next;</span><br><span class="line">    edge() = <span class="keyword">default</span>;</span><br><span class="line">    edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> next)</span><br><span class="line">            : u(u), v(v), w(w), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>, M = N;</span><br><span class="line"><span class="keyword">int</span> n, c[N];</span><br><span class="line">longs sum[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FWS</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> head[N];</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    edge ee[M * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ee[tot] = edge(u,v,w,head[u]);</span><br><span class="line">        head[u] = tot ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FWS::addedge(u, v, w);</span><br><span class="line">    FWS::addedge(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> PointDC</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>[N];</span><br><span class="line">    <span class="keyword">bool</span> vis[N];</span><br><span class="line">    <span class="keyword">int</span> _sum, _root, _part;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">namespace</span> innerDFS</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> dfs = <span class="keyword">void</span>(*)(<span class="keyword">int</span>, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">        longs contrib[N];</span><br><span class="line">        longs total;</span><br><span class="line">        <span class="keyword">int</span> cnt[N], colors;</span><br><span class="line">        longs other;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(cnt));</span><br><span class="line">            <span class="built_in">memset</span>(contrib, <span class="number">0</span>, <span class="keyword">sizeof</span>(contrib));</span><br><span class="line">            total = colors = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs count = [](<span class="keyword">int</span> u, <span class="keyword">int</span> father)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">size</span>[u] = <span class="number">1</span>; <span class="keyword">bool</span> zero = !(cnt[c[u]] ++);</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> ii = head[u]; ~ii; ii = ee[ii].next)</span><br><span class="line">            &#123;</span><br><span class="line">                edge &amp;e = ee[ii]; <span class="keyword">int</span> &amp;v = e.v;</span><br><span class="line">                <span class="keyword">if</span> (v == father || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">                count(v, u); <span class="built_in">size</span>[u] += <span class="built_in">size</span>[v];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (zero)</span><br><span class="line">            &#123;</span><br><span class="line">                total += <span class="built_in">size</span>[u];</span><br><span class="line">                contrib[c[u]] += <span class="built_in">size</span>[u];</span><br><span class="line">            &#125;</span><br><span class="line">            -- cnt[c[u]];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        dfs disContrib = [](<span class="keyword">int</span> u, <span class="keyword">int</span> father)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> zero = !(cnt[c[u]] ++);</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> ii = head[u]; ~ii; ii = ee[ii].next)</span><br><span class="line">            &#123;</span><br><span class="line">                edge &amp;e = ee[ii]; <span class="keyword">int</span> &amp;v = e.v;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v] &amp;&amp; v != father) disContrib(v, u);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (zero)</span><br><span class="line">            &#123;</span><br><span class="line">                total -= <span class="built_in">size</span>[u];</span><br><span class="line">                contrib[c[u]] -= <span class="built_in">size</span>[u];</span><br><span class="line">            &#125;</span><br><span class="line">            -- cnt[c[u]];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        dfs reContrib = [](<span class="keyword">int</span> u, <span class="keyword">int</span> father)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> zero = !(cnt[c[u]] ++);</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> ii = head[u]; ~ii; ii = ee[ii].next)</span><br><span class="line">            &#123;</span><br><span class="line">                edge &amp;e = ee[ii]; <span class="keyword">int</span> &amp;v = e.v;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v] &amp;&amp; v != father) reContrib(v, u);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (zero)</span><br><span class="line">            &#123;</span><br><span class="line">                total += <span class="built_in">size</span>[u];</span><br><span class="line">                contrib[c[u]] += <span class="built_in">size</span>[u];</span><br><span class="line">            &#125;</span><br><span class="line">            -- cnt[c[u]];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        dfs update  = [](<span class="keyword">int</span> u, <span class="keyword">int</span> father)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">bool</span> zero = !(cnt[c[u]] ++);</span><br><span class="line">            <span class="keyword">if</span> (zero)</span><br><span class="line">            &#123;</span><br><span class="line">                total -= contrib[c[u]];</span><br><span class="line">                ++ colors;</span><br><span class="line">            &#125;</span><br><span class="line">            sum[u] += total + colors * other;</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> ii = head[u]; ~ii; ii = ee[ii].next)</span><br><span class="line">            &#123;</span><br><span class="line">                edge &amp;e = ee[ii]; <span class="keyword">int</span> &amp;v = e.v;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v] &amp;&amp; v != father) update(v, u);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (zero)</span><br><span class="line">            &#123;</span><br><span class="line">                total += contrib[c[u]];</span><br><span class="line">                -- colors;</span><br><span class="line">            &#125;</span><br><span class="line">            -- cnt[c[u]];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        dfs <span class="built_in">clear</span> = [](<span class="keyword">int</span> u, <span class="keyword">int</span> father)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt[c[u]] = contrib[c[u]] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> ii = head[u]; ~ii; ii = ee[ii].next)</span><br><span class="line">            &#123;</span><br><span class="line">                edge &amp;e = ee[ii]; <span class="keyword">int</span> v = e.v;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v] &amp;&amp; v != father) <span class="built_in">clear</span>(v, u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> cleanRoot = [](<span class="keyword">int</span> <span class="built_in">size</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        _root = <span class="number">0</span>; _part = inf;</span><br><span class="line">        _sum = <span class="built_in">size</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> setRoot = [](<span class="keyword">int</span> u, <span class="keyword">int</span> maxPart)</span><br><span class="line">    &#123;</span><br><span class="line">        _part = maxPart;</span><br><span class="line">        _root = u;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">bool</span>) * (n + <span class="number">1</span>));</span><br><span class="line">        setRoot(<span class="number">0</span>, inf); innerDFS::init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> father)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">size</span>[u] = <span class="number">1</span>; <span class="keyword">int</span> maxPart = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ii = head[u]; ~ii; ii = ee[ii].next)</span><br><span class="line">        &#123;</span><br><span class="line">            edge&amp; e = ee[ii]; <span class="keyword">int</span>&amp; v = e.v;</span><br><span class="line">            <span class="keyword">if</span> (v == father || vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            findRoot(v, u);</span><br><span class="line">            <span class="built_in">size</span>[u] += <span class="built_in">size</span>[v];</span><br><span class="line">            maxPart = <span class="built_in">max</span>(maxPart, <span class="built_in">size</span>[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        maxPart = <span class="built_in">max</span>(maxPart, _sum - <span class="built_in">size</span>[u]);</span><br><span class="line">        <span class="keyword">if</span> (maxPart &lt; _part) setRoot(u, maxPart);</span><br><span class="line">        <span class="keyword">return</span> _root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> innerDFS;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">        count(u, <span class="number">0</span>);</span><br><span class="line">        sum[u] += total - contrib[c[u]] + <span class="built_in">size</span>[u];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ii = head[u]; ~ii; ii = ee[ii].next)</span><br><span class="line">        &#123;</span><br><span class="line">            edge &amp;e = ee[ii]; <span class="keyword">int</span> v = e.v;</span><br><span class="line">            <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            cnt[c[u]] = <span class="number">1</span>; total -= <span class="built_in">size</span>[v];</span><br><span class="line">            contrib[c[u]] -= <span class="built_in">size</span>[v];</span><br><span class="line">            disContrib(v, u);</span><br><span class="line">            cnt[c[u]] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            other = <span class="built_in">size</span>[u] - <span class="built_in">size</span>[v];</span><br><span class="line">            update(v, u);</span><br><span class="line"></span><br><span class="line">            cnt[c[u]] = <span class="number">1</span>; total += <span class="built_in">size</span>[v];</span><br><span class="line">            contrib[c[u]] += <span class="built_in">size</span>[v];</span><br><span class="line">            reContrib(v, u);</span><br><span class="line">            cnt[c[u]] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        colors = total = <span class="number">0</span>; <span class="built_in">clear</span>(u, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dc</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        vis[u] = <span class="literal">true</span>; calculate(u);</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ii = head[u]; ~ii; ii = ee[ii].next)</span><br><span class="line">        &#123;</span><br><span class="line">            edge &amp;e = ee[ii]; <span class="keyword">int</span> &amp;v = e.v;</span><br><span class="line">            <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">            cleanRoot(<span class="built_in">size</span>[v]);</span><br><span class="line">            <span class="keyword">auto</span> root = findRoot(v, u);</span><br><span class="line">            dc(root);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">solution</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        cleanRoot(n);</span><br><span class="line">        <span class="keyword">auto</span> root = findRoot(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        dc(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n; FWS::init(); <span class="keyword">int</span> x, y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) <span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        addEdge(x, y, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    PointDC::solution();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sum[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<code>disContrib</code>和<code>reContrib</code>：两个行为是对称的，你可以合成一个函数，也可以开一些全局变量记录这些修改；此外，这个题目还有 O(n) 的算法；想要了解可以去看这题的题解。</p><h3 id="洛谷-p2305-noi2014购票"><a href="https://www.luogu.com.cn/problem/P2305">洛谷 P2305 [NOI2014]购票</a></h3><p>这道题也相当的麻烦……</p><blockquote><p>一颗有n个节点的有根树，所有的子节点向父节点连边；你可以从节点出发，支付这个节点的旅行费用，然后到达这个节点距离不超过 l 的祖先节点；每个节点有不同的 l 和费用：费用的计算方式是：f(dis) = dis*p + q；p和q是节点的常数。现要求求出从每个子节点出发到达根节点时的最少花费。</p><p>数据范围：N = 2e5，P = 1e6，Q = 1e12</p></blockquote><h2 id="总结后记">总结&amp;后记</h2><h3 id="参考资料">参考资料</h3><p>本篇博文在创作过程中参考了这些资料，在这里给出它们的链接：</p><ul><li><a href="https://oi-wiki.org/graph/tree-divide/">树分治 - OI Wiki</a></li><li><a href="https://www.cnblogs.com/bztMinamoto/p/9489473.html">点分治&amp;&amp;动态点分治学习笔记</a></li><li><a href="http://liu-cheng-ao.blog.uoj.ac/blog/2969">一种基于错误的寻找重心方法的点分治的复杂度分析</a></li><li><a href="https://www.cnblogs.com/LadyLex/p/8006488.html">点分治 &amp; 动态点分治小结</a></li><li><a href="https://www.cnblogs.com/PinkRabbit/p/8593080.html">【算法学习】点分治</a></li></ul><p>如果觉得哪里没有说清楚你们也可以去看看这些链接。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 树上算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“Shopee杯” e起来编程暨武汉大学2020年大学生程序设计大赛（决赛）题解</title>
      <link href="/2020/whu-shopee-cup-2020-spring-final/"/>
      <url>/2020/whu-shopee-cup-2020-spring-final/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Nowcoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二届“传智杯”全国大学生IT技能大赛（决赛）</title>
      <link href="/2020/chuanzhi-cup-final-2020-luogu/"/>
      <url>/2020/chuanzhi-cup-final-2020-luogu/</url>
      
        <content type="html"><![CDATA[<p>按照惯例还是先挂出来一些链接。</p><p>比赛地址：<a href="https://www.luogu.com.cn/contest/29004" class="uri">https://www.luogu.com.cn/contest/29004</a></p><p>官方题解：<a href="https://www.zhihu.com/question/388180965/answer/1163540927" class="uri">https://www.zhihu.com/question/388180965/answer/1163540927</a></p><p>但是已经不能在上面的比赛链接里上交题目了，所有的题目已经加入公共题库了，所以你可以搜索题目的名字然后在公共题库中找到它们；好像直接点进去就会自动切到公共题库，还行。</p><p>两个黄题没有做出来，这不太行啊。</p><h2 id="a---暴力模拟">A - 暴力模拟</h2><p>暴力模拟，语言题。但是数据范围给的有些歧义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> longd = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> ulongs = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> longs INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> graph[<span class="number">100</span>][<span class="number">100</span>] =</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="string">R&quot;(...........................,]]OOO@@@@OOO]`........)&quot;</span>,</span><br><span class="line">                <span class="string">R&quot;(....................,]OO@@@@@@@@@@@@@@@@@@@@O`....)&quot;</span>,</span><br><span class="line">                <span class="string">R&quot;(................./O@@@@@@@@@@@@@@@@@@@@@@@@@@@@^..)&quot;</span>,</span><br><span class="line">                <span class="string">R&quot;(............../O@@@@@@@@@@@@@@@OOOOOOO@@@@@@@@@@@.)&quot;</span>,</span><br><span class="line">                <span class="string">R&quot;(..........,/@@@@@@@@@@@@O/[.............[O@@@@@@@\)&quot;</span>,</span><br><span class="line">                <span class="string">R&quot;(........,O@@@@@@@@@@O/`..................,O@@@@@@O)&quot;</span>,</span><br><span class="line">                <span class="string">R&quot;(.......O@@@@@@@@@O`......]OO@@@O\`........O@@@@@@@)&quot;</span>,</span><br><span class="line">                <span class="string">R&quot;(.....,O@@@@@@@@/`.....]O@@@@@@@@@@^.......O@@@@@@@)&quot;</span>,</span><br><span class="line">                <span class="string">R&quot;(...,/@@@@@@@O/...../@@@@@@@@@@@@@@O....../@@@@@@@0)&quot;</span>,</span><br><span class="line">                <span class="string">R&quot;(..=@@@@@@@O`...../@@@@@@@@@@@@@@@@^.....O@@@@@@@O.)&quot;</span>,</span><br><span class="line">                <span class="string">R&quot;(./@@@@@@@/......O@@@@@@@@@@@@@@@O`..../@@@@@@@@O..)&quot;</span>,</span><br><span class="line">                <span class="string">R&quot;(=@@@@@@@O......O@@@@@@@@@@@@@@@^....O@@@@@@@@@O...)&quot;</span>,</span><br><span class="line">                <span class="string">R&quot;(O@@@@@@@^.....=@@@@@@@@@@@@@O[..../@@@@@@@@@O`....)&quot;</span>,</span><br><span class="line">                <span class="string">R&quot;(@@@@@@@O.......\@@@@@@@@O[...../O@@@@@@@@@O`......)&quot;</span>,</span><br><span class="line">                <span class="string">R&quot;(@@@@@@@@^.........[`.......]OO@@@@@@@@@@O`........)&quot;</span>,</span><br><span class="line">                <span class="string">R&quot;(O@@@@@@@@O\............]/@@@@@@@@@@@@O/...........)&quot;</span>,</span><br><span class="line">                <span class="string">R&quot;(=@@@@@@@OOOoo`........O@@@@@@@@@@@@/`.............)&quot;</span>,</span><br><span class="line">                <span class="string">R&quot;(..\OOOOO*,`*..........O@@@@@@@@@O`................)&quot;</span>,</span><br><span class="line">                <span class="string">R&quot;(.....,[[..............O@@@@@@O`...................)&quot;</span>,</span><br><span class="line">                <span class="string">R&quot;(......................O@@@@@@O....................)&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> campus[<span class="number">2060</span>][<span class="number">2060</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, h, w;</span><br><span class="line">    <span class="keyword">int</span> x, y, r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> initfill = [&amp;]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w; ++ j)</span><br><span class="line">                campus[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            campus[i][w] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> paint = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x, ii = <span class="number">0</span>; i &lt; h; ++ i, ++ ii)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ii &gt;= <span class="number">20</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = y, jj = <span class="number">0</span>; j &lt; w; ++ j, ++ jj)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (jj &gt;= <span class="number">50</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (graph[ii][jj] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                campus[i][j] = graph[ii][jj];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> paint180 = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = x, ii = <span class="number">19</span>; i &lt; h; ++ i, -- ii)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ii &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = y, jj = <span class="number">49</span>; j &lt; w; ++ j, -- jj)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (jj &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (graph[ii][jj] == <span class="string">&#x27;.&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (j &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                campus[i][j] = graph[ii][jj];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; h &gt;&gt; w;</span><br><span class="line">    initfill();</span><br><span class="line">    <span class="keyword">while</span> (n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> (r) paint180(x,y);</span><br><span class="line">        <span class="keyword">else</span> paint(x,y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; h; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; campus[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者说是贴标赞助题好一些？</p><h2 id="b---屑游戏">B - 屑游戏</h2><p>脑筋急转弯。考虑为0的边界情况之后，防御塔留一手给英雄，要是能鲨咯那就完事。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> longd = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> ulongs = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> longs INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    longs h, x, y;</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; h &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span> (!y) &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">continue</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!x) &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">continue</span>;&#125;</span><br><span class="line">        longs tt = h / x + <span class="number">1</span>;</span><br><span class="line">        longs mm = h % x;</span><br><span class="line">        <span class="keyword">if</span> (!mm) mm += x, -- tt;</span><br><span class="line">        <span class="keyword">if</span> (mm / y + <span class="keyword">bool</span>(mm % y) &lt;= tt) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得开<code>long long</code>。</p><h2 id="c---加大范围">C - 加大范围</h2><p>比赛时候的数据只要暴力模拟就行了，但是需要使用更优的算法：最优的算法是O(n³)的</p><p>朴素的想法：枚举重心的高度和所在坐标，然后判断每个位置是否可行，这是跑不满的五次方算法；如果把遍历获得所需操作数的行为使用二维前缀和/差分优化的话就可以压到四次方；如果使用二维RMQ问题的解决方法，判断一个方形区域是否都大于某个值，就可以压到最优复杂度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="d---迫真最短路">D - 迫真最短路</h2><p>又是一个暴力。传送门问题往往是先最短路，然后枚举传送门的位置。这个题目只不过就是题面有些吓人，但是数据范围是小的可怜的100，就算是四次方算法也是可以接受的（</p><p>因为要求出所有的最短路之和，所以要用Floyd；然后再加上暴力枚举传送门位置，暴力枚举求出题目说的和，维护它的最小值即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> longd = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> ulongs = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> longs INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line">longs dis[<span class="number">105</span>][<span class="number">105</span>], ans = INF;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++ k)       <span class="comment">// Floyd：中转点要写在外面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">                dis[i][j] = <span class="built_in">min</span>(dis[i][j], dis[i][k] + dis[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">longs <span class="title">sum</span><span class="params">(<span class="keyword">int</span> ii, <span class="keyword">int</span> jj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    longs tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            tmp += <span class="built_in">min</span>(</span><br><span class="line">                dis[i][j], </span><br><span class="line">                <span class="built_in">min</span>(</span><br><span class="line">                    dis[i][ii] + dis[jj][j],</span><br><span class="line">                    dis[i][jj] + dis[ii][j]</span><br><span class="line">                ));</span><br><span class="line">    <span class="keyword">return</span> tmp;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        dis[u][v] = dis[v][u] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        dis[i][i] = <span class="number">0</span>;</span><br><span class="line">    floyd(); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            longs tmp = sum(i, j);</span><br><span class="line">            ans = <span class="built_in">min</span>(tmp, ans);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Floyd算法三重循环的<strong><font color="red">中转点在最外层</font></strong>！</p><h2 id="e---上课">E - 上课</h2><p>本　次　比　赛　唯　一　的　一　个　绿　题</p><p>做法很多。我是找到所有连续的课程作为断点，然后对于每个连续的区间扫描一遍，记录扫描过的区域不同课出现的次数，然后加算贡献的。有点像是在乱搞，复杂度O(n)。</p><p>事实上这个题还可以<a href="https://www.zhihu.com/question/388180965/answer/1162781501">DP</a>，也可以莫队（？），还可以反向思维：也就是先算出所有大于l的点对，在用双指针法减掉各种不太行的情况，时间复杂度都是O(n)的。</p><p>贴的代码不是DP的，是比赛时乱搞的版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">using</span> longd = <span class="keyword">long</span> <span class="keyword">double</span>;</span><br><span class="line"><span class="keyword">using</span> ulongs = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> longs INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n, l, a[N], c[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; vv;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mm;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> jump = [&amp;]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[i] != c[i+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                a[i] = i+<span class="number">1</span>;</span><br><span class="line">                t = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s != t) vv.emplace_back(s, i);</span><br><span class="line">                <span class="keyword">int</span> j = i+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (c[++ j] == c[i]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; ++ k)</span><br><span class="line">                    a[k] = j;</span><br><span class="line">                i = j - <span class="number">1</span>; s = t = j - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != n) vv.emplace_back(s, n);</span><br><span class="line">        a[n] = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        vv.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; l;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; c[i];</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n &lt; l) <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            jump();</span><br><span class="line">            longs ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> ii : vv)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ii.second - ii.first + <span class="number">1</span> &lt; l) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> lim = ii.second - l + <span class="number">1</span>, noko = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> xx = ii.first + l - <span class="number">1</span>; xx &lt;= ii.second; ++ xx)</span><br><span class="line">                &#123;</span><br><span class="line">                    ++ mm[c[xx]];</span><br><span class="line">                    ++ noko;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> xx = ii.first; xx &lt;= lim; ++ xx)</span><br><span class="line">                &#123;</span><br><span class="line">                    ans += noko - mm[c[xx]];</span><br><span class="line">                    -- noko;</span><br><span class="line">                    -- mm[c[xx + l - <span class="number">1</span>]];</span><br><span class="line">                &#125;</span><br><span class="line">                mm.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是DP版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>写了半天，我紫菜（</p><h2 id="后记">后记</h2><p>kkksc03：什么嘛，我的洛谷比赛系统还挺好用的嘛。</p><p>但是非专业性质的比赛打成这样，属实不太行。引人深思。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>“科大讯飞杯”第18届上海大学程序设计联赛春季赛暨高校网络友谊赛</title>
      <link href="/2020/SHU-iflytek-cup-18th-spring-contest/"/>
      <url>/2020/SHU-iflytek-cup-18th-spring-contest/</url>
      
        <content type="html"><![CDATA[<p>科大讯飞冠名的上海大学校赛网络赛。一共五个小时，十二个题目。前六个题是简单题，后六个题是麻烦一点的题目；本来还想着能不能挑战一下A七个，然后……然后我就签到完六个题目光荣下岗（</p><figure><img src="https://i.loli.net/2020/04/18/5N6TFGQ9VEOZPf3.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/04/18/5N6TFGQ9VEOZPf3.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="A2B28BE5A2859BE14CE402031844A7D3.jpg" /><figcaption aria-hidden="true">A2B28BE5A2859BE14CE402031844A7D3.jpg</figcaption></figure><p>补题链接：<a href="https://ac.nowcoder.com/acm/contest/5278" class="uri">https://ac.nowcoder.com/acm/contest/5278</a></p><p>因为官方目前还没有放出官方题解，只有民间题解，所以这里就不贴链接了。如果有了再补</p><blockquote><p>Update：2020 - 4 - 20</p><p>官方的题解slide找到了，您可以<a href="https://cdn.jsdelivr.net/gh/ymd45921/util_assets@master/post/SHU-iflytek-18th/slide.pdf">点击这里下载</a>。</p><p>如果上面的CDN链接崩了，您也可以在这个博客的素材仓库中找到这个文件：<a href="https://github.com/ymd45921/util_assets/blob/master/post/SHU-iflytek-18th/slide.pdf">传送门</a></p><p>日后如果实现了静态博客的pdf展览的页面，那么链接也会在这里更新的。</p></blockquote><p>小声bb：这科大讯飞属实有牌面啊，比起武大校赛就六百多个人，这场比赛报名了四千一百多个人，三千两百多人实际参加，简直不能比（</p><p>然后接下来是题解，签到就直接贴码了。部分参考民间题解制作：</p><h2 id="a---组队比赛">A - <a href="https://ac.nowcoder.com/acm/contest/5278/A">组队比赛</a></h2><p>真正的签到题。但是我吃了一发罚时，因为我忘记加上绝对值了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> in[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; in[i];</span><br><span class="line">    sort(in,in+<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">abs</span>(in[<span class="number">0</span>]+in[<span class="number">3</span>]-in[<span class="number">1</span>]-in[<span class="number">2</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一发就WA给爷整傻了（</p><h2 id="b---每日一报">B - <a href="https://ac.nowcoder.com/acm/contest/5278/B">每日一报</a></h2><p>只要你会使用Arrays.sort，这个题就可以过。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> date;</span><br><span class="line">    <span class="built_in">string</span> id;</span><br><span class="line">    <span class="keyword">double</span> temp;</span><br><span class="line"></span><br><span class="line">    info() = <span class="keyword">default</span>;</span><br><span class="line">    info(<span class="keyword">int</span> date, <span class="built_in">string</span> id, <span class="keyword">double</span> temp) : date(date), id(id), temp(temp) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> info &amp;rhs) <span class="keyword">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (date &lt; rhs.date)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (rhs.date &lt; date)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt; rhs.temp)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (rhs.temp &lt; temp)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> id &gt; rhs.id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> info &amp;rhs) <span class="keyword">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> rhs &lt; *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> info &amp;rhs) <span class="keyword">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !(rhs &lt; *<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&gt;=(<span class="keyword">const</span> info &amp;rhs) <span class="keyword">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; rhs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> x; <span class="built_in">string</span> y; <span class="keyword">double</span> z;</span><br><span class="line">    <span class="built_in">vector</span>&lt;info&gt; v;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line">        <span class="keyword">if</span> (z &lt; <span class="number">38.0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        ++ m;</span><br><span class="line">        v.emplace_back(x,y,z);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; m &lt;&lt; <span class="built_in">endl</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; v[m].date &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">             &lt;&lt; v[m].id &lt;&lt; <span class="string">&#x27; &#x27;</span></span><br><span class="line">             &lt;&lt; v[m].temp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你愿意，你甚至还可以让CLion帮你自动重载运算符。</p><h2 id="c---最长非公共子序列">C - <a href="https://ac.nowcoder.com/acm/contest/5278/C">最长非公共子序列</a></h2><p>首先，题目给了你两个样例：告诉了你，当两个字符串一摸一样的时候答案是-1；然后，显然当两个字符串不一样长的时候，答案是长字符串的长度——因为长字符串自身一定是自己的子序列，而必不可能是短字符串的子序列；</p><p>那么，问题就集中在了两个字符串一样长但是不相等的情况了——然而，此时任何一个字符串自身也是满足上面的条件的，所以答案就是字符串长度。没了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s1, s2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="keyword">int</span> l1 = s1.length(), l2 = s2.length();</span><br><span class="line">    <span class="keyword">if</span> (l1 == l2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1 == s2) <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="built_in">max</span>(l1, l2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>七海的大脑经过快速的思考，发现实际上只有两种情况啊草（</p><h2 id="d---最大字符集">D - <a href="https://ac.nowcoder.com/acm/contest/5278/D">最大字符集</a></h2><p>签到题里一个比较有意思的题目。首先想到，n比较大的时候，单字肯定不可取；然后看样例，推测除了特殊情况，k = n - 1；那么问题就变成了如何构造这样的一系列字符串。</p><p>啊呀本质上这个题目做了半天就是被样例坑了：有一种万金油的构造方式：n = 2的时候选择<code>"11"</code>，然后n更大的时候向中间插<code>'0'</code>；这样肯定没问题，狂喜，遂敲代码，提交，WA（</p><p>前面说了n比较大的时候，那么什么是比较大呢？n = 2？但是按照上面的构造方法，n = 2选<code>"11"</code>的话，似乎并不妨碍n = 1时我构造<code>"0"</code>啊……问题解决了==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;11&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        k = n - <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">string</span> s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; s &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">while</span> (len &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            ++ len;</span><br><span class="line">            s.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; s &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>害，因为这个盲点损失的不仅是+3罚时，还有思考时间和心态啊（</p><h2 id="e---美味的序列">E - <a href="https://ac.nowcoder.com/acm/contest/5278/E">美味的序列</a></h2><p><em>“吃序列，感觉直接贪心模拟就好了啊——然后一边模拟一边开个变量存最大值，完美啊</em></p><p>——我最开始是这么想的。然后就会显然的遇到一个问题：如果两头一样大，就要检查下一位直到可以分辨优劣的程度；但是这么做，最坏每次模拟时间复杂度会退化到O(n)，整个算法会变成平方，不可取；更何况如果整个数列的值一样，那么每次扫描全队列的我岂不是个憨憨。</p><p>啊呀不对啊，这不是一小时以内过了一千多个人的签到题吗，不应该有什么高深算法才对啊== 难道不知不觉我已经菜到这么离谱的程度了嘛（卑微</p><p>然后，七海的大脑经过了快速<del>（不</del>的思考，发现了题目中有一句话：“把整个序列吃完”</p><p>哦，吃完啊，那没事了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, a[N];</span><br><span class="line">    longs maxx = <span class="number">0</span>, disc = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i], maxx += a[i];</span><br><span class="line">    disc = (n + <span class="number">1l</span>l) * n / <span class="number">2l</span>l - n;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxx - disc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>求个和，求个总损失，减一下完事。</p><h2 id="f---日期小助手">F - <a href="https://ac.nowcoder.com/acm/contest/5278/F">日期小助手</a></h2><p>给日期，计算最近的父亲节或者母亲节。因为有日期，再加上这两个节日都和星期几有关，很快就想到了fstqwq学长无私分享的板子的 <span class="math inline">\(Miscellany\)</span> 版块里提到的Zeller日期转换。</p><p>所谓Zeller日期转换，就是从公元后的年月日日期到正整数的一个双射。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">dateString</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">5</span>) s = <span class="string">&quot;Mother\&#x27;s Day: May &quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> s = <span class="string">&quot;Father\&#x27;s Day: June &quot;</span>;</span><br><span class="line">    s.append(to_string(d));</span><br><span class="line">    <span class="keyword">if</span> (d / <span class="number">10</span> == <span class="number">1</span>) s.append(<span class="string">&quot;th, &quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (d % <span class="number">10</span> == <span class="number">1</span>) s.append(<span class="string">&quot;st, &quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (d % <span class="number">10</span> == <span class="number">2</span>) s.append(<span class="string">&quot;nd, &quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (d % <span class="number">10</span> == <span class="number">3</span>) s.append(<span class="string">&quot;rd, &quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> s.append(<span class="string">&quot;th, &quot;</span>);</span><br><span class="line">    s.append(to_string(y));</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Zeller</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">date</span> &#123;</span><span class="keyword">int</span> year, month, day; &#125;;</span><br><span class="line">    <span class="keyword">enum</span> weekday &#123;sun = <span class="number">0</span>, mon, tue, wed, thu, fri, sat&#125;;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function">id <span class="title">getZellerId</span><span class="params">(<span class="keyword">int</span> y, <span class="keyword">int</span> m, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">3</span>) -- y, m += <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">365</span> *  y + y / <span class="number">4</span> - y / <span class="number">100</span> + y / <span class="number">400</span> + (<span class="number">153</span> * (m - <span class="number">3</span>) + <span class="number">2</span>) / <span class="number">5</span> + d - <span class="number">307</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">date <span class="title">getZellerDate</span><span class="params">(id zellerId)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = zellerId + <span class="number">1789995</span>, n, i, j, y, m, d;</span><br><span class="line">        n = <span class="number">4</span> * x / <span class="number">146097</span>; x -= (<span class="number">146097</span> * n + <span class="number">3</span>) / <span class="number">4</span>;</span><br><span class="line">        i = (<span class="number">4000</span> * (x + <span class="number">1</span>)) / <span class="number">1461001</span>; x -= <span class="number">1461</span> * i / <span class="number">4</span> - <span class="number">31</span>;</span><br><span class="line">        j = <span class="number">80</span> * x / <span class="number">2447</span>; d = x - <span class="number">2447</span> * j / <span class="number">80</span>; x = j / <span class="number">11</span>;</span><br><span class="line">        m = j + <span class="number">2</span> - <span class="number">12</span> * x; y = <span class="number">100</span> * (n - <span class="number">49</span>) + i + x;</span><br><span class="line">        <span class="keyword">return</span> &#123;y,m,d&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">weekday <span class="title">getWeekday</span><span class="params">(id zellerId)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;weekday&gt;((zellerId + <span class="number">1</span>) % <span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">using</span> Zeller::getZellerId;</span><br><span class="line">    <span class="keyword">using</span> Zeller::getWeekday;</span><br><span class="line">    <span class="keyword">using</span> Zeller::getZellerDate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> getMotherDayId = [](<span class="keyword">int</span> y)</span><br><span class="line">    &#123;</span><br><span class="line">        Zeller::id xx = getZellerId(y, <span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> yy = getWeekday(xx);</span><br><span class="line">        <span class="keyword">if</span> (!yy) xx += <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> dd = <span class="number">7</span> - yy;</span><br><span class="line">            xx += dd + <span class="number">7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> xx;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> getFatherDayId = [](<span class="keyword">int</span> y)</span><br><span class="line">    &#123;</span><br><span class="line">        Zeller::id xx = getZellerId(y, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> yy = getWeekday(xx);</span><br><span class="line">        <span class="keyword">if</span> (!yy) xx += <span class="number">14</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> dd = <span class="number">7</span> - yy;</span><br><span class="line">            xx += dd + <span class="number">14</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> xx;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t; <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">int</span> y, m, d;</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; y &gt;&gt; m &gt;&gt; d;</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> id = getMotherDayId(y);</span><br><span class="line">            <span class="keyword">auto</span> dd = getZellerDate(id);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; dateString(dd.year, dd.month, dd.day) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m &gt; <span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> id = getMotherDayId(y + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">auto</span> dd = getZellerDate(id);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; dateString(dd.year, dd.month, dd.day) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> ll = getMotherDayId(y);</span><br><span class="line">            <span class="keyword">auto</span> rr = getFatherDayId(y);</span><br><span class="line">            <span class="keyword">auto</span> mm = getZellerId(y,m,d);</span><br><span class="line">            Zeller::date dd;</span><br><span class="line">            <span class="keyword">if</span> (mm &lt; ll) dd = getZellerDate(ll);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mm &lt; rr) dd = getZellerDate(rr);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> id = getMotherDayId(y + <span class="number">1</span>);</span><br><span class="line">                dd = getZellerDate(id);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; dateString(dd.year, dd.month, dd.day) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是这个题目就变成了愉快的板子题。</p><p>看了官方题解，采用的是打表找规律：因为每年365天满足 365 ≡ 1 mod 7，第x个星期日每次的日期偏移是1——所以某月第确定个个星期日一定是出现在一个确定的范围内；找规律可以发现出了闰年之外，每年变化一天；这样我们就可以先打表预处理本就不大的范围内的父亲解母亲节日期，然后再根据输入二分查找。</p><p>小声bb：出题人为了照顾大家的英语水平，甚至事后补充了十二个月的单词拼写和 st/nd/rd/th……</p><h2 id="g---血压游戏">G - <a href="https://ac.nowcoder.com/acm/contest/5278/G">血压游戏</a></h2><p>一棵树上n个点，每个点有一些松鼠。有一个根节点，这些松鼠都会朝根节点跑，最后在根节点被救出。单位时间内，这些松鼠会按顺序做下面这些事情：</p><ul><li>如果这个节点上有多只松鼠，那么先打架，导致一只松鼠去世</li><li>剩下来的松鼠跑到当前节点的父节点上；如果当前在根节点，那么被救出</li></ul><p>问，所有的松鼠都被从树中救出后，一共还剩下多少只松鼠。</p><h3 id="一些想法">一些想法</h3><p>暴力做法就是多次DFS更新树节点，统计答案，平均O(nh)；但是显然当树退化成一条链的时候，这样做就变成平方的了，也就是说没了（</p><p>想过分层统计每一层树高上的松鼠数量然后……好像和上面没什么区别啊== 但是不同深度的松鼠确实是互不影响的，如果使用某种方法分层处理就好了（</p><h3 id="解题思路">解题思路</h3><p>虽然不是很懂，但是读完题之后就产生了这题要使用树剖的预感；虽然最后没做出来== 看了民间的题解，确实需要使用树剖的知识。在开始补题之前，先简单介绍一下这些前置知识：</p><blockquote><h5 id="dsu-on-tree">DSU on tree</h5></blockquote><p>官方题解思路一：对于每一种深度的点分块建虚树，对于每一棵虚树统计答案；总复杂度O(n log n)。</p><h3 id="补题代码">补题代码</h3><h2 id="h---纸牌游戏">H - <a href="https://ac.nowcoder.com/acm/contest/5278/H">纸牌游戏</a></h2><p>扑克，有n张牌，每张代表0~9的数字；要求从手牌中选出k张，组成一个能被3整除的k位非负整数，且不能有前导零；问最大能组成多少。</p><p>不超过1000组数据，不超过1e5张牌；这些数字用一个字符串给出；如果无解，输出-1.</p><h2 id="i---古老的打字机">I - <a href="https://ac.nowcoder.com/acm/contest/5278/I">古老的打字机</a></h2><p>有n个小写字母构成的字符串si，每个字符串的价值是vi；有一个只有一个键的打字机，你的输入有50%的概率变成backspace，剩下的50%是输入一个随机小写字母；你按下了这个按键m次，得到了字符串t；这个字符串的价值可以这样计算：设字符串si在t中出现了ci次，那么价值是</p><p><span class="math display">\[\sum_{i=1}^n c_i v_i  \]</span> 求随机字符串t的价值的数学期望，并且输出这个值的<span class="math inline">\(21^m\)</span>倍数关于1e9+7的模。</p><h2 id="j---能到达吗">J - <a href="https://ac.nowcoder.com/acm/contest/5278/J">能到达吗</a></h2><p>n × m的地图中有k个障碍物，给定了障碍物的坐标；玩家最开始在左上角(1,1)，可以四方向在地图内无障碍物的地方移动；求地图中可以互相连通的点对的数量，关于1e9+7取模；这里的点对的两个点可以是一致的，但是颠倒的点对将被算作和原点对同一个。</p><h2 id="k---迷宫">K - <a href="https://ac.nowcoder.com/acm/contest/5278/K">迷宫</a></h2><p>n × m的迷宫，有障碍；给定起点和终点，玩家可以四方向移动，还可以使用一次穿越：无视连通性，在一步的时间内转移到切比雪夫/曼哈顿距离不超过d的另一片空地上；求到达终点所需要的最少步数，如果无解，输出-1.</p><h3 id="一些想法-1">一些想法</h3><p>切比雪夫距离，扩展开来是一个</p><h2 id="l---动物森友会">L - <a href="https://ac.nowcoder.com/acm/contest/5278/L">动物森友会</a></h2><p>你需要参加n个活动c次数，但这些活动每周只会在固定的m天开放；此外，你每天最多只能参加e次活动；问从一周的周一开始，你最少要几天后才能参加完这些活动。</p><h3 id="一些想法-2">一些想法</h3><p>像极了二分图匹配模型，但是因为每天可以干多项活动，每天也有数量限制，那么就用具有通用性的网络流，应该就好可以了。于是，网络流建模完了然后呢？</p><h3 id="解题思路-1">解题思路</h3><p>这题目确实应该就是要用网络流的了。那么我们首先来建个模：</p><ul><li>从源点向一周的七天连边，边的流量是这个日子经历的次数*e</li><li>每周天向当天可以举行的活动连边，边的流量是无穷大</li><li>从每个活动向汇点连边，第i个活动的边的流量是ci</li></ul><p>非常的合理：从源点流出的是我们可以执行活动的总次数，流向汇点的是有效的次数；如果最后满流了，那么也就成了。但是这并不能帮助我们直观的求出来答案天数。</p><p>进一步分析，求的是满足条件的最小天数：显然这是一个具有二分单调性的经典模型；然后，这个网络流模型从源点流出的边的流量恰好需要一个确定的天数来确定，然后判断一个答案的可行性——那么一个使用二分+网络流模型来解题的思路就有了。</p><p>曾经某一次比赛中，可能有这么一个同学说过了这样一句话：“网络流的本质还是贪心”；那么这个题目（确实，七天不算是特别复杂）可不可以直接裸贪心来解决呢？</p><figure><img src="https://i.loli.net/2020/04/18/cZTHgr17C6WGviA.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/04/18/cZTHgr17C6WGviA.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="693EA78014F78D5CE246D2818BCC3E4E.jpg" /><figcaption aria-hidden="true">693EA78014F78D5CE246D2818BCC3E4E.jpg</figcaption></figure><p>那等我想到了再补好了（</p><h3 id="补题代码-1">补题代码</h3><p>补题的时候这个题目总是过不了，一度让我认为我的板子出锅了== 然而经过多轮检查，发现它并没有什么问题（</p><p>这是网络流最大流的dinic算法+当前弧的板子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> FlowNetwork</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> dis[N], cur[N];</span><br><span class="line">    <span class="keyword">int</span> S, T, cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> __addedge = [](<span class="keyword">int</span> u, <span class="keyword">int</span> v, longs w)</span><br><span class="line">    &#123;</span><br><span class="line">        FWS::addedge(u, v, w);</span><br><span class="line">        FWS::addedge(v, u, <span class="number">0</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(cnt + <span class="number">1</span>));</span><br><span class="line">        q.push(S); dis[S] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> cc = head[u]; ~cc; cc = ee[cc].next)</span><br><span class="line">            &#123;</span><br><span class="line">                edge&amp; e = ee[cc]; <span class="keyword">int</span> v = e.v, w = e.w;</span><br><span class="line">                cur[u] = head[u];</span><br><span class="line">                <span class="keyword">if</span> (!w || dis[v] &lt;= dis[u] + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dis[v] = dis[u] + <span class="number">1</span>; q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[T] != inf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">longs <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, longs inflow)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">        <span class="keyword">if</span> (u == T) <span class="keyword">return</span> inflow;</span><br><span class="line">        longs outflow = <span class="number">0</span>, rest = inflow;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> &amp;cc = cur[u]; ~cc; cc = ee[cc].next)</span><br><span class="line">        &#123;</span><br><span class="line">            edge &amp;e = ee[cc]; <span class="keyword">int</span> v = e.v; longs w = e.w;</span><br><span class="line">            edge &amp;r = ee[cc ^ <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!w || dis[v] != dis[u] + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            longs t = dfs(v, <span class="built_in">min</span>(w, rest));</span><br><span class="line">            outflow += t; e.w -= t; r.w += t; rest -= t;</span><br><span class="line">            <span class="keyword">if</span> (!rest) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!outflow) dis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> outflow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">longs <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        longs maxflow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (bfs()) maxflow += dfs(S, inf);</span><br><span class="line">        <span class="keyword">return</span> maxflow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日……loj的代码编辑器也太好看了吧== 个人觉得某些方面超过Monaco Editor了。如果我知道了这是哪个前端轮子的话我也去整一个——不过整哪里呢（</p><p>然后就是本题的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FN FlowNetwork</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> longs = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">signed</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> longs INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1050</span>, M = N * <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, e, c[N], sum;</span><br><span class="line"><span class="built_in">bitset</span>&lt;8&gt; a[N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, next;</span><br><span class="line">    longs w;</span><br><span class="line">    edge() = <span class="keyword">default</span>;</span><br><span class="line">    edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, longs w, <span class="keyword">int</span> next)</span><br><span class="line">            : u(u), v(v), w(w), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FWS</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> head[N];</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    edge ee[M * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n = N<span class="number">-1</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, longs w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ee[tot] = edge(u,v,w,head[u]);</span><br><span class="line">        head[u] = tot ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FlowNetwork</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> dis[N], cur[N];</span><br><span class="line">    <span class="keyword">int</span> S, T, cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> __event = <span class="number">9</span>, __day = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> event = [](<span class="keyword">int</span> i)&#123;<span class="keyword">return</span> __event+i;&#125;;</span><br><span class="line">    <span class="keyword">auto</span> day = [](<span class="keyword">int</span> i)&#123;<span class="keyword">return</span> __day+i;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> __addedge = [](<span class="keyword">int</span> u, <span class="keyword">int</span> v, longs w)</span><br><span class="line">    &#123;</span><br><span class="line">        FWS::addedge(u, v, w);</span><br><span class="line">        FWS::addedge(v, u, <span class="number">0</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> __build = [](<span class="keyword">int</span> t)</span><br><span class="line">    &#123;</span><br><span class="line">        cnt = <span class="number">0</span>; FWS::init(n+<span class="number">9</span>);</span><br><span class="line">        S = ++ cnt; T = ++ cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">7</span>; ++ i)</span><br><span class="line">            __addedge(S, ++ cnt, (t/<span class="number">7</span>+(t%<span class="number">7</span>&gt;=i))*e);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            __addedge(++ cnt, T, c[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">7</span>; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (a[i][j]) __addedge(day(j), cnt, INF);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(cnt + <span class="number">1</span>));</span><br><span class="line">        q.push(S); dis[S] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> cc = head[u]; ~cc; cc = ee[cc].next)</span><br><span class="line">            &#123;</span><br><span class="line">                edge&amp; e = ee[cc]; <span class="keyword">int</span> v = e.v, w = e.w;</span><br><span class="line">                cur[u] = head[u];</span><br><span class="line">                <span class="keyword">if</span> (!w || dis[v] &lt;= dis[u] + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dis[v] = dis[u] + <span class="number">1</span>; q.push(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dis[T] != inf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">longs <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, longs inflow)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line">        <span class="keyword">if</span> (u == T) <span class="keyword">return</span> inflow;</span><br><span class="line">        longs outflow = <span class="number">0</span>, rest = inflow;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> &amp;cc = cur[u]; ~cc; cc = ee[cc].next)</span><br><span class="line">        &#123;</span><br><span class="line">            edge &amp;e = ee[cc]; <span class="keyword">int</span> v = e.v; longs w = e.w;</span><br><span class="line">            edge &amp;r = ee[cc ^ <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!w || dis[v] != dis[u] + <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            longs t = dfs(v, <span class="built_in">min</span>(w, rest));</span><br><span class="line">            outflow += t; e.w -= t; r.w += t; rest -= t;</span><br><span class="line">            <span class="keyword">if</span> (!rest) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!outflow) dis[u] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> outflow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">longs <span class="title">dinic</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        longs maxflow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (bfs()) maxflow += dfs(S, INF);</span><br><span class="line">        <span class="keyword">return</span> maxflow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; e;</span><br><span class="line">    <span class="keyword">int</span> m, x; sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c[i] &gt;&gt; m;</span><br><span class="line">        sum += c[i];</span><br><span class="line">        <span class="keyword">while</span> (m --)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">            a[i][x] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](<span class="keyword">int</span> mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (e * mid &lt; sum) <span class="keyword">return</span> <span class="literal">false</span>;        </span><br><span class="line">        FN::__build(mid);</span><br><span class="line">        <span class="keyword">return</span> FN::dinic() == sum;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ll = <span class="number">0</span>, rr = inf / e, ans = <span class="number">0</span>;      </span><br><span class="line">    <span class="keyword">while</span> (ll &lt;= rr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mm = ll + rr &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mm)) ans = mm, rr = -- mm;</span><br><span class="line">        <span class="keyword">else</span> ll = ++ mm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真的离谱：验完板子，还是那个板子重新敲一遍就一遍过了可还行（</p><h2 id="后记">后记</h2>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Nowcoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nowcoder 练习赛61</title>
      <link href="/2020/nowcoder-practice-contest-61/"/>
      <url>/2020/nowcoder-practice-contest-61/</url>
      
        <content type="html"><![CDATA[<p>按照惯例，开始之前先码一下比赛的一些相关链接：</p><p>比赛地址： <a href="https://ac.nowcoder.com/acm/contest/5026#question" class="uri">https://ac.nowcoder.com/acm/contest/5026#question</a></p><p>官方题解： <a href="https://ac.nowcoder.com/discuss/405216?type=101&amp;order=0&amp;pos=1&amp;page=1" class="uri">https://ac.nowcoder.com/discuss/405216?type=101&amp;order=0&amp;pos=1&amp;page=1</a></p><p>题目比较的简单，做起来还算是比较舒服的—— 但是最后两个题目没做出来，不太行。题解还是一如既往的中规中矩，虽然说做起来或多或少都有些思路，有的题目应该还是有一些别的简单<del>乱搞</del>一些的办法来解决的；</p><p>夜。大雨，家里没水==</p><figure><img src="https://i.loli.net/2020/04/11/tSa1MiDw3kPsJGL.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/04/11/tSa1MiDw3kPsJGL.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="9O14_@MZ6L~_Z_X_NQQLP_9.jpg" /><figcaption aria-hidden="true">9O14_<span class="citation" data-cites="MZ6L~_Z_X_NQQLP_9.jpg">@MZ6L~_Z_X_NQQLP_9.jpg</span></figcaption></figure><p>下次还是多打点天梯舒服一点……话说周日就要武大校赛了啊== 害，要好好打啊（）下面开始：</p><h2 id="a---打怪">A - 打怪</h2><p>非常简单，所有的怪的hp和atk是一样的。只需要计算你会挨它几下然后计算总伤害就可以了；因为要保证自己不死，所以还需要处理一下自己的余数；总而言之细心点准没错。</p><p><del>然后就吃了一发罚时，bksn</del></p><h3 id="我的代码">我的代码</h3><p>这是比赛时交的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t, hp, atk, h, a;</span><br><span class="line">    <span class="keyword">auto</span> solve = [&amp;]() -&gt; <span class="keyword">int</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> xx = h / atk;</span><br><span class="line">        <span class="keyword">int</span> yy = h - xx*atk;</span><br><span class="line">        <span class="keyword">int</span> tt = yy ? xx : xx<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> dmg = a*tt;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; dmg &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (!dmg) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> hp%dmg ? hp/dmg : hp/dmg<span class="number">-1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; hp &gt;&gt; atk &gt;&gt; h &gt;&gt; a;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; solve() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是直接写的所以就顾不上美观了（</p><h2 id="b---吃水果">B - 吃水果</h2><p>算是一个贪心题吧。关于输入的两种水果的数量，设较多的那个是x，另一个是y；简单分析一下就可以得到下面几种情况：</p><ul><li>x = y： 直接吃就可以了，输出x；</li><li>x = 2y：消费1使得较少的翻倍，然后就变成情况1了，输出x+1；</li><li>x &lt; 2y：可以先吃一点变成情况2，然后再吃完，输出x+1；</li><li>x &gt; 2y：……一眼看不出来，那除了翻倍y别无他法——但是这样一定可以转化为上面某一种情况；</li></ul><p>所以，分情况讨论完了之后就简单了：分情况判断完了返回不同的值就可以了；</p><p>此外，题解提了一句说因为规模比较小可以模拟。</p><h3 id="我的代码-1">我的代码</h3><p>综上所述，除了第四种情况需要一个递归（甚至也不需要）之外无他；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == m) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="built_in">max</span>(n,m), y = <span class="built_in">min</span>(n,m);</span><br><span class="line">    <span class="keyword">if</span> (x == y&lt;&lt;<span class="number">1</span>) <span class="keyword">return</span> y&lt;&lt;<span class="number">1</span>^<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; y&lt;&lt;<span class="number">1</span>) <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> solve(x,y&lt;&lt;<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t, n, m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; solve(n,m) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图省事就没改成迭代了（</p><h2 id="c---选择题">C - 选择题</h2><p>稍微麻烦一点的题目。看题干还是比较容易想到是使用一个并查集，先把必须要答案相同的选择题合并起来，然后再分块搜索；心里想着最坏情况12个选择题全部独立，需要4¹²种情况绝对会T的……后来看看题目的样例，已经可以说是最坏情况了，因为有限制的存在，爆搜会剪枝——情况似乎大概也就369600大概的水平：3e5 &lt;&lt; 5e8，所以大概还是可行的；实际上也是可行的就是了（就这？</p><p>题解的说法是使用DP——倒也不是没想到，甚至我的文件里还有注释掉了的写了一半的DP== 但是因为实在是有点麻烦，还是爆搜来的简单就偷懒没写了== 就结果而言是好的（</p><p>因为这个题n=12，实在是太小了（）题解里还说了一些在n更大的时候可以做的一些优化：</p><blockquote><p>（多重背包问题）：如果数据量再大一点，可以把所有背包的体积的所有状态哈希一下，变成一个二维dp，再滚动一下第一维即可。</p></blockquote><p>如果是使用DP来解的话，那就是比较经典的多重背包问题。我们定义 <span class="math inline">\(dp[i][x_1][x_2][x_3][x_4]\)</span> 是枚举了i个物品，四个背包（答案选项）已经使用了<span class="math inline">\(x_{1..4}\)</span>个的状态。那么转移就可以从其他不同背包转移过来，枚举所有的背包就可以了；因为每个背包有容量上限，所以有的情况是转移不了的，可以节约掉。</p><h3 id="我的代码-2">我的代码</h3><p>比赛时直接莽了一波写了一个剪枝的暴力搜索；非常的丑陋但是因为不想重写了所以就这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max4</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(a,<span class="built_in">max</span>(b,<span class="built_in">max</span>(c,d)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> na, nb, nc, nd, m;</span><br><span class="line">    <span class="keyword">int</span> x, y, p[<span class="number">13</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">12</span>; ++ i)</span><br><span class="line">        p[i] = i;</span><br><span class="line">    function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; father = [&amp;](<span class="keyword">int</span> ii) -&gt; <span class="keyword">int</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[ii] == ii) <span class="keyword">return</span> ii;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> p[ii] = father(p[ii]);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> join = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> px = father(x),</span><br><span class="line">                py = father(y);</span><br><span class="line">        p[px] = py;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">13</span>], cnt = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mm;</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; search =</span><br><span class="line">            [&amp;](<span class="keyword">int</span> s, <span class="keyword">int</span> a,<span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d) -&gt; <span class="keyword">int</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (s == cnt) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (num[s] &gt; max4(a,b,c,d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (a &gt;= num[s]) ret += search(s+<span class="number">1</span>,a-num[s],b,c,d);</span><br><span class="line">                <span class="keyword">if</span> (b &gt;= num[s]) ret += search(s+<span class="number">1</span>,a,b-num[s],c,d);</span><br><span class="line">                <span class="keyword">if</span> (c &gt;= num[s]) ret += search(s+<span class="number">1</span>,a,b,c-num[s],d);</span><br><span class="line">                <span class="keyword">if</span> (d &gt;= num[s]) ret += search(s+<span class="number">1</span>,a,b,c,d-num[s]);</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; na &gt;&gt; nb &gt;&gt; nc &gt;&gt; nd &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        join(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span> num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mm[father(i)])</span><br><span class="line">            mm[p[i]] = ++cnt;</span><br><span class="line">        ++ num[mm[p[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; search(<span class="number">1</span>,na,nb,nc,nd) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用并查集完了之后再统计一波——甚至还要为此开一个map是真的丑陋…… 虽然时间上大概是O(n)的而且n非常非常小，并不会带来什么影响但是还是丑陋== 下次还是少用点lambda表达式吧（</p><p>因为这个题目理论上是要DP搜索的，所以还是补了一下丑陋的DP代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> longd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x7fffffff</span>;</span><br><span class="line"><span class="keyword">const</span> longs INF = <span class="number">0x7fffffffffffffff</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max4</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(a,<span class="built_in">max</span>(b,<span class="built_in">max</span>(c,d)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> na, nb, nc, nd, m;</span><br><span class="line">    <span class="keyword">int</span> x, y, p[<span class="number">13</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">12</span>; ++ i) p[i] = i;</span><br><span class="line">    function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; father = [&amp;](<span class="keyword">int</span> ii) -&gt; <span class="keyword">int</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[ii] == ii) <span class="keyword">return</span> ii;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> p[ii] = father(p[ii]);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> join = [&amp;](<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> px = father(x), py = father(y);</span><br><span class="line">        p[px] = py;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">13</span>], cnt = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mm; <span class="keyword">int</span> f[<span class="number">13</span>][<span class="number">13</span>][<span class="number">13</span>][<span class="number">13</span>][<span class="number">13</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> dp = [&amp;]</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f)); f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt;= na; ++ a)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= nb; ++ b)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt;= nc; ++ c)</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt;= nd; ++ d)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">auto</span> &amp;xx = num[i];</span><br><span class="line">                            <span class="keyword">if</span> (a + xx &lt;= na) f[i][a+xx][b][c][d] += f[i<span class="number">-1</span>][a][b][c][d];</span><br><span class="line">                            <span class="keyword">if</span> (b + xx &lt;= nb) f[i][a][b+xx][c][d] += f[i<span class="number">-1</span>][a][b][c][d];</span><br><span class="line">                            <span class="keyword">if</span> (c + xx &lt;= nc) f[i][a][b][c+xx][d] += f[i<span class="number">-1</span>][a][b][c][d];</span><br><span class="line">                            <span class="keyword">if</span> (d + xx &lt;= nd) f[i][a][b][c][d+xx] += f[i<span class="number">-1</span>][a][b][c][d];</span><br><span class="line">                        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[cnt][na][nb][nc][nd];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; na &gt;&gt; nb &gt;&gt; nc &gt;&gt; nd &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        join(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(num,<span class="number">0</span>,<span class="keyword">sizeof</span> num);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mm[father(i)])</span><br><span class="line">            mm[p[i]] = ++cnt;</span><br><span class="line">        ++ num[mm[p[i]]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于背包的状态的哈希那就没有做了。</p><h2 id="d---最短路">D - 最短路</h2><p>这样的题目不出意外应该是第三次遇到了——一种显而易见的套路就是正向反向最短路，然后枚举要”修改“的边，根据最短路求出的值快速计算新值，从而进行判断；而且这个题目也没有像洛谷那个题目那样卡了遍历，可以说没有什么路子都是套路了。</p><p>关于判断的部分：首先我们可以求出原来的最短路；然后可以快速算出来的新路长度，一定是包含反转后的这条路的最短路——其他的路要不不变，要不变了也不是最短路。所以：如果它可以更新最短路，那么最短路显然变短；否则，一定不会存在其他的路可以更新最短路。</p><p>唯一有些担心的是：如果这些更新是累计的更新的话，这种针对一条边修改的套路就会失效。方法……等我想出来再说吧（</p><h3 id="题解分析">题解分析</h3><p>题解里最后提了一句，问应该如何判断修改单边之后，判断最短路长度是否不变的做法。</p><p>解决这个问题之前，我们应该先意识到：如果最短路因为单边修改而缩短，那么显然这样就可以；但是如果单边的修改破坏了原有最短路，我们并不能直接看出增长之后的最短路的长度——于是就不能判定不变了。</p><h3 id="我的代码-3">我的代码</h3><p>使用dijkstra正反扫描最短路，然后针对询问进行O(1)的查询。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> u, v, w, next;</span><br><span class="line">    edge() = <span class="keyword">default</span>;</span><br><span class="line">    edge(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> next)</span><br><span class="line">            : u(u), v(v), w(w), next(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>, M = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FWS</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> head[N];</span><br><span class="line">    <span class="keyword">int</span> tail[N];</span><br><span class="line">    <span class="keyword">int</span> tot;</span><br><span class="line">    edge ee[M*<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">memset</span>(tail, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">        tot = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ee[tot] = edge(u,v,w,head[u]);</span><br><span class="line">        head[u] = tot ++;</span><br><span class="line">        ee[tot] = edge(v,u,w,tail[v]);</span><br><span class="line">        tail[v] = tot ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> dij</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FWS;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> vis[N];</span><br><span class="line">    longs ds[N], dt[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> goal)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;longs ,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">int</span>* li = goal == n ? tail : head;</span><br><span class="line">        longs* dis = goal == n ? dt : ds;</span><br><span class="line"></span><br><span class="line">        q.push(<span class="built_in">make_pair</span>(<span class="number">0</span>, goal));</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">bool</span>)*(n+<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>, <span class="keyword">sizeof</span>(longs)*(n+<span class="number">1</span>));</span><br><span class="line">        dis[goal] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.top().second; q.pop();</span><br><span class="line">            <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>; vis[u] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> c = li[u]; ~c; c = ee[c].next)</span><br><span class="line">            &#123;</span><br><span class="line">                edge&amp; e = ee[c];</span><br><span class="line">                <span class="keyword">int</span> v = e.v;</span><br><span class="line">                <span class="keyword">if</span> (dis[v] &gt;= dis[u] + e.w)</span><br><span class="line">                    q.push(<span class="built_in">make_pair</span>(</span><br><span class="line">                            -(dis[v] = dis[u] + e.w),</span><br><span class="line">                            v</span><br><span class="line">                    ));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">using</span> dij::dijkstra;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> u, v, c;</span><br><span class="line">    <span class="keyword">int</span> x, q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    FWS::init();</span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; c;</span><br><span class="line">        FWS::addedge(u,v,c);</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra(<span class="number">1</span>); dijkstra(n);</span><br><span class="line">    <span class="keyword">const</span> longs shortest = dij::ds[n];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        <span class="keyword">auto</span>&amp; ii = FWS::ee[(x<span class="number">-1</span>)&lt;&lt;<span class="number">1</span>];</span><br><span class="line">        longs to = dij::ds[ii.v] + dij::dt[ii.u] + ii.w;</span><br><span class="line">        <span class="keyword">if</span> (to &lt; shortest) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一直抄板子一直爽</p><h2 id="e---字符串">E - 字符串</h2><p>这个题目做的有点憋屈……最后一个多小时几乎都砸在这个题目上：我一直觉得这个题目是KMP，然而我对于KMP的next数组理解的并没有那么的透彻（<del>除了板子一无所有</del>）；最后就演变成了对着log打出来的next数组找规律，嗯……找规律……属实离谱（</p><p>然而，标答给的算法是二分答案+DP——看似奇妙又显而易见，啊这……</p><p>我也许是受了吹水群里一波接着一波的KMP的影响吧。但是这个题目真的不能使用KMP吗……就算是不能使用KMP也应该有一个反例来证明才是。我想通了就再这里写清楚好了。</p><h3 id="题解分析-1">题解分析</h3><p>显然，这个问题相当于求解：字符串s中有k个相同的子串p，要求使得 x = p.length() 最大化；显然这个x，又具有显而易见的二分单调性——x的极限值之下均可行，以上均不可行；问题转化为寻找简单的验证x是否可行的方法——然而这又可以使用<del>显而易见的</del>DP完成，于是就大概有做这个题的思路了。</p><p>那么这个DP具体应该怎么操作呢：直接比较字符串，且不说是不是会暴毙，想想都觉的丑陋== 这个时候就可以使用万能的hash——将所有的长度为m的子串hash化，然后使用map储存hash-dp键值对；具体的操作方法如下：</p><p>开dp数组和map：map用来存储长度为x且 hash code 为h的字符串在已经扫描过的部分中最后一次出现的位置，用开头的下标表示；dp[i]的含义是下标i开头的（长度为x）字符串在子串[begin, i + x]中出现的最大次数；知道定义之后，操作就比较的简单了：从头扫描到尾，当扫描的部分长度大于x的时候，就每次将长度为x后缀计算hash放进map中，并且标记它的开头位置；然后计算从i开始的长度为x的子串的哈希：如果这个哈希还没出现在map中，那么它出现了一次，暂且可以标记dp[i] = 1；否则，它可以从上次出现的位置转移过来，这个位置就是被map记录的位置。</p><p>然后我们二分这个x，check当子串长度为x时所有字串出现的最大次数是否能够超过k即可；特别注意要特判0——因为0不是一个字符串，上述统计方法无法正常转移，会统计出确定值1.（其实应该是∞）</p><p>想想都觉得这个hash-dp十分的诡异……如果这真的是唯一做法那我认了（但其实这题还可以使用后缀数组</p><h3 id="我的代码-4">我的代码</h3><p>真的是debug到吐血——这样的经历说明了一件事情：标准是根据算法来的，而不是个人喜好来的== 比如这字符串哈希，一般最好是字符串存储在[1 ... n]的下标，用[L, R]来标记子串比较方便自然。然而我采用经典的[0 ... n)、[L, R)标记法，就会导致一堆情况要特判（</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ulongs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k; <span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">int</span> ff[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> StringHash</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> __base = <span class="number">6151</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> __offset = <span class="number">97</span>;</span><br><span class="line">    ulongs <span class="built_in">pow</span>[N], var[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> __idx(<span class="keyword">const</span> <span class="keyword">char</span> ch)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ch - <span class="string">&#x27;a&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">pow</span>[<span class="number">0</span>] = <span class="number">1</span>; var[<span class="number">0</span>] = __idx(s[<span class="number">0</span>]) + __offset;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">pow</span>[i] = <span class="built_in">pow</span>[i - <span class="number">1</span>] * __base;</span><br><span class="line">            var[i] = var[i - <span class="number">1</span>] * __base + __idx(s[i]) + __offset;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ulongs <span class="title">getHashCode</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r || !r) <span class="keyword">return</span> <span class="number">0u</span>ll;</span><br><span class="line">        <span class="keyword">auto</span> __elim = l ? var[l - <span class="number">1</span>] : <span class="number">0u</span>ll;</span><br><span class="line">        <span class="keyword">return</span> var[r - <span class="number">1</span>] - __elim * <span class="built_in">pow</span>[r - l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](<span class="keyword">int</span> mid) -&gt; <span class="keyword">bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mid == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">using</span> StringHash::getHashCode;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">unordered_map</span>&lt;ulongs, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>, lim = n - mid;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lim; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i - mid &gt;= <span class="number">0</span>) <span class="built_in">map</span>[getHashCode(i - mid, i)] = i - mid;</span><br><span class="line">            ulongs hashcode = getHashCode(i, i + mid);</span><br><span class="line">            ff[i] = <span class="built_in">map</span>.count(hashcode) ? ff[<span class="built_in">map</span>[hashcode]] + <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">            ret = <span class="built_in">max</span>(ret, ff[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">map</span>.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">return</span> ret &gt;= k;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k &gt;&gt; s;</span><br><span class="line">    StringHash::init(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ll = <span class="number">0</span>, rr = n, ans = <span class="number">0</span>;</span><br><span class="line">    check(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (ll &lt;= rr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mm = ll + rr &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mm)) ans = mm, ll = ++ mm;</span><br><span class="line">        <span class="keyword">else</span> rr = -- mm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码的上一个版本也AC了，但是使用Valgrind分析发现有一处[-1]的越界访问，就离谱（</p><h2 id="f---林檎树">F - 林檎树</h2><p>唔姆……看了下答案，我完全没有想对== 但是出于学习目的，还是把我的一些想法在这里记录一下好了：</p><p>首先肯定建树，然后用一个set维护苹果的成熟度和位置；这样每次新建苹果就会变成向set中插入节点，找到所有符合条件的苹果就变成STL的两个bound；求到一个苹果的距离就等于说是带权LCA，在所有的苹果里求一个最小值就好办了；除了带权LCA之外的都可以用STL轻松实现，美滋滋（</p><p>看起来十分的美好，但是可能被一些极端的数据卡掉——如果所有的苹果都落在了符合条件的区间内的话，就算题目给了4s也会被活活卡死== 因为没有写这只是推测，但是至少说明这个算法还需要进一步的优化或者说根本就不行。</p><p>然而……</p><figure><img src="https://i.loli.net/2020/04/11/1eUMhSu64rHbkIO.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/04/11/1eUMhSu64rHbkIO.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="78_0_9_S2_2LN9518NZ1DSP.jpg" /><figcaption aria-hidden="true">78_0_9_S2_2LN9518NZ1DSP.jpg</figcaption></figure><p>事实上，当我找了半个小时发现我并没有现成的、完成度比较好的带权LCA板子之后我就放弃写这题了（</p><h3 id="题解分析-2">题解分析</h3><p>要想做这个题，首先你要先学会线段树和点分治。<del>明白，这就去学习点分治（</del></p><h3 id="我的代码-5">我的代码</h3><h2 id="后记">后记</h2><p>虽然这场打的还算是比较顺利的，但是实际上还是并不理想；之后的准备，一方面是要多整一点模板：有了想法却没有优秀的板子支撑实在是太令人心痛了（）平时算法学习还是要注意理解——甚至到现在我还是觉得，E题可以通过魔改KMP利用next数组求解==</p><p>比赛是打不完的，今晚（明天凌晨）的cf教育场，明天AtCoder和洛谷的公开赛，后天的武大校赛…… 既来之则安之，砥砺前行，尽心尽力完成每一个题目吧。</p><p>又及：Typora里的排版到博客上渲染不了内联CSS有些难受……&lt;br/&gt;强制换行就很蠢（</p><p><font><br/></font></p><hr /><center><br/>2020-4-11　1:11:11　雨未停</center>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Nowcoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷ACM春季多校训练营：第五场</title>
      <link href="/2020/luogu-ACM-2020-spring-multi-5/"/>
      <url>/2020/luogu-ACM-2020-spring-multi-5/</url>
      
        <content type="html"><![CDATA[<p>这一波还是只有八个题目。简单题基本上算是真正的简单题，套模板或者自己认真写一写就出来了；但是麻烦的题就总是感觉还差一把火的样子——倒不如说这应该是水平不足的通常表现吧。还是因为版权原因，并不能把题目挂出来，所以只能看我空讲了：</p><p>根据出题人的定义，题目的难度分配大概是下面这样的：</p><table><thead><tr class="header"><th>简单题</th><th>中档题</th><th>困难题</th></tr></thead><tbody><tr class="odd"><td>C、F、G</td><td>A、D</td><td>B、E、H</td></tr></tbody></table><p>既然给了难度定义，那就根据出题人的思路来补这套题。部分题就直接使用赛场上的代码了。</p><h2 id="c---change">C - Change</h2><blockquote><p>给n个题，每个题有一些可用的名字，问能否让第i个题以第i个字母开头；可以改变题目的顺序。</p></blockquote><p>说白了就是二分图匹配：每个题有的名字的头文字就是连边，表示这个题可以和这些头文字匹配；二分图两侧都有n个元素，问是否存在满匹配；这种问题有多个模板解法，比如匈牙利DFS和dinic算法。矩阵乘法是怎么解决的我不太了解，了解了再做一个专题好了。这里我就直接套了一个匈牙利的板子。</p><h3 id="代码">代码</h3><p>这是套了匈牙利算法的板子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q,m;</span><br><span class="line"><span class="keyword">bool</span> li[<span class="number">30</span>][<span class="number">30</span>];    <span class="comment">// =&gt;[n][m]</span></span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">30</span>];     <span class="comment">// =&gt; m(首字母)</span></span><br><span class="line"><span class="keyword">int</span> match[<span class="number">30</span>];      <span class="comment">// =&gt;match[m]=n</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">nextMatch</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)   <span class="comment">// 不要从中途开始</span></span><br><span class="line">        <span class="keyword">if</span>(li[i][j]&amp;&amp;!visit[j])</span><br><span class="line">        &#123;</span><br><span class="line">            visit[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(!~match[j]||nextMatch(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = i;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">maxMatch</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)   <span class="comment">// 要重置visit</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">bool</span>)*(m+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(nextMatch(i)) ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n; m = n;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">memset</span>(li,<span class="number">0</span>,<span class="keyword">sizeof</span> li);</span><br><span class="line">    <span class="built_in">memset</span>(match,<span class="number">-1</span>,<span class="keyword">sizeof</span> match);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">        <span class="keyword">while</span> (q--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">            li[i][s[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> matches = maxMatch();</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt;matches&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(matches == n ? <span class="string">&quot;Yes&quot;</span> : <span class="string">&quot;No&quot;</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，一般来说都使用0表示未匹配状态；但是这里因为每个待匹配元素是<code>char-'a'</code>，所以0本身也是一个匹配元素，应该使用其他方便的数字比如-1作为未匹配状态；或者也可以修正字符的值。虽然是很细节的东西但是吃了罚时所以还是要注意一下。不如之后的模板都使用-1作为未匹配状态，更加健壮。</p><h2 id="f---flaw">F - Flaw</h2><blockquote><p>给定一个不等式，问在自然溢出的意义下成立的方案数</p></blockquote><p>这里的溢出指的是int溢出。出题人也说少考虑了好多种情况；对于不等式<code>a+n1&lt;/&gt;n2</code>来说，左侧的a+n1是分成多个区间的：一个区间是未溢出时正常运算，还有一部分是溢出后的部分；分别讨论处理一下就可以了——具体地说，可以是下面这样：</p><p>对于<code>a+n1&lt;n2</code>： 未溢出的部分是[-2³¹, n2-n1)，溢出的部分是[2³¹-n1,INTMAX]；</p><p>对于<code>a+n1&gt;n2</code>： 未溢出的部分是(n2-n1, INTMAX-n1]，溢出的部分是[INTMAX+n2-n1,INTMAX]；</p><p>处理一下读入的字符串然后进行对应的计算就可以了。但是本题更为经济的做法是观察题目样例，找到规律。比如下面的代码：</p><h3 id="代码-1">代码</h3><p>进行一些线性组合的猜测后发现这个答案似乎只和n2有关，因此可以这么写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n1,n2;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ch&gt;&gt;ch&gt;&gt;n1&gt;&gt;ch&gt;&gt;n2;</span><br><span class="line">    longs ans;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="number">2147483647l</span>l-n2;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="number">2147483648l</span>l+n2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说是int范围，但是答案还是会爆int的。</p><h2 id="g---gene">G - Gene</h2><blockquote><p>给定两个大写字符串进行匹配：其中匹配是alpha分，失配是-beta分，gap是-gamma分；问最大匹配得分</p></blockquote><p>看题目样例给的图，真的像极了LCS——其实它就是一个LCS：只是转移的规则不太一样——失配有减益效果，使用空格也需要费用。那么简单修改LCS的模板就可以了：转移不再仅通过判等来转移，而是直接通过成本转移；因为空挡有损失，所以dp[0,i]和dp[i,0]都需要预先填入i个空挡的消费。</p><p>最后算法的时间复杂度是O(nm)的。</p><h3 id="代码-2">代码</h3><p>这是n²空间的写法；实际上这是显然可以优化到线性空间的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5050</span>, M = <span class="number">5050</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> longs <span class="title">max3</span><span class="params">(longs a, longs b, longs c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">max</span>(a,b),c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,a,b,y;</span><br><span class="line"><span class="keyword">char</span> s1[N],s2[N];</span><br><span class="line">longs dp[N][M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;a&gt;&gt;b&gt;&gt;y;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s1[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; s2[i];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (longs i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        dp[i][<span class="number">0</span>] = -y*i;</span><br><span class="line">    <span class="keyword">for</span> (longs i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">        dp[<span class="number">0</span>][i] = -y*i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = max3(</span><br><span class="line">                    dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+(s1[i]==s2[j]?a:-b),</span><br><span class="line">                    dp[i<span class="number">-1</span>][j]-y, dp[i][j<span class="number">-1</span>]-y</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][m] &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这题评测机闹了个乌龙：我连续两发WA的莫名其妙，最后队友一交就过了=== 唯一的区别是我是C++14 O2，他直接交的C++(11)；后来我尝试关掉O2优化也通过了，他把我的<code>cin.tie(nullptr)</code>搞成0，开O2也过了，就比较的玄学。</p><p><del>纯　氧　杀　人 （大嘘）</del></p><h2 id="a---ammunition">A - Ammunition</h2><blockquote><p>有三个物品，第一种值是a，第二种值是b，第三种值在[0,b/2]中任选，物品的值是整数，现在拿了n个物品，问值的和是否可能是m，保证a&lt;b。</p></blockquote><p>就是说，你有a，b和[0,b&gt;&gt;1]的整数，能否可以从中选取n个整数，使得他们的和为m。</p><p>因为自己的一些考虑炸了，所以直接按照标准答案的方法：首先排除不可能的情况——比如超过了<code>max(a,b)*n</code>的话，是无论如何都不可能解决的；话说题目里保证了a&lt;b，那就不用max了；在接下来的讨论中，我们将[0,b&gt;&gt;1]记为c。</p><p>然后就是先只考虑b：如果只选b，那显然就是{kb}，k∈[0,n]；换一个b成c，可以达成[kb, kb+(b&gt;&gt;1)]，k∈[0,n)；换两个，那就可达成[kb, kb+(b&gt;&gt;1&lt;&lt;1)]，k∈[0,n-1)；综合考虑，就是说可以选到[0,(n-1)b+(b&gt;&gt;1)] ∪ {nb}范围内的所有数字。这已经是一个很稳健的范围了；</p><p>接下来在上面的基础上再考虑a：如果a ≤ (b&gt;&gt;1)，那没事了，要你何用；否则，绝大多数的可能性也都被上面的很大的范围包含了，只需要考虑处于((n-1)b+(b&gt;&gt;1), nb)范围内的值就可以了，而这样的值是有限个的；虽然得出这样的值也是有一定的策略的：</p><p>理论上，a可以由b或c变过来，但是如果遍历的话就比较蠢了；我们可以反向考虑：这个值之所以还需要a，是因为它大于上述的连续区间——也就是容不得b&gt;&gt;1存在；如果这个只有ab构成的值要变成上界nb，那只能把它的a全部换成b——也就是它和max的差必须是b-a的倍数；这样就可以做出来这个题目了。</p><p>出题人的标程使用了<code>__int128</code>这种标准库不支持且仅可以在Linux环境下使用的类型，实际上用<code>unsigned long long</code>也可以刚过去。</p><h3 id="做题记录">做题记录</h3><p>这个题目，我最开始想着是解不等式：首先设选了x个a和y个b，满足下面不等式的情况： <span class="math display">\[\begin{cases}f(x,y) = m-ax-by&gt;0 \\g(x,y) = x+y&lt;n\end{cases}\]</span> 并且两个函数的值都尽可能的小。然后再根据剩余的值进行判断；但是最后因为情况实在是太多了于是作罢。也许这种做法需要gcd等一些东西？看起来又有点像是线性规划……</p><p>最后尝试写出来的代码也没有考虑f大于0的情况，最后就导致一些本不可能的情况变得可能了起来== 如果再乱搞一波说不定还是可以的，但是实在管不了这么多特殊情况的乱搞了。但是果然还是没有上述标准做法来的简单轻松——不是没有想过换两个b，但是对于b换a考虑多了。</p><h3 id="代码-3">代码</h3><p>使用出题人标程的策略完成的判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ulongs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ok[] = <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> no[] = <span class="string">&quot;No&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    ulongs t, n, m, a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (!n) <span class="built_in">cout</span> &lt;&lt; (!m ? ok : no) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            ulongs <span class="built_in">max</span> = n*b;</span><br><span class="line">            ulongs maxx = <span class="built_in">max</span> - b + (b&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            ulongs diff = <span class="built_in">max</span> - m;</span><br><span class="line">            ulongs dis = b - a;</span><br><span class="line">            <span class="keyword">if</span> (m &gt; <span class="built_in">max</span>) <span class="built_in">cout</span> &lt;&lt; no &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m == <span class="built_in">max</span> || m &lt;= maxx) <span class="built_in">cout</span> &lt;&lt; ok &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (diff % dis == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt;</span><br><span class="line">                (diff / dis &lt;= n ? ok : no) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; no &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么分析一波之后真实简单……</p><h2 id="d---duliu">D - Duliu</h2><blockquote><p>定义maxpre和maxsuf（以下简称函数P和S）为参数区间的最大前缀/后缀和，要求求出： <span class="math display">\[\sum^n_{l=1}\sum^n_{r=l+1}\sum^{r-1}_{i=l}P(l,i)S(i+1,r)\]</span> 并且输出答案对指定质数取模后的值。</p></blockquote><p>题如其名，看起来毒瘤的不行== 但是考虑上一次多校的那个A题，这种“全子串状态”考虑的问题——而且还是求和——更是要从考虑每个元素的贡献的角度入手；姑且大方向是确定的。</p><h2 id="b---bolshevik">B - Bolshevik</h2><blockquote><p>有n个人，第i个人有ai元，钱包里有bi元，问第x个人想成为最有钱的人至少偷几个钱包</p></blockquote><p>在这个题里，偷钱包有两种策略：一种是偷最有钱的人的钱包，降低成为最有钱的人的门槛；还有一种是偷钱包最有钱的人的钱包，获得最大收益。但是这两种策略不能等量齐观，都得视情况而定——这是显然的。</p><h3 id="做题记录-1">做题记录</h3><p>感觉像极了贪心，但是又不知道应该怎么偷；毕竟偷最有钱的人还是最大方的人带来的收益并不能直观的表示出来…… 感觉和之前做过的两个人抢占目标点完全不一样== 虽然这是废话。</p><p>尝试了使用两个堆来维护钱包里钱的数量和总钱数，但是总是谜之挂在#7……就不是很能理解；感觉就凭自己还是不太能看出问题了……解决了这个问题再贴代码。</p><h2 id="e---earthquake">E - Earthquake</h2><blockquote><p>给定长度为n的序列，初值为0；给定两种操作：1：区间对x取max，然后这里从区间两端开始向两边传播，传播的过程中每传播一格就-1；2：区间max。</p></blockquote><h2 id="h---heartfelt-fancy">H - Heartfelt Fancy</h2><blockquote><p>给一个图，已经给定了部分边的边权；你可以加一条u和v之间的边，边权为 (u-v)²，以最小化s到t的最短路。</p></blockquote><p>这是一个比较经典的问题：和上一次校内训练的添加节点是一样的思路——正向扫一遍反向扫一遍最短路，然后再遍历节点求出 (u-v)² 最优解；但是在这个题目里这样做会超时——不论最短路怎么求，最后遍历是O(n²)的，对于2e5的数据规模来说无论怎么也不可能过；因此可能需要考虑一些优化。</p><h2 id="后记">后记</h2>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷ACM春季多校训练营：第四场</title>
      <link href="/2020/luogu-ACM-2020-spring-multi-4/"/>
      <url>/2020/luogu-ACM-2020-spring-multi-4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>因为是版权原因，这里并不能公开的放题目链接和题目的讲评之类的东西。各位看官就将就着看看我说吧==</p><p>已经没什么好怕的了（笑</p></blockquote><p>这次的题解给的是比较干净的PDF，先行给个好评。这下要做的工作就要少很多—— 但是还是要认真的补题的。一共有八个题目，三个题目是比较白给的，但是不白给的一个也做不出（）现在想想这场要是足够能干的话还是可以AK的——我的意思是并不是标准场。</p><p><del>但是相对地，这次的讲评直播是 洛　谷　最　速　传　说（迫真</del></p><p>如果可以的话甚至想直接贴PDF，但是想想看看还是算了——还是一点一点听我讲罢了。</p><h2 id="a---ancient-tree">A - Ancient Tree</h2><p>有一颗树，每个点都有点权。求这棵树的一颗Y型子树，这颗子树包含的所有点的点权xor和最大。所谓Y型树，就是最多有三条链连接到同一个节点的树，用题解的话说，就是求两条到根的链；</p><h2 id="b---blooming-gentians">B - Blooming Gentians</h2><p>给定 n×m 的矩阵；每次先随机选择一种颜色删去，删去该颜色之后，与其他颜色不相邻的颜色也会被删去；求出将矩阵的所有颜色删去的次数的数学期望；</p><h2 id="c---chests">C - Chests</h2><p>给定n个数集，从每个集合中可以选择一个元素，要求选出的数字的方差最小；</p><h2 id="d---decryption">D - Decryption</h2><h2 id="e---eel">E - Eel</h2><h2 id="f---firm-structure">F - Firm Structure</h2><p>定义k-连通图为：至少删去 k 个点才能让图不连通的图。求 n 个点的 k-连通图的最小边数。</p><h2 id="g---giovannis-ticket">G - Giovanni's Ticket</h2><p>解方程： A = ((x&gt;&gt;B) ^ C) + ((x&lt;&lt;D) ^ E) + x (mod (1&lt;&lt;32))。</p><h2 id="h---ham-sausage">H - Ham Sausage</h2><p>将两头是半球体，中间是圆柱体的香肠尽可能的切成n段，求每一段的体积。</p><h2 id="后记">后记</h2>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2015 NEERC 回顾</title>
      <link href="/2020/2015-neerc/"/>
      <url>/2020/2015-neerc/</url>
      
        <content type="html"><![CDATA[<p>校队欢乐赛其三。现在还是觉得欢乐赛的氛围还是属实比较欢乐的，但是很快就要随着三月的结束而结束了。接下来就是正式结成队伍训练了。</p><p>按照惯例，先码官方网站：<a href="https://neerc.ifmo.ru/archive/2015.html" class="uri">https://neerc.ifmo.ru/archive/2015.html</a></p><p>可以下载到问题集、测试数据和标程，但是不知道是什么原因，没有能找到题解的PPT…… 最后在谷歌上找到的题解PPT，链接在下面：</p><p>题解PPT：<a href="https://www.slideshare.net/elizarov/acm-icpc-2015-neerc-northeastern-european-regional-contest-problems-review?from_action=save" class="uri">https://www.slideshare.net/elizarov/acm-icpc-2015-neerc-northeastern-european-regional-contest-problems-review?from_action=save</a></p><p>按照LinkedIn账号登陆就可以下载，也可以在线观看。<del>等博客图书馆功能施工完成后也会提供站内链接</del></p><p>补题地址：<a href="http://codeforces.com/gym/100851" class="uri">http://codeforces.com/gym/100851</a></p><p>在开始之前应当特别注意：本次比赛中的绝大多数题目的输入输出都不是标准输出/输入文件，需要重定向输入流到特定文件。C++选手需要使用<code>freopen("fileName","r",stdin)</code>和<code>freopen("fileName","w",stdout)</code>；Java选手需要使用<code>System.setIn(new BufferedInputStream(new FileInputStream("fileName")))</code>和<code>System.setOut(new PrintStream(new FileOutputStream("fileName")))</code>；Python选手需要使用<code>sys.stdin=open("fileName","r")</code>和<code>sys.stdout=open("fileName","w")</code>。</p><p>根据官方提供的提交数据，可以对本次题目做出以下的难度划分：</p><ul><li>简单题：E、A、G、F —— 通过数量均为100+</li><li>中档题：L、J、K ——通过数量在24~60之间</li><li>困难题：C、B、D、H、I ——通过数量不超过20，甚至还有0</li></ul><p>欢乐赛过程中，所有队伍一共做了A、B、E、F、G、J、K、L八道题，最高通过七道题。</p><p>废话不多说，开始补题了：</p><h2 id="problem-a.-adjustment-office">Problem A. Adjustment Office</h2><p>给一个N*N的矩阵A，A[i,j] = i+j；一共Q次操作，操作有两种类型：R r 取出第r行还未被取的所有数，并输出和；C c取出第c列还未被取出的所有数并输出和；要求输出每次操作之后需要输出的和。n的范围是1e6，q的范围是1e5.</p><h3 id="分析">分析</h3><h2 id="problem-b.-binary-vs-decimal">Problem B. Binary vs Decimal</h2><p>首先，我们先定义专有名词bindecimal数字：</p><blockquote><p>一个数字是bindecimal，当且仅当它的十进制表示是它的二进制表示的后缀。</p></blockquote><p>输入一个n，要求你求出第n个bindecimal的十进制表示。n的规模是10000.</p><h2 id="problem-c.-cactus-jubilee">Problem C. Cactus Jubilee</h2><p>首先先定义仙人掌树：仙人掌树是一般树的一些拓展——允许在树上出现一些环，但是要求每条边最多只能在一个环中。该无向图中不会出现重边和自环；现在给定一个仙人掌树，允许移动一条边（不可以放在原处），求移动之后还是仙人掌树的方案数。</p><p>输入n和m——顶点数和不同的路径数；接下来的m行每行包含一个路径：第一个整数k表示该行数字数量；保证输入的是仙人掌，并且每条边只遍历了一次。n和m的数据规模是5e4.</p><h2 id="problem-d.-distance-on-triangulation">Problem D. Distance on Triangulation</h2><p>给一个n个顶点的凸多边形，和对它的一种三角剖分（n-3条对角线）；接下来进行q次查询：每次查询有两个顶点索引组成，要求查找两个顶点间在多边形的边和给定的对角线上移动的最短距离——每个边和对角线的长度记为1.</p><p>输入顶点数量 n，接下来 n-3 行包含所有对角线；输入查询数 q，接下来 q 行包含了查询的两个定点序号。</p><h2 id="problem-e.-easy-problemset">Problem E. Easy Problemset</h2><p>一共有n个考官，每个人有pi个难度介于0<sub>49的简单问题和无限个复杂问题；每次从1</sub>n顺序选当前考官的问题，如果这个问题的难度≥之前所有问题难度系数和，则将这个问题加入问题集；否则，舍弃这个问题。</p><p>比赛一共需要k个问题。当一个考官拿不出简单的问题时，它会拿出难度系数为50的困难问题。求最终比赛的问题集的难度总和是多少。</p><h2 id="problem-f.-froggy-ford">Problem F. Froggy Ford</h2><p>有一条宽度为w的河流，河的两岸位于 x = 0 和 x = w 两条直线上；在 x ∈ (0,w) 的河流中有 n 块石头，每块石头的坐标是 (xi,yi)；小青蛙现在想要过河，但是它只能从石头上跳着走；现在你可以在河流中任意一处放置一块石头来帮助小青蛙，使得它在过河的最短路中单次跳跃的最大距离尽可能最小化。</p><p>题目给出w和n，以及石头的坐标，求为了达成目的，新石头应当放置的坐标。</p><h2 id="problem-g.-generators">Problem G. Generators</h2><p>线性同余生成器：可以由 x₀ a b c 四个整数定义，可以根据递归定义 x' = (ax + b) mod c 产生无穷序列。</p><p>一共有n个序列，每个序列包含 x a b c 四个值，描述了一个LCG；求从每一个LCG生成的序列中取出一个数，求和之后不是k的倍数的最大值。如果求出，输出最大值和一种具体选取方案，否则输出-1。n k 给出，n规模1e4，k规模1e9.</p><h2 id="problem-h.-hypercube">Problem H. Hypercube</h2><h2 id="problem-i.-iceberg-orders">Problem I. Iceberg Orders</h2><h2 id="problem-j.-jump">Problem J. Jump</h2><p>我们基于游戏 OneMax （猜字串中猜中的位数）定义游戏 Jump ：</p><blockquote><p>Jump游戏的交互方法：</p><ul><li>你知道一个整数n，有一个长度为n的01字符串S，你不知道它的具体内容。</li><li>你可以猜一个01字符串并且发起询问，根据你给出的字符串Q：<ul><li>当Q和S完全相同时，系统返回 n 并退出</li><li>当Q和S恰好有一半的位置相同时，系统返回 n/2 并等待下次询问</li><li>其他情况时，系统返回 0 并等待下次询问</li></ul></li><li>您被允许最多发起 n+500 次询问，要求在这些询问次数之内使得 Q=S</li></ul><p>系统退出后尝试输出，或者超过指定的询问次数将会导致WA；如果询问包含了非法字符或长度≠n，会导致PE和系统退出；完成要求会AC，并且在超过时间限制的情况下会TLE。</p></blockquote><p>给一个长度 n，按照Jump游戏规则进行猜测；要求在 n+500 次猜测之内猜出字符串 S。</p><h2 id="problem-k.-kings-inspection">Problem K. King’s Inspection</h2><p>给定一个有n个节点和m条边的有向图，问是否存在一条路从1号节点出发，访问每个其他节点一次后回到1号节点（哈密顿环）；如果存在，输出以1作为首尾的哈密顿环；否则输出指定字符串。</p><h2 id="problem-l.-landscape-improved">Problem L. Landscape Improved</h2><p>给定一个宽度为N的网格，第i列上有高度为hi的方块；现在给w个方块，要求使得加上这些方块后，得到的网格的最高列的高度尽可能高；放置方块需要放置的位置的下方、左下方、右下方都有方块——也就是说最左和最右两列不能放置方块。</p><h2 id="后记">后记</h2>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Codeforces </tag>
            
            <tag> Gym </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷ACM春季多校训练营：第三场</title>
      <link href="/2020/luogu-ACM-2020-spring-multi-3/"/>
      <url>/2020/luogu-ACM-2020-spring-multi-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>因为是版权原因，这里并不能公开的放题目链接和题目的讲评之类的东西。各位看官就将就着看看我说吧==</p><p>又是一场接近爆零的比赛呢（笑</p></blockquote><p>打的很丑，补题不及时罪加一等。题目不多，难度不做评价，但是就英语来说题目都很好懂，读起来都不费劲<del>就是自己做不出来</del>。……所以就不多废话，直接讲题目。</p><p>首先是出题人自己对于这次题目难度的评价：</p><table><thead><tr class="header"><th style="text-align: center;">简单题</th><th style="text-align: center;">中档题</th><th style="text-align: center;">较难题</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">B,C,D</td><td style="text-align: center;">H,E,G</td><td style="text-align: center;">A,F</td></tr></tbody></table><p>然后，我根据出题人当晚讲评的顺序来说这些题目：</p><h2 id="b---bit-fixer">B - Bit fixer</h2><p>给你一个二进制串，宇宙射线每天会取反一个bit，你很辣鸡，每天只能掰反一个bit；给你一个目标串，问你最少多少天能完成任务。数据规模在1e5之内。</p><h3 id="引导">引导</h3><p>官方讲评在说这个题目之前说了一道下面这样的题目。</p><blockquote><p>这题来源于一道CF题目：</p><p>有一条船，速度v1；水速每天都会变，船的方向也可以每天调整，但在一天中方向都不变；而且船每天的航行时间相同。给出两点距离，以及每天的水流大小和方向，问最少需要花多少天？</p><p>对于这个题：因为船和水的位移都是矢量，如果把船和水的位移加起来等于起点到终点的向量，就表示船可以到达终点。 又因为矢量相加符合交换律，所以可以先计算水的总位移，与起点-&gt;终点的向量相减，就可以得到船要走的位移。</p><p>因此，这个题目，只要枚举天数，得到船应走的唯一，判断能不能走完就行了。</p></blockquote><p>所以这个题目，仔细想想也可以用这种思想来解决。</p><h3 id="分析">分析</h3><p>二进制串，每次会被动的变一次；你每次可以修改一位。如果把二进制串也看成向量的话，那么在第x天，你最多只能满足目标串和当前串相差的模≤x的情况。因为每天原串都会变化，所以模也在不断变化；又因为相反一位的值，也就是异或，也是满足交换律的；所以也可以像上面那个题目那样。</p><p>为什么反复提到交换律呢？我们的做法，相当于把每个时间片的“外力”和“内力”造成的偏移分离之后统一考虑：然而题目原模型是交错的。只有满足了交换律，我们才能随意挪移一个式子中的不同项，整理组合从而简化。</p><p>实现的话，直接枚举然后求差的话，1e10就爆炸了。但是实际上，因为这是一个二进制串，每次只需要更新修改的那一位的状态就可以了（也就是出题人说的曼哈顿法），或者也可以二分答案。</p><p>二分单调性：显而易见的，因为外力和内力是可以抵消的。当某个x可以达成目标之后，之后只需不断抵消内外力即可。</p><p>总而言之，有了交换性，随便怎么整理（移项）都可以哦。</p><h3 id="误区">误区</h3><p>因为题目只让我们求一个具体的值——也就是能不能在指定天数内达成目标，而不是求一个具体的方案。所以完全可以通过挪移整理来简化模型。最开始我的分析是顺推，分不同的情况，使用队列维护修改的优先级。这样做也许是对的，但是我赛场上没有分析出来（逃），这题就这么死了。事实上只要能想到是只求天数的话，完全没有必要这样麻烦自己。</p><p>此外，因为这个题目时求一个最小天数的，且显然具有二分单调性——如果能想到一个二分答案，即使是我那样处理来判别，也是有可能做出来的。总而言之，做不出来就是你傻了。</p><h3 id="代码">代码</h3><p>这是使用优化的枚举的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> len,lim,cnt,pos;</span><br><span class="line"><span class="keyword">char</span> str[N], ch;</span><br><span class="line"><span class="keyword">bool</span> dis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;len&gt;&gt;lim;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i) <span class="built_in">cin</span>&gt;&gt;str[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">        <span class="keyword">if</span> (str[i] != ch)</span><br><span class="line">        &#123;</span><br><span class="line">            ++ cnt;</span><br><span class="line">            dis[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> dis[i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=lim;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;pos;</span><br><span class="line">        pos = len<span class="number">-1</span>-pos;</span><br><span class="line">        <span class="keyword">if</span> (dis[pos])</span><br><span class="line">        &#123;</span><br><span class="line">            dis[pos] = <span class="literal">false</span>;</span><br><span class="line">            ++ cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dis[pos] = <span class="literal">true</span>;</span><br><span class="line">            -- cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &lt;= i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;icu&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个需要注意的就是，输入中的这个index实际上是从右到左的，所以需要进行处理之后才可以使用。当然也可以输入的时候就从后向前存储。</p><h2 id="c---coprime">C - Coprime</h2><p>给你一个整数序列，再给你一个操作：每次你可以把某个数变成任意的另一个数；问最少经过多少次操作，使得序列中任意相邻两个数互质。数据规模1e5。</p><h3 id="分析-1">分析</h3><p>首先，互质也就是说 gcd(a, b) =1. 如果a b中有一个数是1，那这就是板上钉钉的了；所以要改，肯定就是改成1.</p><p>然后对于具体的数列来说，可以使用贪心处理：假设从左向右处理，如果a b相邻但是不互质，最好肯定还是修改b：因为改a只能保证和b互质，而改b还可以保证和未来的c也一定互质。</p><h3 id="代码-1">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt; a) <span class="keyword">return</span> gcd(b,a);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        <span class="keyword">if</span> (gcd(a[i<span class="number">-1</span>],a[i])<span class="number">-1</span>)</span><br><span class="line">            a[i] = <span class="number">1</span>, ++ cnt;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>豆知识（模外挂）：其实比起<code>a%b</code>取模，加上判断地使用<code>a-s/b*b</code>来的更快哦。</p><h2 id="d---dodo-bird-painting">D - Dodo bird painting</h2><p>有一根绳子，每次往绳子上滴一滴墨水，墨水会一固定速度扩散；给出滴墨水的时间和位置，问最早什么时候， 绳子完全被墨水覆盖。绳子长度是1e9，墨水数量1e5.</p><h3 id="分析-2">分析</h3><blockquote><p>这其实是一个二分套路题。</p></blockquote><p>虽然不是大家都喜欢的经典最大求最小或者最小求最大的问题，但是依然是可以用二分求解：</p><ul><li>二分单调性：如果某个时间t恰好可以给整条绳子染色，那么小于t的时间一定不能全部染色，且大于t的时间一定也可以给整条绳子染色。</li><li>问题特性：直接求解（比如DP？），至少需要O(n²)的时间；而确认一个答案可不可以全部染色，只需要O(n)的时间。符合二分答案问题的特点</li></ul><p>综上所述，采用二分答案的方法，把最优化问题转化为可行性问题。 这个题目就可以做了，复杂度大约是O(nlogk)，k和墨水的传输速度和绳子长度相关。</p><p>具体的说，对于具体的时间，求解这个时间下每滴墨水可以染色的区间，再按顺序合并：如果出现无法合并的情况，就说明不可全部染色。</p><h3 id="误区-1">误区</h3><p>其实不想话太多笔墨来说自己是怎么错的。但是既然蠢了，就要挂起来婊着。我最开始想着是DP每两滴墨水之间的绳子长度被墨水染色需要的时间，再考虑墨水“跨界点染色”的事情，也就是说DP。这确实是模拟的思路，但是会TLE。并且只要是这种DP，就必须要确认每滴墨水的可能性。可以说就是没什么太大的优化空间，复杂度O(n²)，对于这个题目的1e5的数据规模，那是死的透透的。</p><p>其次是实现方面的一些事情：合并区间并不可以贪心！除非经过稳健的排序。否则，位置处在后方的区间仍然可以覆盖前面并未合并的区间，如果贪心退出就判断错误了。</p><h3 id="代码-2">代码</h3><p>理清思路的情况下还能吃一发WA也是没谁了。只能说不愧是我==</p><p>写代码的时候还是不能太过于自以为是了。这里的check要做的事是合并区间，而这个行为并不能通过贪心来节约时间——原因上面也提到了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pos first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> spd second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> npos (q+1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">double</span>,<span class="keyword">double</span>&gt; ink;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">range</span> &#123;</span><span class="keyword">double</span> left,right;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-6</span>;</span><br><span class="line">ink li[N];</span><br><span class="line">range r[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(range&amp; a, range&amp; b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(a.left - b.left) &lt; EPS)</span><br><span class="line">        <span class="keyword">return</span> a.right &lt; b.right;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.left &lt; b.left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> q, <span class="keyword">double</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;ii = li[i];</span><br><span class="line">        tmp = t*ii.spd;</span><br><span class="line">        r[i] = &#123;ii.pos-tmp, ii.pos+tmp&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(r+<span class="number">1</span>,r+q+<span class="number">1</span>);</span><br><span class="line">    range rr = &#123;r[<span class="number">1</span>].left, r[<span class="number">1</span>].right&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=q;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (r[i].left &gt; rr.right) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> rr.right = <span class="built_in">max</span>(r[i].right,rr.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !(rr.left &gt; <span class="number">0</span> || rr.right &lt; (<span class="keyword">double</span>)n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    li[<span class="number">0</span>] = <span class="built_in">make_pair</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    li[npos] = <span class="built_in">make_pair</span>(n,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">double</span> maxv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> x,v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;v;</span><br><span class="line">        li[i] = <span class="built_in">make_pair</span>(x,v);</span><br><span class="line">        maxv = <span class="built_in">max</span>(maxv,v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> left = <span class="number">0</span>, right = n/maxv;</span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">while</span> (times --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        (check(q,mid) ? right : left) = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> ans = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">7</span>)&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有几个比较坑的地方：首先输入的墨水的位置和速度都是浮点数——这我还是查了标程才知道的；然后，关于<code>check</code>函数里面的<code>rr.right</code>的问题：看起来这里的max判断是非必要的，因为我已经排序了；但是因为eps的存在以及一些其他的原因，这里必须要强制保证才可以AC。</p><p>另一件事情：如果你不想要使用<code>std::pair&lt;T1,T2&gt;</code>的默认大小判断的话，就干脆的建立一个新类，而不是重命名一个<code>pair</code>——即使你显式的重写了<code>operator&lt;</code>，它用的是什么也不为人知——其实这可实验验证。</p><h2 id="h---huaji-robot">H - Huaji robot</h2><p>有一个n*n的网格图，坐标范围为[(1,1),(n,n)]；横纵坐标互质的地方不能通行；每次移动都是八个方向的移动；给定起点和终点，问能否到达。地图大小n的数据规模是1e9.</p><h3 id="引导-1">引导</h3><p>出题人讲评的幻灯片上，有下面这段文字：</p><blockquote><p>◦ 推公式？我菜得一比，不会推公式！</p><p>◦ 此题更可行的办法是打表+猜结论。</p><p>◦ 打表小技巧：当打出的表只有0和1时，就不需要用空格隔开，进一步地，把1换成空格，这样每一个数字和它周围的 关系就更清楚。</p></blockquote><p>这个题目的障碍物非常的奇特——横坐标和纵坐标互质则不能通行。看起来没什么规律，可以打个表来看看特点。这里就直接写打表可以得到的信息：</p><ul><li>x=y对角线除了x=1时均可以通行：正确性显然</li><li>对于质数行列，会有长段连续的不可通行区域</li><li>连通块被质数的行列等切成了比较规则的区域</li></ul><p>综上所述，可以猜想：除了与整张图的主对角线相连的，所有的连通块都不会太大。因为会被编号时质数行列的直线切开。虽然质数直线并不是连续的，但是还是可以证明每个连通块不大：</p><p>因为每个数的质因子数是 log 级别的，所以在 x=p1 和 x=p2 之间，至多会有 log n×(p2-p1) 个点，把相邻的联通块连接起来。所以每个块的大小是 log n×max(pi-pj) 级别，其中 pi 和 pj 是相邻的两个质数。</p><p>又因为，1e9的范围内两个质数的差不会太大——实际上1e9内，最大的质数间距为282。这真的不大，这样就可以有一种思路：</p><ul><li><p>从起点和终点开始搜索，只要到达 y=x≠1 的点即视为联通</p></li><li><p>使用 map、哈希、偏移量数组来做这次搜索</p></li></ul><p>这样这个题目就可以做了，</p><h3 id="分析-3">分析</h3><p>其实也并不需要打表，稍微想想也可以得到上面看出来的两点结论：对角线联通，质数直线阻塞。然而这种题目似乎除了搜索别无他法，只要能够简化搜索就可以做了。也可以得出双向搜索，使用 map 存储遍历情况来做。</p><p>但是在实现的过程中还要注意，可能两个点都连接到</p><p>当然，这种奇怪的题目也有可能是一个结论，这个时候就别无他法<del>只能当场去世</del>了。</p><h3 id="代码-3">代码</h3><p>使用 map 作为访问数组的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bound(x,y) (x<span class="meta-string">&lt;=n&amp;&amp;x&gt;=1&amp;&amp;y&lt;=n&amp;&amp;y&gt;=1)</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pos</span>&#123;</span><span class="keyword">int</span> x,y;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dx[] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dy[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,sx,sy,ex,ey;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">short</span>&gt;&gt; m;</span><br><span class="line"><span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt; a) <span class="keyword">return</span> gcd(b,a);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b, a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">short</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;pos&gt; q; pos top;</span><br><span class="line">    m[x][y] = flag; q.push(&#123;x,y&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        top = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> xx = top.x + dx[i];</span><br><span class="line">            <span class="keyword">int</span> yy = top.y + dy[i];</span><br><span class="line">            <span class="keyword">if</span> (bound(xx,yy) &amp;&amp; gcd(xx,yy) != <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!m[xx][yy])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (xx == yy &amp;&amp; xx != <span class="number">1</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    m[xx][yy] = flag;</span><br><span class="line">                    q.push(&#123;xx,yy&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (m[xx][yy] != flag)</span><br><span class="line">                    <span class="keyword">return</span> found = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;sx&gt;&gt;sy&gt;&gt;ex&gt;&gt;ey;</span><br><span class="line">    <span class="keyword">bool</span> c1 = check(sx,sy,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">bool</span> c2 = check(ex,ey,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">bool</span> checked = c1 &amp;&amp; c2;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;((checked||found)?<span class="string">&quot;gl&quot;</span>:<span class="string">&quot;gg&quot;</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次写的时候不知道犯了什么浑，结果按照标程的方法布局代码就过了，不是很懂…… 也许两头搜索就应该使用 vis 数组记录具体哪一次搜索到达的信息吧。</p><h2 id="e---eluos-blocks">E - Eluos blocks</h2><p>给了一个由三种俄罗斯方块拼成的图形，记为ABC；A类俄罗斯方块只有一个，而其他的有无数个；求出这唯一的A类方块的位置。整个图形的规模小于500。求出解的数量。并且按照指定的顺序输出所有的解。</p><figure><img src="https://i.loli.net/2020/03/20/Uv3sJw2oPH58rh6.png" class="lazyload" data-srcset="https://i.loli.net/2020/03/20/Uv3sJw2oPH58rh6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="AHCKV__1S9__8P_GBE_BGY.png" /><figcaption aria-hidden="true">AHCKV__1S9__8P_GBE_BGY.png</figcaption></figure><center>↑这是三种俄罗斯方块的样子↑</center><h3 id="引导-2">引导</h3><p>这种一看就是考智商的思维题。这道题再加大难度之前是这样的：</p><blockquote><p>弱化版的条件有这样的区别：无B类方块，依然是一个A类和若干C类方块</p><p>这种情况下，只有两种不同的图形，图形之间的差距挺容易被对比出来的，这里直接说：</p><ul><li>显然，A是斜杠的对角线的两个方块缺失，C是反斜杠的对角线。</li><li>即使这些方块不断的堆积，这种特性也会得以保留。</li><li>A图形跨三行：首尾两行只有一个方块，中间一行有两个；C跨两行，每行两个。</li></ul><p>那么这题的解法就有眉目了：可以利用最后一条特性，确定A所在的水平位置，再搜索垂直方向，找到满足条件的情况输出即可；也可以利用前两条特性，找到最左上角的“孤立”方块，若右侧无方块那就可以肯定是A，否则是C，删去。这种做法的正确性也可以比较容易的讨论证明。</p></blockquote><p>现在的情况是不仅有AC，还有B类方块；这样的话上面的方法就不行了，我们需要去找新的规律：</p><h3 id="分析-4">分析</h3><p>虽然对角线上的两个方块的独特性已经消失了，但是参考上面的特性，我们还是可以找出新的特性：从反对角线方向观察方块的“厚度”，也可以观察到这样的特点：</p><ul><li>A类方块占有斜杠方向对角线的四列，每列有一个方块；</li><li>B类、C类方块占有斜对角线方向的两列，每列有两个方块；</li></ul><p>这样就和上面简单版题目的第三条特性相似，可以使用同样的方法来做了：通过统计对角线的方块数量，找到数量是奇数的四列方块，然后再遍历某对角线上的所有方块，检查它们是A的一部分时的正确性，就可以在O(n³)的时间内求解。所有的解都会出现在这个范围内。</p><p>这里说的斜杠方向指的是将整个图逆时针旋转45°。旋转之后可以得到图形的“列”和“厚度”。</p><p>这个题目似乎实际上O(n⁴)的算法也可以卡过去。也就是说枚举能过的。</p><h3 id="代码-4">代码</h3><p>特别注意：输出的坐标是需要排序的。也就是说这题没有SPJ。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="g---game">G - Game</h2><p>给5个整数，要求使用加减乘除括弧运算符以及前4个数字拼成一个算式，使得算式结构等于第5个数；问是否可以构造出这样的算式。</p><h3 id="分析-5">分析</h3><p>非常经典的问题：你可以不停枚举，枚举数字排列，枚举运算符，枚举括号位置，然后求解验证；也可以每次选出两个数字和一种运算符计算，将计算结果丢回去，重新选择计算直到只剩下一个数字，都可以。怎么做都可以做出来，暴力只要写对了也可以AC。</p><h3 id="误区-2">误区</h3><p>这个游戏和常规24点游戏有一个根本上的不同：数字的顺序是可以随机调换的，最后构造的算式中，数字出现在式子中的顺序未必是输入的顺序。如果按照一般24点写死的话就会死。这有可能就是赛场上我和队友没有AC这个题目的原因所在。</p><h3 id="代码-5">代码</h3><p>首先四选二，再三选二，枚举所有可能的运算方式（包括反向的减法除法）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span>&#123;</span><span class="keyword">int</span> x,y;&#125; other[<span class="number">4</span>][<span class="number">4</span>] =</span><br><span class="line">        &#123;</span><br><span class="line">                &#123;&#123;&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">3</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;&#125;,</span><br><span class="line">                &#123;&#123;<span class="number">3</span>,<span class="number">2</span>&#125;,&#123;&#125;,&#123;<span class="number">0</span>,<span class="number">3</span>&#125;,&#123;<span class="number">0</span>,<span class="number">2</span>&#125;&#125;,</span><br><span class="line">                &#123;&#123;<span class="number">3</span>,<span class="number">1</span>&#125;,&#123;<span class="number">3</span>,<span class="number">0</span>&#125;,&#123;&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;,</span><br><span class="line">                &#123;&#123;<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;&#125;&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="keyword">int</span> ed;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">operate</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">int</span> mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (mode)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> a+b;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> a*b;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> a-b;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> b-a;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">return</span> !a?<span class="number">0</span>:b/a;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> b?a/b:<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deepSearch</span><span class="params">(<span class="keyword">double</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;<span class="number">3</span>;++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> op1=<span class="number">0</span>;op1&lt;<span class="number">6</span>;++op1)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> op2=<span class="number">0</span>;op2&lt;<span class="number">6</span>;++op2)</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">fabs</span>(operate(</span><br><span class="line">                            operate(a[i],a[j],op1),a[<span class="number">3</span>-i-j],op2</span><br><span class="line">                    )-ed)&lt;eps)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t,op[<span class="number">4</span>];</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fun = [&amp;]() -&gt; <span class="keyword">bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> arr[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;<span class="number">4</span>;++j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="number">6</span>;++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    arr[<span class="number">0</span>] = operate(op[i],op[j],k);</span><br><span class="line">                    arr[<span class="number">1</span>] = op[other[i][j].x];</span><br><span class="line">                    arr[<span class="number">2</span>] = op[other[i][j].y];</span><br><span class="line">                    <span class="keyword">if</span> (deepSearch(arr)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;op[<span class="number">0</span>]&gt;&gt;op[<span class="number">1</span>]&gt;&gt;op[<span class="number">2</span>]&gt;&gt;op[<span class="number">3</span>]&gt;&gt;ed;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(fun()?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在觉得适当的多用用lambda表达式声明一些函数还是蛮好的== 有点香</p><h2 id="a---able-was-i-ere-i-saw-elba">A - Able was I ere I saw Elba</h2><p>给一个长度为 n 字符串，以及m个操作；每个操作能让你花 c 个代价把字符 a 变成字符 b；对于串中的所有子串[l,r]，都可以花一个最小的代价来把它变成回文串；问对于所有n*(n-1)/2个子串，最小代价和是多少。</p><h3 id="引导-3">引导</h3><p>首先题目里是子串，而不是子序列（否则个数也不对了），子串是连续的。</p><p>和很多的区间数据结构题目不同，这个题目并不是每次询问一个空间内的子串，而是所有可能的子串。这和随机询问不同，是一种特殊性，可以加以利用；下面我们考虑一对字符 s[i] 和 s[j] 的贡献：</p><ul><li>设 i j 的对称轴为 k，显然k是中点；显然，所有以k为对称轴的子串都会受到同样来自 i j 的贡献；</li><li>这样的子串数量是 min(i,n-j+1)，这也是显然的。</li><li>直接枚举复杂度太大，但是可以简化：若贡献 i 次，那么一定满足 i &lt; n-j+1， j 的取值有范围；</li><li>假设 j 的最大值为 m，则 i &lt; n-m+1 =&gt; m&lt;n-i+1 。</li></ul><p>至于让 i j 字符相同，可以修改两者中的一个，也可以同时修改两个字符使他们的值相等，找到最小的花费。又因为它们有不同的贡献度，还要记得加算倍数。事实上，分贡献的倍数讨论就可以了。</p><p>根据上面的分析，可以确定这样的实现思路：</p><ul><li>根据奉献的次数来分别处理：奉献次数为 i 时，也就是a[i]与所有的 a[t] (i&lt;t&lt;n-i+1) 不发生冲突的最少花费的和；奉献 j 次时，就是反向同理；</li><li>因为字符集只有26，可以处理每个字母数量的前缀和，从而快速得出区间 (i,n-i+1) 内存在的不同字符个数，以累加对答案的总贡献；</li><li>因为变化字符使得相等有多种方案，需要预先处理任意两个字符的转化代价，再处理消除任意两个冲突字符的代价；这可以使用 Floyd 预处理。</li></ul><p>这样，就可以着手实现这个题目了。</p><h3 id="分析-6">分析</h3><p>首先看懂题目。我们选择样本不大且有代表性的样例2：</p><table><thead><tr class="header"><th>输入数据</th><th>输出数据</th></tr></thead><tbody><tr class="odd"><td>5 2 aabaa a b 1 b a 10</td><td>6</td></tr></tbody></table><p>字符串"aabaa"一共有十个子串，下面只列出需要修改字符的子串：</p><ul><li>"aaba", "abaa" =&gt; "abba"：a -&gt; b，消费1*2</li><li>"aab", "baa" =&gt; "bab"：a -&gt; b，消费1*2</li><li>"ab", "ba" =&gt; "bb"：a -&gt; b，消费1*2</li></ul><p>综上所述，将这个字符串的全部子串变为回文串的总消费是6，也就是要求解输出的值。</p><p>首先维护一个字符集的前缀和；然后根据输入的转化成本信息，使用Floyd求出所有可互相转化的字符转化的最低成本；然后考虑解决冲突：当字符 i j 不同时，将它们改成相同的时候所需要的最低成本；随后遍历串中每一个字符，只考虑单个字符的贡献以统计答案。具体地说，统计答案是这样做的：</p><ul><li>对于下标为 [0,n-1] 的字符串的第 i 个字符：它的左侧有 i 个字符，右侧有 n-i-1 个字符；</li><li>若字符靠左侧，则 i 较小；这里仅考虑 i 作为对称轴左侧字符的情况，因为右侧的情况会被更小的 i 考虑到；</li><li>若字符 i 在左侧，那么它的左侧还可能有 [0,i] 个字符；这里仅考虑 i 的情况，因为其他情况会被从右侧对称考虑到；但是仍然要计算所有的可能前缀的回文串；</li><li>问题转化成：当子串的对称轴左侧最前端有 substr(0,i) 的前缀时，字符 i 可以为回文串奉献的最小修改成本；</li><li>因为有了长度为 i 的前缀，所以可能在子串中和 i 对称的字符只有下标为 [i+1,n-i-1] 的字符；尝试修改字符 i 使得字符 i 与每个这些字符都相等；</li><li>因为有可选的长度为 i 的前缀，所以上述计算得到的奉献还需要加算奉献倍数 i+1；</li><li>当字符 i 在右侧时，需要注意的是：使用全部后缀的情况已经被对应的左侧字符考虑过了，所以考虑的对称字符只有下标为 [n-i, i-1] 的字符。</li><li>特别注意，字符串长度为奇数的时候，最中间的一个字符单独计算贡献时不能带来任何贡献；</li></ul><p>注意上述的所有细节，方可写出这个题目的代码。</p><h3 id="代码-6">代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="f---fake-information">F - Fake information</h2><p>空间中有 m 个点，有 n 个粒子在这些点上随机运动；开始时所有粒子处在1号点；每轮运动，粒子都会随机运动到其它另一个点，运动持续无数次；设 d[i,j] 表示第 i 个粒子和第 j 个粒子运动轨迹的最长公共前缀，求 max{d[i,j]} 的期望值。数据规模是100.</p><h3 id="引导-4">引导</h3><h3 id="分析-7">分析</h3><h2 id="后记">后记</h2><p>菜呢，是真的菜。签到题的思路全部歪了，到最后除了最简单的划水题，一个题目也没有做出来。甚至根本都没有向二分答案的方向上去想。</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Luogu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法分析与设计：实验1-3实验报告</title>
      <link href="/2020/class-algorithm-experiment-report-1-3/"/>
      <url>/2020/class-algorithm-experiment-report-1-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>所有的三次实验的源码由博主使用 Java/Kotlin 写成，已经开源：<br />项目首页： <a href="https://dev.azure.com/Pure-Asahi/2020_Spring_In_Class_Job" class="uri">https://dev.azure.com/Pure-Asahi/2020_Spring_In_Class_Job</a><br />仓库地址： <a href="https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job" class="uri">https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job</a><br />代码正确性不做绝对保证，使用需谨慎；有问题欢迎指出。</p></blockquote><h2 id="front-matter">Front-matter</h2><p>去网上找成品代码太难了，写错的还有一大堆。最后还是得自己写……</p><p>对于每一个实验，只需要执行项目下的<code>Main.main(String[] args)</code>就可以全自动的解出题目所要求的数据。因为项目使用IDEA写的，使用了一些Jetbrains自己的特性。所以请使用IDEA打开项目。</p><p>因为有很多的基础算法，它们的原理这里就不再赘述了，要是不知道的自己去看书。</p><h2 id="实验一排序算法">实验一：排序算法</h2><p>实验要求如下：</p><blockquote>#####<center>实验一：排序算法</center><p><strong>一、实验目的</strong> 1. 掌握算法科学解决问题的基本模式 2. 了解确定性算法和随机性算法区别 3. 分析同一问题不同解决算法之间的效率差</p><p><strong>二、实验条件</strong> - 硬件：计算机 - 软件：计算机程序语言开发平台，如 C、C++、Java、Matlab。 - 学生：至少掌握一门计算机程序设计语言，如 C、C++、Java、Matlab</p><p><strong>三、实验内容及要求</strong> 1. 利用计算机程序设计语言，实现教材第 2 章介绍的“插入排序算法”，自主拟定一组输入数据，输出相应的算法结果。 2. 利用计算机程序设计语言，实现教材第 2 章介绍的“合并排序算法”，自主拟定长度分别为偶数和奇数的输入数据，输出相应的算法结果。 3. 利用计算机程序设计语言，实现教材第 7 章介绍的“快速排序算法”，自主拟定一组输入数据，输出相应的算法结果。 4. 利用计算机程序设计语言，实现教材第 7 章介绍的“随机快速排序算法”，采用实验内容 3的输入数据，输出相应的算法结果。 5. 利用计算机程序设计语言，实现教材第 8 章介绍的“计数排序算法”，自主拟定一组适合“计数排序”问题特征的输入数据，输出相应的算法结果。 6. 利用计算机程序设计语言，实现教材第 8 章介绍的“基数排序算法”，自主拟定一组适合“基数排序”问题特征的输入数据，输出相应的算法结果。 7. 利用计算机程序设计语言，实现教材第 8 章介绍的“桶排序算法”，自主拟定一组适合“桶排序”问题特征的输入数据，输出相应的算法结果。 8. 分析上述 7 种排序算法的效率，并用直观的形式表达出效率随输入规模的变化趋势</p><p><strong>四、思考题</strong> - 算法科学解决问题的一般模式是什么？ - 确定性算法和随即性算法的差异在那里？随机化对于算法效率的影响如何？ - 如何理解算法效率分析的渐近特征和相对性？</p></blockquote><h3 id="实现算法">实现算法</h3><p>算法的原理参考《算法导论》，使用Java实现了整数排序机<code>IntegerSorter</code>类，包含任务要求的所有排序算法。</p><p>源代码可以看<a href="https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job?path=%2FSort_Algorithm%2Fsrc%2Fcom%2Fshiroha%2Fcurriculum%2Falgorithm%2Fsort">仓库</a>，代码的具体内容这里不再赘述。</p><p>测试函数使用Java虚拟机提供的计时器计时，计算整个函数运行的时间消耗并输出到控制台上。根据用户的输入多次连续的测试某种算法的时间消耗，并且验证正确性后输出到控制台。</p><p>查看<a href="https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job?path=%2FSort_Algorithm%2Fsrc%2Fcom%2Fshiroha%2Fcurriculum%2Falgorithm%2Fsort%2FIntegerSorter.java">核心代码</a></p><h3 id="实验结果">实验结果</h3><h4 id="算法正确性">算法正确性</h4><p>控制台的输出如下：</p><figure><img src="https://i.loli.net/2020/03/17/XcWo2mKqelEfVdy.png" class="lazyload" data-srcset="https://i.loli.net/2020/03/17/XcWo2mKqelEfVdy.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="W_AZ_1Q_4TKI2_NACZQ_SXK.png" /><figcaption aria-hidden="true">W_AZ_1Q_4TKI2_NACZQ_SXK.png</figcaption></figure><p>可见算法的正确性是可以保障的。</p><h4 id="算法效率">算法效率</h4><p>执行<a href="https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job?path=%2FSort_Algorithm%2Fsrc%2Fcom%2Fshiroha%2Fcurriculum%2Falgorithm%2Fsort">源代码</a>的<code>Main.main</code>方法，输入不同的数据大小，可以得到这样的测试结果（控制台文件）：</p><figure><img src="https://i.loli.net/2020/03/17/gihHMp2J4yPlVC5.png" class="lazyload" data-srcset="https://i.loli.net/2020/03/17/gihHMp2J4yPlVC5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="K0ILDUBZ_37Y_EO_PQK__ME.png" /><figcaption aria-hidden="true">K0ILDUBZ_37Y_EO_PQK__ME.png</figcaption></figure><p>小于1000的数据集规模因为时间过短，统计时间为0ms；大于1e7的数据集规模因为Java内部原因，运行常数过大导致虚拟机中断，未能输出结果。合并排序速度较慢的一大原因是因为Java内部数据拷贝以及内存分配释放速度较慢导致。</p><p>因为算法实现以及Java的一些原因，所有的非原位排序算法都将面临一个很大的常数。这是由于内存分配和释放带来的额外开销。也许可以在更加优雅的实现方式中使用一些方法来降低这方面的开销。</p><h4 id="算法分析">算法分析</h4><p>以下是包含本次实验的七个排序算法在内的算法分析表：</p><table><thead><tr class="header"><th>排序方法</th><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>最好时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr class="odd"><td>插入排序</td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td>稳定</td></tr><tr class="even"><td>希尔排序</td><td><span class="math inline">\(O(n^{1.3})\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td>不稳定</td></tr><tr class="odd"><td>选择排序</td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td>不稳定</td></tr><tr class="even"><td>堆排序</td><td><span class="math inline">\(O(nlog_2n)\)</span></td><td><span class="math inline">\(O(nlog_2n)\)</span></td><td><span class="math inline">\(O(nlog_2n)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td>不稳定</td></tr><tr class="odd"><td>冒泡排序</td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td>稳定</td></tr><tr class="even"><td>快速排序</td><td><span class="math inline">\(O(nlog_2n)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(nlog_2n)\)</span></td><td><span class="math inline">\(O(nlog_2n)\)</span></td><td>不稳定</td></tr><tr class="odd"><td>归并排序</td><td><span class="math inline">\(O(nlog_2n)\)</span></td><td><span class="math inline">\(O(nlog_2n)\)</span></td><td><span class="math inline">\(O(nlog_2n)\)</span></td><td><span class="math inline">\(O(n)\)</span></td><td>稳定</td></tr><tr class="even"><td>计数排序</td><td><span class="math inline">\(O(n+k)\)</span></td><td><span class="math inline">\(O(n+k)\)</span></td><td><span class="math inline">\(O(n+k)\)</span></td><td><span class="math inline">\(O(n+k)\)</span></td><td>稳定</td></tr><tr class="odd"><td>桶排序</td><td><span class="math inline">\(O(n+k)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(n)\)</span></td><td><span class="math inline">\(O(n+k)\)</span></td><td>稳定</td></tr><tr class="even"><td>基数排序</td><td><span class="math inline">\(O(nk)\)</span></td><td><span class="math inline">\(O(nk)\)</span></td><td><span class="math inline">\(O(nk)\)</span></td><td><span class="math inline">\(O(n+k)\)</span></td><td>稳定</td></tr></tbody></table><p>上述表格只提供了对算法的简单分析。诸如基数排序等部分排序算法的复杂度还受到了一些其他可控因素的影响，这里不再讨论。</p><p>这些算法的运行时间/空间将会随着输入规模的变化大致按照上表所示的趋势变化。但是因为并不能收集到数量级跨较大范围的数据变化趋势，所以无法绘图。</p><h3 id="思考题">思考题</h3><h4 id="算法科学解决问题的一般模式">算法科学解决问题的一般模式</h4><p>简单地说，算法就是解决问题的方法和步骤。这些步骤可以简要的概括为： - 分析问题：对问题进行思考分析 - 设计算法编写程序：设计出合理的算法并将其改写为计算机程序 - 运行程序并验证结果：运行所得的程序验证是否能够解决问题，如果不能，重新设计算法或改写程序 - 解决问题：使用所得程序解决问题</p><h4 id="确定性算法和随机性算法的差异">确定性算法和随机性算法的差异</h4><p>随机化算法是一种在算法中使用了随机函数，且随机函数的返回值直接或间接的影响了算法的执行流程或执行结果的算法。而确定性算法是与随机化算法相对的：算法本身执行的过程是相对确定的。具体地说，随机化算法，即指的是在运行的过程中的某一步或某几步涉及一个随机决策，或者说其中的一个决策依赖于某种随机事件的一类算法；而相对应地，确定性算法不具有此特征。通常而言，对于确定的输入，确定性算法能输出稳定一致的结果，而随机化算法不一定能。</p><h4 id="随机化对于算法效率的影响">随机化对于算法效率的影响</h4><ul><li>在许多情况下，当算法在执行过程中面临一个选择时，随机化选择常比最优选择省事。<br /></li><li>因此，大多数情况下，随机化算法都可以在很大程度上降低算法的复杂度。</li><li>例如对于快排而言，快排的排序速度取决于数组的无序程度，数组越乱，快排的效率越高；所以，对快排算法加入随机化十分重要。</li><li>一个简单的应用，例如：数据读入时将数据排放在随机位置，这样就可以将快排的的时间复杂度维持在较好状态。</li></ul><h4 id="如何理解算法效率分析的渐近特征和相对性">如何理解算法效率分析的渐近特征和相对性</h4><ul><li>渐进性：在算法效率度量中，常常采用渐进表达式；因为常数间的差异较小，而渐进表达式的核心就是忽略常数。</li><li>相对性：算法的效率是相对的，我们选取的参照不同，数值的意义就不同；我们需要为自己的算法效率评估确定一个基准，然后相对于这个基准我们来做算法效率评估。</li><li>例如希望测试快排的效率，不能直接对大量数据进行快排计算时间；而应选取参照，例如与冒泡，桶排序等方案进行比较，从而分析出快排的效率的优越性</li></ul><hr /><h2 id="实验二strassens-矩阵乘法和最近点对算法">实验二：Strassen’s 矩阵乘法和最近点对算法</h2><p>实验要求如下：</p><blockquote>#####<center>实验二：Strassen’s 矩阵乘法和最近点对算法</center><p><strong>一、实验目的</strong> 1. 理解“分治法”算法设计思想及其实现步骤 2. 掌握分治算法效率递归分析方法 3. 掌握主方式求解递归式方法</p><p><strong>二、实验条件</strong> - 硬件：计算机 - 软件：计算机程序语言开发平台，如 C、C++、Java、Matlab。 - 学生：至少掌握一门计算机程序设计语言，如 C、C++、Java、Matlab</p><p><strong>三、实验内容及要求</strong> 1. 利用计算机程序设计语言，实现教材第 28.2 章介绍的“Strassen’s 矩阵乘法算法”，自主生成两个 8×8 的矩阵，检验算法的正确性并输出算法结果。 2. 比较 Strassen’s 矩阵乘法算法和数学定义的矩阵乘法算法效率之间的区别，并用直观的表达方式把两种不同矩阵乘法的效率随矩阵维数的变化趋势。 3. 利用计算机程序设计语言，实现教材第 33.4 章介绍的“最近点对算法”，在拟定的二维空间点集上检验算法的正确性并输出算法结果。</p><p><strong>四、思考题</strong> 1. 分治法算法设计思想的三个基本步骤是什么？如何证明分治算法的正确性？ 2. 利用主方式求解 Strassen’s 矩阵乘法和最近点对算法效率的递归分析结果。 3. 解释怎样修改 Strassen’s 矩阵乘法算法，使得它也可以用于大小不必为 2 的幂的矩阵</p></blockquote><h3 id="任务一-stressen-方法">任务一： Stressen 方法</h3><p>关于 Stressen 矩阵乘法方法的描述，详见算法导论：</p><p><img src="https://i.loli.net/2020/03/17/KhZPjEISkQ98ruy.png" class="lazyload" data-srcset="https://i.loli.net/2020/03/17/KhZPjEISkQ98ruy.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="_97TUCE_DG_GDVAV_WP6BF.png" /><br /><img src="https://i.loli.net/2020/03/17/ebQOFo8sNjLHVgy.png" class="lazyload" data-srcset="https://i.loli.net/2020/03/17/ebQOFo8sNjLHVgy.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="R_CD_JGF2J_EF_5N6RB_M90.png" /><br /><img src="https://i.loli.net/2020/03/17/M8ez6tYHULkR4yj.png" class="lazyload" data-srcset="https://i.loli.net/2020/03/17/M8ez6tYHULkR4yj.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="JLZTD_VW6R__MJU3HT28HC.png" /></p><p>就这样，先把矩阵分块，然后根据书上的做法敲一遍。只要不敲错就不会有什么问题。验证请看实验结果。</p><p>下面是我实现的Stressen方法的核心部分。具体内容请参见<a href="https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job?path=%2FDivide_Algorithm%2Fsrc%2Fcom%2Fshiroha%2Fcurriculum%2Falgorithm%2Fdivide">源代码</a>中的<code>Matrix</code>类下的一些方法的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] stressen(<span class="keyword">int</span>[][] ma, <span class="keyword">int</span>[][] mb) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> n = ma.length, half = n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span>[][] ret = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">        ret[<span class="number">0</span>][<span class="number">0</span>] = ma[<span class="number">0</span>][<span class="number">0</span>] * mb[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> a11[][] = <span class="keyword">new</span> <span class="keyword">int</span>[half][half];</span><br><span class="line">        <span class="keyword">int</span> a12[][] = <span class="keyword">new</span> <span class="keyword">int</span>[half][half];</span><br><span class="line">        <span class="keyword">int</span> a21[][] = <span class="keyword">new</span> <span class="keyword">int</span>[half][half];</span><br><span class="line">        <span class="keyword">int</span> a22[][] = <span class="keyword">new</span> <span class="keyword">int</span>[half][half];</span><br><span class="line">        <span class="keyword">int</span> b11[][] = <span class="keyword">new</span> <span class="keyword">int</span>[half][half];</span><br><span class="line">        <span class="keyword">int</span> b12[][] = <span class="keyword">new</span> <span class="keyword">int</span>[half][half];</span><br><span class="line">        <span class="keyword">int</span> b21[][] = <span class="keyword">new</span> <span class="keyword">int</span>[half][half];</span><br><span class="line">        <span class="keyword">int</span> b22[][] = <span class="keyword">new</span> <span class="keyword">int</span>[half][half];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; half; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; half; ++j) &#123;</span><br><span class="line">                a11[i][j] = ma[i][j];</span><br><span class="line">                a12[i][j] = ma[i][j+half];</span><br><span class="line">                a21[i][j] = ma[i+half][j];</span><br><span class="line">                a22[i][j] = ma[i+half][j+half];</span><br><span class="line">                b11[i][j] = mb[i][j];</span><br><span class="line">                b12[i][j] = mb[i][j+half];</span><br><span class="line">                b21[i][j] = mb[i+half][j];</span><br><span class="line">                b22[i][j] = mb[i+half][j+half];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] s1 = sub(b12,b22);</span><br><span class="line">        <span class="keyword">int</span>[][] s2 = add(a11,a12);</span><br><span class="line">        <span class="keyword">int</span>[][] s3 = add(a21,a22);</span><br><span class="line">        <span class="keyword">int</span>[][] s4 = sub(b21,b11);</span><br><span class="line">        <span class="keyword">int</span>[][] s5 = add(a11,a22);</span><br><span class="line">        <span class="keyword">int</span>[][] s6 = add(b11,b22);</span><br><span class="line">        <span class="keyword">int</span>[][] s7 = sub(a12,a22);</span><br><span class="line">        <span class="keyword">int</span>[][] s8 = add(b21,b22);</span><br><span class="line">        <span class="keyword">int</span>[][] s9 = sub(a11,a21);</span><br><span class="line">        <span class="keyword">int</span>[][] s10 = add(b11,b12);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] p1 = stressen(a11,s1);</span><br><span class="line">        <span class="keyword">int</span>[][] p2 = stressen(s2,b22);</span><br><span class="line">        <span class="keyword">int</span>[][] p3 = stressen(s3,b11);</span><br><span class="line">        <span class="keyword">int</span>[][] p4 = stressen(a22,s4);</span><br><span class="line">        <span class="keyword">int</span>[][] p5 = stressen(s5,s6);</span><br><span class="line">        <span class="keyword">int</span>[][] p6 = stressen(s7,s8);</span><br><span class="line">        <span class="keyword">int</span>[][] p7 = stressen(s9,s10);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c11[][] = sub(add(p5,p4),sub(p2,p6));</span><br><span class="line">        <span class="keyword">int</span> c12[][] = add(p1,p2);</span><br><span class="line">        <span class="keyword">int</span> c21[][] = add(p3,p4);</span><br><span class="line">        <span class="keyword">int</span> c22[][] = sub(add(p5,p1),add(p3,p7));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; half; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; half; ++j) &#123;</span><br><span class="line">                ret[i][j] = c11[i][j];</span><br><span class="line">                ret[i][j+half] = c12[i][j];</span><br><span class="line">                ret[i+half][j] = c21[i][j];</span><br><span class="line">                ret[i+half][j+half] = c22[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="任务二-最近点对问题">任务二： 最近点对问题</h3><h4 id="问题简述">问题简述</h4><p>在一个二维空间内有一些点，求出所有点对中距离最小的点对以及距离值。这里的距离指的是欧几里得距离即直线距离。</p><h4 id="问题分析">问题分析</h4><p>这个问题可以分解成一些互不相干的子问题，并且小规模求解更加简单，同时还具有最优的子结构。满足使用分治思想求解的问题的特点，故可以使用分治思想求解。参考《算法导论》上的相关内容，分治的步骤可以是下面这样：</p><ol type="1"><li>分治</li></ol><ul><li>对所有的点按照x坐标（或者y）从小到大排序。（排序方法时间复杂度<span class="math inline">\(O(nlogn)\)</span>）</li><li>根据下标进行分割，使得点集较平均地分为两个集合。</li></ul><ol start="2" type="1"><li>求解</li></ol><ul><li>递归的寻找两个集合中的最近点对。</li><li>取两个集合最近点对中的最小值<span class="math inline">\(d=min(d_{L},d_{R})\)</span>。</li></ul><ol start="3" type="1"><li>合并</li></ol><ul><li>最近距离不一定存在于两个集合中，可能在分解的两侧。</li><li>若一个点在集合A，一个点在集合B，那么这两点间距离小于d。</li></ul><p>前面的部分还都比较好理解，关键就在于合并步骤。根据上面的分析：当最近点对在分割线两侧的时候，它们的距离一定会小于d；因此，我们可以在分割线m的周围取以下区间<span class="math inline">\([m-d,m+d]\)</span>；显然，若最小点对跨过了分界线，那么一定会出现在这个条状区域内。那么只需要遍历一端在<span class="math inline">\([m-d,m]\)</span>另一端在<span class="math inline">\([m,m+d]\)</span>内的所有点对并计算距离就可以了。</p><p>但是这里有一个显而易见的最坏情况：若两侧所有的点都出现在这一个带状区域之内，那么我们做的分治只是白白地增加了整个算法的常数而已。所以要在这个的基础之上进行优化。这里，算法导论上还给出了一个方法——把带状区域中的点按照另一个坐标排序；则在该数组中，对于任何一个点，最多只需要检查紧随其后的7个点，就可以确保找到存在的最小点对或确保它不存在。我们着重讨论这种做法的正确性所在：</p><p>首先先给出一个结论：若（p,q）是Q的最近点对，且p在带域左半部分，则q点必在下图所示的δ∗2δ长方形上；而在该长方形上，最多只能有边点集的6个点；每个点对之间的距离不小于δ。</p><figure><img src="https://i.loli.net/2020/03/17/kbwfAKrBUWSyRgY.png" class="lazyload" data-srcset="https://i.loli.net/2020/03/17/kbwfAKrBUWSyRgY.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2018092815112973.png" /><figcaption aria-hidden="true">2018092815112973.png</figcaption></figure><p>可以使用反证法来证明它的正确性：我们现在将上面的这个δ∗2δ的长方形划分成6个2δ/3∗δ/2的小长方形。如果存在第七个符合条件的点，那么一定有一个长方形拥有了两个点——然而这个长方形内最长的距离，也就是对角线，也不过长5δ/6；然后我们将这个打长方形对折到p同侧：根据同样的考虑，同侧最多也只能再有额外的两个点的距离大于δ；在考虑扫描的顺序，即可说明仅扫描随后7个点的正确性。</p><p>经过这种简化，扫描带状区域的复杂度被压缩到了常数级别，大大提升了算法的效率。</p><p>此外，还有如下的更进一步的优化：</p><blockquote><p>1998年，由周玉林、熊鹏荣、朱洪教授提出了平面最近点对的一个改进算法，针对Preparata-Shamos算法提出的6个点，又证明其实只需要4个点就可以确定最近点对距离，该证明提出2个定理，利用更加准确的半径画圈，证明了只要对左半域上的每个点p，检验右半域y坐标与p最近的至多4个点即可（上下个两个）。具体明可以参考《求平面点集最近点对的一个改进算法》。</p><p>根据以上的优化，可以在合并时，通过检测与左半域点p的y坐标相邻的2个或者3个，即使用4点或者6点来检测，一般为了省事，只求与p点y坐标上界或者下界右半域连续的6个、4个点即可。</p><p><em>版权声明：本文为CSDN博主「码到sucess」的原创文章，遵循 CC 4.0 BY-SA 版权协议。</em><br /><em>原文链接：https://blog.csdn.net/sinat_35678407/article/details/82874216</em></p></blockquote><p>经过上述的优化之后，我们就可以确实地使用分治策略来优化这个问题了。上面说到的按照另一坐标轴排序的部分，还可以使用预排序的方法，再额外优化掉每次排序的一个<span class="math inline">\(log n\)</span>的复杂度。排序的预处理消耗<span class="math inline">\(O(nlogn)\)</span>，处理阶段消耗<span class="math inline">\(\Theta (n)\)</span>；最终的时间复杂度的递推公式如下：</p><center><span class="math display">\[T(n) = \begin{cases} 1 ,&amp; n \leq 3 \\2T(\frac{n}{2}) + O(n) ,&amp; n &gt; 3\end{cases} \]</span></center><p>也就是说，整体的复杂度是 O(nlog n)。</p><h4 id="代码实现">代码实现</h4><p>分治分为三个模块：分治模块，合并模块和暴力模块；当区间较小时直接由暴力模块求解，否则则先递归的分治，之后再使用合并模块合并两区间的答案求解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Point[] mergeDivisor(<span class="keyword">double</span> m, <span class="keyword">double</span> d, Point[] set) &#123;</span><br><span class="line">    ArrayList&lt;Point&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> l = m-d, r = m+d;</span><br><span class="line">    <span class="keyword">for</span> (Point pii : set)</span><br><span class="line">        <span class="keyword">if</span> (pii.x &gt;= l &amp;&amp; pii.x &lt;= r)</span><br><span class="line">            list.add(pii);</span><br><span class="line">    Point[] ret = <span class="keyword">new</span> Point[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> length = list.size();</span><br><span class="line">    <span class="keyword">if</span> (length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        ret[<span class="number">0</span>] = <span class="keyword">new</span> Point(-inf);</span><br><span class="line">        ret[<span class="number">1</span>] = <span class="keyword">new</span> Point(inf);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ret[<span class="number">0</span>] = list.get(<span class="number">0</span>);ret[<span class="number">1</span>] = list.get(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">double</span> now = ret[<span class="number">0</span>].distance(ret[<span class="number">1</span>]), tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++ i) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> lim = Math.min(length, i + <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; lim; ++ j) &#123;</span><br><span class="line">            tmp = list.get(i).distance(list.get(j));</span><br><span class="line">            <span class="keyword">if</span> (tmp &lt; now) &#123;</span><br><span class="line">                now = tmp;</span><br><span class="line">                ret[<span class="number">0</span>] = list.get(i);</span><br><span class="line">                ret[<span class="number">1</span>] = list.get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Point[] solveDivisor(<span class="keyword">int</span> l, <span class="keyword">int</span> r, Point[] arr) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> m = arr.length / <span class="number">2</span>, ml = m + l;</span><br><span class="line">    <span class="keyword">if</span> (arr.length == <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">new</span> Point[]&#123;arr[<span class="number">0</span>],arr[<span class="number">1</span>]&#125;;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (arr.length == <span class="number">3</span>) <span class="keyword">return</span> bruteDivisor(arr);</span><br><span class="line">    <span class="keyword">double</span> mid = (arr.length % <span class="number">2</span> == <span class="number">1</span>) ? <span class="keyword">this</span>.set[l+m].x : (<span class="keyword">double</span>)(<span class="keyword">this</span>.set[l+m].x + <span class="keyword">this</span>.set[l+m-<span class="number">1</span>].x) / <span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">int</span> lcredit = <span class="number">0</span>, rcredit = <span class="number">0</span>, cur = l + m;</span><br><span class="line">    <span class="keyword">while</span> (cur &lt; r &amp;&amp; <span class="keyword">this</span>.set[cur++].x == mid) ++rcredit; cur = l + m - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur &gt;= l &amp;&amp; <span class="keyword">this</span>.set[cur--].x == mid) ++lcredit;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ca = <span class="number">0</span>, cb = <span class="number">0</span>, mm = arr.length - m;</span><br><span class="line">    Point[] left = <span class="keyword">new</span> Point[m], right = <span class="keyword">new</span> Point[mm];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i].x &lt; mid) left[ca++] = arr[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i].x &gt; mid) right[cb++] = arr[i];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (rcredit &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                right[cb++] = arr[i];</span><br><span class="line">                -- rcredit;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (lcredit &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                left[ca++] = arr[i];</span><br><span class="line">                -- lcredit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Point[] ans1 = solveDivisor(l,ml,left), ans2 = solveDivisor(ml,r,right);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> d1 = ans1[<span class="number">0</span>].distance(ans1[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> d2 = ans2[<span class="number">0</span>].distance(ans2[<span class="number">1</span>]);</span><br><span class="line">    Point[] ans3 = mergeDivisor(mid,Math.min(d1,d2),arr);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">double</span> d3 = ans3[<span class="number">0</span>].distance(ans3[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (d3 &lt; Math.min(d1,d2)) <span class="keyword">return</span> ans3;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> d1 &gt; d2 ? ans2 : ans1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Point[] bruteDivisor(Point[] set) &#123;</span><br><span class="line">    Point[] ret = <span class="keyword">new</span> Point[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">double</span> now = set[<span class="number">0</span>].distance(set[<span class="number">1</span>]), tmp;</span><br><span class="line">    ret[<span class="number">0</span>] = set[<span class="number">0</span>]; ret[<span class="number">1</span>] = set[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; set.length; ++ i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; set.length; ++ j) &#123;</span><br><span class="line">            tmp = set[i].distance(set[j]);</span><br><span class="line">            <span class="keyword">if</span> (tmp &lt; now) &#123;</span><br><span class="line">                now = tmp;</span><br><span class="line">                ret[<span class="number">0</span>] = set[i]; ret[<span class="number">1</span>] = set[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现的不够优雅…… 虽然说预排序确实减少了每次排序的一个 log n 的复杂度，但是每次分治都要复制数组还是不够优雅；若是像Java这种分配空间开销极大，并且面临不定时的垃圾回收的语言来说，想必常数是极大的吧。</p><h3 id="实验结果-1">实验结果</h3><h4 id="stressen-正确性验证">Stressen 正确性验证</h4><p>随机生成 8x8 矩阵，分别使用定义和Stressen方法计算矩阵乘法；将答案对比并输出结果到控制台，运行结果如下：</p><figure><img src="https://i.loli.net/2020/03/18/5skgeOImM3SDTW8.png" class="lazyload" data-srcset="https://i.loli.net/2020/03/18/5skgeOImM3SDTW8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="O_U_09LTHT43NVU9X~_RTYN.png" /><figcaption aria-hidden="true">O_U_09LTHT43NVU9X~_RTYN.png</figcaption></figure><p>可以证明实现是正确的。</p><h4 id="效率对比">效率对比</h4><p>随机生成矩阵，使用两种方法进行多次重复计算；每次改变方阵规模，并计时输出到控制台；运行结果如下：</p><figure><img src="https://i.loli.net/2020/03/18/OMUackXKsSAgjuJ.png" class="lazyload" data-srcset="https://i.loli.net/2020/03/18/OMUackXKsSAgjuJ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="_QIYW71_VE_UCW8ARS7YB7.png" /><figcaption aria-hidden="true">_QIYW71_VE_UCW8ARS7YB7.png</figcaption></figure><p>因为Stressen方法实现过程中有大量的矩阵新建/销毁的操作，反复的分配/释放内存，导致了常数大幅提高；在实验中的表现甚至不如一般的矩阵乘法。</p><h4 id="最小点对测试">最小点对测试</h4><p>进行随机测试，运行结果如下：</p><figure><img src="https://i.loli.net/2020/03/18/3eQlI2Z7RGHBTwO.png" class="lazyload" data-srcset="https://i.loli.net/2020/03/18/3eQlI2Z7RGHBTwO.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Z__FNF_F3O7I3_U__L5M_HW.png" /><figcaption aria-hidden="true">Z__FNF_F3O7I3_U__L5M_HW.png</figcaption></figure><p>关于自动测试程序的正确性，可以参照<a href="https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job?path=%2FDivide_Algorithm%2Fsrc%2Fcom%2Fshiroha%2Fcurriculum%2Falgorithm%2Fdivide%2FMain.java">源代码</a>中的<code>Main.main</code>方法的调用。下面的运行结果是输出暴力和分治求解结果的一些测试结果：</p><figure><img src="https://i.loli.net/2020/03/18/LDTXsGR5aPHMUlt.png" class="lazyload" data-srcset="https://i.loli.net/2020/03/18/LDTXsGR5aPHMUlt.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="_N8~YP_NTBALAW_1XR4207R.png" /><figcaption aria-hidden="true">_N8~YP_NTBALAW_1XR4207R.png</figcaption></figure><p>这些测试结果足以证明了算法实现的正确性。</p><h3 id="思考题-1">思考题</h3><h4 id="分治算法的步骤和正确性">分治算法的步骤和正确性</h4><p>分治算法包括三个基本步骤：</p><p><strong>Step1</strong>：Devide——将要解决的问题划分成若干规模较小的同类问题</p><p><strong>Step2</strong>：Conquer——当子问题划分得足够小时，用较简单的方法解决 (一般都是递归)</p><p><strong>Step3</strong>：Combine——将子问题的解逐层合并构成原问题的解</p><p>正确性可用数学归纳法证明。</p><h4 id="使用主方法分析-stressen-方法和点对分治">使用主方法分析 Stressen 方法和点对分治</h4><p>Strassen’s 矩阵乘法的递归式为 <span class="math inline">\(T(n) = 7T(\frac n 2) + Θ(n^2)\)</span>，可以由主定理的公式</p><figure><img src="https://i.loli.net/2020/05/05/8M1bsgjtaN7ywCn.png" class="lazyload" data-srcset="https://i.loli.net/2020/05/05/8M1bsgjtaN7ywCn.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="FN2D2S89GW3SGVR6L7_L_F.png" /><figcaption aria-hidden="true">FN2D2S89GW3SGVR6L7_L_F.png</figcaption></figure><p>得到：<span class="math inline">\(T(n) = n^{lg7}\)</span>。</p><h4 id="修改-stressen-方法增广使用范围">修改 Stressen 方法增广使用范围</h4><p>首先，先梳理一下 Stressen 方法要求方阵的规模是二次幂的原因： Stressen 方法将子矩阵的乘法变成了加法，而加法对于两个“加数”矩阵的规模要求十分严格——即满足相同规模；因此，为了保证每次分治二分的矩阵都可以进行矩阵加法，才要求矩阵的规模必须是2的幂。基于这一点，我们有两种思路：</p><ul><li>将矩阵补成二次幂形式： 因为矩阵乘法性质规定了，以补0的方式扩大现有方阵，乘法的结果依然不变；也就是说可以先将矩阵扩大到二次幂形式，相乘之后再取出特定部分的值还原矩阵即可。但是这样做将面临可能的很大的空间开销，并不是很好的方案。</li><li>规定一个小方阵规模： 小方阵直接使用定义求解；令这个最小规模为m，那么我们要求的方阵规模就从二次幂转化为了<span class="math inline">\(n*2^a\)</span>，其中 n &lt; m。这样扩充矩阵造成的空间浪费就得以控制，且较小范围内，由于常数原因并不会损失太多的性能。</li></ul><p>因为基本的思路都是扩充矩阵，还有一种可行的方案是：每次进行分治的时候检测方阵的规模，若方阵的规模为奇数且不为1时（或者大于最小方阵规模时）将它扩充为+1的偶数。这样下次再遇到扩充的数值就缩小了一半，也不会造成过多的空间浪费。</p><hr /><h2 id="实验三作业排程和最长共同子序列算法">实验三：作业排程和最长共同子序列算法</h2><p>实验要求如下：</p><blockquote>#####<center>实验三：作业排程和最长共同子序列算法</center><p><strong>一、实验目的</strong></p><p>理解动态规划算法设计思想，利用动态规划算法设计方法解决作业排程和最长共同子序列问题。</p><p><strong>二、实验条件</strong></p><p>计算机及程序语言开发平台（如 C、C++、Java、Matlab 等）。</p><p><strong>三、实验内容及要求</strong> - 描述并实现动态规划的作业排程算法，并显示下图的排程结果。 <img src="https://i.loli.net/2020/03/17/zBjG623wqDi7T9O.png" class="lazyload" data-srcset="https://i.loli.net/2020/03/17/zBjG623wqDi7T9O.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="0_LTF___QM@M3P~URBZ_X_T.png" /> - 描述并实现最长共同子序列动态规划 算 法 ， 并 显 示 S1 = ACCGGTCGAGATGCAG，S2 = GTCGTTCGGAATGCAT 的最长共同子序列。</p><p><strong>四、思考题</strong> - 动态规划算法范式是什么？ - 利用动态规划算法设计方法解决矩阵链相乘问题？</p></blockquote><h3 id="任务一作业排程问题">任务一：作业排程问题</h3><h4 id="问题简述-1">问题简述</h4><p>有一个车间，有n条生产线，每条生产线有m个工序组成。每个工序可以组装一个零件，且第i条生产线的第j个工序花费的时间是a(i,j)；如果在一条生产线上加工产品，则产品在不同的工序之间流转的消费是0；否则，如果要将在第i条生产线的第j个工序处理之后的产品移动到另一条生产线的第j+1个工序，则需要额外的成本t(i,j)；此外，对于每条生产线，将零件送上生产线需要e(i)，将产品撤下生产线需要x(i)。</p><p>装载一个产品恰好需要经历一整条生产线上的所有工序，请问如果要生产一个产品，所需要的最小花费是？</p><h4 id="问题分析-1">问题分析</h4><p>在每一个工序上花费的时间是恒定的。如果决定某工序在确定的生产线上生产，那么它的耗时仅取决于处理之前所有工序的最短时间。这说明了这个模型具有可转移性；并且这个模型具有无后效性：因为处理某工序之前，无论之前的工序在哪条生产线上完成都不会影响到该工序的处理。所以这是一个DP模型，可以使用DP解。</p><p>我们设<span class="math inline">\(dp_{i,j}\)</span>的含义是：产品到达第i条生产线上的第j个工序时，可能的最短耗时。那么根据上面的分析易得推导关系：</p><center><span class="math display">\[ dp_{i,j} = min\begin{cases} dp_{k,j-1}+a_{k,j-1} ,&amp; k = i \\dp_{k,j-1}+a_{k,j-1}+t_{k,j-1} ,&amp; k \neq i\end{cases} \]</span></center><p>上式中有$k $；特别地，在最后一道工序和第一道工序的时候，因为有上下费用，所以推导式略有不同：</p><center><span class="math display">\[ \begin{cases} dp_{i,1} = e_i \\ans = min(dp_{i,m}) ,&amp; i \in [1,n]\end{cases} \]</span></center><p>这样<code>ans</code>就是最小的时间费用了。如果要求出具体的转移方案也很简单：在转移的同时开一个数组记录转移的前缀。找到答案后再倒退回去就可以了。</p><h4 id="核心代码">核心代码</h4><p>下面的这些代码可以在<a href="https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job">文首仓库</a>的<code>DP_Algorithm\src\com\shiroha\curriculum\algorithm\dp</code>目录下找到。</p><p>不包含追踪，仅求出最少花费的版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(Problem p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> m = p.getLines(), n = p.getStations();</span><br><span class="line">    <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[m][n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = p.getEntry(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++ j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i) &#123;</span><br><span class="line">            dp[i][j] = dp[i][j-<span class="number">1</span>] + p.getTime(i,j-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++ k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k == i) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j], dp[k][j-<span class="number">1</span>] + p.getTransfer(k,j-<span class="number">1</span>) + p.getTime(k, j - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i) &#123;</span><br><span class="line">        dp[i][n] = dp[i][n-<span class="number">1</span>] + p.getExit(i) + p.getTime(i,n-<span class="number">1</span>);</span><br><span class="line">        ans = Math.min(ans, dp[i][n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包含回溯的版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String[] backtraceSolve(Problem p) &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> m = p.getLines(), n = p.getStations();</span><br><span class="line">    String[] ret = <span class="keyword">new</span> String[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> dp[][] = <span class="keyword">new</span> <span class="keyword">int</span>[m][n+<span class="number">1</span>], tmp, cur;</span><br><span class="line">    <span class="keyword">int</span> trace[][] = <span class="keyword">new</span> <span class="keyword">int</span>[m][n], f[] = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = p.getEntry(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++ j) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i) &#123;</span><br><span class="line">            dp[i][j] = dp[i][j-<span class="number">1</span>] + p.getTime(i,j-<span class="number">1</span>);</span><br><span class="line">            cur = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; ++ k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k == i) <span class="keyword">continue</span>;</span><br><span class="line">                tmp = dp[k][j-<span class="number">1</span>] + p.getTransfer(k,j-<span class="number">1</span>) + p.getTime(k, j - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (tmp &lt; dp[i][j]) &#123;</span><br><span class="line">                    dp[i][j] = tmp;</span><br><span class="line">                    cur = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            trace[i][j] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0x7fffffff</span>, pos = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i) &#123;</span><br><span class="line">        dp[i][n] = dp[i][n-<span class="number">1</span>] + p.getExit(i) + p.getTime(i,n-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (dp[i][n] &lt; ans) &#123;</span><br><span class="line">            ans = dp[i][n];</span><br><span class="line">            pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i) &#123;</span><br><span class="line">        f[i] = pos;</span><br><span class="line">        pos = trace[pos][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret[<span class="number">0</span>] = Integer.toString(ans);</span><br><span class="line">    ret[<span class="number">1</span>] = backtraceToString(f);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详情请参考<a href="https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job?path=%2FDP_Algorithm%2Fsrc%2Fcom%2Fshiroha%2Fcurriculum%2Falgorithm%2Fdp">全部源代码</a>。</p><h3 id="任务二lcs问题">任务二：LCS问题</h3><h4 id="问题简述-2">问题简述</h4><p>子序列的定义：对于由序列<span class="math inline">\(A_{1..n}\)</span>中的元素构成的子序列<span class="math inline">\(A_i..A_j\)</span>，若对于任意 i,j 都有 i &lt; j，那么该序列就是原序列的子序列。</p><p>现给定两个字符串，求出它们的最长子序列。</p><h4 id="问题分析-2">问题分析</h4><p>同样是简单的递推关系：若对于两个序列<span class="math inline">\(A\)</span>,<span class="math inline">\(B\)</span>：设序列<span class="math inline">\(A_i\)</span>的意义是从串A开始到第i个字符阶段的字符串，<span class="math inline">\(a_i\)</span>是A串位于第i位 的字符；那么，设<span class="math inline">\(dp_{i,j}\)</span>的含义是<span class="math inline">\(lcs(A_i,B_j)\)</span>，易得推导关系：</p><center><span class="math display">\[dp_{i,j} = \begin{cases} dp_{i-1,j-1}+1 ,&amp; a_i = b_j \\max(dp_{i-1,j},dp_{i,j-1}) ,&amp; a_i \neq b_j\end{cases} \]</span></center><p>同理，若要求出其中一种最长子序列，只需要记录前缀信息，求出答案后回溯即可。</p><h4 id="核心代码-1">核心代码</h4><p>无回溯版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">basicSolve</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l1 = s1.length(), l2 = s2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[l1+<span class="number">1</span>][l2+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    Arrays.fill(dp[<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l1; ++ i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; l2; ++ j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = Math.max(dp[i][j + <span class="number">1</span>], dp[i + <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[l1][l2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回溯版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">backtraceSolve</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l1 = s1.length(), l2 = s2.length();</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[l1+<span class="number">1</span>][l2+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">byte</span>[][] backtrace = <span class="keyword">new</span> <span class="keyword">byte</span>[l1+<span class="number">1</span>][l2+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    Arrays.fill(dp[<span class="number">0</span>],<span class="number">0</span>);</span><br><span class="line">    Arrays.fill(backtrace[<span class="number">0</span>], (<span class="keyword">byte</span>) -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l1; ++ i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        backtrace[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; l2; ++ j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i) == s2.charAt(j)) &#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j] + <span class="number">1</span>;</span><br><span class="line">                backtrace[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j + <span class="number">1</span>] &gt; dp[i + <span class="number">1</span>][j]) &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i][j + <span class="number">1</span>];</span><br><span class="line">                    backtrace[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>][j+<span class="number">1</span>] = dp[i + <span class="number">1</span>][j];</span><br><span class="line">                    backtrace[i+<span class="number">1</span>][j+<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtrace[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> x = l1, y = l2;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span> &amp;&amp; y != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (backtrace[x][y]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                --x; --y;</span><br><span class="line">                sb.append(s1.charAt(x));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: --x; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> -<span class="number">1</span>: --y; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StringBuffer(sb.toString()).reverse().toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详情请参考<a href="https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job?path=%2FDP_Algorithm%2Fsrc%2Fcom%2Fshiroha%2Fcurriculum%2Falgorithm%2Fdp">全部源代码</a>。</p><h3 id="实验结果-2">实验结果</h3><h4 id="任务一">任务一</h4><p>样例运行结果：</p><figure><img src="https://i.loli.net/2020/03/17/ORCSmQ1WA3DyUhV.png" class="lazyload" data-srcset="https://i.loli.net/2020/03/17/ORCSmQ1WA3DyUhV.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="0SWM5YS978YWB0I~GU7A_0.png" /><figcaption aria-hidden="true">0SWM5YS978YWB0I~GU7A_0.png</figcaption></figure><p>自行测试结果：</p><figure><img src="https://i.loli.net/2020/03/17/V6i9pDE5FlkZm3n.png" class="lazyload" data-srcset="https://i.loli.net/2020/03/17/V6i9pDE5FlkZm3n.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="5_L_YNZ_7W4POEXE0_M2UC.png" /><figcaption aria-hidden="true">5_L_YNZ_7W4POEXE0_M2UC.png</figcaption></figure><figure><img src="https://i.loli.net/2020/03/17/ClkVqPvmfW38XRG.png" class="lazyload" data-srcset="https://i.loli.net/2020/03/17/ClkVqPvmfW38XRG.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="_S5VX_Q6N84PZ4U8T8FVW.png" /><figcaption aria-hidden="true">_S5VX_Q6N84PZ4<sub>U8T8F</sub>VW.png</figcaption></figure><h4 id="任务二">任务二</h4><p>样例运行结果：</p><figure><img src="https://i.loli.net/2020/03/17/cOYLUEgToQCP75S.png" class="lazyload" data-srcset="https://i.loli.net/2020/03/17/cOYLUEgToQCP75S.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="VS_FN_VE~67Q_VJK9A2_FUG.png" /><figcaption aria-hidden="true">VS_FN_VE~67Q_VJK9A2_FUG.png</figcaption></figure><p>自行测试结果：</p><figure><img src="https://i.loli.net/2020/03/17/GTdyMzHt1cFnwUo.png" class="lazyload" data-srcset="https://i.loli.net/2020/03/17/GTdyMzHt1cFnwUo.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="~_E_M3G6GDXQ@WCVRTOPLDF.png" /><figcaption aria-hidden="true">~_E_M3G6GDXQ@WCVRTOPLDF.png</figcaption></figure><p>上述运行结果和预想结果一致，说明了算法实现的正确性。</p><h3 id="思考题-2">思考题</h3><h4 id="动态规划算法范式">动态规划算法范式</h4><p>动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中,可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。</p><p>其基本思想是将待求解问题分解成若干个子问题：先求解子问题，然后从这些子问题的解得到原问题的解。这一点和分治法类似。</p><p>适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。有些子问题会被重复计算了很多次，对于这部分子问题可以记忆化。</p><p>简单的说，适合使用动态规划求解的问题往往具有可转移性和无后效性两大特点。</p><h4 id="利用动态规划算法设计方法解决矩阵链相乘问题">利用动态规划算法设计方法解决矩阵链相乘问题</h4><p>不同矩阵相乘所需要的乘法次数是不同的。而当大量矩阵以链的形式相乘的时候，因为矩阵的乘法满足结合律，所以可通过适当选择乘法计算的优先级，可以找到某种计算顺序：它所需要进行的乘法计算次数是最少的。</p><p>首先：n*m的矩阵和m*k相乘所需要进行的乘法次数是nmk。设矩阵连乘的公式是<span class="math inline">\(A_iA_{i+1}..A_j,i \leq j\)</span>，简写为<span class="math inline">\(A[i:j]\)</span>。假设对于这个连乘的最优分割位置是k，那么就有<span class="math inline">\(A[i:j]=A[i:k]A[k+1:j]\)</span>。设<span class="math inline">\(A[i:j]\)</span>的计算量是<span class="math inline">\(p[i:j]\)</span>，那么显然：最优的<span class="math inline">\(p[i:j]\)</span>是最优的<span class="math inline">\(p[i:k]\)</span>和最优的<span class="math inline">\(p[k+1:j]\)</span>之和加上<span class="math inline">\(A[i:k]A[k+1:j]\)</span>的消耗。</p><p>这样就可以建立起状态转移方程了。记<span class="math inline">\(p[i:j]\)</span>为<span class="math inline">\(dp_{i,j}\)</span>，矩阵<span class="math inline">\(A_i\)</span>是<span class="math inline">\(a_i*b_i\)</span>矩阵；那么显然有：</p><center><span class="math display">\[dp_{i,j} = dp_{i,k}+dp_{k+1,j}+a_ib_kb_j\]</span></center><p>显然，当 i=j 的时候，<span class="math inline">\(dp_{i,j}\)</span>为0；在其他情况下，只需要遍历区间内的k，找到最小的dp进行转移就可以了。最后可以得到最少的乘法数；如果需要获得一种具体的方案，也可以通过回溯前缀的方法实现。</p><hr /><h3 id="参考资料">参考资料</h3><ul><li><a href="https://blog.csdn.net/alzzw/article/details/98100378" class="uri">https://blog.csdn.net/alzzw/article/details/98100378</a></li><li><a href="https://www.jianshu.com/p/b749a8afdfd2" class="uri">https://www.jianshu.com/p/b749a8afdfd2</a></li><li><a href="https://blog.csdn.net/sinat_35678407/article/details/82874216" class="uri">https://blog.csdn.net/sinat_35678407/article/details/82874216</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 课业 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课内作业 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 实验报告 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统原理：脚本程序编写实验报告</title>
      <link href="/2020/class-FoDOS-experiment-bat-programming/"/>
      <url>/2020/class-FoDOS-experiment-bat-programming/</url>
      
        <content type="html"><![CDATA[<p>开始之前先简单介绍一下这次的任务要求：</p><blockquote>#####<center>《操作系统原理》第一次上机实验</center><p><strong>一、实验目的</strong></p><ol type="1"><li>理解操作系统生成的概念和过程；</li><li>理解操作系统两类用户界面（操作界面，系统调用）概念；</li></ol><p><strong>二、实验内容</strong></p><ol type="1"><li>在 Ubuntu 或其他 Linux 平台环境下裁剪和编译 Linux 内核，并启用新的内核。</li><li>在 Ubuntu 或其他 Linux 平台为 Linux 内核增加 1-3 个新 的系统调用，并启用新的内核，编写一个应用程序测试新增加的系 统调用是否能正确工作。</li><li>在 Windows 环境下，编写一个批处理程序（算命大 师.bat），程序运行后，输入：出生年月日（例如 2000-07-31）。系 统输出相应的属相和星座，例如：你属兔， 狮子座。要求：输入进 行合法性检查，能循环接收用户的输入，直到输入 q 或 Q 就退出。</li></ol></blockquote><h2 id="front-matter">Front-matter</h2><p>由于增加系统调用的部分在<a href="https://shiraha.cn/2019/Linux-FoDOS-experiment-dian/">之前</a>已经做过了，而且一遍下来耗时很多…… 在家里一台电脑折腾的情况下挺浪费时间的就不做了。想要看上次怎么做的请去看<a href="https://shiraha.cn/2019/Linux-FoDOS-experiment-dian/">这里</a>。</p><p>因为Bat年久失修，微软官网上都找不到它的文档，于是考虑写一个Powershell脚本。况且新型Windows的<code>cmd</code>都是可以执行Powershell脚本的，就直接写了；然后因为我实在是不懂星座，当不了星座带师；干脆就把之前大一无聊写的简易野兽先辈论证器的逻辑搞过来整成了Powershell版本的野兽先辈论证器（</p><p>事实上后来也有补充一个Bat的简单的版本。算了这篇文章还是文风清新了一点，我重写一篇好了 == 新文章的地址是：</p><p>好的，接下来是实验报告正文：</p><h2 id="实验目的">实验目的</h2><ol type="1"><li>理解操作系统生成的概念和过程；</li><li>理解操作系统两类用户界面（操作界面，系统调用）概念；</li></ol><h2 id="实验内容">实验内容</h2><ol type="1"><li>在 Ubuntu 或其他 Linux 平台环境下裁剪和编译 Linux 内核，并启用新的内核。</li><li>在 Ubuntu 或其他 Linux 平台为 Linux 内核增加 1-3 个新 的系统调用，并启用新的内核，编写一个应用程序测试新增加的系 统调用是否能正确工作。</li><li>在 Windows 环境下，编写一个批处理程序（算命大 师.bat），程序运行后，输入：出生年月日（例如 2000-07-31）。系 统输出相应的属相和星座，例如：你属兔， 狮子座。要求：输入进 行合法性检查，能循环接收用户的输入，直到输入 q 或 Q 就退出。</li></ol><p>因为裁剪、增加系统调用和应用修改后的内核已经在上一次实验中做过了，这里仅简述实验过程和实验结果。</p><h2 id="实验过程">实验过程</h2><p>第一个实验包含了编辑内核，生成补丁已经应用内核三个步骤。这里将简要介绍。第二个实验仅包含编码和测试。</p><h3 id="编辑内核">编辑内核</h3><p>在下载的内核使用<code>menuconfig</code>打开图形化的内核裁剪页面，进行必要的调整之后保存为配置文件就可以了。</p><p>复制一份下载的纯净内核文件，修改其中的<code>include/uapi/asm-generic/unistd.h</code>和<code>include/linux/syscalls.h</code>两个头文件来增加系统调用的函数。</p><p>进入系统调用注册表的目录<code>arch/x86/entry/syscalls</code>，根据要安装的操作系统位数修改其下的<code>tbl</code>文件，注册增加的系统调用。特别注意不应该与已经存在的系统调用的编号冲突。</p><p>使用vim打开系统调用的实现的源文件<code>kernel/sys.c</code>来增加刚才增加的函数的实现。如果要增加的是在内核缓冲区打印消息这种最简单的系统调用，则它可以是下面这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">void</span> <span class="title">sys_shirohashow</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;Shiroha do your best!&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;\n@Edit by Shiroha on 2019-11-15.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就增加了一个系统调用函数<code>sys_shirohashow</code>的实现。完成之后还要在<code>include/uapi/asm-generic/unistd.h</code>增加宏。</p><h3 id="生成补丁并应用内核">生成补丁并应用内核</h3><p>将修改过的内核和纯净内核使用<code>diff -Naur</code>生成差异补丁，再使用<code>patch</code>命令应用到纯净内核上。使用<code>make -j6</code>进行多线程编译。</p><p>编译成功后执行安装，并将必要的文件复制到特定的地方之后更新grub的引导信息，就完成了内核的应用。</p><p>在运行新内核的操作系统上写C程序，调用增加的系统调用，就可以看到我们在内核中编写的程序可以成功运行了。</p><h3 id="编写powershell程序">编写Powershell程序</h3><p>简要分析实验要求，大概得出这个程序的工作流程：</p><!-- ![__X1~Y~L_LSV__`HP8___3O.png](https://i.loli.net/2020/03/16/pFu5hKJ7RobmX46.png) --><figure><img src="https://i.loli.net/2020/03/16/pFu5hKJ7RobmX46.png" class="lazyload" data-srcset="https://i.loli.net/2020/03/16/pFu5hKJ7RobmX46.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="流程图" /><figcaption aria-hidden="true">流程图</figcaption></figure><p>因为Powershell支持绝大多数的C语言特性，可以开强类型变量也可以构造函数，并且可以使用 .NET Framework 的一些东西，所以很轻松的就写出来了。</p><blockquote><h5 id="编码环境和工具">编码环境和工具：</h5><p><strong>文本编辑器</strong> ： Microsoft Visual Studio Code 1.44 <strong>操作系统版本</strong> ： Windows 10 Pro 1903 18362.720 <strong>Powershell版本</strong> ： Windows Powershell 5.1</p></blockquote><p>关于输入文字的方式，可以使用Powershell原生的<code>Read-Host</code>，也可以使用框架提供的GUI窗口；甚至还可以使用 Visual Basic 的窗口。这就看个人喜好了，下面的代码是使用了框架的窗口实现的生日数字论证器：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Add-Type</span> <span class="literal">-AssemblyName</span> System.Windows.Forms</span><br><span class="line"><span class="built_in">Add-Type</span> <span class="literal">-AssemblyName</span> System.Drawing</span><br><span class="line"></span><br><span class="line">[<span class="built_in">int</span>[]] <span class="variable">$days</span> = <span class="number">29</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span></span><br><span class="line"><span class="variable">$dayIsIllegal</span> = <span class="string">&quot;The days you input is illegal. try again&quot;</span></span><br><span class="line">[<span class="built_in">string</span>[]] <span class="variable">$months</span> = <span class="string">&#x27;Feb&#x27;</span>,<span class="string">&#x27;Jan&#x27;</span>,<span class="string">&#x27;Feb&#x27;</span>,<span class="string">&#x27;Mar&#x27;</span>,<span class="string">&#x27;Apr&#x27;</span>,<span class="string">&#x27;May&#x27;</span>,<span class="string">&#x27;Jun&#x27;</span>,<span class="string">&#x27;Jul&#x27;</span>,<span class="string">&#x27;Aug&#x27;</span>,<span class="string">&#x27;Sep&#x27;</span>,<span class="string">&#x27;Oct&#x27;</span>,<span class="string">&#x27;Nov&#x27;</span>,<span class="string">&#x27;Dec&#x27;</span></span><br><span class="line">[<span class="built_in">string</span>[]] <span class="variable">$iiyokoiyo</span> = <span class="selector-tag">@</span>(</span><br><span class="line">    <span class="string">&#x27;1+1+4-5-1^4=0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4-5*1^4=1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4-5+1^4=2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1-4+5*1^4=3&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4-5-1+4=4&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4-5+1*4=5&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4+5-1-4=6&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4+5-1*4=7&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4+5+1-4=8&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1*4+5-1^4=9&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4+5-1^4=10&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4+5*1^4=11&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4+5+1^4=12&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1*4+5-1+4=13&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4+5-1+4=14&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4+5+1*4=15&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4+5+1+4=16&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4*5-1-4=17&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4*5-1*4=18&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4*5+1-4=19&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1*4*5-1^4=20&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4*5-1^4=21&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4*5*1^4=22&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4*5+1^4=23&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1*4*5-1+4=24&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4*5-1+4=25&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4+5*1*4=26&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4*5+1+4=27&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;(1+1)*4+5*1*4=28&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;(1+1+4)*5-1^4=29&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;(1+1+4)*5*1^4=30&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;(1+1+4)*5+1^4=31&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isLunar</span> <span class="params">([int] <span class="variable">$y</span>)</span> </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$y</span> % <span class="number">4</span>) &#123;<span class="keyword">return</span> <span class="string">&#x27;False&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="keyword">if</span>(<span class="variable">$y</span> % <span class="number">400</span>) &#123;<span class="keyword">return</span> <span class="string">&#x27;True&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="keyword">if</span>(<span class="variable">$y</span> % <span class="number">100</span>) &#123;<span class="keyword">return</span> <span class="string">&#x27;False&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="keyword">return</span> <span class="string">&#x27;True&#x27;</span>&#125;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$form</span> = <span class="built_in">New-Object</span> System.Windows.Forms.Form</span><br><span class="line">    <span class="variable">$form</span>.Text = <span class="string">&#x27;Birthday input form&#x27;</span></span><br><span class="line">    <span class="variable">$form</span>.Size = <span class="built_in">New-Object</span> System.Drawing.Size(<span class="number">300</span>,<span class="number">200</span>)</span><br><span class="line">    <span class="variable">$form</span>.StartPosition = <span class="string">&#x27;CenterScreen&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$okButton</span> = <span class="built_in">New-Object</span> System.Windows.Forms.Button</span><br><span class="line">    <span class="variable">$okButton</span>.Location = <span class="built_in">New-Object</span> System.Drawing.Point(<span class="number">65</span>,<span class="number">120</span>)</span><br><span class="line">    <span class="variable">$okButton</span>.Size = <span class="built_in">New-Object</span> System.Drawing.Size(<span class="number">75</span>,<span class="number">23</span>)</span><br><span class="line">    <span class="variable">$okButton</span>.Text = <span class="string">&#x27;OK&#x27;</span></span><br><span class="line">    <span class="variable">$okButton</span>.DialogResult = [<span class="type">System.Windows.Forms.DialogResult</span>]::OK</span><br><span class="line">    <span class="variable">$form</span>.AcceptButton = <span class="variable">$okButton</span></span><br><span class="line">    <span class="variable">$form</span>.Controls.Add(<span class="variable">$okButton</span>)</span><br><span class="line"></span><br><span class="line">    <span class="variable">$cancelButton</span> = <span class="built_in">New-Object</span> System.Windows.Forms.Button</span><br><span class="line">    <span class="variable">$cancelButton</span>.Location = <span class="built_in">New-Object</span> System.Drawing.Point(<span class="number">160</span>,<span class="number">120</span>)</span><br><span class="line">    <span class="variable">$cancelButton</span>.Size = <span class="built_in">New-Object</span> System.Drawing.Size(<span class="number">75</span>,<span class="number">23</span>)</span><br><span class="line">    <span class="variable">$cancelButton</span>.Text = <span class="string">&#x27;Cancel&#x27;</span></span><br><span class="line">    <span class="variable">$cancelButton</span>.DialogResult = [<span class="type">System.Windows.Forms.DialogResult</span>]::Cancel</span><br><span class="line">    <span class="variable">$form</span>.CancelButton = <span class="variable">$cancelButton</span></span><br><span class="line">    <span class="variable">$form</span>.Controls.Add(<span class="variable">$cancelButton</span>)</span><br><span class="line"></span><br><span class="line">    <span class="variable">$label</span> = <span class="built_in">New-Object</span> System.Windows.Forms.Label</span><br><span class="line">    <span class="variable">$label</span>.Location = <span class="built_in">New-Object</span> System.Drawing.Point(<span class="number">10</span>,<span class="number">20</span>)</span><br><span class="line">    <span class="variable">$label</span>.Size = <span class="built_in">New-Object</span> System.Drawing.Size(<span class="number">280</span>,<span class="number">20</span>)</span><br><span class="line">    <span class="variable">$label</span>.Text = <span class="string">&#x27;Input your Birthday as YYYY-MM-DD&#x27;</span></span><br><span class="line">    <span class="variable">$form</span>.Controls.Add(<span class="variable">$label</span>)</span><br><span class="line"></span><br><span class="line">    <span class="variable">$textBox</span> = <span class="built_in">New-Object</span> System.Windows.Forms.TextBox</span><br><span class="line">    <span class="variable">$textBox</span>.Location = <span class="built_in">New-Object</span> System.Drawing.Point(<span class="number">10</span>,<span class="number">40</span>)</span><br><span class="line">    <span class="variable">$textBox</span>.Size = <span class="built_in">New-Object</span> System.Drawing.Size(<span class="number">260</span>,<span class="number">20</span>)</span><br><span class="line">    <span class="variable">$form</span>.Controls.Add(<span class="variable">$textBox</span>)</span><br><span class="line"></span><br><span class="line">    <span class="variable">$form</span>.Topmost = <span class="variable">$true</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$form</span>.Add_Shown(&#123;<span class="variable">$textBox</span>.Select()&#125;)</span><br><span class="line">    <span class="variable">$result</span> = <span class="variable">$form</span>.ShowDialog()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$result</span> <span class="operator">-eq</span> [<span class="type">System.Windows.Forms.DialogResult</span>]::OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$x</span> = <span class="variable">$textBox</span>.Text</span><br><span class="line">        <span class="string">&quot;Your input: &quot;</span>+<span class="variable">$x</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$x</span> <span class="operator">-eq</span> <span class="string">&#x27;q&#x27;</span> <span class="operator">-or</span> <span class="variable">$x</span> <span class="operator">-eq</span> <span class="string">&#x27;Q&#x27;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;Exting ...&quot;</span></span><br><span class="line">            <span class="keyword">exit</span></span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="built_in">int</span>[]] <span class="variable">$data</span> = <span class="variable">$x</span>.Split(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$data</span>.Count <span class="operator">-ne</span> <span class="number">3</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Write-Host</span> <span class="literal">-ForegroundColor</span> RED <span class="string">&quot;The String you input is not refer to a date.&quot;</span></span><br><span class="line">            <span class="keyword">continue</span> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$data</span>[<span class="number">0</span>] <span class="operator">-lt</span> <span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Write-Host</span> <span class="literal">-ForegroundColor</span> YELLOW <span class="string">&quot;You cannot born before AC. try again&quot;</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$data</span>[<span class="number">1</span>] <span class="operator">-lt</span> <span class="number">1</span> <span class="operator">-or</span> <span class="variable">$data</span>[<span class="number">1</span>] <span class="operator">-gt</span> <span class="number">12</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Write-Host</span> <span class="literal">-ForegroundColor</span> RED <span class="string">&quot;The month is illegal. try again&quot;</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$lunar</span> = isLunar <span class="variable">$data</span>[<span class="number">0</span>]</span><br><span class="line">        <span class="variable">$month</span> = <span class="variable">$data</span>[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$lunar</span> <span class="operator">-eq</span> <span class="string">&#x27;True&#x27;</span> <span class="operator">-and</span> <span class="variable">$data</span>[<span class="number">1</span>] <span class="operator">-eq</span> <span class="number">2</span>) &#123;<span class="variable">$month</span> = <span class="number">0</span>&#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$data</span>[<span class="number">2</span>] <span class="operator">-lt</span> <span class="number">1</span> <span class="operator">-or</span> <span class="variable">$data</span>[<span class="number">2</span>] <span class="operator">-gt</span> <span class="variable">$days</span>[<span class="variable">$month</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Write-Host</span> <span class="literal">-ForegroundColor</span> RED <span class="variable">$dayIsIllegal</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">Write-Host</span> <span class="literal">-ForegroundColor</span> YELLOW <span class="string">&quot;PROOVE STRAT:&quot;</span></span><br><span class="line">        <span class="string">&quot;You born in &quot;</span>+<span class="variable">$months</span>[<span class="variable">$data</span>[<span class="number">1</span>]]+<span class="string">&quot;, which means &quot;</span>+<span class="variable">$data</span>[<span class="number">1</span>]+<span class="string">&quot;, and there is &quot;</span>+<span class="variable">$iiyokoiyo</span>[<span class="variable">$data</span>[<span class="number">1</span>]]</span><br><span class="line">        <span class="string">&quot;You born at &quot;</span>+<span class="variable">$data</span>[<span class="number">2</span>]+<span class="string">&quot;, and there is &quot;</span>+<span class="variable">$iiyokoiyo</span>[<span class="variable">$data</span>[<span class="number">2</span>]]</span><br><span class="line">        <span class="built_in">Write-Host</span> <span class="literal">-ForegroundColor</span> GREEN <span class="string">&quot;Q.E.D. You are HonMono No Yaju Senpai ! &quot;</span></span><br><span class="line"></span><br><span class="line">        pause</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中的自定义函数isLunar完成对闰年的判断。通过返回字符串作为布尔值代表结果。每次循环都调用框架创建一个包含两个按钮和一个文本框的窗口，用来获得用户的输入。输入之后从文本框组件中获得输入的字符串进行后续处理。</p><p>这里使用了<code>Add-Type</code>引入了框架，使用<code>$</code>来定义变量和数组，使用<code>[]</code>来指定强类型限制。对于输入字符串不是<code>YYYY-MM-DD</code>格式的情况，我利用强类型转换的失败自动抛出异常，并继续到下一个循环。关于弹出GUI窗口的操作，具体请参照微软的<a href="https://docs.microsoft.com/zh-cn/powershell/">官方文档</a>。</p><p>显而易见地，也可以使用控制台直接输入文字而不是弹出一个GUI窗口来获取用户输入。这就需要使用到<code>Read-Host</code>。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">int</span>[]] <span class="variable">$days</span> = <span class="number">29</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span></span><br><span class="line"><span class="variable">$dayIsIllegal</span> = <span class="string">&quot;The days you input is illegal. try again&quot;</span></span><br><span class="line">[<span class="built_in">string</span>[]] <span class="variable">$months</span> = <span class="string">&#x27;Feb&#x27;</span>,<span class="string">&#x27;Jan&#x27;</span>,<span class="string">&#x27;Feb&#x27;</span>,<span class="string">&#x27;Mar&#x27;</span>,<span class="string">&#x27;Apr&#x27;</span>,<span class="string">&#x27;May&#x27;</span>,<span class="string">&#x27;Jun&#x27;</span>,<span class="string">&#x27;Jul&#x27;</span>,<span class="string">&#x27;Aug&#x27;</span>,<span class="string">&#x27;Sep&#x27;</span>,<span class="string">&#x27;Oct&#x27;</span>,<span class="string">&#x27;Nov&#x27;</span>,<span class="string">&#x27;Dec&#x27;</span></span><br><span class="line">[<span class="built_in">string</span>[]] <span class="variable">$iiyokoiyo</span> = <span class="selector-tag">@</span>(</span><br><span class="line">    <span class="string">&#x27;1+1+4-5-1^4=0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4-5*1^4=1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4-5+1^4=2&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1-4+5*1^4=3&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4-5-1+4=4&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4-5+1*4=5&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4+5-1-4=6&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4+5-1*4=7&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4+5+1-4=8&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1*4+5-1^4=9&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4+5-1^4=10&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4+5*1^4=11&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4+5+1^4=12&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1*4+5-1+4=13&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4+5-1+4=14&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4+5+1*4=15&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4+5+1+4=16&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4*5-1-4=17&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4*5-1*4=18&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4*5+1-4=19&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1*4*5-1^4=20&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4*5-1^4=21&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4*5*1^4=22&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4*5+1^4=23&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1*4*5-1+4=24&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4*5-1+4=25&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4+5*1*4=26&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1+1+4*5+1+4=27&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;(1+1)*4+5*1*4=28&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;(1+1+4)*5-1^4=29&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;(1+1+4)*5*1^4=30&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;(1+1+4)*5+1^4=31&#x27;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isLunar</span> <span class="params">([int] <span class="variable">$y</span>)</span> </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$y</span> % <span class="number">4</span>) &#123;<span class="keyword">return</span> <span class="string">&#x27;False&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="keyword">if</span>(<span class="variable">$y</span> % <span class="number">400</span>) &#123;<span class="keyword">return</span> <span class="string">&#x27;True&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="keyword">if</span>(<span class="variable">$y</span> % <span class="number">100</span>) &#123;<span class="keyword">return</span> <span class="string">&#x27;False&#x27;</span>&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="keyword">return</span> <span class="string">&#x27;True&#x27;</span>&#125;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$x</span> = <span class="built_in">Read-Host</span> <span class="string">&quot;Please input your birthday as YYYY-MM-DD &quot;</span></span><br><span class="line">    <span class="string">&quot;Your input: &quot;</span>+<span class="variable">$x</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$x</span> <span class="operator">-eq</span> <span class="string">&quot;&quot;</span>) &#123;<span class="string">&quot;You input nothing, try again.&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$x</span> <span class="operator">-eq</span> <span class="string">&#x27;q&#x27;</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;Exting because of &#x27;q&#x27;...&quot;</span></span><br><span class="line">        <span class="keyword">exit</span></span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="built_in">int</span>[]] <span class="variable">$data</span> = <span class="variable">$x</span>.Split(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$data</span>.Count <span class="operator">-ne</span> <span class="number">3</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Write-Host</span> <span class="literal">-ForegroundColor</span> RED <span class="string">&quot;The String you input is not refer to a date.&quot;</span></span><br><span class="line">        <span class="keyword">continue</span> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$data</span>[<span class="number">0</span>] <span class="operator">-lt</span> <span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Write-Host</span> <span class="literal">-ForegroundColor</span> YELLOW <span class="string">&quot;You cannot born before AC. try again&quot;</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$data</span>[<span class="number">1</span>] <span class="operator">-lt</span> <span class="number">1</span> <span class="operator">-or</span> <span class="variable">$data</span>[<span class="number">1</span>] <span class="operator">-gt</span> <span class="number">12</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Write-Host</span> <span class="literal">-ForegroundColor</span> RED <span class="string">&quot;The month is illegal. try again&quot;</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$lunar</span> = isLunar <span class="variable">$data</span>[<span class="number">0</span>]</span><br><span class="line">    <span class="variable">$month</span> = <span class="variable">$data</span>[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$lunar</span> <span class="operator">-eq</span> <span class="string">&#x27;True&#x27;</span> <span class="operator">-and</span> <span class="variable">$data</span>[<span class="number">1</span>] <span class="operator">-eq</span> <span class="number">2</span>) &#123;<span class="variable">$month</span> = <span class="number">0</span>&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$data</span>[<span class="number">2</span>] <span class="operator">-lt</span> <span class="number">1</span> <span class="operator">-or</span> <span class="variable">$data</span>[<span class="number">2</span>] <span class="operator">-gt</span> <span class="variable">$days</span>[<span class="variable">$month</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Write-Host</span> <span class="literal">-ForegroundColor</span> RED <span class="variable">$dayIsIllegal</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="literal">-ForegroundColor</span> YELLOW <span class="string">&quot;PROOVE STRAT:&quot;</span></span><br><span class="line">    <span class="string">&quot;You born in &quot;</span>+<span class="variable">$months</span>[<span class="variable">$data</span>[<span class="number">1</span>]]+<span class="string">&quot;, which means &quot;</span>+<span class="variable">$data</span>[<span class="number">1</span>]+<span class="string">&quot;, and there is &quot;</span>+<span class="variable">$iiyokoiyo</span>[<span class="variable">$data</span>[<span class="number">1</span>]]</span><br><span class="line">    <span class="string">&quot;You born at &quot;</span>+<span class="variable">$data</span>[<span class="number">2</span>]+<span class="string">&quot;, and there is &quot;</span>+<span class="variable">$iiyokoiyo</span>[<span class="variable">$data</span>[<span class="number">2</span>]]</span><br><span class="line">    <span class="built_in">Write-Host</span> <span class="literal">-ForegroundColor</span> GREEN <span class="string">&quot;Q.E.D. You are HonMono No Yaju Senpai ! &quot;</span></span><br><span class="line"></span><br><span class="line">    pause</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和上一个代码不同，因为没有引入框架创建GUI窗口，这个脚本的代码就显的短得多。理论上还可以使用<code>[Microsoft.VisualBasic.interaction].Inputbox(string,string,string)</code>来构建输入的GUI窗口，这里就不尝试了。</p><p>当然，文首提到的仓库中也包含了功能并不复杂的简单的 bat 脚本版本。如果你想看那些内容，可以前往这篇文章的重制版的地址：<a href="https://shiraha.cn/2020/class-FoDOS-experiment-1/" class="uri">https://shiraha.cn/2020/class-FoDOS-experiment-1/</a></p><h2 id="实验结果">实验结果</h2><h3 id="应用新内核">应用新内核</h3><p>详情请看<a href="https://shiraha.cn/2019/Linux-FoDOS-experiment-dian/">上一次的实验报告</a>。</p><h3 id="编写脚本程序">编写脚本程序</h3><p>特别要注意的地方是，因为安全原因的考虑，Windows 10 系统自带的Powershell因为安全考虑，默认是禁止通过控制台加载ps1脚本文件的。我们需要进行检查：</p><p>使用以下命令检查当前的执行策略；如果值为<code>Restricted</code>，将不允许任何的脚本加载运行。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">get-executionpolicy</span></span><br></pre></td></tr></table></figure><p>如果是<code>Restricted</code>，我们需要将它变更为<code>RemoteSigned</code>，通过执行以下命令来实现。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> <span class="literal">-Scope</span> CurrentUser RemoteSigned</span><br></pre></td></tr></table></figure><p>这样，我们就可以通过ps1脚本的相对路径/绝对路径来运行任何的ps1脚本了。以下默认你已经保证你的Powershell允许直接加载脚本。</p><p>在某个目录新建一个文件，后缀名叫做<code>ps1</code>；比如我的叫<code>YJSNPI.ps1</code>。将实验过程中的两端代码中的任何一段复制到其中保存；随后右键开始菜单，打开Windows Powershell，使用<code>cd</code>命令到达你现在的目录（或者在Explorer的“文件”选项卡中，在当前的目录下启动Windows Powershell）；使用命令<code>.\YJSNPI.ps1</code>执行刚才我们创建的脚本。</p><p>如果上述步骤不出现问题，预计就会看到下面的画面：</p><p>有窗口版本弹出的GUI输入框：</p><figure><img src="https://i.loli.net/2020/03/16/labfRg4PtxCjFGo.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/03/16/labfRg4PtxCjFGo.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="LMD_7SEUR7_E9V_6_4WF~YB.jpg" /><figcaption aria-hidden="true">LMD_7SEUR7_E9V_6_4WF~YB.jpg</figcaption></figure><p>输入不合法判定：</p><figure><img src="https://i.loli.net/2020/03/16/PyFmcsKBfN4hQaw.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/03/16/PyFmcsKBfN4hQaw.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="PZ__B794716QTC_4_7P_ZTF.jpg" /><figcaption aria-hidden="true">PZ__B794716QTC_4_7P_ZTF.jpg</figcaption></figure><p>输入正确之后进行后处理输出字符串：</p><figure><img src="https://i.loli.net/2020/03/16/EbWyPspCu9H1ZlB.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/03/16/EbWyPspCu9H1ZlB.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="J~__XMFPF__AP19MFI_QD6D.jpg" /><figcaption aria-hidden="true">J~__XMFPF__AP19MFI_QD6D.jpg</figcaption></figure><p>输入Q之后退出脚本：</p><figure><img src="https://i.loli.net/2020/03/16/qgTLM4COEdDFoSU.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/03/16/qgTLM4COEdDFoSU.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="~WL_PYFOW4DLB@_LY3H__YC.jpg" /><figcaption aria-hidden="true">~WL_PYFOW4DLB@_LY3H__YC.jpg</figcaption></figure><p>无弹出窗口的输入版本的基本操作：</p><figure><img src="https://i.loli.net/2020/03/16/hIzPvTaZx9YSLuA.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/03/16/hIzPvTaZx9YSLuA.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="__OWFP_BLXG_A2FQFD_I3ZE.jpg" /><figcaption aria-hidden="true">__OWFP_BLXG_A2FQFD_I3ZE.jpg</figcaption></figure><p>上述截图足以证明这些操作已经正确的实现。</p><h2 id="体会">体会</h2><p>通过这次实验，我：</p><ul><li>熟悉了Linux内核的应用过程，对Linux命令的理解更进一步；</li><li>更加生动的理解了系统调用的概念以及Linux操作系统从POST开始之后的启动过程；</li><li>熟悉了Powershell简单开发和部分.NET API的使用；</li></ul><p>特别的，一般的家用Windows 10的Powershell是不允许直接加载<code>ps1</code>脚本的，需要先行修改运行策略。</p><h2 id="后记">后记</h2><p>编程开始之前查查官方文档基本就差不多了。需要了解的只有运算，输入输出就可以了。因为有了这些东西，无论什么程序都可以写出来——因为它已经“图灵完备”了。如果提供了更多的支持（比如框架），只会降低我们开发的难度。</p><p><del>其实所有的整数都可以被用某些方式计算得到114514</del></p><h3 id="参考资料">参考资料</h3><ul><li><a href="https://docs.microsoft.com/zh-cn/powershell/scripting/samples/creating-a-custom-input-box?view=powershell-7" class="uri">https://docs.microsoft.com/zh-cn/powershell/scripting/samples/creating-a-custom-input-box?view=powershell-7</a></li><li><a href="https://www.cnblogs.com/zhaozhan/archive/2012/06/01/2529384.html" class="uri">https://www.cnblogs.com/zhaozhan/archive/2012/06/01/2529384.html</a></li><li><a href="https://blog.csdn.net/qishine/article/details/98216418" class="uri">https://blog.csdn.net/qishine/article/details/98216418</a></li><li><a href="https://www.pstips.net/pass-boolean-to-script.html" class="uri">https://www.pstips.net/pass-boolean-to-script.html</a></li><li><a href="https://blog.csdn.net/weixin_33785972/article/details/91540883" class="uri">https://blog.csdn.net/weixin_33785972/article/details/91540883</a></li><li><a href="https://www.pstips.net/powershell-specify-return-value-from-function.html" class="uri">https://www.pstips.net/powershell-specify-return-value-from-function.html</a></li><li><a href="https://www.pstips.net/powershell-create-new-function.html" class="uri">https://www.pstips.net/powershell-create-new-function.html</a></li><li><a href="https://www.pstips.net/continue-and-labels.html" class="uri">https://www.pstips.net/continue-and-labels.html</a></li><li><a href="https://www.pstips.net/powershell-creating-new-arrays.html" class="uri">https://www.pstips.net/powershell-creating-new-arrays.html</a></li><li><a href="https://www.cnblogs.com/victor963/p/12010909.html" class="uri">https://www.cnblogs.com/victor963/p/12010909.html</a></li><li><a href="https://www.zhihu.com/question/264059954?sort=created" class="uri">https://www.zhihu.com/question/264059954?sort=created</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 课业 </category>
          
          <category> 操作系统 </category>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> 课内作业 </tag>
            
            <tag> 实验报告 </tag>
            
            <tag> Powershell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nowcoder 练习赛59</title>
      <link href="/2020/nowcoder-practice-contest-59/"/>
      <url>/2020/nowcoder-practice-contest-59/</url>
      
        <content type="html"><![CDATA[<p>按照惯例，开始之前先码一下比赛的一些相关链接：</p><p>比赛地址： <a href="https://ac.nowcoder.com/acm/contest/4743" class="uri">https://ac.nowcoder.com/acm/contest/4743</a> 官方题解： <a href="https://ac.nowcoder.com/discuss/381692?type=101&amp;order=0&amp;pos=1&amp;page=1" class="uri">https://ac.nowcoder.com/discuss/381692?type=101&amp;order=0&amp;pos=1&amp;page=1</a></p><p>这次题目可以说是优化DP/树形数据结构专场？六个题目很大一部分都可以使用优化DP的方法来解决。但是总体感觉还是题目没有出好，很多的题目只要你思维敏捷也能方便的使用其他的方法解决。</p><p>嘛……毕竟是马后炮，怎么说都是可以的（不过有一说一，从七点发呆到九点错过比赛时间，比赛结束之后立马补题倒也是有点真实==</p><figure><img src="https://i.loli.net/2020/03/16/nRUg3maHvrLweqT.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/03/16/nRUg3maHvrLweqT.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="YS@39GS0XAKAL@L_CIKUTXN.jpg" /><figcaption aria-hidden="true">YS@39GS0XAKAL<span class="citation" data-cites="L_CIKUTXN.jpg">@L_CIKUTXN.jpg</span></figcaption></figure><p>不过比起打休闲，还是打天梯技术进步的更快，所以还是多打比赛，少自己补题休闲的好；虽然就算是事后自己做，结果好像也没做出来几个题目就是了==</p><h2 id="a---字符串">A - 字符串</h2><p>签到题，直接找就行。</p><h3 id="我的代码">我的代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">char</span> xq[] = <span class="string">&quot;XiaoQiao&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> xhh[] = <span class="string">&quot;XiaoHuiHui&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;s;</span><br><span class="line">    <span class="keyword">auto</span> x = s.<span class="built_in">find</span>(<span class="string">&#x27;X&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="built_in">string</span>::npos) <span class="comment">// 必须的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;emm&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ca = <span class="number">1</span>, cb = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> lim = s.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; lim; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==xq[ca]) <span class="keyword">if</span>(xq[ca]) ++ca;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==xhh[cb]) <span class="keyword">if</span>(xhh[cb]) ++cb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(xq[ca] || xhh[cb]) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;emm&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Happy&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一的笔记就是<code>string::npos</code>不能忽视，还是要进行特判的。</p><h2 id="b---修路">B - 修路</h2><p>签到题，排个序然后累加得到的就是最小生成树。</p><p>题目中的那个费用整理一下合并就可以得到费用至于每个小镇相关，而和哪两个小镇无关。</p><h3 id="我的代码-1">我的代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fee(a,b) (abs(f[a]-f[b]))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">longs f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    longs x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        f[i] = y*(x-y)*(x-y);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(f+<span class="number">1</span>,f+<span class="number">1</span>+n);</span><br><span class="line">    longs ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">        ans += f[i+<span class="number">1</span>]-f[i];</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="c---买装备">C - 买装备</h2><p>首先两种装备的消耗是给死了的。所以可以列方程，这恰好是二元一次不等式，可以线性规划。但是线性规划因为是一个浮点数，所以可能存在误差，需要对规划结果周围的数字进行一下判定，同时也需要特判解出负数的情况；</p><p>当然，因为题目写死了数据的原因，易得这个问题的单调极值性，那就可以三分来做了；同样是为了保险起见，区间缩小到一定范围就遍历求解比较就行。</p><p>如果不给死的话就是一个典型DP，但是这题目既然写死了还多组数据，显然就不是DP了。</p><h3 id="我的代码-2">我的代码</h3><p>线性规划法：单次询问 O(1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getN(m) min(y-3*(m),(x-2*(m))&gt;&gt;2)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"></span><br><span class="line"><span class="function">longs <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    longs m = (<span class="number">4l</span>l*y-x)/<span class="number">10l</span>l;</span><br><span class="line">    longs n = getN(m);</span><br><span class="line">    <span class="keyword">if</span>(m &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">min</span>(x&gt;&gt;<span class="number">1</span>,y/<span class="number">3</span>),<span class="built_in">min</span>(x&gt;&gt;<span class="number">2</span>,y));</span><br><span class="line">    longs ans = <span class="built_in">max</span>(m+n,m+<span class="number">1</span>+getN(m+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(ans,m<span class="number">-1</span>+getN(m<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    longs t,x,y;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;solve(x,y)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三分答案法：单次复杂度 O(log n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line"></span><br><span class="line"><span class="function">longs <span class="title">check</span><span class="params">(longs m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    longs n = <span class="built_in">min</span>((x-(m&lt;&lt;<span class="number">1</span>))&gt;&gt;<span class="number">2</span>, y<span class="number">-3</span>*m);</span><br><span class="line">    <span class="keyword">return</span> m+n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="built_in">max</span>(<span class="built_in">min</span>(x/<span class="number">2</span>,y/<span class="number">3</span>),<span class="built_in">min</span>(x/<span class="number">4</span>,y));</span><br><span class="line">        <span class="keyword">while</span>(r-l&gt;<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = (r-l)/<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">int</span> m1 = l+t, m2 = r-t;</span><br><span class="line">            <span class="keyword">if</span>(check(m1) &gt; check(m2)) r = m2;</span><br><span class="line">            <span class="keyword">else</span> l = m1;</span><br><span class="line">        &#125;</span><br><span class="line">        longs ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=l;i&lt;=r;++i)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,check(i));</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理论上是一个DP，但是这个DP你就挂了==</p><h2 id="d---石头游戏">D - 石头游戏</h2><p><em>异想天开的找规律，你不死谁死呢（叹气</em></p><p>玩家先手，如果是1，根据游戏定义那必败；那么因为大家都会采用最优战略，所以只要能转移到1的状态的状态就是必胜态；相反的，如果一个状态是必败态，那么它能转移到的状态一定都是必胜态；</p><p>所以，设每一个状态有效区间是[s,e]，从必败转移到必胜的区间就是[e+1,2e+1]（或者[2s,2e+1]），从必胜转移到必败就是[e+1,2e]。显然，必胜-必败区间是相互交错的。</p><p>得到了推导式，就可以算出包含输入的上限1e18的所有区间的状态。输入之后查询属于的区间后输出结果就可以。因为区间是翻倍的所以会指数级别增长，推导大约只需要进行64轮就可以完成所需要的预处理。</p><h3 id="我的代码-3">我的代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">longs st[N], ed[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    st[<span class="number">0</span>] = ed[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        st[i] = ed[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        ed[i] = (ed[i<span class="number">-1</span>]&lt;&lt;<span class="number">1</span>) + (i&amp;<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    preProcess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    longs n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        <span class="keyword">int</span> s = upper_bound(st,st+M,n) - st;</span><br><span class="line">        <span class="keyword">if</span>(s&amp;<span class="number">1</span>) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;XiaoQiao&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;XiaoHuiHui&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="e---搬石头">E - 搬石头</h2><p><em>看起来贼像一个贪心，甚至还能装模做样大胆地猜出几个结论：贪，你接着贪——贪完你就去世了==</em></p><p>首先对于一堆确定数量的石头，分成x次搬运成本最低的方法显然是平均分配。但是要注意如果分配出0的话就没有意义了。</p><p>然后就是贪心的不正确性：大堆的石头分成多份可能比好几堆小的分成两份带来的收益大。所以这需要DP：将两堆石头分成m份带来的最优解是可以由两堆石头不同的分割方案递推而来的；这个时候还需要引入虚堆标记，有些麻烦。</p><p>计算单堆石头的所有分割方案的成本是O(n)，再加上虚堆求出整个石头堆的最佳方案的成本就是O(n³)。嗯其实还可以接受，如果数据量不是特别大的话；</p><p>但是这个题目不仅要分配方案，这堆石头还在不停的变化；每次变化都是要重新DP才能得到最优解的，这样整体的复杂度就变成了O(n⁴)了，这可不就凉凉==</p><p>刚才提到了DP是需要虚点的，所以可以利用线段树的思想，维护一个区间；每一次的石头堆的变化相当于单点修改；这样的话可以节约相当一部分的资源，每一次单点修改就是使用O(n)重新计算一堆石头的所有分割方案，然后更新相关联的区块的DP。线段树的单点修改的复杂度是O(nlog n)，加上这次的修改复杂度就是O(n²log n)，再算上修改次数就是O(n³log n)，差不多可以接受了。</p><p>虽然线段树的常数大的离谱，但是因为跑不满等诸多原因，这个题目还是可以勉勉强强的卡过去的。</p><h3 id="社区讨论">社区讨论</h3><p>这道题由很多大佬认为线段树过于愚蠢，可以使用其他优秀的办法来解决；可是又语焉不详，叫人听的半懂不懂的。因为我不是大佬，所以我只能<del>爬</del>简单的做一些大佬语录。如果之后了解了这些做法<del>还记得这里的话</del>就再更新了。</p><blockquote><p><strong>查.无.此.人.</strong> <em>4#</em> ： E题怎么做都比题解优吧 闵可夫斯基和n^3 贪心每次取变化量最小的n^2log😑</p><p><strong>boxxxx</strong> <em>15#</em> ： E题裸dp每次是n<sup>3,但是可以3分优化成n</sup>2logn ……</p></blockquote><p>三分我或多或少能理解…… 但是三分优化的DP是什么操作我就不得而知了（</p><h3 id="我的代码-4">我的代码</h3><p>这就是题解的线段树代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cline(x) memset(x,0x3f,sizeof(longs)*(m1))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">405</span>;</span><br><span class="line"><span class="keyword">const</span> longs INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">longs f[N&lt;&lt;<span class="number">2</span>][N];</span><br><span class="line"><span class="keyword">int</span> wide[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,li,m1;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> <span class="built_in">line</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cline(f[<span class="built_in">line</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> l = <span class="built_in">line</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> r = l^<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = wide[l]; i &lt;= m; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = wide[r]; (p = i+j) &lt;= m; ++ j)</span><br><span class="line">            f[<span class="built_in">line</span>][p] = <span class="built_in">min</span>(f[<span class="built_in">line</span>][p], f[l][i]+f[r][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cline(f[index]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> lim = <span class="built_in">min</span>(li,a[num]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lim; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> longs val = a[num] / i;</span><br><span class="line">        <span class="keyword">const</span> longs mod = a[num] % i;</span><br><span class="line">        f[index][i] = mod*(val+<span class="number">1</span>)*(val+<span class="number">1</span>) + (i-mod)*val*val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    wide[index] = r - l + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        calculate(l,index);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(l, m, index &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    build(m+<span class="number">1</span>, r, index &lt;&lt; <span class="number">1</span> ^ <span class="number">1</span>);</span><br><span class="line">    update(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> index, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        calculate(l,index);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= m) modify(l, m, index &lt;&lt; <span class="number">1</span>, x);</span><br><span class="line">    <span class="keyword">else</span> modify(m+<span class="number">1</span>, r, index &lt;&lt; <span class="number">1</span> ^ <span class="number">1</span>, x);</span><br><span class="line">    update(index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    li = m-n+<span class="number">1</span>;</span><br><span class="line">    m1 = m+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">        f[i][<span class="number">1</span>] = a[i]*a[i];</span><br><span class="line">        sum += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    build(<span class="number">1</span>,n,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> q,x,v;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;q;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;v;</span><br><span class="line">        sum += v-a[x];</span><br><span class="line">        a[x] = v;</span><br><span class="line">        modify(<span class="number">1</span>,n,<span class="number">1</span>,x);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;f[<span class="number">1</span>][<span class="built_in">min</span>(m,sum)]&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">// 总数不超过x的石头不会被分为超过x堆</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个特别的小细节就是要注意到分割成0是无意义的，因此需要一直统计sum</p><h2 id="f---吃果果">F - 吃果果</h2><p>相当于说，告诉你所有的果子落地的时间和位置，当然还有营养；问你应该怎么吃才能获得最大的营养。</p><p>显然题目开始之前，先根据时间排序。对于 j &gt; i，如果吃到了第i个果果还能吃到第j个，那么两者的时间差一定大于距离；但是因为果果有不同的营养价值，所以还是不能贪，需要DP（话说就算全是1，似乎还是要DP……）。i和j都是n的复杂度，O(n²)对于本题1e5的数据会自动暴毙==</p><p>然后接下来的部分就是题解的申必优化：</p><p>对于位置 pi ≥ pj： 能吃到的条件就可以化为 ti - pi ≥ tj - pj<br />对于位置 pi ≤ pj： 能吃到的条件就可以化为 ti + pi ≥ tj + pj</p><p>记 Xi = ti - pi，Yi = ti + pi；再利用树套树来优化DP的转移过程，就可以把时间复杂度降低到 O(nlog²n)，就可以卡过这个题目了=</p><p>说实话我还没学树套树，不是很能理解这种做法；那就学完了在更新好了（</p><h3 id="事后分析">事后分析</h3><p>这其实是一个二位偏序的问题。题解使用的算法是一种叫做树套树的在线算法：但是常数大的离谱，模板也很长。如果出错的话后果不堪设想== 但是也是可以做的。可是题目并不是要求强制在线，所以可以使用一些高效率的离线算法来解决。不仅写代码更好写，也不容易出错，时间复杂度还更低。</p><p>这个题目的离线算法Tag： CDQ分治， 带权LIS</p><h3 id="我的代码-5">我的代码</h3><p>还没写呢（</p><p>总的来说这次的题目主要还是用来优化写代码的熟练度，以及各种树形数据结构的使用== 当然也见识到了各种DP的常见优化。在这个的指引下，又可以学习一些新的知识了。不也挺好吗（ 所以说不仅要补题，还要补的是基本功和知识储备啊==</p><figure><img src="https://i.loli.net/2020/03/16/RrZ2NpSuWsaQ48X.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/03/16/RrZ2NpSuWsaQ48X.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2D~HSI7CWL46_WU__M~A590.jpg" /><figcaption aria-hidden="true">2D~HSI7CWL46_WU__M~A590.jpg</figcaption></figure><p>谁叫咱现在的知识储备还处于精卫填海，女娲补天的水平呢== 人要有自知之明，不会的东西就得赶快去补（</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Nowcoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2016 NWERC 回顾</title>
      <link href="/2020/2016-nwerc/"/>
      <url>/2020/2016-nwerc/</url>
      
        <content type="html"><![CDATA[<p>欢乐赛2，既然表现不佳那自然是要认真的补题的。按照惯例，在开始之前首先先码一下官方的题解：</p><p>官方网址： <a href="https://people.bath.ac.uk/masjhd/2016.NWERC/" class="uri">https://people.bath.ac.uk/masjhd/2016.NWERC/</a></p><p>在这里你可以下载到题目、官方题解、判题官写的标程以及测试数据。</p><p>由于本人实力原因以及<del>各种其他原因</del>，补题仍然有很多不全面的地方，只好先暂时搁置了……（希望Utaha学长教我）目前这个题解仍然存在这些问题：</p><blockquote><ul><li>D、G两题我是真的不会写……</li><li>J题网络流做法还没有写</li><li>I题的Steiner Tree也没有深入的讨论，直接搬的赛场上的代码</li><li>其他我还没能确定的一些小问题</li></ul></blockquote><p>希望看官可以理解。若是我做出来了那些题目，一定会及时更新在这里的.</p><h2 id="e-exam-redistribution">E – Exam Redistribution</h2><p>本次签到题，是个人都做出来了。</p><h3 id="题目大意">题目大意</h3><p>n个房间包含不同数量的学生，收卷子然后发卷子交换批改；先收的卷子先发，求一个安全的顺序，让所有学生都不能改到本房间的试卷。</p><p>也就是说给一个序列，求一个满足题目要求的顺序；</p><h3 id="分析">分析</h3><p>暴死的情况有两种：<br />1. 要不就是改自己的卷子——一个房间的大小超过了所有其他房间大小的和，那么本身就是不可能的；<br />2. 要不就是进房间的时候卷子不够用了，那只能改自己的卷子了；所以要先大房间再小房间；</p><p>只要没有出现那种极端大的房间，那就先整大房子再整小房子就好了，上面两种情况必不会出现。写代码注意点就行了。</p><p>其实看这个白给的数据规模直接暴力模拟都成……</p><h3 id="我的代码">我的代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; s[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">30</span>;++i)</span><br><span class="line">        s[i].second = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n,sum = <span class="number">0</span>;</span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s[i].first,sum+=s[i].first;</span><br><span class="line">    sort(s+<span class="number">1</span>,s+<span class="number">1</span>+n);</span><br><span class="line">    <span class="keyword">if</span>(s[n].first &gt; sum&gt;&gt;<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;<span class="number">0</span>;--i)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;s[i].second&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为忘记初始化和大于等于忘记<code>=</code>而吃了一发WA也是没谁了……</p><h2 id="h-hamiltonian-hypercube">H – Hamiltonian Hypercube</h2><p>另一个签到题，是个人都做出来了。</p><h3 id="题目大意-1">题目大意</h3><p>n位Gray码可以通过某种申必的方法映射到那个申必n维立方体上，并且还能形成哈密顿路（环）；但是这不重要——只是方便大家理解Gry码的。题目会输入两个Gray码，然后你要输出在这个申必立方体上两个码映射的节点在这个哈密顿路上的区间内包含的节点数。</p><p>也就是说求两个Gray码代表的数字的差的绝对值-1.</p><h3 id="分析-1">分析</h3><p>妹啥好分析的，你会Gray码直接写个转换函数就成；不会的多读几遍题目也该会了。转化方式有好多种，我用的也是最常用的定义法——递归：</p><center><span class="math display">\[ ind(x_n) = \begin{cases} ind(x_{n-1}), &amp; x = 0\ x_{n-1} \\2^{n} - ind(x_{n-1}) - 1, &amp; x = 1\ x_{n-1} \\\end{cases} \]</span></center><p>只要注意点别手贱，写出了转换函数之后求差的绝对值-1输出就可以了。和n是没什么关系的，n只是方便了读入以及告诉你转换结果开<code>long long</code>是能存的下而已。</p><h3 id="我的代码-1">我的代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">100</span>],s2[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">longs <span class="title">gray</span><span class="params">(<span class="keyword">char</span>* s, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> s[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> gray(s+<span class="number">1</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        longs ret = <span class="number">1l</span>l&lt;&lt;n;</span><br><span class="line">        <span class="keyword">return</span> ret<span class="number">-1</span>-gray(s+<span class="number">1</span>,n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s1[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s2[i];</span><br><span class="line">    longs v1 = gray(s1,n);</span><br><span class="line">    longs v2 = gray(s2,n);</span><br><span class="line">    <span class="keyword">if</span>(v1&gt;v2) swap(v1,v2);</span><br><span class="line">    longs ans = v2-v1<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考试的时候不知道为什么没有写对，但是事后一遍过，就非常的离谱。我寻思该注意的应该都注意到了啊。</p><h2 id="c-careful-ascent">C – Careful Ascent</h2><p>又一个签到题，是个人都做出来了。</p><h3 id="题目大意-2">题目大意</h3><p>垂直速度恒定，水平速度理论上恒定：但是会受到不同高度区间的水平风的影响，导致最后实际的速度并不是恒定的。现在在高远的前方有一个目标，你的飞行器要从原点开始升起，要求恰好可以到达这个目标点应该控制的水平速度。</p><p>也就是说告诉你目标点的坐标以及不同高度的水平风信息，问你怎么控制水平速度。</p><h3 id="分析-2">分析</h3><p>初中物理学过吧？那列个方程拿电脑解出来就行。</p><p>然后那答案还给了一种比较通用的方法，用于情况稍微复杂一点的状况（<del>但是这个题目一点也不复杂</del>）：二分法，然后模拟验证答案的正确性——偏离目标点左侧就加速，否则减速；直到和目标点的距离差距在eps之内。说不定只要能模拟判断可行性的答案都可以二分的去找。</p><h3 id="我的代码-2">我的代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> longd;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ulong;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    longs x,y;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    longd sum = <span class="number">0</span>, k;</span><br><span class="line">    longs u,l, d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;u&gt;&gt;k;</span><br><span class="line">        d += u-l;</span><br><span class="line">        sum += k*(u-l);</span><br><span class="line">    &#125;</span><br><span class="line">    longd ans = x/(y-d+sum);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="f-free-weights">F – Free Weights</h2><p>算是一个比较简单的题目，校队的朋友们都做出来了。</p><h3 id="题目大意-3">题目大意</h3><p>一个健身房里有两排哑铃，每种重量的轮盘只有两个。现在我们想要把相同重量的轮盘放在一起；每排的空间是无限的，如果你想要将哑铃轮盘滚到旁边的空位上，这是免费的；否则你挪动任何一个轮盘都会消耗和轮盘等重的费用；问你整理完了这一波哑铃之后单次消耗的最高费用是多少。</p><p>也就是说求的是整理好这一波哑铃轮盘必须要挪动的轮盘的最大重量的最小值。</p><h3 id="分析-3">分析</h3><p>如果要是求总的消费我可真是没太多想法，但是既然都说了“最大xx的最小值”，这一看就是一个二分答案的题目。但是应该怎么来模拟这个行为进行快速判定呢？</p><p>因为题目说了只求最高费用，换句话说就是比最高费用低的费用都免费了——随便挪的意思。那我们不如把所有较小的哑铃全部挪到千里之外并且让他们有序——恰好空间也是无限大的；然后再看留下来的轮盘是不是匹配的——不匹配咱也挪不了，说明这个最大重量不行；这样就可以方便的判断答案可行性了。</p><h3 id="我的代码-3">我的代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> longd;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ulong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>+<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> in[<span class="number">2</span>][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line">    <span class="keyword">bool</span> got = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(in[<span class="number">0</span>][i]&lt;=m) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!got)</span><br><span class="line">        &#123;</span><br><span class="line">            got = <span class="literal">true</span>;</span><br><span class="line">            last = in[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(last!=in[<span class="number">0</span>][i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            got = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(got) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(in[<span class="number">1</span>][i]&lt;=m) <span class="keyword">continue</span>;<span class="comment">// 上点心吧</span></span><br><span class="line">        <span class="keyword">if</span>(!got)</span><br><span class="line">        &#123;</span><br><span class="line">            got = <span class="literal">true</span>;</span><br><span class="line">            last = in[<span class="number">1</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(last!=in[<span class="number">1</span>][i])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            got = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !got;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// freopen(R&quot;(D:\shiroha\Downloads\nwerc2016testdata.tar\nwerc2016testdata\free_weights\6-lightly-shuffled.in)&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = <span class="number">0</span>, <span class="built_in">min</span> = <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;in[<span class="number">0</span>][i];</span><br><span class="line">        <span class="keyword">if</span>(in[<span class="number">0</span>][i]&gt;<span class="built_in">max</span>) <span class="built_in">max</span> = in[<span class="number">0</span>][i];</span><br><span class="line">        <span class="keyword">if</span>(in[<span class="number">0</span>][i]&lt;<span class="built_in">min</span>) <span class="built_in">min</span> = in[<span class="number">0</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;in[<span class="number">1</span>][i];</span><br><span class="line">        <span class="keyword">if</span>(in[<span class="number">1</span>][i]&gt;<span class="built_in">max</span>) <span class="built_in">max</span> = in[<span class="number">1</span>][i];</span><br><span class="line">        <span class="keyword">if</span>(in[<span class="number">1</span>][i]&lt;<span class="built_in">min</span>) <span class="built_in">min</span> = in[<span class="number">1</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    longs l = <span class="number">0</span>;</span><br><span class="line">    longs r = <span class="built_in">max</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> longs mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) r = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cerr</span>&lt;&lt;<span class="string">&quot;check(9589) = &quot;</span>&lt;&lt;check(<span class="number">9589</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;l&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依然是一个不会写代码的玩家因为犯了低级错误而连续WA的结果……</p><h3 id="附录">附录</h3><p>虽然说是一个典型的二分的题目，但是这个模型可以利用的地方还是比较多的：感觉像是降低难度而牵强附会了一些条件。所以还是有别的路子可以走——比如说标程里这位老哥写的sweep法。它非常符合我们的直观感受，且可以解出正确答案，在这里码一下好了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//this solution considers one element after another on the rack</span></span><br><span class="line"><span class="comment">//     A. consider the first two weights next to each other:</span></span><br><span class="line"><span class="comment">//              1. they are equal -&gt; just delete them, nothing to do</span></span><br><span class="line"><span class="comment">//              2. they are different, so I know I have to lift the lighter one, rember the weight of the lighter one and delete it</span></span><br><span class="line"><span class="comment">//     go to A</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Running time: O(n)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sweep_rack</span><span class="params">(<span class="keyword">const</span> vi &amp;rack)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cand=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">int</span> &amp;e:rack)&#123; </span><br><span class="line">        <span class="keyword">if</span>(e==cand)<span class="comment">//found second!</span></span><br><span class="line">            cand=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(e&lt;cand)<span class="comment">//I have to be strong enough to lift e (but who knows, maybe also cand)</span></span><br><span class="line">            res=<span class="built_in">max</span>(res, e);</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">// if(e&gt;cand), There is no way out, I have to lift the candidate, but it is not yet clear with e-&gt; make it candidate</span></span><br><span class="line">            res=<span class="built_in">max</span>(res, cand);</span><br><span class="line">            cand=e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(res, cand);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vi <span class="title">read_rack</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="function">vi <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;e:res)</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; e;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">max</span>(sweep_rack(read_rack(n)), sweep_rack(read_rack(n))) &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相当于扫行的时候做这样的事情：如果已经放在一起了，就直接删除；否则，就挪比较轻的那个（反正没有损失，之后要挪重的话更新答案便是），把另一个比较轻的也给删喽。这样子跑一边下来就能得到题目要的答案。每一步删除的正确性都能保证，稍微想想就知道了。</p><h2 id="i-iron-and-coal">I – Iron and Coal</h2><p>一个图论题，可以用搜索来解决。但是其实是一个 Steiner Tree <del>命运石之树（大嘘）</del>的问题，有深挖的价值。</p><p>按照惯例，先问是不是再问为什么，所以先科普一下：</p><blockquote><h5 id="steiner-tree">Steiner Tree</h5><p>斯坦纳树问题是组合优化学科中的一个问题。将指定点集合中的所有点连通，且边权总和最小的生成树称为最小斯坦纳树（Minimal Steiner Tree）。最小生成树是它的一种特殊情况，而斯坦纳树则是最小斯坦纳树的另有一种情况：只保证指定的点集合联通，但是不保证最小距离。</p><p>此外，一般来说，求一个最小斯坦纳树是一个 <a href="https://baike.baidu.com/item/NP%E5%AE%8C%E5%85%A8%E9%97%AE%E9%A2%98/4934286?fr=aladdin">NP-complete 问题</a>。</p></blockquote><p>此外关于这个有篇博文写的不错，大家可以去看看： <a href="https://www.cnblogs.com/ECJTUACM-873284962/p/7643445.html" class="uri">https://www.cnblogs.com/ECJTUACM-873284962/p/7643445.html</a></p><h3 id="题目大意-4">题目大意</h3><p>给你一张图，有的点有矿，有的点有煤，你全都要；如果要拥有这个点的资源，你必须要占点才行；从一个点只能到达相邻的点，你最开始只有一号点；题目确保不存在任何一个节点同时拥有两个资源；问你如果能两个都要，最少所需要占的点数；如果不能两个都要就输出<code>"impossible"</code>。</p><p>也就是说要求出占领两种资源的最优方法。</p><h3 id="分析-4">分析</h3><p>最开始做的时候我<del>的队友</del>也没想那么多。首先不能两个都要的情况很简单，就是无路可走。这个判断一下就可以了；两个都要的情况大概分成两种：</p><ul><li>一种是一路到头，不仅找到了煤还找到了矿，应有尽有；</li><li>另一种是走到某个点然后兵分两路，最后也是两手捧花；</li></ul><p>判定最小路径你之前需要先知道怎么求出路径：根据或不根据上面的分析，我们要想判定一个路径（也就这样的树），需要知道三个值：从家到这个点的距离、从这个点到最近的煤的距离、这个点到最近的矿的距离。然而这些距离都是可以通过搜索求出来的，每次搜索复杂度可控制在O(n)，然后遍历所有可能的“三方会谈点”，就可以找到这个最小值了。</p><p>不用担心上面的一步到位的情况，它就相当于节点在资源点，然后某条边的长度为0.</p><p>然后就是我没有深挖的题解的做法。题解提供了两种做法，一种是类似于我采用的做法，一种是Steiner树归约。先翻一下官方的题解：</p><blockquote><p><strong>解法一： Steiner树归约</strong></p><ol type="1"><li>将地图上的每个单元都抽象地看作一个节点</li><li>为每一个可到达的邻居点增加一条权重为0的有向边</li><li>将所有的每种资源都向该资源的超级节点连一条权重为0的边</li><li>以原点作为起点，对每一个超级节点求一个最小Steinner树</li></ol><figure><img src="https://i.loli.net/2020/03/12/VWcPGt8smDnirlh.png" class="lazyload" data-srcset="https://i.loli.net/2020/03/12/VWcPGt8smDnirlh.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="458HPW6_1_5NF_ZJ84KS8O8.png" /><figcaption aria-hidden="true">458HPW6_1_5NF_ZJ84KS8O8.png</figcaption></figure><center>↑这是大概的示意图↑</center></blockquote><p>除了第二条没怎么看懂…… 写了代码在更新这里好了</p><blockquote><p><strong>解法二： 多项式算法</strong></p><p>虽然一般来说这是个NPC问题，但是在这种三个节点的特殊情况下，可以设计出多项式的算法来求这个最小Steinner树。我们假设已经建立了解法一所说的超级节点，具体步骤如下：</p><ol type="1"><li>使用BFS找出原点到所有其他节点的距离</li><li>使用BFS在反图上求出每种资源的超级节点到所有点的距离</li><li>找到到原点和每种资源的超级节点的距离和最短的点</li></ol><p>整个算法是一个O(n)时间的算法。</p></blockquote><p>也就是我<del>们队伍</del>在赛场上采用的做法。</p><h3 id="我的代码-4">我的代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> norm 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iron 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> coal 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> longd;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ulong;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x1f1f1f1f</span>;     <span class="comment">// 因为会出现3*INF，所以不能是0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> cannot[] = <span class="string">&quot;impossible&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,k;</span><br><span class="line"><span class="keyword">int</span> o[N],c[N];</span><br><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">3</span>][N];  <span class="comment">// dis[!norm]代表了从某点能到达的最近的矿源的距离</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N];</span><br><span class="line">edge e[(N&lt;&lt;<span class="number">1</span>)+(N&lt;&lt;<span class="number">3</span>)];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> tail[N];</span><br><span class="line">edge re[(N&lt;&lt;<span class="number">1</span>)+(N&lt;&lt;<span class="number">3</span>)];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tot = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(tail,<span class="number">-1</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(dis[<span class="number">0</span>],<span class="number">0x1f</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(dis[<span class="number">1</span>],<span class="number">0x1f</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(dis[<span class="number">2</span>],<span class="number">0x1f</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++tot;</span><br><span class="line">    e[tot] = &#123;v,head[u]&#125;;</span><br><span class="line">    head[u] = tot;</span><br><span class="line">    re[tot] = &#123;u,tail[v]&#125;;</span><br><span class="line">    tail[v] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFS</span><span class="params">(<span class="keyword">int</span> typ)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">if</span>(typ)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(typ==iron)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">                q.push(o[i]), dis[iron][o[i]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i)</span><br><span class="line">                q.push(c[i]), dis[coal][c[i]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> top = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> c = tail[top];</span><br><span class="line">            <span class="keyword">while</span>(~c)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[typ][re[c].to] &gt; dis[typ][top]+<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dis[typ][re[c].to] = dis[typ][top]+<span class="number">1</span>;</span><br><span class="line">                    q.push(re[c].to);       <span class="comment">// 有可能更新距离时再更新</span></span><br><span class="line">                &#125;</span><br><span class="line">                c = re[c].next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        q.push(<span class="number">1</span>);</span><br><span class="line">        dis[norm][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> top = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">int</span> c = head[top];</span><br><span class="line">            <span class="keyword">while</span>(~c)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[norm][e[c].to] &gt; dis[norm][top]+<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dis[norm][e[c].to] = dis[norm][top]+<span class="number">1</span>;</span><br><span class="line">                    q.push(e[c].to);</span><br><span class="line">                &#125;</span><br><span class="line">                c = e[c].next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    freopen(R&quot;(D:\shiroha\Downloads\nwerc2016testdata.tar\nwerc2016testdata\iron_and_coal\022_one_ore_of_many.in)&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    init();</span><br><span class="line">    dis[norm][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;o[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;++i)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">        <span class="keyword">while</span>(a--)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;b, addedge(i,b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BFS(norm);</span><br><span class="line">    BFS(iron);</span><br><span class="line">    BFS(coal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        ans = <span class="built_in">min</span>(ans,dis[norm][i]+dis[iron][i]+dis[coal][i]);</span><br><span class="line">    <span class="keyword">if</span>(ans-INF) <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;cannot&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别需要注意的地方也就是我代码里注释提到的地方：因为最终我们会把三个值加起来，<code>INF</code>就算开了<code>0x3f3f3f3f</code>，加起来也是会暴毙的。所以应该采用一个更小的INF。我的代码种使用<code>0x1f1f1f1f</code>就可以通过了。啊理论上你开<code>long long</code>或者是开<code>unsigned int</code>都是可以的。</p><h2 id="a-arranging-hat">A – Arranging Hat</h2><p>血麻烦、代码极其难写的一个题目。虽然很快的有了思路但是代码不知道写了多久……</p><h3 id="题目大意-5">题目大意</h3><p>会输入一列n数字，每个数字有m位，且包含前缀0；你可以花费1并且改动任何一个数字的任何一位的数字；问最少需要改动多少次才能将原数列改成一个升序的数列，并且输出任何一个结果；</p><p>也就是说给一写字符串型的数字，输出一个符合字典序的新序列，它花费了最少的费用。</p><h3 id="分析-5">分析</h3><p>这题有两种思路。一种是显而易见但是难写的二维DP，另一种是不那么显而易见但是同样难写的递归。两种做法官方的题解里都有提到。</p><p>有一个需要注意到的事情：因为n的上限是不超过100的。最坏情况下我们只需要把整个序列的数字的前两位的数字改成递增的，就可以保证整个数列是递增的。也就是说改动次数的上限是2n。如果只是输出一个数值的话似乎只需要看一下前几位就可以了，但是因为还要输出任何一种方案，所以代码瞬间变得难写了起来。（不过似乎本来也就不是多少好写）</p><p>在开始前我先翻译一下官方的题解：</p><blockquote><p><strong>解法一： 递归</strong></p><ol type="1"><li>对于所有数量X，将前X个数字将第一个数字修改位0</li><li>现在，原问题被拆解为两个规模更小的子问题</li></ol><ul><li>对于前X个数字，处理他们除了第一位的部分</li><li>对于接下来的数字，修改第一位成为 ≥0 的数字</li></ul><ol start="3" type="1"><li>查找序列的每一个子区间，每一个起始索引和数字</li><li>利用记忆化搜索，可以控制时间复杂度在 O(N³·M)</li></ol><p>不要使用缓慢的Python递归，会死的！</p></blockquote><p>解法一是比较的直观的一种方法。维护这个序列字典序可以简单的划分为这几部：</p><ul><li>将前X个数的第一位改成0；并且保证前X个数除了第一位的部分是有序的</li><li>将剩下的数字的第一位改成大于0的某个数，并且保证它们是有序的</li></ul><p>尾递归是当区间、数字、数位无效或者必然有序（比如只有一个）时返回。但是因为我们没有什么好的办法方便的确定这个X的具体的值，所以就需要尝试所有的X。当更优的时候更新分页标签（<code>split</code>数组存储的就是对于每一个子问题的最优划分位置X），就可以在找到最小费用的桶式得到一种具体的方案。</p><blockquote><p><strong>解法二： 动态规划</strong></p><ol type="1"><li>首先我们把一个数字字符串看成一个整体</li><li>令dp[i,j]是我们对前i个数字修改j次可以得到的最小的第i数字</li><li>对于每一种状态，尝试修改第i+1个数字</li><li>从现有的状态贪心地在O(M)的时间内得到最小的数字</li><li>如果转移得到的数字比原状态大，该次转移有效</li><li>这样的状态复杂度是O(N²·M)，转移的复杂度是O(M²)</li><li>但是可以推导出答案的复杂度不会大于O(N·log₁₀N)</li><li>所以最终实际复杂度是：状态O(N²·log₁₀N)，转移O(N·log₁₀N·M)</li></ol></blockquote><p>网上的题解多半也是这样做的，这也确实更加符合一般的思维。只是代码会比较的难写。在之前已经说到了改动次数是由上限的，所以可以用在这里。而且因为dp数组最终的推导值并不是我们需要的答案，所以还要开数组记录一下前缀状态用来还原答案。</p><p>另一个麻烦的地方就是有效转移和无效转移：定义上有效转移是转移结果符合字典序的转移。显然对于无效转移，已经没有再推导下去的必要了。所以只要基于有效转移进行有效转移，就可以推导出答案了。虽然基于状态构造有效转移也是一件麻烦事。</p><h3 id="我的代码-5">我的代码</h3><p>首先是递归的代码：因为写的时候没少出事，所以注释也都详细的写了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> toChar(x) (<span class="meta-string">&#x27;0&#x27;</span> + x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cur [st][ed][pos][x]   <span class="comment">// 当前函数处理的位置</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> longd;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ulong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">45</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">405</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> s[N][M];</span><br><span class="line"><span class="keyword">int</span> best[N][N][M][<span class="number">10</span>];          <span class="comment">// 最优修改次数，初值INF</span></span><br><span class="line"><span class="keyword">int</span> split[N][N][M][<span class="number">10</span>];         <span class="comment">// 修改标签，初值是0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recurse</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> ed, <span class="keyword">int</span> pos, <span class="keyword">int</span> x)</span>     <span class="comment">// 将第[st,ed)个数字的第pos位改为x后，生成有效答案的最少步数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &gt;= m || st == ed) <span class="keyword">return</span> <span class="number">0</span>;         <span class="comment">// 参数无效：无贡献</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">10</span>) <span class="keyword">return</span> INF;                    <span class="comment">// 不可能的情况：返回INF</span></span><br><span class="line">    <span class="keyword">int</span> &amp; that = best cur;</span><br><span class="line">    <span class="keyword">if</span> (that &lt; INF) <span class="keyword">return</span> that;                <span class="comment">// 记忆化搜索</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cost = <span class="number">0</span>;                               </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = st; k &lt;= ed; ++k)              <span class="comment">// 尝试修改区间内所有分界点为 x</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = cost                          <span class="comment">// 当前的费用 = 修改当前位的费用 + 维护两个区间的有效性的费用</span></span><br><span class="line">                  + recurse(st, k, pos+<span class="number">1</span>, <span class="number">0</span>)    </span><br><span class="line">                  + recurse(k, ed, pos, x+<span class="number">1</span>);   </span><br><span class="line">        <span class="keyword">if</span> (now &lt; that)                         <span class="comment">// 更新最小费用和分界标签</span></span><br><span class="line">        &#123;</span><br><span class="line">            split cur = k;          </span><br><span class="line">            that = now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; ed)                             </span><br><span class="line">            cost += (s[k][pos] != toChar(x));   <span class="comment">// 这次的修改在区间内且是有效更改，累加步数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> that;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remake</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> ed, <span class="keyword">int</span> pos, <span class="keyword">int</span> x)</span>     <span class="comment">// 利用split还原最优方案，以修改原数组     </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">10</span> || pos &gt;= m || st == ed)        <span class="comment">// 无效参数</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> &amp; val = split cur;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = st; i &lt; val; ++ i)             </span><br><span class="line">        s[i][pos] = toChar(x);                  <span class="comment">// 根据标签的指示修改</span></span><br><span class="line">    remake(st, val, pos+<span class="number">1</span>, <span class="number">0</span>);                  </span><br><span class="line">    remake(val, ed, pos, x+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;s[i];</span><br><span class="line">    <span class="built_in">memset</span>(best,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(best));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cerr</span>&lt;&lt;<span class="string">&quot;COST: &quot;</span>&lt;&lt;recurse(<span class="number">0</span>,n,<span class="number">0</span>,<span class="number">0</span>)&lt;&lt;<span class="built_in">endl</span>;     <span class="comment">// cerr输出最优步数</span></span><br><span class="line">    remake(<span class="number">0</span>,n,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，一个答案是可以通过一个方案来导出来的。所以先寻找更优的方案存储起来，这样最终利用存储的方案就可以得到最优解。寻找最优解需要尝试，每次尝试修改时更新最优方案的存储。代码中利用了尝试函数<code>recurse</code>完成了尝试和记录的工作。</p><p>对于尝试函数，整列数字分为三个部分：前X个数字的第一位，前X个数字的剩余部分（子问题1），后面的数字（子问题2）。每次都尝试修改第一部分，并统计这些修改中的有效修改（显然，0→0并不是有效的修改），最后递归统计剩余两部分的消费，就可以找到最小的修改次数和修改方案。使用数组<code>split</code>存储在这个参数的状态下最优的X。最后利用它还原修改的结果就可以了。</p><p>因为这种递归是可能出现多种相同的状态的。而因为这个函数的结果只会和状态相关，所以可以使用记忆化搜索来减少这部分不必要的开支。</p><p>然后是二维DP的代码，这是我在赛场上写的：所以没什么注释，我简单的补了一些</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">45</span>, M = <span class="number">405</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N2 = N&lt;&lt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> in[N][M];</span><br><span class="line"><span class="keyword">char</span> tmp[M];            <span class="comment">// findNext的返回值</span></span><br><span class="line"><span class="keyword">char</span> dp[N][N2][M];</span><br><span class="line"><span class="keyword">bool</span> flag[N][N2];       <span class="comment">// 转移是否有效</span></span><br><span class="line"><span class="keyword">int</span> pre[N][N2];         <span class="comment">// 前导状态表</span></span><br><span class="line"><span class="keyword">char</span>* ans[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当前dp值now，下一个原数字Next，长度为m，k次修改机会</span></span><br><span class="line"><span class="comment"> * 能否构造出有效转移；能则将转移结果存入tmp</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findNext</span><span class="params">(<span class="keyword">char</span> *now, <span class="keyword">char</span> *Next, <span class="keyword">int</span> m, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = k, pos;</span><br><span class="line">    <span class="built_in">strcpy</span>(tmp, Next);</span><br><span class="line">    <span class="keyword">if</span>(!k)                              <span class="comment">// 无修改次数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(tmp, now) &gt;= <span class="number">0</span>;   <span class="comment">// 下一个数有效则找到</span></span><br><span class="line">    <span class="keyword">for</span>(pos = <span class="number">0</span>; pos &lt; m &amp;&amp; num &gt; <span class="number">0</span>; ++pos)</span><br><span class="line">        <span class="keyword">if</span>(tmp[pos] != now[pos])</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[pos] = now[pos];        <span class="comment">// 贪心修改高位</span></span><br><span class="line">            --num;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(tmp, now) &gt;= <span class="number">0</span>)   </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 若未返回，说明未修改部分[pos,m]不够大</span></span><br><span class="line">    <span class="keyword">for</span>(--pos; pos &gt;= <span class="number">0</span> &amp;&amp; now[pos] == <span class="string">&#x27;9&#x27;</span>;)</span><br><span class="line">        --pos;          <span class="comment">// 找到可以修改的高位部分中最低的一位</span></span><br><span class="line">    <span class="keyword">if</span>(pos &lt; <span class="number">0</span>)         <span class="comment">// 如果不可能将已修改的位改的更大，就不可能</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    num = k;</span><br><span class="line">    <span class="built_in">strcpy</span>(tmp, Next);  <span class="comment">// 重新开始</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pos; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp[i] != now[i])</span><br><span class="line">        &#123;</span><br><span class="line">            tmp[i] = now[i];</span><br><span class="line">            --num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tmp[pos] != now[pos] + <span class="number">1</span>)  <span class="comment">// 尝试可修改的最低位改为+1</span></span><br><span class="line">    &#123;</span><br><span class="line">        tmp[pos] = now[pos] + <span class="number">1</span>;</span><br><span class="line">        --num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(++pos; pos &lt; m &amp;&amp; num &gt; <span class="number">0</span>; ++pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp[pos] != <span class="string">&#x27;0&#x27;</span>)       <span class="comment">// 用尽所有的修改次数尽可能减小答案</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmp[pos] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            --num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;                  <span class="comment">// 这样的修改一定是有效的</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(flag, <span class="literal">false</span>, <span class="keyword">sizeof</span>(flag));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>][i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][m] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    flag[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%*c&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n2 = n &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, in[i]);</span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n2; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!flag[i][j]) <span class="keyword">continue</span>;                     <span class="comment">// 跳过无效状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= m &amp;&amp; j + k &lt; n2; ++k)     <span class="comment">// 尝试所有可能的转移</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(findNext(dp[i][j], in[i + <span class="number">1</span>], m, k)</span><br><span class="line">                &amp;&amp; ( !flag[i + <span class="number">1</span>][j + k]</span><br><span class="line">                || <span class="built_in">strcmp</span>(tmp, dp[i + <span class="number">1</span>][j + k]) &lt; <span class="number">0</span>  <span class="comment">// 找到有效的转移</span></span><br><span class="line">            ))</span><br><span class="line">            &#123;</span><br><span class="line">                flag[i + <span class="number">1</span>][j + k] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">strcpy</span>(dp[i+<span class="number">1</span>][j+k], tmp);</span><br><span class="line">                pre[i+<span class="number">1</span>][j+k] = j;          <span class="comment">// 做标记，存储字符串，记录前导</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ptr;</span><br><span class="line">    <span class="keyword">for</span>(ptr = <span class="number">0</span>; ptr &lt; n2; ++ptr)</span><br><span class="line">        <span class="keyword">if</span>(flag[n][ptr]) <span class="keyword">break</span>;             <span class="comment">// 找到次数最少的有效转移</span></span><br><span class="line">    <span class="built_in">cerr</span>&lt;&lt;<span class="string">&quot;COST: &quot;</span>&lt;&lt;ptr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; ptr = pre[i][ptr], --i)</span><br><span class="line">        ans[i] = dp[i][ptr];             </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">puts</span>(ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要来说一下最麻烦的构造有效转移，也就是<code>findNext</code>函数（也是我不知道写暴毙多少次的一个地方）。这里我们使用贪心的策略：尽可能的修改高位，并且尽可能的让高位小，同时也要保证字典序。这样，对于每一位数字只有两种可能：</p><ul><li>因为从高位向低位修改，每次修改都按照上面的规则，所以可以认为前半部分是一致的。</li><li>这一位的后面部分足够给力，比前一个数字的同位部分大；那么这一位只需和前一个数字的这一位一样就行；</li><li>否则，这一位必须领头，修改成比前一个数字同位的数字大一；且这一定是最后一次修改。</li></ul><p>简单的说，就是要不改成和前一个数字同位值相等，要不改成大1；因为尽可能构造小的满足字典序的数字，所以大1的这次修改一定只会出现在最后一次。……不仅说起来绕口，写起来也很麻烦。我采用的方法是这样的：</p><ul><li>首先贪心的用完所有次数，从高位向低位修改：一律改成和同位值相等</li><li>如果这样已经满足了字典序，那必然是最小的有效转移</li><li>否则，向高位遍历，寻找可以再大1的位置；它可以不是刚才已经修改过的位置，因为它一定比最后一次贪心修改的位置靠前</li><li>重新修改，将找到的这一位之前所有数字改成相等，这一位改成大1. 此时字典序可以保证</li><li>若还有未用尽的次数，可以贪心地修改这一位后的高位来尽可能降低返回值</li></ul><p>这样就完成了基于有效状态的有效转移的构造。再将构造结果传给DP用来进行状态转移即可。</p><h2 id="j-jupiter-orbiter">J – Jupiter Orbiter</h2><p>这是一个好题目，但是不难做。标准解法是最大流问题，但是可以简单的贪心出答案。不过俗话说得好，最大流不过是套在网络流模型上的贪心罢了，从这题来看就非常的正确。</p><h3 id="题目大意-6">题目大意</h3><p>一个探测器有s个传感器和q个FIFO的存储卡。这些存储卡有一定的容量；每个传感器都会将它收集到的数据存储到属于该传感器的唯一的存储卡中；现在这台探测仪要进行n轮探测，每次探测过程分为收集阶段和传输阶段；收集阶段每个传感器都会收集到ai的数据存储到它的存储卡中；传输阶段可以将总量不超过d的信息从存储卡发送回地球。告诉你上面的这些所有的量，问你会不会有数据因为装不进存储卡而丢失。</p><p>换句话说，就是有Q和容量为C的FIFO队列，有n个从这些队列中删除数据的机会，且每次最多的删除总量为d。并且每次删除前队列都会获得a的数据，但是存不下的部分会丢失。请问能不能做到在最后一次删除数据之后，所有的队列为空。</p><h3 id="分析-6">分析</h3><p>我<del>的队友</del>并没有考虑的很复杂。虽然说是先接受数据在传输数据，但是这题并不一定这样做：我们可以先接受数据，静等下一轮的情况，然后选择性的传输容量最紧缺的地方的数据。倒是也可以顺风顺水的做出来。但是还是先说比较常规的网络流做法：</p><p>说之前依然先看题解：</p><blockquote><p><strong>解法一： 网络流最大流</strong></p><ol type="1"><li>将本题根据网络流模型建模</li><li>确认最大流是否和产生的数据总量相等</li></ol><figure><img src="https://i.loli.net/2020/03/12/QHnTR8y9glS5ZiK.png" class="lazyload" data-srcset="https://i.loli.net/2020/03/12/QHnTR8y9glS5ZiK.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="M7DIIU_S_T_A_@GL0OPWR@4.png" /><figcaption aria-hidden="true">M7DIIU_S_T_A_<span class="citation" data-cites="GL0OPWR">@GL0OPWR</span><span class="citation" data-cites="4.png">@4.png</span></figcaption></figure><center>↑建模大概是这样的↑</center></blockquote><p>题解说的非常简单，然后给了一个图。我自己又根据第一组测试样例画了一个：</p><figure><img src="https://i.loli.net/2020/03/12/Y3aenu7wxHm46hc.png" class="lazyload" data-srcset="https://i.loli.net/2020/03/12/Y3aenu7wxHm46hc.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="WD2Z4_Y_WS_3SWFKF~3_P.png" /><figcaption aria-hidden="true">WD2Z4_Y_<code>WS_3SW</code>FKF~3_P.png</figcaption></figure><p>简单的总结一下我自己的建模方法，和题解画图略有不同但是本质是一样的；大概就是这样：</p><ul><li>对于每一轮的探测，将每个传感器和队列都建立一个节点；对于每次传输数据也建立一个节点</li><li>从原点出发，向每轮的所有传感器连边，容量是它们这一轮获得的数据数量</li><li>对于每一轮的每个传感器，向它对应的本轮的队列连边，容量是队列的流量</li><li>从本轮的队列节点出发，向本轮的传输节点连边，容量是无限大；向可能存在的下一轮的对应探测器连边，容量是无限大</li><li>对于所有的传输数据节点，则可以向汇点连边，容量是本轮可以发送数据量的最大值</li></ul><p>完成了这样的建模，就可以套板子来一遍最大流，轻松而愉快的解出这个题目了。</p><p>此外，题解也提供了贪心的做法：</p><blockquote><p><strong>解法二： 模拟贪心</strong></p><ol type="1"><li>模拟接受数据的全过程</li><li>只要队列满了，就记录多出去的部分：这是必须要在上一轮处理掉的数据</li><li>再模拟一次数据接受的全过程</li><li>使用第一轮得到的经验进行数据处理：处理不了时就失败了</li><li>因为要尽可能避免失败，所以要尽早的回避记录的限制</li><li>可以在排序后的记录表的指导下贪婪的传输数据</li></ol></blockquote><p>感觉有点怪怪的…… 不知道是我翻译的问题还是思维上的不同。但是总体的指导思想就是在知道下一轮的情况下科学安排本轮数据传输的侧重点。这其实并不需要扫两遍模拟，一次模拟就可以实现目的。我简单介绍下我<del>的队友</del>实现的思路：</p><ul><li>对于每一轮的数据：如果可以完全传输，那么就今日事今日毕，清空队列</li><li>对于任何一组数据：如果当局获得的数据总量比容量大，那必然是会丢失数据</li><li>如果本轮数据不能完全传输，那就先不处理；可传输容量带到下一轮</li><li>模拟接受下一轮的数据时，如果有的队列溢出了，那这部分就是上一轮必须要处理的部分</li><li>如果最后一轮结束时队列仍然不能清零，那么失败；否则成功</li></ul><p>应该还是非常清晰的，具体可以看我的代码。</p><h3 id="我的代码-6">我的代码</h3><p>因为我想要偷懒，所以就先把比赛时候的代码搬上来了。这个代码并没有使用最大流：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> longd;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ulong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> can[] = <span class="string">&quot;possible&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> cannot[] = <span class="string">&quot;impossible&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">35</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q,s;</span><br><span class="line"><span class="keyword">int</span> uq[M], c[N];</span><br><span class="line"><span class="keyword">int</span> d, a;</span><br><span class="line"><span class="keyword">int</span> tmp[N];</span><br><span class="line"><span class="keyword">bool</span> state = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    longs todo = <span class="number">0</span>;</span><br><span class="line">    longs cando = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s;++i) <span class="built_in">cin</span>&gt;&gt;uq[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i) <span class="built_in">cin</span>&gt;&gt;c[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;d;                 <span class="comment">// 本回合的资金</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=s;++j) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">            <span class="keyword">if</span>(a &gt; c[uq[j]]) state = <span class="literal">false</span>; <span class="comment">// 不可能装下：直接暴毙</span></span><br><span class="line">            tmp[uq[j]] += a;                </span><br><span class="line">            <span class="keyword">if</span>(tmp[uq[j]] &gt; c[uq[j]])       <span class="comment">// 用上回合的资金处理危险部分</span></span><br><span class="line">            &#123;</span><br><span class="line">                cando -= tmp[uq[j]] - c[uq[j]];</span><br><span class="line">                <span class="keyword">if</span>(cando &lt; <span class="number">0</span>) state = <span class="literal">false</span>;</span><br><span class="line">                tmp[uq[j]] = c[uq[j]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!state) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!state) <span class="keyword">break</span>;</span><br><span class="line">        cando += d;             <span class="comment">// 使用本回合资金</span></span><br><span class="line">        todo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;++i)</span><br><span class="line">            todo += tmp[i];     </span><br><span class="line">        <span class="keyword">if</span>(todo &lt;= cando)       <span class="comment">// 可以全部处理完：清零</span></span><br><span class="line">        &#123;</span><br><span class="line">            cando = todo = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(q+<span class="number">1</span>));</span><br><span class="line">        &#125;                       <span class="comment">// 否则看下回合情况</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(todo &gt; cando) state = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(state) <span class="built_in">cout</span>&lt;&lt;can&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;cannot&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路就是上面分析里提到的那样，简单解决。</p><h2 id="k-kiwi-trees">K – Kiwi Trees</h2><p>计算几何的题目。因为没有板子（理由！）和忘掉了很多<del>非常非常基础的</del>几何知识最后没有做出来。但是其实是一个比较好写的题目，不会写属实有些吃亏。</p><h3 id="题目大意-7">题目大意</h3><p>隔壁老王有一个形状是简单多边形的院子。这个多边形有一些特点：每条边的长度大于30m；任何的一个角的大小在18°~144°之间，但是不保证多边形是凸多边形；现在老王想在这个院子里种两棵一模一样的果树，于是它买来了两棵树。老板告诉他这两棵树长大了之后会占用以种树点为圆心的，半径为3.999m的圆的区域；而且两棵树如果树冠长在一起是NG的。种的时候邻居也来抗议，称如果老王的树冠长出了他自家的院子，他们就向居委会举报。问老王应该把这两棵树中在哪里才能避免树的死亡以及居委会的整改？</p><p>换句话说，就是告诉你一个有点特殊的多边形，能不能在这个多边形内摆两个不相交的圆。能的话就算出两个圆心坐标。</p><p>特别提示：输入的多边形的顶点对于多边形而言是顺时针的。</p><h3 id="分析-7">分析</h3><p>因为这个多边形的边有保底长度，所以不用想太多：就算是一个极端的情况下，一般来说一个凸角塞一个圆就没什么问题了。塞完之后再遍历所有可以塞的地方，找到一对满足要求的输出就可以了。</p><p>但是实现的时候要更加的注意细节。因为即使你将这个圆塞进了某个凸角里，它仍然有可能和一切不是这个角的边相交。所以为了保险起见还要扫一遍所有的边判断确保没有这种情况的发生。</p><p>然后就是具体实现了。有了几何板子和几何知识就是顺理成章的事情。但是为了照顾一下没有这些东西的看客<del>比如我</del>，这里简单的进行一下知识的科普。如果之后有时间的话会整理专题的：</p><blockquote><p>二维向量叉乘的作用： - 求两个向量的夹角，因为可以由定义式求出sinθ - 求两个向量为两条边形成的平行四边形的面积 - 在顺/逆时针下判断多边形角的凹凸性<br />比如对于顺时针多边形，叉乘为正的时候，这个角是一个凹角</p></blockquote><p><del>高等数学白学力（大悲）</del></p><p>然后题目给了一个官方题解。大体类似但是也有不同，姑且给翻译了一波：</p><blockquote><ol type="1"><li>任何大于四个顶点的简单多边形至少会有两个凸角</li><li>由题意可知，多边形的角度是18~144度，边长至少30m</li><li>这样的一个凸角割成三角形，一定能容纳一个半径不超过4.008m的圆</li><li>特判：当输入是一个三角形的时候，可以直接判定不可以</li></ol></blockquote><p>怎么说呢，这样做的话题目的代码大概会变的更加地好写。数学论证凸角一定可以塞下，然后只需要随便找两个凸角算一下圆心就可以了——这个也可以通过角平分线算出来。但是关于三角形的特判我是不太苟同：因为如果三角形的边足够大，它还是可以塞下符合标准的两个圆的。所以我觉得这一步还是应该进行尝试。</p><h3 id="我的代码-7">我的代码</h3><p>因为没有板子，所以补题的时候基本计算的板子抄了校队另一个同学的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THIS (*this)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> longd;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ulong;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    longd x, y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">point</span> <span class="keyword">operator</span> +(<span class="keyword">const</span> <span class="built_in">point</span>&amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    <span class="built_in">point</span> <span class="keyword">operator</span> -(<span class="keyword">const</span> <span class="built_in">point</span>&amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">    longd <span class="keyword">operator</span> *(<span class="keyword">const</span> <span class="built_in">point</span>&amp; rhs) <span class="keyword">const</span>;   <span class="comment">// 点乘</span></span><br><span class="line">    <span class="built_in">point</span> <span class="keyword">operator</span> *(longd rhs) <span class="keyword">const</span>;          <span class="comment">// 数乘</span></span><br><span class="line">    <span class="built_in">point</span> <span class="keyword">operator</span> *(<span class="keyword">double</span> rhs) <span class="keyword">const</span>;</span><br><span class="line">    <span class="built_in">point</span>&amp; <span class="keyword">operator</span> +=(<span class="keyword">const</span> <span class="built_in">point</span>&amp; rhs);</span><br><span class="line">    <span class="built_in">point</span>&amp; <span class="keyword">operator</span> -=(<span class="keyword">const</span> <span class="built_in">point</span>&amp; rhs);</span><br><span class="line">    <span class="built_in">point</span>&amp; <span class="keyword">operator</span> *=(longd rhs);</span><br><span class="line">    <span class="built_in">point</span>&amp; <span class="keyword">operator</span> *=(<span class="keyword">double</span> rhs);</span><br><span class="line"></span><br><span class="line">    <span class="function">longd <span class="title">cross</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span>&amp; rhs)</span> <span class="keyword">const</span></span>;        <span class="comment">// 叉乘模：平行四边形面积</span></span><br><span class="line">    <span class="function">longd <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span></span>;                       <span class="comment">// 向量的模</span></span><br><span class="line">    <span class="function"><span class="built_in">point</span> <span class="title">normal</span><span class="params">()</span> <span class="keyword">const</span></span>;                       <span class="comment">// 单位化向量</span></span><br><span class="line">    <span class="function">longd <span class="title">distance</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span>&amp; b)</span> <span class="keyword">const</span></span>;       <span class="comment">// 到某点的距离</span></span><br><span class="line">    <span class="function">longd <span class="title">distance</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span>&amp; ls,<span class="keyword">const</span> <span class="built_in">point</span>&amp; rs)</span> <span class="keyword">const</span></span>;  <span class="comment">// 到直线ls-rs的距离</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">println</span><span class="params">()</span></span>;                             <span class="comment">// 一行输出坐标</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> R = <span class="number">4000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> r = <span class="number">4000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> r2 = <span class="number">2</span>*r - eps;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2060</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">point</span> p[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">point</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">point</span> <span class="title">calculate</span><span class="params">(<span class="built_in">point</span> a,<span class="built_in">point</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a = a.normal();</span><br><span class="line">    b = b.normal();</span><br><span class="line">    longd angle = <span class="built_in">acos</span>(a*b) / <span class="number">2</span>;    <span class="comment">// 计算夹角的1/2</span></span><br><span class="line">    <span class="built_in">point</span> k = (a+b).normal();       <span class="comment">// 角平分线的单位向量</span></span><br><span class="line">    <span class="keyword">return</span> k * (R / <span class="built_in">sin</span>(angle));    <span class="comment">// 返回满足垂直距离≥R的相对坐标</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">intersect</span><span class="params">(<span class="built_in">point</span>&amp; x,<span class="built_in">point</span>&amp; ls,<span class="built_in">point</span>&amp; rs)</span>    <span class="comment">// 相交（距离不足）返回false</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((ls-x)*(rs-ls) &gt; <span class="number">0</span>) <span class="keyword">return</span> x.distance(ls) &gt;= r-eps; <span class="comment">// x在ls的远端</span></span><br><span class="line">    <span class="keyword">if</span> ((rs-x)*(ls-rs) &gt; <span class="number">0</span>) <span class="keyword">return</span> x.distance(rs) &gt;= r-eps;</span><br><span class="line">    <span class="keyword">return</span> x.distance(ls,rs) &gt;= r-eps;          <span class="comment">// x在直线ls-rs的正上方</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">(<span class="built_in">point</span>&amp; x)</span>     <span class="comment">// 遍历检查点到所有边的距离</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!intersect(x,p[i<span class="number">-1</span>],p[i])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; p[i].x &gt;&gt; p[i].y;</span><br><span class="line">    p[<span class="number">0</span>] = p[n]; p[n+<span class="number">1</span>] = p[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((p[i]-p[i<span class="number">-1</span>]).cross(p[i+<span class="number">1</span>]-p[i]) &gt; <span class="number">0</span>)   <span class="comment">// 跳过多边形的凹角</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">auto</span> tmp = p[i] + calculate(p[i<span class="number">-1</span>]-p[i],p[i+<span class="number">1</span>]-p[i]);   <span class="comment">// 得到绝对位置</span></span><br><span class="line">        <span class="keyword">if</span> (test(tmp)) v.push_back(tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p1 : v) <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p2 : v)</span><br><span class="line">        <span class="keyword">if</span> (p1.distance(p2) &gt;= r2)          <span class="comment">// 判断两个点之间的距离</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">10</span>);</span><br><span class="line">            p1.<span class="built_in">println</span>();</span><br><span class="line">            p2.<span class="built_in">println</span>();</span><br><span class="line">            found = <span class="literal">true</span>; <span class="keyword">goto</span> END;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    END:</span><br><span class="line">    <span class="keyword">if</span>(!found) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">point</span> <span class="built_in">point</span>::<span class="keyword">operator</span> +(<span class="keyword">const</span> <span class="built_in">point</span>&amp; rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> (<span class="built_in">point</span>)&#123;x + rhs.x, y + rhs.y&#125;;&#125;</span><br><span class="line"><span class="built_in">point</span> <span class="built_in">point</span>::<span class="keyword">operator</span> -(<span class="keyword">const</span> <span class="built_in">point</span>&amp; rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> (<span class="built_in">point</span>)&#123;x - rhs.x, y - rhs.y&#125;;&#125;</span><br><span class="line">longd <span class="built_in">point</span>::<span class="keyword">operator</span> *(<span class="keyword">const</span> <span class="built_in">point</span>&amp; rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> x * rhs.x + y * rhs.y;&#125;</span><br><span class="line"><span class="built_in">point</span> <span class="built_in">point</span>::<span class="keyword">operator</span> *(<span class="keyword">const</span> longd rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> (<span class="built_in">point</span>)&#123;rhs * x, rhs * y&#125;;&#125;</span><br><span class="line"><span class="built_in">point</span> <span class="built_in">point</span>::<span class="keyword">operator</span> *(<span class="keyword">const</span> <span class="keyword">double</span> rhs) <span class="keyword">const</span> &#123;<span class="keyword">return</span> (<span class="built_in">point</span>)&#123;rhs * x, rhs * y&#125;;&#125;</span><br><span class="line"><span class="built_in">point</span>&amp; <span class="built_in">point</span>::<span class="keyword">operator</span> +=(<span class="keyword">const</span> <span class="built_in">point</span>&amp; rhs) &#123;x += rhs.x; y += rhs.y; <span class="keyword">return</span> THIS;&#125;</span><br><span class="line"><span class="built_in">point</span>&amp; <span class="built_in">point</span>::<span class="keyword">operator</span> -=(<span class="keyword">const</span> <span class="built_in">point</span>&amp; rhs) &#123;x -= rhs.x; y -= rhs.y; <span class="keyword">return</span> THIS;&#125;</span><br><span class="line"><span class="built_in">point</span>&amp; <span class="built_in">point</span>::<span class="keyword">operator</span> *=(longd rhs) &#123;x *= rhs; y *= rhs; <span class="keyword">return</span> THIS;&#125;</span><br><span class="line"><span class="built_in">point</span>&amp; <span class="built_in">point</span>::<span class="keyword">operator</span> *=(<span class="keyword">double</span> rhs) &#123;x *= rhs; y *= rhs; <span class="keyword">return</span> THIS;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">longd <span class="title">point::cross</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span>&amp; rhs)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> rhs.y * x - rhs.x * y;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">longd <span class="title">point::length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> sqrtl(THIS*THIS);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">point</span> <span class="title">point::normal</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    longd l = <span class="keyword">this</span>-&gt;length();</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">point</span>)&#123;x/l,y/l&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">longd <span class="title">point::distance</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span>&amp; b)</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> (THIS-b).length();&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">longd <span class="title">point::distance</span><span class="params">(<span class="keyword">const</span> <span class="built_in">point</span>&amp; ls,<span class="keyword">const</span> <span class="built_in">point</span>&amp; rs)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fabsl((ls-THIS).cross(rs-THIS))/ls.distance(rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">point::println</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br></pre></td></tr></table></figure><p>想清楚了，套板子出答案也是相对简单的事情；不过就是要想清楚才行。实际赛场上A了这个题目的两支队伍都吃了那么两三发罚时才A的，这个和事后套板子应该还是有很大的差距吧。有一个可能要注意的地方就是：在把圆塞进某个具体的角的时候也要去判断它和其他边的情况——而判断这个实际上还要分情况讨论。细节就是有点多啊==</p><h2 id="b-british-menu">B – British Menu</h2><p>一个比较典型的SCC缩点+DAGdp的题目。如果有板子并且打的比较熟练的话应该能很快的做出来吧，但是可惜我两者都不是。</p><h3 id="题目大意-8">题目大意</h3><p>你去英国旅行，想吃英国菜，但是酒店只给了你一张自助餐餐券；所以你打算今晚往死里吃，尽可能多吃几种菜。但是有的菜连着吃可能会出问题<del>比如温两碗酒，要一份头孢</del>，但是如果把它们分开吃就没毛病。旅游指南告诉了你你可以在吃完一种菜之后吃哪些菜，但是这样的话就难免重复：你发现如果有一种菜可以吃两次，那么它们之间一定不会有超过四种的不同的菜。但是你并不想吃两次一样的菜，所以今晚你应该怎么吃，才能尽可能多的吃到不同的菜？</p><p>换句话说，就是给你一个有向图，途中的每个环最多包含五个不同的节点。然后你要计算出图中不经过相同节点的最长路。</p><p>特别提示：这道题的时空限制是<font color="red">10000ms，512MB</font>。</p><h3 id="分析-8">分析</h3><p>有向有环图，它有环；求最长路，一般要求无环图。怎么样才能做这个题目？有环缩环成点不就有无环图了嘛。怎么缩点呢？那必然是Tarjan法。因为还要求最长路，所以要求出每个SCC内的路的长度——反正最多五个点，怎么玩都行。至于缩成的DAG可以怎么求最长路？拓扑排序啊！……才不是咧，SCC缩成的点可不能和一般的点等量齐观，所以需要DAGdp。那这个题目大概的思路就有了。</p><p>然后就是抄板子→手抖抄错了→WA了然后肉眼扫描→……的死循环（悲）</p><p>官方依然给了题解，所以还是翻译一下：</p><blockquote><ol type="1"><li>这个问题一般来说是 <a href="https://baike.baidu.com/item/NP%E5%AE%8C%E5%85%A8%E9%97%AE%E9%A2%98/4934286?fr=aladdin">NP-complete</a> 的。但是这个问题可通过在DAG中使用DP，在O(n+m)的时间内求解</li><li>由题意可得，图中的每个SCC最多只有五个节点</li><li>所以可以暴力地求出每个SCC内任何两个顶点之间的最长路。O(n!)已经够快了</li><li>将所有的SCC缩成一个点</li><li>现在图变成DAG了，可以DP；需要读取刚才对每个SCC计算的最长路。</li></ol></blockquote><p>大概写代码实现的思路就是这样。因为给了10s，这个算法基本上只要敲对了都能过。</p><h3 id="我的代码-8">我的代码</h3><p>真正的模板题，事后重写也差不多要了我的老命，是时候准备一份优秀的板子了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> same(u,v) (sccId[u]==sccId[v])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> cleanDis() memset(dis,0,sizeof dis)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> V e[c].to</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arrays;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span><span class="keyword">int</span> to,next;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> FrontStar</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> head[N];</span><br><span class="line">    edge e[M];</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Tarjan</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> dfn[N], low[N];</span><br><span class="line">    <span class="keyword">int</span> nextDfn = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">bool</span> instack[N];</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> SCCcomponent</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> sccId[N];       <span class="comment">// 顶点属于的SCC分量</span></span><br><span class="line">    <span class="keyword">int</span> id[N];          <span class="comment">// 顶点在分量内的编号</span></span><br><span class="line">    arrays group[N];    <span class="comment">// SCC分量包含的点</span></span><br><span class="line">    <span class="keyword">int</span> dis[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line">    <span class="keyword">bool</span> visit[N];</span><br><span class="line">    arrays inEdge[N];   <span class="comment">// 分量内的边</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> DAGgraph</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> in[N];</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">int</span> tmp[N], dp[N];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Tarjan;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FrontStar;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> SCCcomponent;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> DAGgraph;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(dfn,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(low,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(sccId, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(id,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(tmp,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(instack,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">bool</span>)*(n+<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">bool</span>)*(n+<span class="number">1</span>));</span><br><span class="line">    tot = <span class="number">-1</span>; cnt = <span class="number">0</span>; nextDfn = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FrontStar;</span><br><span class="line">    e[++tot] = &#123;v,head[u]&#125;;</span><br><span class="line">    head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> U)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Tarjan;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> SCCcomponent;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FrontStar;</span><br><span class="line">    </span><br><span class="line">    dfn[U] = low[U] = nextDfn++;</span><br><span class="line">    s.push(U);</span><br><span class="line">    instack[U] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = head[U];</span><br><span class="line">    <span class="keyword">while</span> (~c)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[V])</span><br><span class="line">        &#123;</span><br><span class="line">            tarjan(V);</span><br><span class="line">            low[U] = <span class="built_in">min</span>(low[U], low[V]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (instack[V])</span><br><span class="line">            low[U] = <span class="built_in">min</span>(low[U], low[V]);</span><br><span class="line">        c = e[c].next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dfn[U] == low[U])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cur, tagId = <span class="number">0</span>;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur = s.top(); s.pop();</span><br><span class="line">            instack[cur] = <span class="literal">false</span>;</span><br><span class="line">            sccId[cur] = cnt;</span><br><span class="line">            group[cnt].push_back(cur);</span><br><span class="line">            id[cur] = ++tagId;</span><br><span class="line">        &#125; <span class="keyword">while</span> (cur != U);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> raw, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> SCCcomponent;</span><br><span class="line">    dis[id[raw]][id[now]] = <span class="built_in">max</span>(dis[id[raw]][id[now]], length);</span><br><span class="line">    visit[now] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> that : inEdge[now])</span><br><span class="line">        <span class="keyword">if</span> (!visit[that]) dfs(that, raw, length + <span class="number">1</span>);</span><br><span class="line">    visit[now] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> DAGgraph;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> SCCcomponent;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FrontStar;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i &lt;= cnt; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!in[i]) q.push(i);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front(); q.pop();</span><br><span class="line">        cleanDis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> node : group[now])</span><br><span class="line">            dfs(node,node,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : group[now])</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> j : group[now])</span><br><span class="line">                tmp[i] = <span class="built_in">max</span>(tmp[i],dp[j]+dis[id[j]][id[i]]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> node : group[now])</span><br><span class="line">            dp[node] = tmp[node];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> U : group[now])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> c = head[U];</span><br><span class="line">            <span class="keyword">while</span> (~c)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!same(U, V))</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[V] = <span class="built_in">max</span>(dp[V], dp[U] + <span class="number">1</span>);</span><br><span class="line">                    --in[sccId[V]];</span><br><span class="line">                    <span class="keyword">if</span> (!in[sccId[V]])</span><br><span class="line">                        q.push(sccId[V]);</span><br><span class="line">                &#125;</span><br><span class="line">                c = e[c].next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> u,v;</span><br><span class="line">    <span class="keyword">while</span> (m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        addedge(u,v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Tarjan;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> SCCcomponent;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> DAGgraph;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> FrontStar;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) tarjan(i);</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;SCC component count: &quot;</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> c = FrontStar::head[i];</span><br><span class="line">        <span class="keyword">while</span> (~c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (same(i, e[c].to))</span><br><span class="line">                inEdge[i].push_back(e[c].to);</span><br><span class="line">            <span class="keyword">else</span> ++in[sccId[e[c].to]];</span><br><span class="line">            c = e[c].next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    topsort();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小　心　全　局　变　量（警觉.jpg）</p><p>好像在ACM里，前向星比起开着氧气的<code>vector</code>并没有太大的优势，写起来还容易出错…… 了解，下次还敢==</p><h2 id="d-driving-in-optimistan">D – Driving in Optimistan</h2><p>光是读题都读了很久才大概看明白的一个题目，比赛时没有做出来。</p><p>意外地，这个题和G题都没有查到好心CSDN博主的解析。</p><h3 id="题目大意-9">题目大意</h3><p>奥普提米斯坦国有很多个港口城镇组成；为了省钱，它们只修了能连接所有港口城镇的必要道路，因此从一处到另一处只有一条路；路上每公里都有一个牌子，包含了当前位置到所有城市的最短距离。这个国家的旅游指南上有一张表，记录了任意两个城市之间的最短距离；问能不能通过这些信息，计算出所有的路牌上的数字的平均值。</p><p>也就是说，给定一棵树所有叶子节点之间的距离，求出每1公里道路上都会放置的路标上写着的距离的平均数。</p><h3 id="分析-9">分析</h3><p>贴一下官方题解的翻译：</p><blockquote><ul><li>直接考虑整个树上的所有标志太难了，只考虑叶节点和交叉点<ol type="1"><li>把每个城市作为一个孤立的节点</li><li>按照距离排序所有的城市点对</li><li>给这两个节点加一个树根，合并两棵子树</li></ol></li><li>对于以r为树根的每个子树T，在以下两种情况下计算穿过r的最短路的平均长度：<ul><li>两个端点都在子树T内时，记为 Ar²</li><li>仅一个端点在子树T内时，记为 Ar¹</li></ul></li><li>这两个值可以通过r的所有孩子的 A¹ 和它们到r的距离来计算</li></ul></blockquote><p>也就是说是一个树上DP…… 且慢，这种讨论方式，之前是不是做过差不多的题目……</p><h3 id="我的代码-9">我的代码</h3><p>还没呢，写完了就给补上（</p><h2 id="g-gotta-nudge-em-all">G – Gotta Nudge ’Em All</h2><p><del>宝可梦GO模拟器</del>一道非常恶毒的题目：恶毒就恶毒在它那巨长的题目以及乱七八糟的规则，光是都题目都能让人觉得恶心的一个题目。校队的朋友应该是没有一个人去尝试这个题目的——我们队也不例外；甚至整个vjudge上只有两年前和三年前有两发AC的提交，当年区域赛似乎也没几个队伍A了这题目…… 直说了，我不想做这个题目==</p><p>估计是为了防止阿克的，但是比赛的时候还是有一支队伍阿克了（</p><h3 id="题目大意-10">题目大意</h3><p>这是一个宝可梦GO模拟器：给你若干条宝可梦的进化链；糖果是游戏中的货币：捉一只宝可梦可得3颗糖果，放一只宝可梦可得1颗糖果，糖果和进化链相关。进化宝可梦花费糖果，且进化高级的宝可梦的花费不低于低级宝可梦的花费；捉一只宝可梦可得100经验，进化一只宝可梦可得500经验；开局有一个道具幸运蛋，在使用它后的1800s内获得的经验翻倍；题目规定只在它生效期间内进化宝可梦；现在给你捕捉宝可梦的时间序列，求可以获得经验的最大值。</p><p>也就是说，给你一个你抓到宝可梦的时间表，然后求出可以最大化你获得的XP的翻倍道具的使用时刻。</p><h3 id="分析-10">分析</h3><p><del>本体最大的难点：英语阅读</del></p><p>别的就不知道啦，刚读完题，还没分析呢// 题解又臭又长也不想翻译== 完事了会贴在这里的</p><h3 id="我的代码-10">我的代码</h3><p>还没呢，写完了就给补上（</p><h2 id="后记">后记</h2><h3 id="一些感想">一些感想</h3><p>就比赛而言，如果真的是简单的签到题就快快委托给代码手，早交早仏== 虽然前期开题确实重要，但是真正比赛应该更加的灵活多变一些；虽然最后我们A了8个题（一般是学弟A的，悲），但是前一个小时只签到了一个题目。这是非常的吃亏的==</p><p>就写代码而言，主要还是准备板子吧。一个题目有成熟的板子和没有成熟的板子差距还是很大的== 然后就是代码手多辛苦，你不行你就别上（指自己WA了签到题），老老实实叫队友来写。真要是心有不甘课后补题，自己多练练啊（）</p><p>就个人而言，写代码能力实在是过于欠缺。下次练习专题也整成私人比赛好了。但是就目前情况来看，三人云练习还是水分很多的，不要被蒙蔽了双眼。</p><p><big>小 心 全 局 变 量</big></p><h3 id="参考资料">参考资料</h3><p>http://clatisus.com/NWERC%202016?tdsourcetag=s_pctim_aiomsg</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Codeforces </tag>
            
            <tag> Gym </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有趣的博客小插件 &amp; 特效</title>
      <link href="/2020/interesting-blog-plugins-i/"/>
      <url>/2020/interesting-blog-plugins-i/</url>
      
        <content type="html"><![CDATA[<h2 id="section"></h2><h3 id="旋转的图片立方体">旋转的图片立方体</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">        <span class="comment">/*最外层容器样式*/</span></span><br><span class="line">        .wrap &#123;</span><br><span class="line">            width: <span class="number">100</span>px;</span><br><span class="line">            height: <span class="number">100</span>px;</span><br><span class="line">            margin: <span class="number">150</span>px;</span><br><span class="line">            position: relative;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*包裹所有容器样式*/</span></span><br><span class="line">        .cube &#123;</span><br><span class="line">            width: <span class="number">50</span>px;</span><br><span class="line">            height: <span class="number">50</span>px;</span><br><span class="line">            margin: <span class="number">0</span> auto;</span><br><span class="line">            transform-style: preserve<span class="number">-3</span>d;</span><br><span class="line">            transform: rotateX(<span class="number">-30</span>deg) rotateY(<span class="number">-80</span>deg);</span><br><span class="line">            animation: rotate linear <span class="number">20</span>s infinite;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        @-webkit-keyframes rotate &#123;</span><br><span class="line">            <span class="keyword">from</span> &#123;</span><br><span class="line">                transform: rotateX(<span class="number">0</span>deg) rotateY(<span class="number">0</span>deg);</span><br><span class="line">            &#125;</span><br><span class="line">            to &#123;</span><br><span class="line">                transform: rotateX(<span class="number">360</span>deg) rotateY(<span class="number">360</span>deg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        .cube div &#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            width: <span class="number">200</span>px;</span><br><span class="line">            height: <span class="number">200</span>px;</span><br><span class="line">            opacity: <span class="number">0.8</span>;</span><br><span class="line">            transition: all <span class="number">.4</span>s;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*定义所有图片样式*/</span></span><br><span class="line">        .pic &#123;</span><br><span class="line">            width: <span class="number">200</span>px;</span><br><span class="line">            height: <span class="number">200</span>px;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        .cube .out_front &#123;</span><br><span class="line">            transform: rotateY(<span class="number">0</span>deg) translateZ(<span class="number">100</span>px);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        .cube .out_back &#123;</span><br><span class="line">            transform: translateZ(<span class="number">-100</span>px) rotateY(<span class="number">180</span>deg);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        .cube .out_left &#123;</span><br><span class="line">            transform: rotateY(<span class="number">-90</span>deg) translateZ(<span class="number">100</span>px);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        .cube .out_right &#123;</span><br><span class="line">            transform: rotateY(<span class="number">90</span>deg) translateZ(<span class="number">100</span>px);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        .cube .out_top &#123;</span><br><span class="line">            transform: rotateX(<span class="number">90</span>deg) translateZ(<span class="number">100</span>px);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        .cube .out_bottom &#123;</span><br><span class="line">            transform: rotateX(<span class="number">-90</span>deg) translateZ(<span class="number">100</span>px);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*定义小正方体样式*/</span></span><br><span class="line">        .cube span &#123;</span><br><span class="line">            display: block;</span><br><span class="line">            width: <span class="number">100</span>px;</span><br><span class="line">            height: <span class="number">100</span>px;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: <span class="number">50</span>px;</span><br><span class="line">            left: <span class="number">50</span>px;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        .cube .in_pic &#123;</span><br><span class="line">            width: <span class="number">100</span>px;</span><br><span class="line">            height: <span class="number">100</span>px;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        .cube .in_front &#123;</span><br><span class="line">            transform: rotateY(<span class="number">0</span>deg) translateZ(<span class="number">50</span>px);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        .cube .in_back &#123;</span><br><span class="line">            transform: translateZ(<span class="number">-50</span>px) rotateY(<span class="number">180</span>deg);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        .cube .in_left &#123;</span><br><span class="line">            transform: rotateY(<span class="number">-90</span>deg) translateZ(<span class="number">50</span>px);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        .cube .in_right &#123;</span><br><span class="line">            transform: rotateY(<span class="number">90</span>deg) translateZ(<span class="number">50</span>px);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        .cube .in_top &#123;</span><br><span class="line">            transform: rotateX(<span class="number">90</span>deg) translateZ(<span class="number">50</span>px);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        .cube .in_bottom &#123;</span><br><span class="line">            transform: rotateX(<span class="number">-90</span>deg) translateZ(<span class="number">50</span>px);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/*鼠标移入后样式*/</span></span><br><span class="line">        .cube:hover .out_front &#123;</span><br><span class="line">            transform: rotateY(<span class="number">0</span>deg) translateZ(<span class="number">200</span>px);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        .cube:hover .out_back &#123;</span><br><span class="line">            transform: translateZ(<span class="number">-200</span>px) rotateY(<span class="number">180</span>deg);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        .cube:hover .out_left &#123;</span><br><span class="line">            transform: rotateY(<span class="number">-90</span>deg) translateZ(<span class="number">200</span>px);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        .cube:hover .out_right &#123;</span><br><span class="line">            transform: rotateY(<span class="number">90</span>deg) translateZ(<span class="number">200</span>px);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        .cube:hover .out_top &#123;</span><br><span class="line">            transform: rotateX(<span class="number">90</span>deg) translateZ(<span class="number">200</span>px);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        .cube:hover .out_bottom &#123;</span><br><span class="line">            transform: rotateX(<span class="number">-90</span>deg) translateZ(<span class="number">200</span>px);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!-- 外层最大容器 --&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;wrap&quot;</span>&gt;</span><br><span class="line">        &lt;!--包裹所有元素的容器--&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;cube&quot;</span>&gt;</span><br><span class="line">            &lt;!--前面图片 --&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;out_front&quot;</span>&gt;</span><br><span class="line">                &lt;img src=<span class="string">&quot;https://i.loli.net/2018/05/03/5aeb0eef73838.jpg&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;pic&quot;</span>&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;!--后面图片 --&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;out_back&quot;</span>&gt;</span><br><span class="line">                &lt;img src=<span class="string">&quot;https://i.loli.net/2018/05/03/5aeb0f2fb9a83.jpg&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;pic&quot;</span>&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;!--左面图片 --&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;out_left&quot;</span>&gt;</span><br><span class="line">                &lt;img src=<span class="string">&quot;https://i.loli.net/2018/05/03/5aeb0f55411f0.jpg&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;pic&quot;</span>&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;!--右面图片 --&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;out_right&quot;</span>&gt;</span><br><span class="line">                &lt;img src=<span class="string">&quot;https://i.loli.net/2018/05/03/5aeb0f79a1124.jpg&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;pic&quot;</span>&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;!--上面图片 --&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;out_top&quot;</span>&gt;</span><br><span class="line">                &lt;img src=<span class="string">&quot;https://i.loli.net/2018/05/03/5aeb0f98a8b66.jpg&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;pic&quot;</span>&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;!--下面图片 --&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;out_bottom&quot;</span>&gt;</span><br><span class="line">                &lt;img src=<span class="string">&quot;https://i.loli.net/2018/05/03/5aeb0fdd51b7e.jpg&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;pic&quot;</span>&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">            &lt;!--小正方体 --&gt;</span><br><span class="line">            &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;in_front&quot;</span>&gt;</span><br><span class="line">                &lt;img src=<span class="string">&quot;https://i.loli.net/2018/05/03/5aeb100223dd0.jpg&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;in_pic&quot;</span>&gt;</span><br><span class="line">            &lt;/span&gt;</span><br><span class="line">            &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;in_back&quot;</span>&gt;</span><br><span class="line">                 &lt;img src=<span class="string">&quot;https://i.loli.net/2018/05/03/5aeb101c2c24b.jpg&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;in_pic&quot;</span>&gt;</span><br><span class="line">            &lt;/span&gt;</span><br><span class="line">            &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;in_left&quot;</span>&gt;</span><br><span class="line">                &lt;img src=<span class="string">&quot;https://i.loli.net/2018/05/03/5aeb1038127b5.jpg&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;in_pic&quot;</span>&gt;</span><br><span class="line">            &lt;/span&gt;</span><br><span class="line">            &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;in_right&quot;</span>&gt;</span><br><span class="line">                &lt;img src=<span class="string">&quot;https://i.loli.net/2018/05/03/5aeb0dce1ca55.jpg&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;in_pic&quot;</span>&gt;</span><br><span class="line">            &lt;/span&gt;</span><br><span class="line">            &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;in_top&quot;</span>&gt;</span><br><span class="line">                &lt;img src=<span class="string">&quot;https://i.loli.net/2018/05/03/5aeb1057bb167.jpg&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;in_pic&quot;</span>&gt;</span><br><span class="line">            &lt;/span&gt;</span><br><span class="line">            &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;in_bottom&quot;</span>&gt;</span><br><span class="line">                &lt;img src=<span class="string">&quot;https://i.loli.net/2018/05/03/5aeb107514579.jpg&quot;</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;in_pic&quot;</span>&gt;</span><br><span class="line">            &lt;/span&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;/div&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 有趣的东西 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 个性化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础知识：单调栈</title>
      <link href="/2020/The-concept-of-monotonous-stack/"/>
      <url>/2020/The-concept-of-monotonous-stack/</url>
      
        <content type="html"><![CDATA[<h2 id="练习题">练习题</h2><h3 id="leetcode---柱状图中的最大矩形">LeetCode - 柱状图中的最大矩形</h3><p>题目地址：<a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" class="uri">https://leetcode-cn.com/problems/largest-rectangle-in-histogram/</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = heights.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> *L = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> *R = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i) &#123;</span><br><span class="line">            <span class="keyword">while</span>(s.<span class="built_in">size</span>() &amp;&amp; heights[s.top()] &gt; heights[i]) &#123;</span><br><span class="line">                R[s.top()] = i;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s.empty()) L[i] = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> L[i] = s.top();</span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty()) &#123;</span><br><span class="line">            R[s.top()] = n;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, tmp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;++i) &#123;</span><br><span class="line">            tmp = heights[i]*(R[i]-L[i]<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(tmp &gt; ans) ans = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> npos (n+1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> h[N],l[N],r[N];</span><br><span class="line">longs ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; &amp;s, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[s.top()] = i;</span><br><span class="line">    s.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; &amp;s, <span class="keyword">int</span> i, <span class="keyword">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(s.<span class="built_in">size</span>()&amp;&amp;a[s.top()]&gt;a[i])pop(s,i);</span><br><span class="line">    <span class="keyword">if</span>(s.empty()) l[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> l[i] = s.top();</span><br><span class="line">    s.push(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&amp;&amp;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;h[i];</span><br><span class="line">            push(s,i,h);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())</span><br><span class="line">            pop(s,npos);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,(longs)h[i]*(r[i]-l[i]<span class="number">-1</span>));</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="洛谷-p4147">洛谷 P4147</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">item</span>&#123;</span><span class="keyword">int</span> w,h;&#125;;      <span class="comment">// w是宽度，h是高度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1050</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">char</span> in;</span><br><span class="line"><span class="keyword">int</span> tmph[N]&#123;<span class="number">0</span>&#125;;             <span class="comment">// 可维持的最好高度</span></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>&lt;item&gt; s;          <span class="comment">// 严格递减的单调栈</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;in;</span><br><span class="line">            <span class="keyword">if</span>(in==<span class="string">&#x27;F&#x27;</span>) ++tmph[j];</span><br><span class="line">            <span class="keyword">else</span> tmph[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> tmpw = <span class="number">0</span>;   <span class="comment">// 可维持的最好宽度</span></span><br><span class="line">            <span class="keyword">while</span>(!s.empty()&amp;&amp;s.top().h&gt;=tmph[j])   <span class="comment">// 可以延长</span></span><br><span class="line">            &#123;</span><br><span class="line">                tmpw += s.top().w;                  <span class="comment">// 外延宽度</span></span><br><span class="line">                ans = <span class="built_in">max</span>(ans,s.top().h*tmpw);</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            s.push(&#123;tmpw+<span class="number">1</span>,tmph[j]&#125;);        <span class="comment">// 增加自己的宽度</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> tmpw = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())   <span class="comment">// 出来时最好高度是严格递减的，均可外延</span></span><br><span class="line">        &#123;</span><br><span class="line">            tmpw += s.top().w;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,s.top().h*tmpw);          <span class="comment">// 反向外延更新答案</span></span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    longs out = <span class="number">3l</span>l*ans;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;out&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="补充练习题">补充练习题</h3><h2 id="参考资料">参考资料</h2><ul><li><a href="https://oi-wiki.org/ds/monotonous-stack/" class="uri">https://oi-wiki.org/ds/monotonous-stack/</a></li><li><a href="https://www.cnblogs.com/ACMSN/p/10738687.html" class="uri">https://www.cnblogs.com/ACMSN/p/10738687.html</a></li><li><a href="https://www.cnblogs.com/1024th/p/10778050.html" class="uri">https://www.cnblogs.com/1024th/p/10778050.html</a></li><li><a href="https://blog.csdn.net/lucky52529/article/details/89155694" class="uri">https://blog.csdn.net/lucky52529/article/details/89155694</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round#622 div.2 回顾</title>
      <link href="/2020/codeforces-round-622-div2/"/>
      <url>/2020/codeforces-round-622-div2/</url>
      
        <content type="html"><![CDATA[<!-- 外部链接：您可以选择[洛谷来源]()或者[vjudge来源]()的 Remote Judge。 --><h2 id="题解">题解</h2><h3 id="a---fast-food-restaurant">A - Fast Food Restaurant</h3><p>题目地址：http://codeforces.com/problemset/problem/1313/A 外部链接：您可以选择<a href="https://www.luogu.com.cn/problem/CF1313A">洛谷来源</a>或者<a href="https://vjudge.net/problem/CodeForces-1313A">vjudge来源</a>的 Remote Judge。</p><p>还是比较简单的一个贪心题。根据题目描述的这个厨师的要求来看，他最多只能为七名客人上不同的菜：就是abc排列组合了。因为优先使用最多的菜式，所以排个序，再单独对七种情况if就可以了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t,a,b,c;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(a&gt;<span class="number">0</span>)++ans,--a;</span><br><span class="line">        <span class="keyword">if</span>(b&gt;<span class="number">0</span>)++ans,--b;</span><br><span class="line">        <span class="keyword">if</span>(c&gt;<span class="number">0</span>)++ans,--c;  </span><br><span class="line">        <span class="keyword">int</span> ar[<span class="number">3</span>] = &#123;a,b,c&#125;;</span><br><span class="line">        sort(ar,ar+<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">if</span>(ar[<span class="number">2</span>]&gt;<span class="number">0</span>&amp;&amp;ar[<span class="number">1</span>]&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            --ar[<span class="number">2</span>];</span><br><span class="line">            --ar[<span class="number">1</span>];</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ar[<span class="number">2</span>]&gt;<span class="number">0</span>&amp;&amp;ar[<span class="number">0</span>]&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            --ar[<span class="number">2</span>];</span><br><span class="line">            --ar[<span class="number">0</span>];</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ar[<span class="number">1</span>]&gt;<span class="number">0</span>&amp;&amp;ar[<span class="number">0</span>]&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            --ar[<span class="number">1</span>];</span><br><span class="line">            --ar[<span class="number">0</span>];</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        a=ar[<span class="number">0</span>];b=ar[<span class="number">1</span>];c=ar[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span>(a&gt;<span class="number">0</span>&amp;&amp;b&gt;<span class="number">0</span>&amp;&amp;c&gt;<span class="number">0</span>)++ans;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最开始犹豫了好久应该怎么实现，，早知道最开始就一部排序贪心就好了，毕竟和abc没什么关系啊……嗒哈哈（）</p><h3 id="b---different-rules">B - Different Rules</h3><p>题目地址：http://codeforces.com/problemset/problem/1313/B 外部链接：您可以选择<a href="https://www.luogu.com.cn/problem/CF1313B">洛谷来源</a>或者<a href="https://vjudge.net/problem/CodeForces-1313B">vjudge来源</a>的 Remote Judge。</p><p>这题目就很有意思：这就是真正的思维题吗？加了诸多的限制条件导致结论并不是那么的显而易见，倒也极大的增加了这个题目的难度（毕竟这题过的人数比C要少……<del>不过也算不上是毒瘤题吧</del></p><p>首先是题目（啊我就翻译了这一个）：</p><blockquote><p><strong>题目描述</strong></p><p>Nikolay最接近开始打算法竞赛了，且获得了一场著名比赛的决赛资格。这次决赛将会有包括Nikolay在内的n个参与者。向其他比赛一样，这场决赛由两轮组成。但是和之前不一样的是，组织者提出了新的规则：假设参赛者A第一轮排名x位，第二轮排名y位，那么参赛者A的总得分是x+y，总排名是总分小于等于A的总分的包括A在内的参赛者的数量。请注意：某些参赛者最后可能会有共同的总体排名。此外，在第一轮和第二轮的比赛中，没有多个参赛者并列的情况（也就是说，对于1~n之间的每个i，每轮比赛中都恰好只有一个人获得第i名）。</p><p>比赛结束后，Nikolay直到他在第一轮获得了第x位，第二轮获得了第y位的成绩。Nikolay不知道其他参赛者的成绩，但是他想知道在最坏和最好的情况下，他可以获得的总排名是多少。请帮助Nikolay解决这个问题。</p><p><strong>输入格式</strong></p><p>第一行包含一个整数t(1≤t≤100)，它是待解决的测试用例数；</p><p>在接下来的ttt行内，每行都包含三个整数n，x，y(1≤n ≤10⁹，1≤x，y≤n)，它们分别是这场决赛的参与者人数、Nikolay在第一轮和第二轮中取得的排名。</p><p><strong>输出格式</strong></p><p>每个测试样例输出两个整数：分别是Nikolay在在这次决赛中可以获得的最高排名和最低排名。</p><p><strong>说明/提示</strong></p><p>对于第一个测试样例的解释：</p><p>设这次比赛的 5 个参与者是 A-E。我们令 Nikolay 为参与者 A。那么对于 Nikolay 来说的最好的情况就是像下表所示的那样：</p><figure><img src="https://cdn.luogu.com.cn/upload/vjudge_pic/CF1313B/872ae8abe0092cf9c803f2ce5c9d62856c59786d.png" class="lazyload" data-srcset="https://cdn.luogu.com.cn/upload/vjudge_pic/CF1313B/872ae8abe0092cf9c803f2ce5c9d62856c59786d.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="第一种情况" /><figcaption aria-hidden="true">第一种情况</figcaption></figure><p>然而，这场比赛的结果也可能是这样：</p><figure><img src="https://cdn.luogu.com.cn/upload/vjudge_pic/CF1313B/4e8a21f342219fd22fa5c953b246140cf0a5e36a.png" class="lazyload" data-srcset="https://cdn.luogu.com.cn/upload/vjudge_pic/CF1313B/4e8a21f342219fd22fa5c953b246140cf0a5e36a.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="第二种情况" /><figcaption aria-hidden="true">第二种情况</figcaption></figure><p>在上述第一种情况，Nikolay 可以取得最高排名：第一位；然而在第二种情况中只能获得第三位。</p></blockquote><p>说白了，比起最简单的最好最坏情况的限制条件就是：</p><ul><li>没有并列情况的出现（其实降低了难度？）</li><li>总得分一致的情况下，玩家的排名尽可能的低</li></ul><p>也就是说，最差的排名在尽可能多的人和他分数相等的时候取到：毕竟总分是有限的，相等的分能够压住玩家，就不要多浪费其他的小分数；最好的排名在尽可能多的人比他的分数大一的时候取到，这样也会尽可能不浪费分数来构造大分。</p><p>在纸上模拟或者脑内模拟，最终得到的结论就是：</p><ul><li>x+y&lt;=n时，最优情况是 1，最差情况是 min(x+y-1,n)。</li><li>x+y&gt;n时，最优情况是 min(x+y-1,n)，最差情况是 n。</li></ul><p>虽然模拟确实也能推导出式子，但是果然还是想要更加科学的解释啊：</p><p>最坏情况就是总得分等于x+y的人数：将一个整数k拆成两个整数的和的情况显然是k-1种。但是这个题目有限制：不能相等，要在参赛人数范围内。没事啊，这x+y-1只会比n大不会比n小，限制边界就行了啊（）</p><p>最好情况略微麻烦一点。刚才说了：如果我们希望某人排名比玩家低，那么最优做法就是让某人分数为x+y+1。进行一下分类讨论：</p><ul><li><p>x+y不比n大：对于任何其他人，若第一轮p位，那么一定可能让他在第二轮排名为x+y+1-p甚至更差，所以此时玩家能得第一。</p></li><li><p>x+y比n大：这就比较的有意思。比玩家高的人是玩家的阻碍，但比玩家低的人可以成为玩家的助力，应当利用。若某人第一轮p位且比玩家最好水平要好，那么就让他第二轮继续p位，从而忽略他。这样做使得问题的规模缩小，且所有剩下的参赛人的排名绝对值变小（但不影响）——直到问题变成一个上面情况的子问题，玩家在剩下来的部分中得第一名：设已经忽略了t人，那么这样的问题规模缩减的边界是(x-t)+(y-t)=n-t，轻松解出t=x+y-n；剩下的部分中玩家第一，那么玩家名次是t+1=x+y-n+1。</p></li></ul><p>呜呼……就是贪心啊，无他==</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">best</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">max</span>(x-n+y+<span class="number">1</span>,<span class="number">1</span>),n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">worst</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(<span class="built_in">max</span>(x+y<span class="number">-1</span>,<span class="number">1</span>),n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t,n,x,y;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;best(n,x,y)&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;worst(n,x,y)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ちくしょう……大家都说就算纸上推导也能画出来为啥我就是模拟不出来啊（）</p><figure><img src="https://i.loli.net/2020/02/28/YQkGXneHmygCTDr.png" class="lazyload" data-srcset="https://i.loli.net/2020/02/28/YQkGXneHmygCTDr.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="TIM图片20200228100516.png" /><figcaption aria-hidden="true">TIM图片20200228100516.png</figcaption></figure><p>哦，我知道了，可以在两场比赛中获得相同的排名，是我大意没有仔细看样例导致想复杂了，草。噫呜呜噫，我要回家（）</p><h3 id="c1---skyscrapers-easy-version">C1 - Skyscrapers (easy version)</h3><p>题目地址：http://codeforces.com/problemset/problem/1313/C1 外部链接：您可以选择<a href="https://www.luogu.com.cn/problem/CF1313C1">洛谷来源</a>或者<a href="https://vjudge.net/problem/CodeForces-1313C1">vjudge来源</a>的 Remote Judge。</p><p>这题后面还有一个困难版本，难就难在n的取值范围变大了好多。这个版本n只有1e3，完全可以n方枚举。显然最终建成的大楼是山包形状的——最高点左侧单调不递减，右侧单调不递增，只是取不同的极大值可能会有不同的结果，找到最大的就好了。</p><p>因为数据范围太小的原因，甚至连极大值都不用找：只是枚举最高点然后向两侧走，更新答案就好了（）</p><p>代码就不贴了，C2再贴好了。</p><p>特别注意，别忘记开<code>long long</code>，这每一栋楼都是1e9，爆<code>int</code>轻而易举。</p><h3 id="c2---skyscrapers-hard-version">C2 - Skyscrapers (hard version)</h3><p>题目地址：http://codeforces.com/problemset/problem/1313/C2 外部链接：您可以选择<a href="https://www.luogu.com.cn/problem/CF1313C2">洛谷来源</a>或者<a href="https://vjudge.net/problem/CodeForces-1313C2">vjudge来源</a>的 Remote Judge。</p><p>根据刚才的分析，这个楼最终盖起来的样子一定是中间有一个峰值，然后两侧的高度分别是方向相反发不严格的两个单调序列。根据刚才说的暴力方法，向两侧行走的时候直到遇到比当前楼层高度低的楼层之后，再更新楼层高度。也就是说，假设第 <span class="math inline">\(i\)</span> 个楼是中心的“峰值”，高度为<span class="math inline">\(h_i\)</span>；先考虑它的左侧 $ k&lt;i $ 是左侧第一个高度低于它的楼；另设<span class="math inline">\(f_i\)</span>是<span class="math inline">\(i\)</span>左侧的楼层的高度和的最大值，那么可以得到这样的推导式：</p><center><span class="math inline">\(f_i = f_k + h_k + h_i \cdot (i-k-1)\)</span></center><p>相应的，对于中心楼层<span class="math inline">\(i\)</span>右侧的第一个小于<span class="math inline">\(i\)</span>的楼<span class="math inline">\(k&gt;i\)</span>，令<span class="math inline">\(f&#39;_i\)</span>是<span class="math inline">\(i\)</span>右侧的楼层的高度和的最大值，也可以得到类似的关系：</p><center><span class="math inline">\(f&#39;_i = f&#39;_k + h_k + h_i \cdot (k-i-1)\)</span></center><p>知道了这个表达式之后，我们就能用比C1中的暴力要快得多的方法求出以i作为峰值时的最高高度总和。那么问题就转化成了我们应该怎么样快速地求出序列中i两侧的第一个小于它的高度的楼层。好在这个问题可以使用一个经典的数据结构<a href="">单调栈</a>来解决。我们先简单的看一下单调栈的定义：</p><blockquote><p><strong>单调栈</strong>：</p><p>顾名思义，单调栈中存放的数据是单调有序的；根据这个次序调栈也分为单调递增栈和单调递减栈</p><ul><li>单调递增栈：数据出栈的序列为单调递增序列</li><li>单调递减栈：数据出栈的序列为单调递减序列</li></ul><p>特别注意：这里所说的递增递减指的是出栈的顺序，而不是在栈中数据的顺序。</p><p>那么，为了维持这个有序性，在<code>push</code>和<code>pop</code>的时候就要检查栈顶元素。根据检查结果还可以方便的构造两个数组 L 和 R，分别储存了当前元素 i 两侧的第一个小于/大于（等于）的元素的序号。这个行为的时间复杂度是 O(n) 的，因为序列中的每一个元素只会入栈一次。</p><p>数组 L 和 R 的具体含义取决于检查栈顶元素使用的运算符：例如，如果你使用<code>&gt;</code>作为判定，那么 L 数组就是第一个小于等于 i 的元素，而 R 数组是第一个小于 i 的元素。应该注意到两个数组的严格单调性不一致。</p></blockquote><p>那么问题就变得简单了起来，我们只需要使用 O(n) 的时间使用单调栈构建出序列的 L 和 R 数组，再根据这两个数组以及上面推出的递推公式完成对每一个位置作为峰值的最好结果的求解，进行比较筛选就能找到最大的值了。再根据最大值出现的位置填写每栋楼的高度输出即可。</p><p>此外，这个题目还有一种使用线段树和分治思想的方法，下次写好了也会在这里补上的。下面是使用单调栈完成的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span>+<span class="number">50</span>;</span><br><span class="line">longs n,m[N];               </span><br><span class="line">longs ans[N];               </span><br><span class="line"><span class="keyword">int</span> l[N],r[N];</span><br><span class="line">longs fl[N],fr[N];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[s.top()] = i;</span><br><span class="line">    s.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!s.empty()&amp;&amp;m[s.top()]&gt;m[i]) pop(i);</span><br><span class="line">    <span class="keyword">if</span>(s.empty()) l[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> l[i] = s.top();</span><br><span class="line">    s.push(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> npos = n+<span class="number">1</span>;</span><br><span class="line">    fl[<span class="number">0</span>] = fl[npos] = <span class="number">0</span>;</span><br><span class="line">    fr[<span class="number">0</span>] = fr[npos] = <span class="number">0</span>;</span><br><span class="line">    m[<span class="number">0</span>] = m[npos] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;m[i];</span><br><span class="line">        push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!s.empty()) pop(npos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,j=n;i&lt;=n;++i,--j)       <span class="comment">// 根据递推式计算</span></span><br><span class="line">    &#123;</span><br><span class="line">        fl[i] = fl[l[i]]+m[i]*(i-l[i]<span class="number">-1</span>)+m[l[i]];</span><br><span class="line">        fr[j] = fr[r[j]]+m[j]*(r[j]-j<span class="number">-1</span>)+m[r[j]];</span><br><span class="line">    &#125;</span><br><span class="line">    longs <span class="built_in">max</span> = <span class="number">0</span>, tmp; <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)               <span class="comment">// 加上m[i]进行比较</span></span><br><span class="line">        <span class="keyword">if</span>((tmp=fl[i]+fr[i]+m[i])&gt;<span class="built_in">max</span>)</span><br><span class="line">            <span class="built_in">max</span> = tmp, pos = i;</span><br><span class="line">    ans[pos] = m[pos];                  <span class="comment">// 填值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=pos<span class="number">-1</span>;i&gt;<span class="number">0</span>;--i)</span><br><span class="line">        ans[i] = <span class="built_in">min</span>(m[i],ans[i+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=pos+<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        ans[i] = <span class="built_in">min</span>(m[i],ans[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日，口口声声的说要开<code>long long</code>结果最后自己也还是忘记了，结果整了好几发WA才搞清楚问题在哪里，甚至还有把i和j混写、下标起始值混乱这种不知道该说什么的错误……我真是服了……啪，我死了== 自裁，请（无慈悲</p><p>虽然说单调栈是一侧严格一侧不严格的去找要求的值，但是似乎在大多数的题目中都不会有影响的。所以大可直接放心的使用。</p><h3 id="d---happy-new-year">D - Happy New Year</h3><p>题目地址：http://codeforces.com/problemset/problem/1313/D 外部链接：您可以选择<a href="https://www.luogu.com.cn/problem/CF1313D">洛谷来源</a>或者<a href="https://vjudge.net/problem/CodeForces-1313D">vjudge来源</a>的 Remote Judge。</p><h3 id="e---concatenation-with-intersection">E - Concatenation with intersection</h3><p>题目地址：http://codeforces.com/problemset/problem/1313/E 外部链接：您可以选择<a href="https://www.luogu.com.cn/problem/CF1313E">洛谷来源</a>或者<a href="https://vjudge.net/problem/CodeForces-1313E">vjudge来源</a>的 Remote Judge。</p><h2 id="后记">后记</h2><h3 id="参考资料">参考资料</h3><ul><li><a href="https://www.cnblogs.com/JHSeng/p/12358750.html" class="uri">https://www.cnblogs.com/JHSeng/p/12358750.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nowcoder 小白月赛22</title>
      <link href="/2020/nowcoder-newbie-contest-22/"/>
      <url>/2020/nowcoder-newbie-contest-22/</url>
      
        <content type="html"><![CDATA[<p>比赛赛题地址：<a href="https://ac.nowcoder.com/acm/contest/4462" class="uri">https://ac.nowcoder.com/acm/contest/4462</a> 按照惯例，开始之前先码了官方题解：<a href="https://ac.nowcoder.com/discuss/369662" class="uri">https://ac.nowcoder.com/discuss/369662</a></p><figure><img src="https://i.loli.net/2020/02/26/aODU3vSekxdzlW5.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/02/26/aODU3vSekxdzlW5.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="TIM图片20200226090513.jpg" /><figcaption aria-hidden="true">TIM图片20200226090513.jpg</figcaption></figure><p>怎么说呢，虽然做题目的情况也并没有多少的改善，但是这次确实就是div3水平== 好多题目都是暴力求解的，姑且在这里简单的提一下，算是一个总结吧。毕竟只有比赛途中自己做出来的题目才算的上是真正会的==</p><h2 id="题解">题解</h2><h3 id="a---操作序列">A - 操作序列</h3><p>题目地址：https://ac.nowcoder.com/acm/contest/4462/A</p><p>看讨论帖子中五花乱坠的平衡树啊、线段树啊……什么的，我只觉得他们吵闹——这个题目并没有涉及到任何的区间变动，完全可以直接STL的map怼上去。只是要注意一点，查询一个不存在的元素会导致它被新建，所以查完了还得把它删掉，不然就比较麻烦。</p><p>官方题解提示了平衡树在线，但是它自己也是拿set做的，和我用map并没有什么本质的区别/// 唯一值得一提的就是读入的时候，因为<code>cin</code>在读取的时候不会自动略过换行符什么的，所以一开始<code>getline</code>容易读到空行。可以直接用循环跳过读入的空行即可。</p><h3 id="b---树上子链">B - 树上子链</h3><p>题目地址：https://ac.nowcoder.com/acm/contest/4462/B</p><p>还算是比较简单的递推关系，题解说这算是DP那就算吧。大概就是每个节点都要查询一次，然后更新一次答案并返回一个最长链供父亲使用的感觉。官方题解说的dp[i]就是要返回的以i节点为根的最长子链，最大值官方题解也是维护了最大和次大的长链求和的，没啥好说的。</p><p>题解大多说这是一个求“树的直径”的问题，是一个没有听说过的名词，所以在这里介绍一下这个定义：</p><blockquote><p><strong>树的直径</strong>：我们将一棵树 T = ( V，E ) 的直径定义为 maxδ ( u，v )，其中 u，v ∈ V。也就是说，树中<u>所有最短路径距离的最大值</u>即为树的直径。</p></blockquote><p>一般这种题目给的是边长，但是这个题目给的是点权，因此做法有略微的差别。经典的求树的直径的做法有两种：BFS/DFS和树形DP。先码一个例题在这里：<a href="http://poj.org/problem?id=1985">POJ 1985</a>。</p><p>搜索方法：先从任意一点P出发，找离它最远的点Q，再从点Q出发，找离它最远的点W，W到Q的距离就是树的直径。正确性的证明可以看下方的引用：</p><blockquote><p><em>原作者： forever_dreams</em> <em>来源： <a href="https://blog.csdn.net/forever_dreams/article/details/81051578" class="uri">https://blog.csdn.net/forever_dreams/article/details/81051578</a></em></p><p><strong>搜索方法的正确性证明</strong>：<br />① 若P已经在直径上，根据树的直径的定义可知Q也在直径上且为直径的一个端点<br />② 若P不在直径上，我们用反证法，假设此时WQ不是直径，AB是直径：</p><p>若AB与PQ有交点C，由于P到Q最远，那么PC+CQ&gt;PC+CA，所以CQ&gt;CA，易得CQ+CB&gt;CA+CB，即CQ+CB&gt;AB，与AB是直径矛盾，不成立，如下图（<u>其中AB，PQ不一定是直线，画成直线是为了方便</u>）：</p><figure><img src="https://i.loli.net/2020/02/26/n3POuACaoU7jDvq.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/02/26/n3POuACaoU7jDvq.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="20180715124201842.jpg" /><figcaption aria-hidden="true">20180715124201842.jpg</figcaption></figure><p>若AB与PQ没有交点，M为AB上任意一点，N为PQ上任意一点。首先还是NP+NQ&gt;NQ+MN+MB，同时减掉NQ，得NP&gt;MN+MB，易知NP+MN&gt;MB，所以NP+MN+MA&gt;MB+MA，即NP+MN+MA&gt;AB，与AB是直径矛盾，所以这种情况也不成立，如下图：</p><figure><img src="https://i.loli.net/2020/02/26/AfZD7erQwuKtn6J.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/02/26/AfZD7erQwuKtn6J.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="20180715145337618.jpg" /><figcaption aria-hidden="true">20180715145337618.jpg</figcaption></figure></blockquote><p>上面的证明排除了可能失败的两种情况，反证了做法的正确性。无论是上述的哪一种情况，都不能确定除了WQ之外的任意直径AB的存在，因此找到的WQ必然是直径。</p><p>树形DP方法：也就是这个题目推荐的做法，每个节点i维护两个值。一个是以i为根的子树中，i到叶子节点的最长链的长度；另一个是同样的条件下，这个长度的次大值。我们将它们记为dp1和dp2数组。</p><p>然后这个值是可以由下而上的推导的，设j是i的儿子，两节点之间路径的长度w[i][j]；具体更新策略是：</p><ul><li>若 dp1 [ i ] &lt; dp1 [ j ] + w [ i ][ j ]，先更新 dp2 [ i ] = dp1 [ i ]，再更新 dp1 [ i ] = dp1 [ j ] + w [ i ][ j ]；</li><li>否则，若 dp2 [ i ] &lt; dp1 [ j ] + w [ i ][ j ]，直接更新 dp2 [ i ] = dp1 [ j ] + w [ i ][ j ]；</li></ul><p>这是很容易理解的：首先假定最长链和次长链和此节点构成了直径，更新最大值；然后再将最大值向上传递。最后的答案就是 ans = max(dp1[i]+dp2[i])。</p><h3 id="c---交换游戏">C - 交换游戏</h3><p>题目地址：<a href="https://ac.nowcoder.com/acm/contest/4462/C" class="uri">https://ac.nowcoder.com/acm/contest/4462/C</a></p><p>真就暴力搜索呗（）预处理所有的情况随便DFS可也太顶了== 不过反正字符串就长度只有12，确实可以为所欲为（）</p><h3 id="d---收集纸片">D - 收集纸片</h3><p>题目地址：<a href="https://ac.nowcoder.com/acm/contest/4462/D" class="uri">https://ac.nowcoder.com/acm/contest/4462/D</a></p><p>10张纸片，不同的顺序也没多少种情况，还是一个因为范围不大所以可以为所欲为的题目。出题人说了，全排列然后找最小值也是能过的，但是也有一些还算是算法的做法：就是使用状压DP的方法的旅行商问题的解法。</p><p>这代码事后补的，直接看还是有点混乱的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rint register int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> longd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> mod[] = <span class="string">&quot;The shortest path has length &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">coord</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>-(<span class="keyword">const</span> coord&amp; c);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t,N,M,n;</span><br><span class="line">coord st,pp[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">20</span>][<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span>&lt;&lt;<span class="number">11</span>][<span class="number">20</span>];  <span class="comment">// dp数组：经过点的状压标记，最后到达的点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;t) <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;N&gt;&gt;M&gt;&gt;st.x&gt;&gt;st.y;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">        pp[<span class="number">0</span>] = st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;pp[i].x&gt;&gt;pp[i].y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;++j)</span><br><span class="line">                dis[i][j]=dis[j][i]=pp[i]-pp[j];</span><br><span class="line">        <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> lim = (<span class="number">1</span>&lt;&lt;n+<span class="number">1</span>)<span class="number">-1</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;    <span class="comment">// 1（1&lt;&lt;0) 是起点</span></span><br><span class="line">        <span class="keyword">for</span>(rint i=<span class="number">1</span>;i&lt;=lim;++i)    <span class="comment">// i是状压标记：记录经过的点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=n;++j)</span><br><span class="line">                <span class="keyword">if</span>(i&gt;&gt;j&amp;<span class="number">1</span>)          <span class="comment">// 找到了一个已经经过了的点j</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=n;++k)</span><br><span class="line">                        <span class="keyword">if</span>(i&gt;&gt;k&amp;<span class="number">1</span>)  <span class="comment">// 再找到一个经过了的点k</span></span><br><span class="line">                            dp[i][j]=<span class="built_in">min</span>(dp[i][j],dp[i^(<span class="number">1</span>&lt;&lt;j)][k]+dis[k][j]);</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0x7fffffff</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)       <span class="comment">// 从每种经过所有点的情况回到起点</span></span><br><span class="line">            ans = <span class="built_in">min</span>(ans,dp[lim][i]+dis[i][<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;mod&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> coord::<span class="keyword">operator</span>-(<span class="keyword">const</span> coord&amp; c)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(x-c.x)+<span class="built_in">abs</span>(y-c.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="g---仓库选址">G - 仓库选址</h3><p>题目地址：<a href="https://ac.nowcoder.com/acm/contest/4462/G" class="uri">https://ac.nowcoder.com/acm/contest/4462/G</a></p><p><strong>温馨提示</strong>：<font color='red'> 本题的C++时间限制是4s </font></p><p>本来还看着是一个非常奇怪的题目，但是给了4s的话就完全可以暴搜了== 当然也可以做一些力所能及的但是没啥x用的优化：比如记录二维前缀和，用贡献差来替换多次的暴搜；也可以利用直观感受，直接查找中位数进行检查。</p><blockquote><p>所有数与中位数的绝对差之和最小。</p></blockquote><p>这里的代码就是查找中位数的版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> longd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> mat[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line">longs row[<span class="number">105</span>],col[<span class="number">105</span>];            <span class="comment">// 行、列的总值</span></span><br><span class="line">longs res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">pair&lt;int,int&gt; midium(int n,int m)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> longs half = res+<span class="number">1</span>&gt;&gt;<span class="number">1</span>;    <span class="comment">// 这儿要+1的</span></span><br><span class="line">    longs tmp; <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>,tmp=<span class="number">0</span>;i&lt;=m,tmp&lt;half;++i)</span><br><span class="line">        tmp += row[i];</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>,tmp=<span class="number">0</span>;j&lt;=n,tmp&lt;half;++j)</span><br><span class="line">        tmp += col[j];</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(--i,--j);      <span class="comment">// for检查会多+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T,n,m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;T)<span class="keyword">while</span>(T--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(row,<span class="number">0</span>,<span class="keyword">sizeof</span>(row));</span><br><span class="line">        <span class="built_in">memset</span>(col,<span class="number">0</span>,<span class="keyword">sizeof</span>(col));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;mat[i][j];</span><br><span class="line">                row[i]+=mat[i][j];</span><br><span class="line">                col[j]+=mat[i][j];</span><br><span class="line">                res+=mat[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">auto</span> mid = midium(n,m);</span><br><span class="line">        <span class="keyword">int</span> &amp;x = mid.first, &amp;y = mid.second;</span><br><span class="line">        longs out = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">                out += mat[i][j]*(<span class="built_in">abs</span>(i-x)+<span class="built_in">abs</span>(j-y));</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;out&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总感觉这题目给人一种既视感，但是又不是很清楚…… 之所以能利用中位数的原因是题目采用的是曼哈顿距离吧。如果距离采用的是直线连接的小数距离的话，这个题目还可以利用中位数来解决吗？曼哈顿距离和直线距离可不是一回事了（</p><h3 id="h---货物种类">H - 货物种类</h3><p>题目地址：<a href="https://ac.nowcoder.com/acm/contest/4462/H" class="uri">https://ac.nowcoder.com/acm/contest/4462/H</a></p><p>题目说区间修改，那就是说要维护一个差分序列；区间操作，只在最后有一次询问，询问少，大概是要用线段树的。一开始以为不能用树状数组，后来寻思了一下应该还是可以用的，只是不能维护max值，需要一次遍历来找出最大值就是了（）。</p><p>但是线段树还是太麻烦了，所以还是直接维护差分数组算了。此处吐槽一下题解的代码，有点小乱（）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> longd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n,m,l,r,d;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mount[N];       <span class="comment">// 装载区间</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; umount[N];      <span class="comment">// 卸载区间</span></span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mounted;       <span class="comment">// 区间重叠</span></span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r&gt;&gt;d;</span><br><span class="line">            mount[l].push_back(d);</span><br><span class="line">            umount[r].push_back(d);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>, <span class="built_in">max</span> = <span class="number">-1</span>, pos = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j : mount[i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!mounted[j])++now;</span><br><span class="line">                ++mounted[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(now&gt;<span class="built_in">max</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">max</span> = now;</span><br><span class="line">                pos = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j : umount[i])</span><br><span class="line">            &#123;</span><br><span class="line">                --mounted[j];</span><br><span class="line">                <span class="keyword">if</span>(!mounted[j])--now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;pos&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次自己写的时候是寻思着合并区间的，然后一次给加上去，再根据差分求出最大值，但是不知道因为什么原因最后WA了…… 于是就因为各种原因<del>懒得一行一行看自己的代码</del>，不再合并区间重新写了一遍，就A了。</p><p>再感慨一下，这map用来当JavaScript中的无限大的稀疏数组实在是太舒服了（）</p><h3 id="i---工具人">I - 工具人</h3><p>题目地址：<a href="https://ac.nowcoder.com/acm/contest/4462/I" class="uri">https://ac.nowcoder.com/acm/contest/4462/I</a></p><p>这题大概就是这次比赛中的毒瘤题吧？明显要用到浮点运算，然后还是一个看起来就很乱的模型…… 整个比赛中途只有个位数的人A了这个题，截止我补题，我才是第十个A了这个题目的人（）</p><p>要说做法倒也毫无新意，就是贪心。不过这次不是光线的距离——这也没法算，而是巧妙地将这个随着距离变化而权重变化的距离变成了到原点的角度范围，然后利用角度范围作为贪心区间。这种贪心的结果显然是确定了起点就确定了，可能会考虑不到跨边界的联合，所以为了保证每一种情况都被考虑到，切换起点进行贪心取最小值就可以做出来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> longd;</span><br><span class="line"><span class="keyword">enum</span> bound &#123;st=<span class="number">0</span>,ed=<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> EPS = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.1415926535897932384626</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI2 = <span class="number">2</span>*PI;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">double</span> angle;</span><br><span class="line">    bound type;</span><br><span class="line"></span><br><span class="line">    ray(<span class="keyword">int</span> n,<span class="keyword">double</span> ag,bound typ);</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> ray &amp;r) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> ray &amp;&amp;r) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t,n,d,x,y;</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;t) <span class="keyword">while</span>(t--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;d;</span><br><span class="line">            <span class="built_in">vector</span>&lt;ray&gt; v;</span><br><span class="line">            longs d2 = d*d;</span><br><span class="line">            longd r2;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">                r2 = x*x+y*y;</span><br><span class="line">                <span class="keyword">if</span>(r2-EPS &lt;= d2) <span class="keyword">continue</span>;      </span><br><span class="line">                longd angle = <span class="built_in">atan2</span>(y,x);</span><br><span class="line">                longd delta = <span class="built_in">asin</span>(d/<span class="built_in">sqrt</span>(r2));</span><br><span class="line">                ++cnt;</span><br><span class="line">                v.emplace_back(cnt,angle-delta,st); <span class="comment">// 原地构造代替 push_back+构造器</span></span><br><span class="line">                v.emplace_back(cnt,angle+delta,ed); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!cnt)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;                  <span class="comment">// 原点周围d内必命中，一次解决</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sort(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>());            <span class="comment">// 逆时针</span></span><br><span class="line">            <span class="keyword">int</span> vs = v.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">int</span> ans = cnt;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vs;++i)               <span class="comment">// 以射线i作为起点，确保了所有可能</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">mark</span><span class="params">(cnt+<span class="number">1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>;</span><br><span class="line">                <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;vs;++j)           <span class="comment">// 贪心：每道光尽可能消灭更多</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">auto</span> &amp;vj = v[(i+j)%vs];</span><br><span class="line">                    <span class="keyword">if</span>(!vj.type)                <span class="comment">// 找到开始边界</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        mark[vj.num] = <span class="literal">true</span>;</span><br><span class="line">                        <span class="built_in">list</span>.push_back(vj.num);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(mark[vj.num])       <span class="comment">// 找到已贪心的关闭边界</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        ++c;                    </span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">auto</span> li : <span class="built_in">list</span>)</span><br><span class="line">                            mark[li] = <span class="literal">false</span>;</span><br><span class="line">                        <span class="built_in">list</span>.<span class="built_in">clear</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                c += <span class="built_in">list</span>.<span class="built_in">size</span>();               <span class="comment">// 可能存在的未关闭节点</span></span><br><span class="line">                <span class="keyword">if</span>(c&lt;ans) ans = c;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ray::<span class="keyword">operator</span>&lt;(<span class="keyword">const</span> ray &amp;r) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fabs</span>(angle-r.angle)&gt;EPS)</span><br><span class="line">        <span class="keyword">return</span> angle &lt; r.angle;</span><br><span class="line">    <span class="keyword">return</span> type &lt; r.type;           <span class="comment">// 开始边界在结束边界前</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ray::<span class="keyword">operator</span>&lt;(<span class="keyword">const</span> ray &amp;&amp;r) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span> &lt; r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ray::ray(<span class="keyword">int</span> n, <span class="keyword">double</span> ag, bound typ)</span><br><span class="line">&#123;</span><br><span class="line">    num = n;</span><br><span class="line">    type = typ;</span><br><span class="line">    angle = <span class="built_in">fmod</span>(ag+PI2,PI2);       <span class="comment">// 转变到[0,2π]范围内</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键就在于想到将距离变成角度。也许……起到了开拓思维的作用？第一次写的时候使用不太熟练的C++简化构造器炸了，所以写代码还是少搞这些没用的东西==</p><h2 id="签到题">签到题</h2><p>本次的签到题是E题、F题和J题。特别要注意的是J要手打高精度，应当注意细节。</p><h2 id="后记">后记</h2><p>怎么说呢，不是暴力就是简单题。但是做题的那个状态下还真就不一定能做的出来== I题算是一个比较有点思维的题目，代码实现也应当更加谨慎。很多题目还是要多参考参考数据范围，万一暴搜行呢（捂脸）</p><h3 id="参考链接">参考链接</h3><p>树的直径部分：<a href="https://blog.csdn.net/forever_dreams/article/details/81051578" class="uri">https://blog.csdn.net/forever_dreams/article/details/81051578</a></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Nowcoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础知识：树状数组</title>
      <link href="/2020/The-concept-of-binary-indexed-tree/"/>
      <url>/2020/The-concept-of-binary-indexed-tree/</url>
      
        <content type="html"><![CDATA[<p>没错，是我。练习时长两年半的个人练习生又出来丢人了==</p><p>呜呼！一直以来都以为树状数组就是二叉树的数组表示，然后做题的时候感觉越来越不对劲——我印象里树状数组可没有这么多方便的性质和功能啊？这题目怎么就树状数组呢？但是因为懒惰就一直得过且过，尽可能忽略的都忽略了……直到矛盾爆发的今天：我读了一个自称树状数组的题目，结果发现我并不能读得懂它的代码== 才发觉大事不妙，该学了（）</p><figure><img src="https://i.loli.net/2020/02/20/b6L2P5HpaTMlVg7.png" class="lazyload" data-srcset="https://i.loli.net/2020/02/20/b6L2P5HpaTMlVg7.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="202002202155511.png" /><figcaption aria-hidden="true">202002202155511.png</figcaption></figure><p>不知道树状数组这个东西在我的那些纸质书籍里有没有记载，现在这篇文章就是基于网上可以查到的公开资料整理写成的。如果之后看了书有新的收获再在这里补充就好了。</p><p>本文出现的图片大多来自互联网。</p><h2 id="定义">定义</h2><p>首先先看一下来自<a href="https://baike.baidu.com/item/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/313739?fr=aladdin">百度百科</a>的树状数组的定义：</p><blockquote><p><strong>树状数组</strong>(Binary Indexed Tree(B.I.T), Fenwick Tree)是一个查询和修改复杂度都为<span class="math inline">\(log(n)\)</span>的数据结构。主要用于查询任意两位之间的所有元素之和，但是每次只能修改一个元素的值；经过简单修改可以在<span class="math inline">\(log(n)\)</span>的复杂度下进行范围修改，但是这时只能查询其中一个元素的值(如果加入多个辅助数组则可以实现区间修改与区间查询)。</p></blockquote><h3 id="特点">特点</h3><ul><li>复杂度：查询和修改的时间复杂度都是<span class="math inline">\(log(n)\)</span>，空间复杂度则为<span class="math inline">\(O(n)\)</span>。</li><li>用途：通常用来高效的计算数列的前缀和，区间和，和线段树有点像。</li><li>可解决的问题：可以解决大部分基于区间上的更新以及求和问题。</li><li>缺陷：比起线段树来说，在遇到复杂的区间问题还是不能解决。所以说该上线段树还是得上==</li><li>解题时，应当<strong>优先</strong>考虑使用树状数组，再考虑使用线段树。</li></ul><h3 id="渐近式理解">渐近式理解</h3><p>关于二叉树、线段树和树形数组的理解大概可以简单归纳成这样：</p><table><colgroup><col style="width: 27%" /><col style="width: 33%" /><col style="width: 38%" /></colgroup><thead><tr class="header"><th style="text-align: center;">二叉树</th><th style="text-align: center;">线段树</th><th style="text-align: center;">树状数组</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">就是二叉树啊，一个爸爸两个儿子，儿子可能还有儿子，这样形成的一个结构啊。</td><td style="text-align: center;">如果每个爸爸都存两个儿子的值，就可以方便一些区间问题的解决了。</td><td style="text-align: center;">比起线段树又删去了一部分节点，这样子就可以使用数组建树了。</td></tr></tbody></table><h3 id="图示">图示</h3><p>然后我就在网上找了个树状数组的图，它长这样：</p><p><img src="https://i.loli.net/2020/02/20/kLTcx6GNIXMeqwu.png" class="lazyload" data-srcset="https://i.loli.net/2020/02/20/kLTcx6GNIXMeqwu.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="1564195-20190316205027088-1794315300.png" /> <!-- ![树状数组的图示](https://img2018.cnblogs.com/blog/1564195/201903/1564195-20190316205027088-1794315300.png) --></p><p>这里的A数组就是原来的数组，C数组就是利用这个数组构建的树状数组。可以看出A数组和C数组的节点数是一样的。但是和原数组不同的是，树状数组的每个节点存储的是在这个意义上它的子节点的值和。也就是： <!-- <center>$$</center> --> <span class="math display">\[\begin{align}C_1\ &amp;=\ A_1 \\C_2\ &amp;=\ A_1 + A_2 \\C_3\ &amp;=\ A_3 \\C_4\ &amp;=\ A_1 + A_2 + A_3 + A_4 \\C_5\ &amp;=\ A_5 \\C_6\ &amp;=\ A_5 + A_6 \\C_7\ &amp;=\ A_7 \\C_8\ &amp;=\ A_1 + A_2 + A_3 + A_4 + A_5 + A_6 + A_7 + A_8 \\C_9\ &amp;=\ A_9\end{align}\]</span></p><p>可以发现C数组的取值是有规律的：<span class="math inline">\(C_i=A_{i-2^k+1}+A_{i-2^k+2}+\cdots+A_i\)</span>。这里公式里的k就是i的二进制中从最低位到高位连续零的长度。</p><p>光是这么说还是比较的混乱，那么我们先引入<code>lowbit</code>的概念：</p><blockquote><p><strong>lowbit</strong>： 数字二进制表示的最低1所在位的值。</p><p>它的实现是<code>#define lowbit(x) (x&amp;-x)</code>，返回数字x的二进制表示的最低位的二进制1所在的位置所代表的值。<br />特别地，有<code>lowbit(0) = 0</code>。这样的时候可能会死循环，所以写成函数再加上一个判断会好一些。事实上0就是边界。</p></blockquote><p><code>lowbit</code>返回的值只有一个二进制数字位是1，所以显然它是2的幂。这真的是一个非常巧妙的实现。我是不知道先辈是怎么想出来的，但是又过于理所应当所以不详细解释了。</p><p><del>天呐之前写<code>lowbit</code>竟然还是循环加移位，太蠢了我死了</del></p><p><del>如果不知道原码补码反码我就说一下</del></p><blockquote><p>整数的最高位是符号位，0是正数，1是负数；其他的是数字位。<br />正整数的原码，反码和补码都是这个数字的二进制表示。<br />负整数的原码的数字位和相对应的正整数是一样的，只是符号位是1；它的反码就是数字位全部取反，补码就是反码加上二进制1.</p></blockquote><p>这样，我们就知道刚才的公式里的k其实是满足这样的关系的：<span class="math inline">\(lowbit(x) = 2^k\)</span>。那么也就是说上面的公式说明了：C数组的每个节点（假设位置i）的值等于从A数组上它的位置开始向前数<code>lowbit(i)</code>个节点的值的和。这也就是树状数组的性质：<span class="math inline">\(C_i = \sum_{j=i+1-lowbit(i)}^{i} A_j\)</span>，已经知道了<code>lowbit(i)</code>是位置i的最大的是2的幂的因子。</p><h2 id="构建树状数组">构建树状数组</h2><p>从上面的基本定义已经可以了解到C数组的指定位置的值的求法。C数组的节点可能包含多个A数组节点的值，相应地A数组的一个节点可能会被多个C数组的节点包含。在这个基础上就可以介绍对树状数组的一些操作了：</p><h3 id="节点修改">节点修改</h3><p>因为A数组的节点可能被多个C数组的节点包含，所以更新的时候要把这些都考虑到。因为<span class="math inline">\(C_i = \sum_{j=i+1-lowbit(i)}^{i} A_j\)</span>，所以<span class="math inline">\(A_k\)</span>会被$C_j j kJ_iN J_1 = k, J_i = J_{i-1} + lowbit(J_{i-1}) $更新A节点的代码大概长这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">1</span>) <span class="keyword">return</span>;    <span class="comment">// 在数组外</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= N)        <span class="comment">// N 指数组长度</span></span><br><span class="line">    &#123;</span><br><span class="line">        C[i] += x;</span><br><span class="line">        i += lowbit(i);   <span class="comment">// 向上找爹爹</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就可以在已知A数组的情况下构建出树状数组C了，大概这么做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span>      <span class="comment">// 一般不写成函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)</span><br><span class="line">        add(i,A[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是无后效的在线算法，所以可以一边输入一边构建。事实上一般解题过程中就是这么做的。</p><h3 id="节点查询">节点查询</h3><p>因为并不是每个节点都包含了在自己前面所有节点的值，所以当需要查询前缀和的时候，仍然需要向前推进。下面的<code>query(int):int</code>函数返回的是原数组在区间[1,p]上的前缀和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res += C[p];</span><br><span class="line">        p -= lowbit(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 或者也可以写成这个样子 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=p;i;i-=i&amp;-i)</span><br><span class="line">        res += C[p];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然可以求出前缀和，那么也可以简单的利用前缀和求出区间的和：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> query(r)-query(l<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是单点更新的树状数组的两项基本操作了。但是当题目要求更新区间内的所有值时，它的优势就不那么明显了。</p><h2 id="树状数组的变式">树状数组的变式</h2><p>上面说到的树状数组是最普通的单点更新的树状数组，它可以在<span class="math inline">\(O(log(n))\)</span>的时间内更新单个节点的值，或者计算出区间和。但是如果数组的更新形式不是单点更新而是区间更新，这样的树状数组就没那么好用了，需要进行一些变换才好。</p><p><del>毕竟，高级树状数组即使是在很大的范围也可以进行局部优化降低复杂度的……我不会就是了</del></p><h3 id="区间修改节点查询">区间修改+节点查询</h3><p>这里的修改区间指的是将原数组的某个区间内的每个值都增加x。这样的操作如果是在单点更新的树状数组中，就只能遍历更新区间内的每一个值，复杂度达到<span class="math inline">\(O(nlog(n))\)</span>，这是不好的。</p><p>一种改进的方法就是不再根据数据的值建树，转而引入差分，利用差分建树。</p><p><del>那么差分是什么呢，赶紧<a href="https://baike.baidu.com/item/%E5%B7%AE%E5%88%86/10349967?fr=aladdin">百度百科</a>一下</del></p><blockquote><p><strong>差分</strong>： 又名差分函数或差分运算，差分的结果反映了离散量之间的一种变化，是研究离散数学的一种工具。它将原函数<span class="math inline">\(f(x)\)</span>映射到<span class="math inline">\(f(x+a)-f(x+b)\)</span> 。差分对应离散，微分对应连续。差分又分为前向差分、向后差分及中心差分三种。</p><p><strong>差分算子</strong>： 设y依赖于自变量t，当t变化量为1时因变量y的改变量记为<span class="math inline">\(Dy_1\)</span>，称为函数<span class="math inline">\(y(t)\)</span>在点t处步长为1的(一阶)差分。</p><p>所谓前向/后向/中心差分就是这个变化量的方向不同。对原序列进行差分计算可以得到长度相等（或长度大一）的<strong>差分序列</strong>。它有着这样的性质：</p><ul><li>对差分序列求前缀和可以降低差分序列的阶数，最终得到原序列。</li><li>原序列[L,R]区间内值+x等价于差分序列中，L处+x，R+1处-x。</li></ul></blockquote><p>在了解差分的基础上，我们规定A₀=0，前向差分序列为数组D。也就是说<span class="math inline">\(D_j=A_j-A_{j-1}\)</span>。根据上面说到的性质，我们可以得到以下的关系：</p><ul><li>查询：<span class="math inline">\(A_i = \sum_{j=1}^i D_j\)</span></li><li>修改：<span class="math inline">\(A_{L\to R}+x \Leftrightarrow D_L+x,D_{R+1}-x\)</span></li></ul><p>这样的差分序列有一个巨大的优势：修改一个区间就仅需要修改区间的上下界的两个值。所以为了加速区间的修改，我们可以利用这个性质对D数组建立树状数组，就可以方便区间修改了。</p><p>综上所述，如果要进行修改和查询，可以写出这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p &lt;= N)</span><br><span class="line">    &#123;</span><br><span class="line">        D[p] += x;</span><br><span class="line">        p += p&amp;-p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add(l,x);</span><br><span class="line">    <span class="keyword">if</span> (r&lt;N) add(r+<span class="number">1</span>,x);  <span class="comment">// 可以不判断</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> i)</span>            <span class="comment">// 差分前缀和，即A[i]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i)</span><br><span class="line">    &#123;</span><br><span class="line">        res += D[i];</span><br><span class="line">        i -= i&amp;-i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这里的树状数组D是根据原数组A的一阶差分序列而构建的，所以构建时的输入应该是A数组两个元素的差：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span>      <span class="comment">// 依然是在线算法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;++i)</span><br><span class="line">        add(i,A[i]-A[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，更新的过程被大大的简化，依然可以在<span class="math inline">\(O(log(n))\)</span>的复杂度完成区间的更新和单点查询。但是这也导致了这样的树状数组不能快速的查询区间内值的和。</p><h3 id="区间修改区间查询">区间修改+区间查询</h3><p>如果问题模型既有大量的区间修改又有大量的区间查询怎么办？这样的情况似乎即使是上面的那种树状数组也不是很够用。在开始之前我们先考虑上面说的差分数组，显然有：</p><center><span class="math inline">\(\sum_{i=1}^nA_i=\sum_{i=1}^n\sum_{j=1}^iD_j\)</span></center><p>也就是说：</p><center><span class="math inline">\(\sum_{i=1}^nA_i=\sum_{i=1}^n (n+1-i)D_i\)</span></center><center><span class="math inline">\(=n\sum_{i=1}^nD_i-\sum_{i=1}^n(i-1)D_i\)</span></center><p>只要知道了<span class="math inline">\(\sum_{i=1}^nD_i\)</span>和<span class="math inline">\(\sum_{i=1}^n(i-1)D_i\)</span>，就可以求出A数组的前缀和。而这两个表达式本身都是前缀和。前缀和可以通过维护树状数组方便的求出。所以这次需要分别对D数组和与D数组相关的乘积进行树状数组维护。</p><p>因为两个数组都是和D数组相关，可以整到一起一并处理。设乘积的树状数组是sum数组，那代码大概就可以写成下面这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">int</span> x)</span>  <span class="comment">// 传入A的差分序列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = p<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &lt;= N)</span><br><span class="line">    &#123;</span><br><span class="line">        D[p] += x;</span><br><span class="line">        sum[p] += k*x;</span><br><span class="line">        p += p&amp;-p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> p)</span>       <span class="comment">// 查询A数组的前缀和</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, k = p;</span><br><span class="line">    <span class="keyword">while</span> (p)</span><br><span class="line">    &#123;</span><br><span class="line">        res += k*D[p]-sum[p];</span><br><span class="line">        p -= p&amp;-p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> i)</span>         <span class="comment">// 查询A数组节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i)</span><br><span class="line">    &#123;</span><br><span class="line">        res += D[i];</span><br><span class="line">        i -= i&amp;-i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    add(l,x);</span><br><span class="line">    add(r+<span class="number">1</span>,x);         <span class="comment">// 做题时数组开大点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> query(r)-query(l<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的树状数组就既可以满足区间修改的需要，也可以快速的进行区间查询和节点查询了。大多数的问题都可以使用这样的树状数组来解决吧。</p><h2 id="对比线段树">对比线段树</h2><p>最开始的时候就提到了。树状数组思想上继承自线段树，两者极为相似，但是树状数组的空间复杂度比线段树要小，并且实现更加的简单容易。但是作为代价，它的使用范围比线段树是要小的。</p><h3 id="树状数组的优劣">树状数组的优劣</h3><p>树状数组的优势：空间复杂度略低，编程复杂度低，容易扩展到多维情况。<br />比线段树的劣势：适用范围小，对可以进行的运算也有限制。</p><p><del>等我知道了再完善这一部分</del></p><h3 id="实现的对比">实现的对比</h3><p>这里为了对线段树和全功能一维树状数组的实现进行对比，先简单的介绍以下线段树的几大基本操作的实现：</p><table><thead><tr class="header"><th>操作</th><th>线段树实现描述</th><th>树状数组实现描述</th></tr></thead><tbody><tr class="odd"><td>构造</td><td>使用递归，每次递归二分，直到区间[l,r]缩为一个点。</td><td>在线构建</td></tr><tr class="even"><td>单点修改</td><td>向下找到包含的节点，并全部修改</td><td>使用<code>lowbit</code>找爸爸，修改所有包含。</td></tr><tr class="odd"><td>单点查询</td><td>自上而下一直搜索到目标节点，将路径上的节点值求和即可</td><td>传统树状数组可直接查询，或求差分序列的前缀和</td></tr><tr class="even"><td>区间查询</td><td>在每一个节点（区间），若完全包含就加上，否则递归不完全的区间。</td><td>使用<code>lowbit</code>向前直到完成计算前缀和，之后使用前缀和计算区间和</td></tr><tr class="odd"><td>区间修改</td><td>和查询类似，完全包含的区间就直接加上，否则就递归直到找到完全包含。</td><td>如果是差分序列的树状数组，就仅需对区间两端进行修改就可以满足。</td></tr></tbody></table><p>上述线段树基本操作的实现如下，一般来说用来表示线段树的数组的大小是原数组的<strong>四倍</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义线段树节点结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,v;    <span class="comment">// 区间和数值</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ispoint</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> l==r;&#125;</span><br><span class="line">&#125; t[<span class="number">4</span>*N];         <span class="comment">// 线段树数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 构建线段树： 从根[1~n]开始 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[i].l = l;</span><br><span class="line">    t[i].r = r;</span><br><span class="line">    <span class="keyword">if</span> (l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(l,m,i&lt;&lt;<span class="number">1</span>);</span><br><span class="line">    build(m+<span class="number">1</span>,r,(i&lt;&lt;<span class="number">1</span>)^<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线段树单点修改： A[p]+=k */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> p, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    t[i].v += k;</span><br><span class="line">    <span class="keyword">if</span> (t[i].ispoint()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= t[i&lt;&lt;<span class="number">1</span>].r)</span><br><span class="line">        add(i&lt;&lt;<span class="number">1</span>,p,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p &gt;= t[(i&lt;&lt;<span class="number">1</span>)^<span class="number">1</span>].l)</span><br><span class="line">        add((i&lt;&lt;<span class="number">1</span>)^<span class="number">1</span>,p,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线段树区间查询： ΣA[l~r]的值 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[i].l &gt;= l &amp;&amp; t[i].r &lt;= r)</span><br><span class="line">        <span class="keyword">return</span> t[i].v;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= t[i&lt;&lt;<span class="number">1</span>].r)</span><br><span class="line">        res += query(i&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">if</span> (r &gt;= t[(i&lt;&lt;<span class="number">1</span>)^<span class="number">1</span>].l)</span><br><span class="line">        res += query((i&lt;&lt;<span class="number">1</span>)^<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线段树区间修改： A[l~r]+=k */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t[i].l &gt;= l &amp;&amp; t[i].r &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        t[i].v += k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= t[i&lt;&lt;<span class="number">1</span>].r)</span><br><span class="line">        add(i&lt;&lt;<span class="number">1</span>,l,r,k);</span><br><span class="line">    <span class="keyword">if</span> (r &gt;= t[(i&lt;&lt;<span class="number">1</span>)^<span class="number">1</span>].l)</span><br><span class="line">        add((i&lt;&lt;<span class="number">1</span>)^<span class="number">1</span>,l,r,k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线段树单点查询： A[p]的值 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ask</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = t[i].v;</span><br><span class="line">    <span class="keyword">if</span> (t[i].ispoint()) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="keyword">if</span> (p &lt;= t[i&lt;&lt;<span class="number">1</span>].r)</span><br><span class="line">        res += ask(i&lt;&lt;<span class="number">1</span>,p);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p &gt;= t[(i&lt;&lt;<span class="number">1</span>)^<span class="number">1</span>].l)</span><br><span class="line">        res += ask((i&lt;&lt;<span class="number">1</span>)^<span class="number">1</span>,p);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的实现只是最基础的线段树实现，并没有引入延迟标记之类的优化。如果要使用线段树还应该使用别的板子。</p><h2 id="总结">总结</h2><p>简单的一维树状数组大概就是上面说到的三种。它们的特点简单整理为下表：</p><table><thead><tr class="header"><th>类型</th><th>简介</th><th>树状数组</th><th>ask</th><th>query</th><th>add</th></tr></thead><tbody><tr class="odd"><td>单点修改</td><td>传统的树状数组，可以快速求出前缀和区间和</td><td>基于A维护C</td><td>直接返回A[i]</td><td>返回A的前缀和</td><td>更新指定节点</td></tr><tr class="even"><td>区间修改</td><td>可以快速的修改区间的值，但不支持快速求出原数组的前缀和</td><td>基于A的差分维护D</td><td>返回A的差分的前缀和</td><td>-</td><td>更新区间首尾节点</td></tr><tr class="odd"><td>区间查询</td><td>既可以快速修改区间，也可以快速区间查询</td><td>基于A的差分维护D，以及一个乘积的sum</td><td>返回A的差分的前缀和</td><td>根据推导公式返回</td><td>更新区间首尾节点</td></tr></tbody></table><h2 id="二维树状数组">二维树状数组</h2><p>在和线段树做对比的时候提到了树状数组更容易扩展到多维情况，那这里就简单地提一下多维情况下的树状数组。此时，它的复杂度是<span class="math inline">\(O(log^kn)\)</span>。</p><h2 id="练习题">练习题</h2><p>这里列了几个网上看到的出现的比较多的板子题。等我写完了就会把代码放上来的。</p><h3 id="洛谷-p3374">洛谷 P3374</h3><p>题目链接：<a href="https://www.luogu.com.cn/problem/P3374" class="uri">https://www.luogu.com.cn/problem/P3374</a></p><h3 id="洛谷-p3368">洛谷 P3368</h3><p>题目链接：<a href="https://www.luogu.com.cn/problem/P3368" class="uri">https://www.luogu.com.cn/problem/P3368</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">tree_array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt; c, d;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> uint <span class="title">lowbit</span><span class="params">(uint x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> x &amp; -x;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(uint i, T x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        uint ii = i, siz = c.size();</span><br><span class="line">        <span class="keyword">while</span> (ii &lt; siz)</span><br><span class="line">        &#123;</span><br><span class="line">            c[ii] += x, d[ii] += x * i;</span><br><span class="line">            ii += lowbit(ii);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">sum</span><span class="params">(uint i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T ret = <span class="number">0</span>; uint ii = i;</span><br><span class="line">        <span class="keyword">while</span> (ii)</span><br><span class="line">        &#123;</span><br><span class="line">            ret += (i + <span class="number">1</span>) * c[ii] - d[ii];</span><br><span class="line">            ii -= lowbit(ii);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    tree_array() = <span class="keyword">default</span>;</span><br><span class="line">    explicit tree_array(uint n) : c(n + 1), d(n + 1) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(uint n)</span> </span>&#123;c.resize(n + <span class="number">1</span>), d.resize(n + <span class="number">1</span>);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(uint l, uint r, T x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;add(l, x); add(r + <span class="number">1</span>, -x);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">ask</span><span class="params">(uint l, uint r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> sum(r) - sum(l - <span class="number">1</span>);&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, x; <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">tree_array&lt;longs&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;<span class="built_in">cin</span> &gt;&gt; x; a.add(i, i, x);&#125;</span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> op, y, k;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; op &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; y &gt;&gt; k;</span><br><span class="line">            a.add(x, y, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; a.ask(x, x) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UPD: 2021-3-26 已验证板子的正确性；</p><h3 id="洛谷-p3431">洛谷 P3431</h3><p>题目链接：<a href="https://www.luogu.com.cn/problem/P3431" class="uri">https://www.luogu.com.cn/problem/P3431</a></p><h3 id="hdu---1166">HDU - 1166</h3><p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=1166" class="uri">http://acm.hdu.edu.cn/showproblem.php?pid=1166</a><br />外挂链接：<a href="https://vjudge.net/problem/HDU-1166" class="uri">https://vjudge.net/problem/HDU-1166</a></p><h3 id="poj---3468">POJ - 3468</h3><p>外挂链接：<a href="https://vjudge.net/problem/POJ-3468" class="uri">https://vjudge.net/problem/POJ-3468</a></p><h3 id="poj---2155">POJ - 2155</h3><p>外挂链接：<a href="https://vjudge.net/problem/POJ-2155" class="uri">https://vjudge.net/problem/POJ-2155</a></p><h3 id="ural---1470">URAL - 1470</h3><h3 id="补充练习题">补充练习题</h3><p>如果有好的练习题可以联系我补在这里~</p><h2 id="参考资料">参考资料</h2><ul><li><a href="https://www.cnblogs.com/lyp-Bird/p/10544435.html" class="uri">https://www.cnblogs.com/lyp-Bird/p/10544435.html</a></li><li><a href="https://baike.baidu.com/item/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/313739?fr=aladdin" class="uri">https://baike.baidu.com/item/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/313739?fr=aladdin</a></li><li><a href="https://www.cnblogs.com/xenny/p/9739600.html" class="uri">https://www.cnblogs.com/xenny/p/9739600.html</a></li><li><a href="https://www.zhihu.com/question/54404092" class="uri">https://www.zhihu.com/question/54404092</a></li><li><a href="https://zhuanlan.zhihu.com/p/46699931" class="uri">https://zhuanlan.zhihu.com/p/46699931</a></li><li><a href="https://www.cnblogs.com/--lr/p/9345779.html" class="uri">https://www.cnblogs.com/--lr/p/9345779.html</a></li><li><a href="https://blog.csdn.net/bestsort/article/details/80796531" class="uri">https://blog.csdn.net/bestsort/article/details/80796531</a></li><li><a href="https://bestsort.cn/2019/04/26/195/" class="uri">https://bestsort.cn/2019/04/26/195/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本的图论算法</title>
      <link href="/2020/Basic-graph-theory-algorithm/"/>
      <url>/2020/Basic-graph-theory-algorithm/</url>
      
        <content type="html"><![CDATA[<p>图论是一位同级的计科老哥做的介绍，简单的总结一下他上课提到的这些图论算法以及问题。大概这也就是差不多要准备的模板吧，下面是自己总结的他的一个思路，本文也会根据这个思路来组织内容：</p><figure><img src="https://cdn.jsdelivr.net/gh/ymd45921/util_assets@master/image/post/wjhppt.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ymd45921/util_assets@master/image/post/wjhppt.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="培训内容 - 图论" /><figcaption aria-hidden="true">培训内容 - 图论</figcaption></figure><h2 id="最小生成树">最小生成树</h2><h3 id="定义补足">定义补足</h3><h3 id="prim-算法">Prim 算法</h3><h3 id="kruskal-算法">Kruskal 算法</h3><h3 id="题型">题型</h3><h4 id="树形dp">树形DP</h4><h4 id="lca-倍增">LCA /倍增</h4><h2 id="最短路问题">最短路问题</h2><p>最短路算法应该是整个图论算法体系中使用的最频繁的一类算法吧，大体就是有三种比较常见的算法，它们有各自的特点，但是一般使用是后两者居多。为了熟悉这三个算法大概我是写了<a href="https://www.luogu.com.cn/problem/P3371">洛谷P3371</a>这个题目，分别使用了这三种方法来写。</p><h3 id="floyd-算法">Floyd 算法</h3><h3 id="dijkstra-算法">Dijkstra 算法</h3><h3 id="spfa-算法">SPFA 算法</h3><h2 id="强连通和双连通">强连通和双连通</h2><h2 id="二分图匹配">二分图匹配</h2><p><del>这一部分的东西看之前的代码渐渐魔怔了</del></p><h3 id="匈牙利算法">匈牙利算法</h3><p>说这个之前先提一下二分图的一个性质：</p><blockquote><p><strong>König定理</strong>：</p><p>二分图中，<strong>最小覆盖点数 = 最大匹配数</strong>。这里的最小点覆盖指的是，对于二分图找到最少的一些点，使二分图所有的边都至少有一个端点在这些点之中。或者说，只要删除包含这些点的边，可以删掉所有边，这个点集就是最小点覆盖。</p></blockquote><p>匈牙利算法是使用寻找增广路的方法来解决二分图<strong>最大匹配问题</strong>的算法。简单的说就是有一个二分图，假设两侧点集为M和N。然后先尽可能匹配M和N里的点，如果遇到冲突的话就DFS，让原配去寻找其它的可能性（）也就是增广路。找到了，大家Happy*Happy，匹配数喜加一；找不到，再见==</p><p>最简单的板子大概就长下面这样。主要是<code>nextMatch</code>也就是DFS和对每一个点发起匹配的<code>maxMatch</code>函数构成，不太要求存图方法，下面用的是邻接矩阵。然后得到结果的同时还会得到一个最大匹配的方案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1050</span>;     <span class="comment">// u &lt;= n</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1050</span>;     <span class="comment">// v &lt;= M</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,e,u,v;</span><br><span class="line"><span class="keyword">bool</span> graph[N][M]&#123;<span class="number">0</span>&#125;;    </span><br><span class="line"><span class="keyword">bool</span> visit[M]&#123;<span class="number">0</span>&#125;;       <span class="comment">// v是否被访问</span></span><br><span class="line"><span class="keyword">int</span> match[M]&#123;<span class="number">0</span>&#125;;        <span class="comment">// match[v]=u;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">nextMatch</span><span class="params">(<span class="keyword">int</span> i)</span>   <span class="comment">// 其实这是DFS</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)   <span class="comment">// 不要从中途开始</span></span><br><span class="line">        <span class="keyword">if</span>(graph[i][j]&amp;&amp;!visit[j])</span><br><span class="line">        &#123;</span><br><span class="line">            visit[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(!match[j]||nextMatch(match[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                match[j] = i;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">maxMatch</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)   <span class="comment">// 要重置visit</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">bool</span>)*(m+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(nextMatch(i)) ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;e;</span><br><span class="line">    <span class="keyword">while</span>(e--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        graph[u][v] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;maxMatch()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个板子是基于<a href="https://www.luogu.com.cn/problem/P3386">洛谷P3386</a>来写的。细节方面有两点要注意：一是因为递归链调用累计，所以必须要有visit数组，而且每次还要复位；二就是寻找增广路时，之前扫过的部分不可跳过。</p><h2 id="网络流问题">网络流问题</h2><h3 id="网络流模型">网络流模型</h3><h3 id="edmonds-karp-算法">Edmonds-Karp 算法</h3><h3 id="dinic-算法">Dinic 算法</h3><h3 id="费用流">费用流</h3><h3 id="sat-问题">2-SAT 问题</h3><h2 id="参考资料">参考资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/96229700" class="uri">https://zhuanlan.zhihu.com/p/96229700</a></li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 图论算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nowcoder 2020 寒假算法基础训练</title>
      <link href="/2020/nowcoder-2020-winter-training/"/>
      <url>/2020/nowcoder-2020-winter-training/</url>
      
        <content type="html"><![CDATA[<p>一共六场云比赛，据官方声称大约是cf-div3的难度，然而我做的并不顺畅就是了。首先是它们的题解链接，放在前面备用。 &gt; 第一场：<a href="https://ac.nowcoder.com/discuss/364600" class="uri">https://ac.nowcoder.com/discuss/364600</a><br />&gt; 第二场：<a href="https://ac.nowcoder.com/discuss/364961" class="uri">https://ac.nowcoder.com/discuss/364961</a><br />&gt; 第三场：<a href="https://ac.nowcoder.com/discuss/365306" class="uri">https://ac.nowcoder.com/discuss/365306</a> &gt; 第四场：<a href="https://ac.nowcoder.com/discuss/365889" class="uri">https://ac.nowcoder.com/discuss/365889</a> &gt; 第五场：<a href="https://ac.nowcoder.com/discuss/366644" class="uri">https://ac.nowcoder.com/discuss/366644</a> &gt; 第六场：<a href="https://ac.nowcoder.com/discuss/367149" class="uri">https://ac.nowcoder.com/discuss/367149</a></p><p>然后对一些题目做一些笔记吧，毕竟自己也确实是菜的真实（）</p><h2 id="第四场">第四场</h2><p>所有题目的链接：<a href="https://ac.nowcoder.com/acm/contest/3005" class="uri">https://ac.nowcoder.com/acm/contest/3005</a><br />官方的题解帖子：<a href="https://ac.nowcoder.com/discuss/365889" class="uri">https://ac.nowcoder.com/discuss/365889</a></p><p>为什么这场宣称没有难题没有毒瘤题我只A了一个啊噫呜呜噫我好菜啊哭哭==</p><figure><img src="https://i.loli.net/2020/02/18/1MATsvYu6FStpJL.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/02/18/1MATsvYu6FStpJL.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="4589838F557722182419F54B9B98BF93.jpg" /><figcaption aria-hidden="true">4589838F557722182419F54B9B98BF93.jpg</figcaption></figure><p>不过这一场题目确实，不仅整体相对偏向思维的考察，也非常考察写代码细节注意的程度。像我好多题目对着答案的思路敲也是WA不可避== 这套题补下来还是觉得想法会开拓不少，但是之后遇到类似的题目不知道能不能做出来就是了……</p><h3 id="d---子段异或">D - 子段异或</h3><p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/3005/D" class="uri">https://ac.nowcoder.com/acm/contest/3005/D</a></p><h3 id="f---树上博弈">F - 树上博弈</h3><p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/3005/F" class="uri">https://ac.nowcoder.com/acm/contest/3005/F</a></p><h3 id="g---音乐鉴赏">G - 音乐鉴赏</h3><p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/3005/G" class="uri">https://ac.nowcoder.com/acm/contest/3005/G</a></p><p>这整个就是一个概率题。看懂之前真的连一个式子都列不出来，更别说怎么写代码求解了== 不过我只看了一眼就放弃了，真不愧是我（）所以在上这个题目的代码之前先进行<del>不那么</del>简单的数学推导：</p><p>首先，我们设第<span class="math inline">\(i\)</span>个同学的总分是<span class="math inline">\(S\)</span>，其中包含<span class="math inline">\(s\geq90\)</span>分的平时分以及<span class="math inline">\(r\leq90\)</span>分的随机论文得分，随机的得分在总得分中占比<span class="math inline">\(p\)</span>。显然，同学<span class="math inline">\(i\)</span>优秀的概率是<span class="math inline">\(P_i(S\geq90)\)</span>，这个总分满足等式<span class="math inline">\(S = s\cdot(1-p)+r\cdot p\)</span>。</p>仅仅这样我们也什么都不知道，还需要进行一些变换。首先将总分的等式带入到概率的不等式中，可以得到：<center><span class="math inline">\(P_i:s\cdot(1-p)+r\cdot p\geq90\)</span></center>将不等式的两侧同时减去90，可以得到：<center><span class="math inline">\(P_i:S-90=s\cdot(1-p)+r\cdot p-90\geq0\)</span></center><center><span class="math inline">\((s-90)\cdot(1-p)+(r-90)\cdot p\geq0\)</span></center>又因为<span class="math inline">\(r\)</span>本来就是一个范围是[0,90]的随机数，所以<span class="math inline">\(r-90\)</span>是一个[-90,0]的随机数，和<span class="math inline">\(-r\)</span>是等价的。因此上式可以变成：<center><span class="math inline">\((s-90)\cdot(1-p)-r\cdot p\geq0\)</span></center>整理可得：<center><span class="math inline">\(P_i: \frac{(s-90)\cdot(1-p)}{p} \geq r\)</span></center>又因为<span class="math inline">\(r\)</span>是一个范围是[0,90]的随机数，易得<span class="math inline">\(P(r\leq x)=\frac{x}{90}\)</span>，所以上述不等式成立的概率<span class="math inline">\(\frac{(s-90)\cdot(1-p)}{p} \geq r\)</span>等于<span class="math inline">\(P(r\leq \frac{(s-90)\cdot(1-p)}{p})=\frac{(s-90)\cdot(1-p)}{90p}\)</span>。至此，我们求出了第<span class="math inline">\(i\)</span>位学生优秀的概率：<center><span class="math inline">\(P_i:\ \frac{(s-90)\cdot(1-p)}{90p}\)</span></center>设班级内一共有<span class="math inline">\(n\)</span>名同学，要求优秀率恰好为10%，也就是说：<center><span class="math inline">\(E = \sum _{i=1}^n P_i = \sum _{i=1}^n \frac{(s_i-90)\cdot(1-p)}{90p} = 0.1n\)</span></center><p>解这个方程可得：<span class="math inline">\(p = \frac{\sum _{i=1}^n (s_i-90)}{9n+\sum _{i=1}^n (s_i-90)}\)</span></p><p>但是除此之外，出题人称还可以使用二分的方法求解。这也许是一种数值计算方法，等我弄明白了再在这里补充好了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> longd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,ss;</span><br><span class="line"><span class="keyword">int</span> in[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        ss = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;in[i];</span><br><span class="line">            ss += in[i]<span class="number">-90</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(longd)ss/(<span class="number">9.0l</span>*n+ss)*<span class="number">100.0l</span>&lt;&lt;<span class="string">&#x27;%&#x27;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>属于这种只要你把它推出来了，写代码并不是很难的题目。但是像我就直接被吓死了==</p><p><del>此外，通过这个题目，我熟练了使用MathJax和LaTeX的技巧</del> <!-- <center>$$</center> --></p><h3 id="h---坐火车">H - 坐火车</h3><p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/3005/H" class="uri">https://ac.nowcoder.com/acm/contest/3005/H</a></p><h3 id="i---匹配星星">I - 匹配星星</h3><p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/3005/I" class="uri">https://ac.nowcoder.com/acm/contest/3005/I</a></p><h3 id="j---二维跑步">J - 二维跑步</h3><p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/3005/J" class="uri">https://ac.nowcoder.com/acm/contest/3005/J</a></p><h2 id="第五场">第五场</h2><p>所有题目的链接：<a href="https://ac.nowcoder.com/acm/contest/3006" class="uri">https://ac.nowcoder.com/acm/contest/3006</a><br />官方的题解帖子：<a href="https://ac.nowcoder.com/discuss/366644" class="uri">https://ac.nowcoder.com/discuss/366644</a></p><p>这次的题目里有大量的浮点数……就容易出现各种各样的小麻烦。印象里这里还有严格的卡了IO的题目（指<code>ios::sync_with_stdio</code>不管用）和超级模拟的毒瘤题=== 总而言之这绝对是一套极其麻烦的题目。</p><h3 id="b---牛牛战队的比赛地">B - 牛牛战队的比赛地</h3><p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/3006/B" class="uri">https://ac.nowcoder.com/acm/contest/3006/B</a></p><p>看起来就知道这是一个极其麻烦的题目。直接求解想必是十分困难的，但是验证一个点距离最远基地的最小值是可以一定时间内完成的——这样就要考虑到二分算法的可能性。此外，答案的取值范围是确定的，因此更应该想到使用二分解题。</p><p>题解使用了三分查找的方法，声称这样比二分查找更加的简单。二分查找最值就是一个比较麻烦的事情……大约需要对每一个区间继续二分然后递归……下次知道的话再做一个专题吧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vi vertex[i]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> longd;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">point</span>&#123;</span><span class="keyword">int</span> x,y;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,x,y;</span><br><span class="line"><span class="built_in">point</span> vertex[<span class="number">100050</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">longd <span class="title">distance</span><span class="params">(longd xpos)</span>          <span class="comment">// 这里也用longd就能AC了</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    longd tmp = <span class="number">0.0l</span>;</span><br><span class="line">    longd x2,y2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        y2 = vi.y*vi.y;</span><br><span class="line">        x2 = (vi.x-xpos)*(vi.x-xpos);</span><br><span class="line">        tmp = <span class="built_in">max</span>(tmp,sqrtl(x2+y2));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">longd <span class="title">triple_search</span><span class="params">(longd left, longd right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    longd midl,midr;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">100</span>;++i)     <span class="comment">// 因为浮点，所以只能通过搜索次数提高精度</span></span><br><span class="line">    &#123;</span><br><span class="line">        midl = left + (right-left)/<span class="number">3</span>;</span><br><span class="line">        midr = left + <span class="number">2</span>*(right-left)/<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span>(distance(midl)&gt;distance(midr))</span><br><span class="line">            left = midl;</span><br><span class="line">        <span class="keyword">else</span> right = midr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> midl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;fixed&lt;&lt;setprecision(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">            vertex[i] = &#123;x,y&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;distance(triple_search(<span class="number">-10000</span>,<span class="number">10000</span>))&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题目对于二分/三分查找的最大疑惑就是这个最小值和坐标的x值之间构成的函数关系是不是成单调关系或者是严格凹凸函数关系——至少在这个题里并没有明显的这样的关系的存在，可是笔记里也确实记录了这样的内容：</p><blockquote><p><em>节选自我的笔记</em></p><p>那么单峰函数和使用三分到底有什么关系呢？它比二分的效率要高？不是的，你写一下二分就知道二分会暴毙再极端情况的。因为二分查找对应的是单调函数，而三分查找对应单峰函数极值点的寻找。</p><p>因为是单峰函数，所以最大值的获得只需要使用三分查找就可以了。但是三分查找仅对于严格凹/凸函数有效。如果出现可行域中连续的函数导数为0的情况可能会暴毙。</p></blockquote><p>但是，题目的函数条件虽然写的很复杂，不要忘记你的基础数学知识啊：</p><blockquote><p><strong>凹凸序列</strong>：</p><p>如果一个函数是若干个开口向上的二次函数的最大值，这个函数就是先减后增的凹形序列了，相应地： 如果一个函数是若干个开口向下的二次函数的最小值 这个函数就是先增后减的凸形序列。</p></blockquote><p>因为对于每一个点，距离所求点的距离都是一个凹函数，所以它们最大值构成的函数也是一个凹函数。这样求最小值极值三分法就毫无疑问了。</p><h3 id="f---碎碎念">F - 碎碎念</h3><p>这题是个DP是真的万万没想到== 没做出来的原因大概就是读题的时候RJ-&gt;AC这个条件根本就没有有效利用。因为一发RJ之后必定AC，所以必不会出现连续RJ，一发RJ后必连AC。这样就规定了一种转移关系：AC由AC和RJ转移来，RJ由AC转移来。可设dp[x][0/1]是x句话时最后一个是AC或者RJ的可能性，即可得到推导公式。</p><p>然后是多次询问，这种询问区间大多都是要使用前缀和这种东西进行优化的。所以dp的时候记得加一下就好。询问的时候直接两个前缀和求差就行了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> longd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> longs MOD = <span class="number">1000000007l</span>l;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x,q,l,r;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2</span>][<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> pre[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">preProcess</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> AC=<span class="number">1</span>,RJ=<span class="number">0</span>;</span><br><span class="line">    dp[RJ][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[AC][<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">    pre[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100010</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[RJ][i] = (i&gt;=x)?dp[AC][i-x]:<span class="number">0</span>;</span><br><span class="line">        dp[AC][i] = ((longs)dp[RJ][i<span class="number">-1</span>]+dp[AC][i<span class="number">-1</span>])%MOD;</span><br><span class="line">        pre[i] = ((longs)dp[AC][i]+dp[RJ][i]+pre[i<span class="number">-1</span>])%MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (pre[r]-pre[l<span class="number">-1</span>]+MOD)%MOD;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;x&gt;&gt;q)</span><br><span class="line">    &#123;</span><br><span class="line">        preProcess(x);</span><br><span class="line">        <span class="keyword">while</span>(q--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;l&gt;&gt;r;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;solution(l,r)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>交题目的时候出现了奇怪的问题，本地测试通过但是上传却连样例都无法通过，后来把Nowcoder的编译器从 clang++ 换成 GNU g++ 就好了，现在也不知道是什么原因==</p><h3 id="g---街机争霸">G - 街机争霸</h3><p>因为是题目数据范围不大，大概可以用一些简单的算法。比较麻烦的就是僵尸会动来动去，不然的话直接BFS就完事了。但是僵尸动的周期是一致的，所以可以再输入的时候预处理僵尸不同时刻所在的位置，然后在这样的基础之上进行BFS，这个题目就可以做出来了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> longd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">coord</span>&#123;</span><span class="keyword">int</span> x,y;coord <span class="keyword">operator</span>+(<span class="keyword">const</span> coord&amp; rhs);&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> coord mov[<span class="number">4</span>] = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>coord p;<span class="keyword">int</span> t;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> ohno = <span class="string">&quot;Oh no&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,p,k;</span><br><span class="line"><span class="keyword">char</span> <span class="built_in">map</span>[N][N];</span><br><span class="line"><span class="keyword">bool</span> zmbmap[N][N][<span class="number">50</span>];</span><br><span class="line">coord inpos,st,ed;</span><br><span class="line"><span class="built_in">string</span> instr;</span><br><span class="line"><span class="keyword">int</span> T;</span><br><span class="line"><span class="keyword">int</span> vis[N][N][<span class="number">20</span>];</span><br><span class="line"><span class="built_in">queue</span>&lt;node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(coord pos,<span class="keyword">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pos.x&lt;=<span class="number">0</span>||pos.y&lt;=<span class="number">0</span>||pos.x&gt;n||pos.y&gt;m)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">map</span>[pos.x][pos.y]==<span class="string">&#x27;&amp;&#x27;</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(zmbmap[pos.x][pos.y][now])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())q.pop();</span><br><span class="line">    vis[st.x][st.y][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    q.push(&#123;st,<span class="number">0</span>&#125;);</span><br><span class="line">    node n;coord c;</span><br><span class="line">    <span class="keyword">int</span> nt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        n = q.front(); q.pop();</span><br><span class="line">        <span class="keyword">if</span>(n.p.x==ed.x&amp;&amp;n.p.y==ed.y)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = vis[ed.x][ed.y][n.t];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nt = (n.t+<span class="number">1</span>)%T;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            c = n.p+mov[i];</span><br><span class="line">            <span class="keyword">if</span>(judge(c,nt)&amp;&amp;vis[c.x][c.y][nt]==<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vis[c.x][c.y][nt] = vis[n.p.x][n.p.y][n.t]+<span class="number">1</span>;</span><br><span class="line">                q.push(&#123;c,nt&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">parseDir</span><span class="params">(<span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(s[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;U&#x27;</span>:<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="built_in">exit</span>(<span class="number">-1</span>);<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;p&gt;&gt;k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(zmbmap,<span class="number">0</span>,<span class="keyword">sizeof</span>(zmbmap));</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">-1</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        T = <span class="number">2</span> * k - <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;<span class="built_in">map</span>[i][j];</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]==<span class="string">&#x27;A&#x27;</span>) ed=&#123;i,j&#125;;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]==<span class="string">&#x27;L&#x27;</span>) st=&#123;i,j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;inpos.x&gt;&gt;inpos.y;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;instr;</span><br><span class="line">            zmbmap[inpos.x][inpos.y][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">int</span> dir = parseDir(instr);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>,j=<span class="number">2</span>*k<span class="number">-3</span>;x&lt;k;++x,--j)</span><br><span class="line">            &#123;</span><br><span class="line">                inpos = inpos+mov[dir];</span><br><span class="line">                zmbmap[inpos.x][inpos.y][x] = zmbmap[inpos.x][inpos.y][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = bfs();</span><br><span class="line">        <span class="keyword">if</span>(~res)<span class="built_in">cout</span>&lt;&lt;res&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;ohno&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">coord coord::<span class="keyword">operator</span>+(<span class="keyword">const</span> coord&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;x+rhs.x,y+rhs.y&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议写代码还是尽可能的言简意赅，能不要花里胡哨就不要花里胡哨，不然出错就非常的吃亏。之前包装了一堆函数还给我整了一个段错误出来就非常的离谱== 所以说少麻烦点就少麻烦点。现在感觉这似乎也是某种意义上的多层图：固有障碍每层都有，僵尸不同时间在不同的层的不同位置。</p><h2 id="第六场">第六场</h2><p>所有题目的链接：<a href="https://ac.nowcoder.com/acm/contest/3007" class="uri">https://ac.nowcoder.com/acm/contest/3007</a><br />官方的题解帖子：<a href="https://ac.nowcoder.com/discuss/367149" class="uri">https://ac.nowcoder.com/discuss/367149</a></p><p>总的来说这一次的题目还是比较的常规的——指的不是简单易懂，就是比较的……正常？毕竟比第五场谜之写错要舒服的多，看完了所有题目，只要思路没什么大问题基本写出来就不会有问题。</p><h3 id="b---图">B - 图</h3><p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/3007/B" class="uri">https://ac.nowcoder.com/acm/contest/3007/B</a></p><p>看到这样的题目描述很容易就能知道这个图大概是长什么样子：可能有多个连通块，每个连通块都是一个环外面续着几根链（太阳形），看了题解知道这种图叫做<strong>基环内向树森林</strong>。这样，从一个点出发一定能到一个环。</p><p>如果是在学tarjan判环时期说不定我就直接tarjan了找环然后找最长链了，但是这个题目似乎没有那么麻烦，DFS就好了。因为直接DFS会超时所以要使用记忆化搜索。但是问题就是我没想好这个记忆化具体的实现方法== gg</p><p>自己写的版本还特别统计了每个入度。大概能想到的用场就是从入度为0的点开始，利用入度大于1的点寻找链和环的交接处吧。虽然看起来题解没有这么做便是了。能想到的退化点大概就是太阳形的图，大量的入点会导致道面好多遍这个图然后T。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> longd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,v[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">1000010</span>],in[<span class="number">1000010</span>];</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>,mem[<span class="number">1000010</span>];</span><br><span class="line"><span class="keyword">int</span> cur,c,cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mem_dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(mem[x]) <span class="keyword">return</span> mem[x];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> mem[x] = <span class="number">1</span>+mem_dfs(v[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) <span class="built_in">cin</span>&gt;&gt;v[i];</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">bool</span>)*(n+<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">memset</span>(in,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">bool</span>)*(n+<span class="number">1</span>));</span><br><span class="line">        <span class="built_in">memset</span>(mem,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i])</span><br><span class="line">            &#123;</span><br><span class="line">                cur = i;</span><br><span class="line">                <span class="keyword">while</span>(!vis[cur])        <span class="comment">// 找点</span></span><br><span class="line">                &#123;</span><br><span class="line">                    t.push(cur);</span><br><span class="line">                    vis[cur] = in[cur] = <span class="literal">true</span>;</span><br><span class="line">                    cur = v[cur];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(in[cur])             <span class="comment">// 找到环</span></span><br><span class="line">                &#123;</span><br><span class="line">                    c=v[cur],cnt=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span>(c!=cur)       <span class="comment">// 求环的大小</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        c = v[c];</span><br><span class="line">                        ++cnt;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">do</span>                  <span class="comment">// 存储环的大小</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        c = v[c];</span><br><span class="line">                        mem[c] = cnt;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (c!=cur);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span>(t.<span class="built_in">size</span>())</span><br><span class="line">                &#123;</span><br><span class="line">                    in[t.top()] = <span class="literal">false</span>;</span><br><span class="line">                    t.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans,mem_dfs(i));</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意细节……这样的代码还能写炸就不太象话了（）所谓记忆化主要还是记录环的大小。一次遍历得到环的大小之后，无论有什么样的链都不会重复走环，速度就快了。</p><h3 id="c---汉诺塔">C - 汉诺塔</h3><p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/3007/C" class="uri">https://ac.nowcoder.com/acm/contest/3007/C</a></p><p>显然必然是要先按照一边进行排序的。之后就变成了在已经按照x排序的数列中寻找y边长尽可能少的若干组单调子序列。这个单调的方向和按照x排序的顺序一致。然后就是离散数学里的比较常见的Dilworth定理。</p><blockquote><p><strong>Dilworth定理</strong>： 偏序集的最少反链划分数等于最长链的长度。</p></blockquote><p>这指出了可以通过求出另一个单调方向的最长链长度来求出这个最小划分的组数。</p><p>至于这个最长单调序列的经典求法，可以去看一下<a href="https://www.luogu.com.cn/problem/P1020">洛谷P1020</a>。其实这个最长单调序列问题还是挺经典的，又很多可以做的优化。</p><p>但是仅仅是这样是不行的，题目还要让我们输出这个划分的具体方式。所以需要开数组记录每个木板的分组组号和每个分组当前在“栈顶”的木板的宽度。将每一块木板放在使用二分找到的最大的比它小的（sort默认升序）木板上就好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first.first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y first.second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> num second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> longd;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; it;</span><br><span class="line"></span><br><span class="line">it in[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">100010</span>];    <span class="comment">// 0是组数，1~n记录分组情况</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[<span class="number">100010</span>];  <span class="comment">// 维护最长的下降子序列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(<span class="built_in">stack</span>,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;in[i].x&gt;&gt;in[i].y;</span><br><span class="line">            in[i].num = i;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(in+<span class="number">1</span>,in+<span class="number">1</span>+n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;           <span class="comment">// 使用STL二分找出第一个小于当前木板宽的组号</span></span><br><span class="line">            <span class="keyword">int</span> lb = upper_bound(<span class="built_in">stack</span>+<span class="number">1</span>,<span class="built_in">stack</span>+ans[<span class="number">0</span>]+<span class="number">1</span>,in[i].y,greater&lt;<span class="keyword">int</span>&gt;())-<span class="built_in">stack</span>;</span><br><span class="line">            <span class="built_in">stack</span>[lb] = in[i].y;</span><br><span class="line">            <span class="keyword">if</span>(lb&gt;ans[<span class="number">0</span>]) ans[<span class="number">0</span>]=lb;</span><br><span class="line">            ans[in[i].num] = lb;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans[<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是谁都能想到的朴素n²算法的二分优化……我已经什么都不会了（大悲）</p><h3 id="e---立方数">E - 立方数</h3><p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/3007/E" class="uri">https://ac.nowcoder.com/acm/contest/3007/E</a></p><p>这是这套题目里一个比较令我上头的题目。很显然答案就在 1~³√n之间，验证起来的话倒也不是那么麻烦。看起来极其的像二分找答案== 但是实在不知道拿什么当作判别二分的标准……遂作罢。想着分治但是这看起来不是可以轻易分治的样子，没有想到一种确实可以加快速度的分治方案== gg。</p><p>之后用先提取2然后跳奇数的方法分解因数然后也妥妥T了，转念一想就算是数据的极限情况，有价值尝试的质因数范围也不过1e6，比之前的1e8好多了== 如果用欧拉筛的话1e6的质数也不是事，况且还要多次查询而预处理只需要一次……稳赚不赔啊（）遂尝试欧拉筛选出质数进行分解但是最终谜之WA了，遂作罢。</p><p>看了题解，这是题解中题目作者的进一步分析: &gt; <em>作者：珩月</em><br />&gt; <em>链接：https://ac.nowcoder.com/discuss/367149?type=101&amp;order=0&amp;pos=1&amp;page=1</em><br />&gt; <em>来源：牛客网</em> &gt; &gt; 先做简单一点的优化，容易发现其实只要枚举10<sup>6(N</sup>(1/3)以内)的质数就好，复杂度O(TN<sup>(1/3)/ln(N</sup>(1/3)))<br />&gt; 再作进一步的分析，如果我们仅使用N^(1/4)(记为W)以内的质数去试除，那么最后余下的数X仅具有大于W的因子<br />&gt; 此时X要么是一个完全立方数，要么对答案没有任何贡献，只需要使用二分法来验证X是不是一个完全立方数即可<br />&gt; 复杂度O(TN<sup>(1/4)/ln(N</sup>(1/4)))，不卡常数。</p><p>其实我一开始没怎么看懂…… 使用⁴√n作为测试的素数范围的话，最大的问题就是⁴√n~³√n这个区间范围内的可能性了。筛之后的数字确实不再包含任何小于³√n的因子，也就是说如果它不是完全立方数且对答案有贡献，设贡献的因子为k，那么这个剩下来的数一定会大于k³·m，其中k,m&gt;³√n。但是若这样的k存在，那么这个剩下的数字会大于(³√n)⁴&gt;n，这必然是不可能的。所以只需要判断剩下来的部分是不是完全立方数就好了，而这部操作是可以使用二分查找的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> longd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">longs n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> is[<span class="number">1000100</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> prime[<span class="number">100000</span>]&#123;<span class="number">0</span>&#125;;           <span class="comment">// 1e6内质数大约是7.2w个</span></span><br><span class="line">longs tri[<span class="number">100000</span>],qua[<span class="number">1000000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">preProcess</span><span class="params">()</span>        <span class="comment">// 欧拉筛 + 预先计算幂</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">1000010</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!is[i]) </span><br><span class="line">        &#123;</span><br><span class="line">            prime[++prime[<span class="number">0</span>]]=i;</span><br><span class="line">            tri[prime[<span class="number">0</span>]] = i*i*i;</span><br><span class="line">            qua[prime[<span class="number">0</span>]] = tri[prime[<span class="number">0</span>]]*i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=prime[<span class="number">0</span>]&amp;&amp;(tmp=i*prime[j])&lt;=<span class="number">1000010</span>;++j)</span><br><span class="line">        &#123;</span><br><span class="line">            is[tmp]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(i%prime[j]==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> longs <span class="title">solve</span><span class="params">(longs n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(n&amp;<span class="number">1l</span>l))                <span class="comment">// 处理因数2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!(n&amp;<span class="number">1l</span>l))</span><br><span class="line">        &#123;</span><br><span class="line">            ++cnt;</span><br><span class="line">            n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1l</span>l&lt;&lt;(cnt/<span class="number">3</span>))*solve(n);</span><br><span class="line">    &#125;</span><br><span class="line">    longs ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;qua[i]&lt;=n;++i)  <span class="comment">// i&lt;=prime[0]没有必要</span></span><br><span class="line">        <span class="keyword">if</span>(n%prime[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span>                    <span class="comment">// 完全去除这个因数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!(n%tri[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                ans *= prime[i];</span><br><span class="line">                n /= tri[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(!(n%prime[i])) n/=prime[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">int</span> lb = <span class="number">1</span>, rb = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">while</span>(lb&lt;=rb)               <span class="comment">// 可以二分查找</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = lb+rb &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>((longs)mid*mid*mid&lt;n) lb = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> rb = mid<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((longs)lb*lb*lb==n) ans*=lb;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    preProcess();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;t)</span><br><span class="line">        <span class="keyword">while</span>(t--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;solve(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在想想，最开始想到二分但是不能二分的原因是因为无法确定判据：如果是用大于/小于n的话，只会让二分结果更加趋向于³√n，但是实际上很多数字的答案是1，显然这不合理；如果使用除数/余数作为判据，那就比较的麻烦，甚至可能要考虑它们的变化，就不像是二分了…… 也就是说二分最大的障碍是那些比较小的因数，而这可以先行筛去。之后可能的因数在⁴√n~³√n内，因为这个数一定是小于等于n的，所以要不是立方数要不是倍数，就转化的可以二分了…… 妙啊。</p><p>简单的说，就是：如果n有大于⁴√n~³√n的因子且有贡献，那么必然会有小于³√n的因子，筛去这部分因子之后剩下的就是（有奉献的）完全立方数或者（无奉献的）质因数乘积。</p><p>这么一想，之前写的³√n的时候细节也不怎么注意，常数必然很大，被卡掉也是自然（）而且对于1e18的数据来说两种复杂度差距很大的啊……确实也是根本没有向⁴√n的方向去想吧== 学到了学到了。</p><h3 id="i---导航系统">I - 导航系统</h3><p>题目链接：<a href="https://ac.nowcoder.com/acm/contest/3007/I" class="uri">https://ac.nowcoder.com/acm/contest/3007/I</a></p><p>这应该是这次最麻烦的题目。最开始看到n-1条边、看到两点距离、再看到判断最短距离的正误，第一反应是并查集和树上LCA（虽然板子用的并不熟练）。但是仔细一看发现题目并没有指明点之间的关系用来建图，遂作罢。</p><p>看了题解才想着：n个节点n-1条边就是一棵树，如果数据合法，那么这棵树就是输入的完全图的最小生成树（草怎么就没想到==）。因为边权是非负数的，可以使用Kruskal算法构建最小生成树再进行验证即可。</p><p><del>如果忘记了以贪心为基本思想的Kruskal算法的话，那自裁，请（无慈悲）</del>我爬了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> longd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> from,to,val;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> edge&amp; rhs) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> yes = <span class="string">&quot;Yes&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> no = <span class="string">&quot;No&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">505</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">map</span>[N][N];</span><br><span class="line">edge elist[N*N];</span><br><span class="line"><span class="keyword">int</span> cur = <span class="number">0</span>;        <span class="comment">// 输入的完全图边光标</span></span><br><span class="line"><span class="keyword">bool</span> fall = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">int</span> dis[N][N];      </span><br><span class="line"><span class="keyword">int</span> ufs[N];         <span class="comment">// Kruskal用并查集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> head[N];        <span class="comment">// 前向星存最小生成树</span></span><br><span class="line">edge fstree[N*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> nextptr[N*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">father</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!ufs[x]) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ufs[x]=father(ufs[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">unite</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ufs[u] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">addedge</span><span class="params">(edge&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    nextptr[tot] = head[e.from];</span><br><span class="line">    head[e.from] = tot;</span><br><span class="line">    fstree[tot] = e;</span><br><span class="line">    ++tot;</span><br><span class="line">    nextptr[tot] = head[e.to];</span><br><span class="line">    head[e.to] = tot;</span><br><span class="line">    fstree[tot] = &#123;e.to,e.from,e.val&#125;;</span><br><span class="line">    ++tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> prev,<span class="keyword">int</span> sp,<span class="keyword">int</span> leng)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dis[sp][now] = leng;</span><br><span class="line">    <span class="keyword">int</span> c = head[now];</span><br><span class="line">    <span class="keyword">while</span>(~c)</span><br><span class="line">    &#123;</span><br><span class="line">        edge&amp; ce = fstree[c];</span><br><span class="line">        <span class="keyword">if</span>(ce.to^prev)</span><br><span class="line">            dfs(ce.to,now,sp,leng+ce.val);</span><br><span class="line">        c = nextptr[c];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fall = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">memset</span>(ufs,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*(n+<span class="number">1</span>));</span><br><span class="line">    cur = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;<span class="built_in">map</span>[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]!=<span class="built_in">map</span>[j][i])    <span class="comment">// 简单筛查</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;no&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    fall = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> elist[cur++] = &#123;i,j,<span class="built_in">map</span>[i][j]&#125;;</span><br><span class="line">            <span class="keyword">if</span>(fall) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fall) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        sort(elist,elist+cur);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> ne = n<span class="number">-1</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cur&amp;&amp;tot&lt;ne;++i)      <span class="comment">// Kruskal找树</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> fu=father(elist[i].from),fv=father(elist[i].to);</span><br><span class="line">            <span class="keyword">if</span>(fu!=fv)</span><br><span class="line">            &#123;</span><br><span class="line">                unite(fu,fv);</span><br><span class="line">                addedge(elist[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) dfs(i,<span class="number">0</span>,i,<span class="number">0</span>); <span class="comment">// 找i到所有点的距离</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">map</span>[i][j]!=dis[i][j])    <span class="comment">// 二度核对</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;no&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                    fall = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(fall) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fall) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;yes&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tot;i+=<span class="number">2</span>)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;fstree[i].val&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> edge::<span class="keyword">operator</span>&lt;(<span class="keyword">const</span> edge&amp; rhs) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> val&lt;rhs.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的说一下这个题目的具体实现：首先简单排查双向边的两个方向是否长度相等——因为题目只是保证了自环为0，而且确实需要这么扫一遍来构建题目所说的完全图；建图之后使用并查集跑一边Kruskal找到最小生成树的边存到新图（树）中。之后再以每一个顶点作为树根进行DFS，计算出所有定点对之间的距离并与输入进行核对即可。</p><p>主要就是想到这个最小生成树。完全图的点对之间，最短距离的路径一定在最小生成树上。想到这个之后写代码仔细点基本就没什么问题了…… 虽然说流程比较复杂，但是图论题，数据范围1e2，很显然复数算法折腾没毛病…… 不要怕啊。</p><h2 id="后记">后记</h2><p>说是说写代码，但是这几轮真正考察到的算法硬知识都比较少，主要就是思维和……代码能力吧。而且有的题目即使可以想到可能的算法Tag，自己的实现也会是和答案千差万别，就还是缺乏训练，题目做少了的表现吧== 虽然说学习某些高级算法的时候有那样的万能感，实际上不会运用，连基本的题目也会卡住，大概就是现在的状态吧。毕竟高级算法可以看板子，解题能力和代码能力才是真正要训练的东西啊（）害！路漫漫啊==</p><p>虽说不太喜欢nowcoder这个网站但是这种感觉也还不错。认真的学习这几套题之后要尝试补一补Codeforces的div2/div3以及AtCoder的ABC/ARC了。用之前学化学的感觉来说，就是之前只是在瞎玩，现在大概来感觉了吧。虽然时间很迟，但是是时候做出努力了（）这方面来说我还是期待nowcoder之后的题的，下次还来==</p><p>不说了，一个寒假宅在家里都没碰luogu，名字都绿了，该刷题力（大悲</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> Nowcoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>辗转相除法和有理数取模</title>
      <link href="/2020/Euclid-and-modulus-of-rational-number/"/>
      <url>/2020/Euclid-and-modulus-of-rational-number/</url>
      
        <content type="html"><![CDATA[<p>首先简单复习一下辗转相除法（欧几里得算法）和扩展欧几里得算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大公约数 &amp; 最小公倍数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b) <span class="keyword">return</span> gcd(b,a);    <span class="comment">// 确保 a&gt;b</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a/gcd(a,b)*b;    <span class="comment">// 如果是 a*b/gcd(a,b)，中间结果可能会爆</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓展欧几里得： 解不定方程 ax+by=gcd(a,b)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span>&amp; d, <span class="keyword">int</span>&amp;x, <span class="keyword">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&lt;b) <span class="keyword">return</span> exgcd(b,a,d,y,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!b)     <span class="comment">// 基础情况： 1*a-0*0 = a = gcd(a,0)</span></span><br><span class="line">    &#123;</span><br><span class="line">        d = a;      <span class="comment">// gcd(a,b)</span></span><br><span class="line">        x = <span class="number">1</span>;      <span class="comment">// a 的系数</span></span><br><span class="line">        y = <span class="number">0</span>;      <span class="comment">// b 的系数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        exgcd(b,a%b,d,y,x);</span><br><span class="line">        y -= x*(a/b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据写法流派的不同，<code>exgcd</code>的参数d（最大公约数）可以作为返回值返回。</p><h2 id="扩展欧几里得">扩展欧几里得</h2><p>说这个之前先说一下<strong>贝祖定理</strong>：</p><blockquote><p>贝祖定理：如果a、b是整数，那么一定存在整数x、y使得ax+by=gcd(a,b)。</p></blockquote><p>也就是说，如果ax+by=m有解，那么m一定是<code>gcd(a,b)</code>的若干倍。特别地，如果ax+by=1有解，那么<code>gcd(a,b) = 1</code>。直接的应用就是知道不定方程的情况下，判断这样的等式有没有<u>整数</u>解。</p><p>但是这样并不能得到这个不定方程的解，这种时候就需要使用<strong>扩展欧几里得</strong>算法。</p><blockquote><p><strong>扩展欧几里得算法</strong>可以在求得a、b的最大公约数的同时，能找到整数x、y（其中一个很可能是负数），使它们满足贝祖等式 ax+by=gcd(a,b)。如果a是负数，可以把问题转化成 |a|(-x')+by=gcd(a,b)，然后令 x=(-x')。</p></blockquote><p>和欧几里得算法一样，扩展欧几里得也是使用递归求解，有一样的递归边界：确保a&gt;b的前提下，当b = 0的时候，GCD的值是a，此时对于不定方程 a*x + b*y = gcd(a,b) 有显而易见的解(x,y) = (1,0)。</p><p>现在我们可以从这个基本情况进行反推，求出一般a和b的可能解(x,y)。假设其中的某一阶段是这样的：已知 b、a%b 和 gcd(b,a%b)=gcd(a,b)=d，已经求解得到了 b*x' + (a%b)*y' = d。接下来要继续反推求出 ax + by = d 的x和y：</p><p>显然，a%b = a - (a/b)*b。将这个式子待入到上述状态的不等方程中可以得到：</p><p>d = b * x' + (a%b) * y' <!-- ——代入a%b = a - (a/b)\*b   --> d = b * x' + (a - (a/b) * b) * y' = b * x' + a * y' - (a/b) * b * y'<br />d = a * y' + b * (x' - (a/b) * y') <!-- ——等价于 d = a\*x + b\*y   --></p><p><del><em>小声bb：我马上就去学习怎么输入数学公式</em></del></p><p>综上所述，可以得到：若 b*x' + (a%b)*y' = d，那么解为 x = y'；y = x' - (a/b)*b，即 a*y' + b*(x'-(a/b)*b) = d。递归返回的过程中根据这个更新值就可以。</p><p>更新方法：x和y是引用值，每层递归要使用下一层计算出的y作为自己的x，使用下一层计算的x作为自己的y后再进行本层值的处理。所以有了<code>y -= x*(a/b);</code>。</p><p>扩展欧几里得算法可以用来计算模反元素(也叫模逆元)，而模反元素在RSA加密算法中有重要的作用。</p><h2 id="模逆元">模逆元</h2><p>再说这个之前先简单的复习一下同余和模算数的相关知识：</p><blockquote><p><strong>同余</strong>： a ≡ b (mod n)，含义是 a, b除以 n的余数相同。它的充要条件是 a-b 可以被 n整除。若有整数 y满足 a ≡ y (mod n)，那么 y ≡ b (mod n)。所以实际上同余方程的一个解指的是一整个同余等价类。</p><p><strong>模线性方程组</strong>： 形如 ax ≡ b (mod n) 的方程。由上述等价条件可知 ax - b = ny，再进行移项可得 ax - ny = b，正是可以被扩展欧几里得求解的不等方程的形式。先对 a, n 进行 exgcd，若 d不能被 b整除，那么无解；否则将求出的 x, y按照比例放大即可。</p><p><strong>模算数</strong>： 同余也有四则运算<br />- 加法： (a + b) % n = ((a%n) + (b%n)) % n - 减法： (a - b) % n = ((a%n) - (b%n) + n) % n - 乘法： ab % n = (a%n)(b%n) % n - 除法： <无> - 同余式： c≠0, ac ≡ bc (mod n) =&gt; a ≡ b (mod n/gcd(c,n))</p><p>特别注意，最后一项不能简单理解为除法。最后一项的特点是都可以整除。</p><p><strong>费马小定理</strong>： 若p是质数，且a、p互质，那么a^(p-1) mod p = 1。若p是质数，有 a^p ≡ a (mod p)。两式在 p|a（p整除a）时不等价。</p></blockquote><p>那么什么是模逆元？就是上述模线性方程组的 b=1 的特殊情况：当 ax ≡ 1 (mod n) 时，解出的 x 就是 <strong>a 关于模 n 的逆</strong>。在这种情况下，a 的逆存在的必要条件就是该模线性方程组（或其等价形式 ax - ny = 1）有解。而它有解的必要条件是 1|gcd(a,n)，也就是 a 和 n 互素，gcd(a,n)=1。此时，该方程有<u>唯一</u>解。（唯一解是刘汝佳书上的原话，但是不是这样的）</p><p>此时，可以利用模逆元来求模算数的除法。虽然模除法相当于对一个分数有理数取模，意义不明，但是它依然满足同余的性质。若已有 x 使得 bx ≡ 1 (mod n)，又由模乘法可以得到： (a/b) % m = (a/b)*1 % m = (a/b)*bx % m = ax % m，即 (a/b) ≡ ax (mod m)，式中 x 是 b 关于模 m 的逆。</p><h3 id="使用扩展欧几里得求模逆元">使用扩展欧几里得求模逆元</h3><p>求解这个逆元就要使用到前面说的扩展欧几里得算法。bx ≡ 1 (mod n) 等价于 bx - ny = 1。若 gcd(b,n)=1，那么可以使用扩展欧几里得求出逆元 x。因为实际上线性不定方程组有无穷多解，这里只求正的最小的逆元。代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用扩展欧几里得求 a 关于模 m 的逆元</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inverse</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> m)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y,d;              <span class="comment">// 等价： ax - ny = 1</span></span><br><span class="line">    exgcd(a,m,d,x,y);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>%d) <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">// gcd(a,m)≠1 时，无解</span></span><br><span class="line">    x *= <span class="number">1</span>/gcd;             <span class="comment">// 解不定方程通用：放大倍数</span></span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>) x+=m;           <span class="comment">// 求出负数时，将它加为正数</span></span><br><span class="line">    <span class="keyword">return</span> x%m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码并没有处理 m 是负数的情况。如果 m 是负数，那么在 exgcd 之后将 m 取绝对值就好了。</p><h3 id="使用费马小定理求模逆元">使用费马小定理求模逆元</h3><p>当模数 m 是素数的时候，求模逆元也可以使用费马小定理进行。很多题目在使用模数时都会给一个很大的素数，与任何比它小的正数互质，就可以使用。设这个很大的质数是 p，那么根据费马小定理，有 a^(p-1) ≡ 1 (mod p)，a 是任何比 p 小的正数。那么根据模逆元的定义，显然有 a*a^(p-2) ≡ 1 (mod p)，故 a 关于模 p 的逆元是 a^(p-2)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速幂： 计算 a^n (n&gt;=0)，非取模</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fastpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!n) <span class="keyword">return</span> a?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans*=a;</span><br><span class="line">        a*=a;</span><br><span class="line">        n&gt;&gt;=<span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用费马小定理求 a 关于模 p 的逆元</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inverse</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;p||a&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> fastpow(a,p<span class="number">-2</span>)%p;    <span class="comment">// 返回模值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别注意：上述代码中的快速幂，如果要取模，即使结果不超过<code>int</code>范围，考虑到中间结果的可能性，参数和中间变量的类型应当改为<code>long long</code>。</p><p>这样的话，就可以很方便的解决一些带模的除法问题了，而不是使用高精度计算了。比如求 x = (a/c) % p，可以简单的转化为 a*c^(-1) % p。又因为费马小定理，1 ≡ c^(p-1) (mod p)，原式可以化为 x = a*c^(p-2) % p。这样就可以完成分数的求模了。</p><h2 id="分数取模">分数取模</h2><p>首先看定义：</p><blockquote><p>分数取模运算的定义： x = a/b (mod m) &lt;=&gt; xb = a (mod m)，仅当 gcd(b,m)=1 时成立</p></blockquote><p>当上述恒等式成立时，求已知分数的模相当于求解等价的不等方程： xb - my = a。这可以使用扩展欧几里得求解。当 m 是质数的时候，也可以使用费马小定理快速求解。</p><p>但是现在有一些题目会给分数取模的整数作为输入数据。这种题目如果是恰好需要计算概率的话，就很容易陷入“将取模后分数转化为分数”的误区中。但是实际上将取模后分数转化为分数并不是分数取模的逆运算——分数的模只是不定方程的一个解，另一个解被舍弃了。然而题目并不会告诉逆被舍弃的解。但是因为分数取模和分数满足同余等式，可以直接使用分数的模当作分数进行计算，只是要注意负数的情况即可。</p><h2 id="练习题">练习题</h2><p>一些相关的题目。写了我就放上来（）</p><h3 id="洛谷-p2613">洛谷 P2613</h3><p>题目链接：<a href="https://www.luogu.com.cn/problem/P2613">洛谷 P2613【模板】有理数取余</a></p><p>真正的模板题，直接告诉了要对分数 a/b 取模。但是数据范围着实吓人，不像是可以用一个变量装下的。如果要是打高精度的话风险太大，也不是这个题目的正确解法。因为分数取模最后可以通过逆元转化为模乘法，所以运算依然是线性的。可以修改C快读模板，在C快读模板每读入一位数字时进行取模操作，最后就可以得到待输入数字的关于给定数字的模。然而这里取模对题目是不影响的。</p><p>检查一下，发现题目给的19260817是一个素数。这太好了，直接费马小定理就完事了。当然也可以使用扩展欧几里得解不定方程解出。因为实际上是分母和大质数求不定方程，有解仅当它们互质，那么易得无解的情况：分母是0，根本就没有和p互质的余地。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> longs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> longs MOD = <span class="number">19260817L</span>L;   <span class="comment">// 是素数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Power = (<span class="keyword">int</span>)MOD<span class="number">-2</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> No[] = <span class="string">&quot;Angry!&quot;</span>;</span><br><span class="line"></span><br><span class="line">longs a,b;</span><br><span class="line"></span><br><span class="line"><span class="function">longs <span class="title">getlongs</span><span class="params">()</span>     <span class="comment">// 未处理负数的带模快读</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    longs ll = <span class="number">0l</span>l;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    ch = getchar();     </span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(ch) &amp;&amp; ch != EOF)</span><br><span class="line">        ch = getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        ll = (ll&lt;&lt;<span class="number">1</span>)+(ll&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ll %= MOD;          <span class="comment">// 立即取模</span></span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ll;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mod</span><span class="params">(longs a, longs b)</span>   <span class="comment">// 费马小定理法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = Power;</span><br><span class="line">    longs ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans = (ans*b)%MOD;</span><br><span class="line">        b = (b*b)%MOD;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = (ans*a)%MOD;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 要使用C快读，必须关闭C++快读</span></span><br><span class="line">    <span class="comment">// ios::sync_with_stdio(false);</span></span><br><span class="line">    <span class="comment">// cin.tie(nullptr);</span></span><br><span class="line"></span><br><span class="line">    a = getlongs();</span><br><span class="line">    b = getlongs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="built_in">cout</span>&lt;&lt;No&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span>&lt;&lt;mod(a,b)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="hdu---4828">HDU - 4828</h3><p>题目链接：<a href="http://acm.hdu.edu.cn/showproblem.php?pid=4828">HDU - 4828 Grids</a></p><h3 id="更多练习题">更多练习题</h3><p>如果遇到好题目以后会补在这里。如果你们有推荐的题目也欢迎在评论区留言~</p><h2 id="参考资料">参考资料</h2><ul><li>《算法竞赛入门经典（第2版）》 - 刘汝佳编著，清华大学出版社<br /></li><li><a href="https://www.cnblogs.com/zhanhonhao/p/11329772.html" class="uri">https://www.cnblogs.com/zhanhonhao/p/11329772.html</a></li><li><a href="https://www.luogu.com.cn/problemnew/solution/P2613" class="uri">https://www.luogu.com.cn/problemnew/solution/P2613</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> ACM </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/hello-world/"/>
      <url>/2020/hello-world/</url>
      
        <content type="html"><![CDATA[<p>如果只是介绍Hexo客户端的用法就太无聊了，干脆简单的说一下搭建Hexo博客的流程好了。系统自动生成的那些东西的翻译就放在最后一个板块了==</p><p>这里只简单的介绍一下在 Windows 10 平台上将 Hexo 博客部署到 Github Pages 上的基本操作，大概就是：准备必须的环境-&gt;在Github上创建仓库-&gt;使用Hexo客户端-&gt;修改博客工程的配置文件-&gt;写作并发表。</p><p>仔细看看<a href="https://hexo.io/zh-cn/docs/index.html">官方文档</a>，发现它讲的其实挺全面的…… 瞬间就不想写这个了。</p><h2 id="准备工作">准备工作</h2><p>这一步主要的是准备Hexo运行的基本环境。</p><h3 id="安装程序">安装程序</h3><p>首先，你得在你的电脑上安装<a href="https://nodejs.org/dist/v12.16.0/node-v12.16.0-x64.msi">Node.js</a>和<a href="https://github.com/git-for-windows/git/releases/download/v2.25.0.windows.1/Git-2.25.0-64-bit.exe">Git</a>。文章里的链接可能不是最新版本的，需要最新版本请去官网：</p><ul><li>Git官网的下载页面： https://git-scm.com/downloads</li><li>Node.js官网的下载页面： https://nodejs.org/zh-cn/</li></ul><p>特别注意，安装Git的时候，安装向导会出现一个复选框提示是否将Git增加到系统变量（PATH），选择这个。</p><p>安装完成之后，右键开始菜单按钮选择 Windows Powershell，输入命令<code>npm</code>和<code>git</code>测试它们是否已经正确安装。如果已经正确安装会出现帮助文字，否则会出错。如果Git已经正确安装但是在控制台中没有找到，可能是因为Git不在系统变量中，这个时候需要手动将Git添加到Path或者使用 git bash 作为终端。</p><h3 id="安装hexo客户端">安装Hexo客户端</h3><p>之后你需要使用Hexo安装Hexo的客户端，执行的命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装之后，使用<code>npx hexo</code>应该就可以使用hexo了。如果需要之后使用的更方便，还可以将 Hexo 所在的目录下的 node_modules 添加到环境变量，之后即可直接使用<code>hexo</code>使用它。（但是我的电脑似乎并没有做这一步操作）</p><h3 id="布置github">布置Github</h3><p>首先，Hexo的Github部署工具只支持SSH方式部署。也就是说在使用前，你需要将你的电脑的SSH公钥存放到Github账户里。你的电脑的SSH公钥的存放位置在你的个人文件夹下的一个叫做<code>.ssh</code>的文件夹下，如果该目录不存在，或者该目录下没有叫做<code>id_rsa</code>和<code>id_rsa.pub</code>的文件存在，则说明公钥不存在，这时需要生成一个公钥。</p><p>可以通过在 Git Bash 或者其他任何终端中键入以下命令生成一个公钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;your_email@youremail.com&quot;</span></span><br></pre></td></tr></table></figure><p>将<code>your_email@youremail.com</code>替换成自己的邮箱，或者任何其他包含一个<code>@</code>的字符串后一路回车采取默认设置，就会在上述位置生成默认SSH密钥对，也就是上面提到的那两个文件。</p><p>登录 Github，点击自己的头像进入 Settings 页面，在 SSH and GPG Keys 目录下，选择新建密钥，将上文提到的<code>id_rsa.pub</code>文件里的所有文本信息复制到网页的文本框里，保存即可。这样就将你电脑的SSH公钥增加到你的 Github 账号里了。</p><h2 id="创建站点">创建站点</h2><p>这一步的主要目的是创建一个Hexo的工程。</p><h3 id="初始化">初始化</h3><h3 id="选择主题">选择主题</h3><h3 id="创建仓库">创建仓库</h3><h2 id="配置站点">配置站点</h2><h3 id="修改主题">修改主题</h3><h3 id="设置部署信息">设置部署信息</h3><h2 id="使用">使用</h2><h3 id="写作">写作</h3><p>……<em>闲的时候会回来补的</em>……</p><h2 id="快速开始原文翻译">快速开始（原文翻译）</h2><p>欢迎使用<a href="https://hexo.io/">Hexo</a>！这是系统默认生成的您的第一篇博文。您可以阅读<a href="https://hexo.io/docs/">官方文档</a>来获得更多的消息。如果您在使用Hexo的过程中遇到了任何的问题，您可以在<a href="https://hexo.io/docs/troubleshooting.html">检修页面</a>中找到答案，或者您也可以在<a href="https://github.com/hexojs/hexo/issues">GitHub</a>上向我发起询问。</p><h3 id="创建一篇新的博文">创建一篇新的博文</h3><p>使用模板创建一篇新的博文的md文件，可以通过执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>这样就创建了一篇叫做 "My New Post" 的博文。</p><p>更多信息： <a href="https://hexo.io/docs/writing.html">使用Hexo写作 - Hexo官方文档</a></p><h3 id="启动服务器">启动服务器</h3><p>在本机启动服务器，然后在浏览器中预览您的博客，您可以通过执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>这样您的博客会在<a href="https://localhost:4000" class="uri">https://localhost:4000</a>（默认端口4000）启动，您可以在浏览器中访问它，或在终端Ctrl+C中断服务器。</p><p>更多信息： <a href="https://hexo.io/docs/server.html">Hexo服务器 - Hexo官方文档</a></p><h3 id="生成静态文件">生成静态文件</h3><p>要将博客发布，需要先生成静态文件，这可以通过执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>这将根据您的配置文件生成静态的html文件，以供部署。</p><p>更多信息： <a href="https://hexo.io/docs/generating.html">构建/生成 - Hexo官方文档</a></p><h3 id="部署到远程站点">部署到远程站点</h3><p>要让您的博客可以在互联网中访问，您可以执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>这样将根据您的配置文件，自动将生成的静态文件发布到互联网。</p><blockquote><p><strong>特别注意</strong>：</p><p>如果您要将博客发布到 Github Pages，您还额外需要先执行以下命令安装 Github 部署工具。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>最新版本的 Hexo 客户端已经不再默认包含这个工具。</p></blockquote><p>更多信息： <a href="https://hexo.io/docs/one-command-deployment.html">部署到远端 - Hexo官方文档</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arch Linux 操作系统原理实验报告</title>
      <link href="/2019/Linux-FoDOS-experiment-dian/"/>
      <url>/2019/Linux-FoDOS-experiment-dian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原标题：Linux操作系统原理实验 - 实验报告</p><p>补档时间：2020-02-12 19:04:35</p><p>因为原稿时间久远，相关的图片素材可能已经遗失。</p></blockquote><h2 id="实验一-安装arch-linux并配置图形界面">实验一： 安装Arch Linux并配置图形界面</h2><h3 id="一实验描述">一、实验描述</h3><p>在虚拟机上安装可以日常使用的Arch Linux，并为之配置图形界面。</p><h3 id="二实验设计">二、实验设计</h3><ol type="1"><li><p>安装前准备：<br />启动Hyper-V虚拟机、下载Arch引导镜像、创建虚拟机并且从镜像启动</p></li><li><p>安装Arch Linux：<br />检测网络、分区并挂载、更改镜像源、使用<code>pacman</code>安装Arch、配置Arch、解挂载并重启</p></li><li><p>安装图形界面：<br />登录Arch、安装图形界面软件包</p></li><li><p><del>安装常用软件包</del>：<br />安装yaourt、安装WMwarm-tools</p></li></ol><h3 id="三实验原理">三、实验原理</h3><ol type="1"><li><p><code>pacman</code>包管理器</p><p>和Ubuntu不一样，Arch Linux使用的包管理程序是<code>pacman</code>。使用pacman安装一个新的包的命令是： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S &lt;包名&gt;</span><br></pre></td></tr></table></figure> 和Ubuntu的<code>apt</code>一样，pacman也需要更新它的信息。更新pacman的软件包的数据库可以使用以下命令的任意一条： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -Syy</span><br><span class="line">pacman -Syu</span><br><span class="line">pacman -Sy</span><br></pre></td></tr></table></figure> 除此之外，pacman还有以下的常用命令： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 移除软件包</span></span><br><span class="line">pacman -R &lt;包名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除软件包以及依赖项</span></span><br><span class="line">pacman -Rs &lt;包名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看可用的包R</span></span><br><span class="line">pacman -Sl | grep &lt;关键词&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出已安装的包</span></span><br><span class="line">pacman -Q &lt;包名&gt;</span><br></pre></td></tr></table></figure></p></li><li><p>UEFI模式</p><p>对于一台使用了“快速创建”的虚拟机或者物理机，我们首先需要知道它引导启动的模式。在archiso的终端执行命令<code>efivar -l</code>，如果输出正确的列出了UEFI变量，则是UEFI模式启动。</p><p>如果通过UEFI模式，那么需要将分区挂载到/boot/EFI目录，而不是BIOS模式下挂载到/boot目录。</p></li><li><p>窗口环境的软件包</p><p>在配置图形界面过程中安装的众多软件包中，不同的软件包有不同的作用：</p><ul><li>xorg server： 众多窗口环境的软件包的基础</li><li>sddm： 提供了图形化的用户登录界面</li><li>xfce4： 常用的Linux桌面环境</li><li>plasma： 基于KDE的更加美观的桌面环境</li></ul><p>安装以上所有的软件包之后，在用户的登陆页面将出现选项框，可以选择进入不同的桌面环境。</p></li></ol><h3 id="四实验步骤">四、实验步骤</h3><h4 id="安装前准备"><strong>安装前准备</strong></h4><p>因为Windows 10 1903 对旧版的VMware Workstation存在兼容性问题，为了方便，所以本次实验采用基于Windows10自带的Hyper-V的虚拟机。Hyper-V功能默认是关闭的。在控制面板中选择“程序或功能-&gt;添加/删除Windows功能”中选择启动Hyper-V，随后系统将会下载相关的数据并且重新启动，Hyper-V功能将启用。</p><p>进入<a href="https://www.archlinux.org/download/">官网</a>或者镜像站下载Arch Linux的镜像，这里给出浙江大学镜像站的<a href="http://mirrors.zju.edu.cn/archlinux/iso/2019.10.01/">下载地址</a>，进入后选择<code>archlinux-2019.10.01-x86_64.iso</code>下载即可。将下载的镜像文件作为新建的Hyper-V虚拟机中虚拟光驱引入，完成虚拟机创建。</p><p>搜索栏中输入“Hyper-V管理器”，可以打开它。在右侧状态栏中选择新建，手动配置新虚拟机的信息。这次实验我使用的是第一代（基于BIOS）的虚拟机，你也可以使用第二代（基于UEFI）虚拟机，但是具体操作将会与本实验报告描述内容存在出入。使用刚才下载的光盘镜像文件作为虚拟光驱，创建虚拟机并启动。</p><h4 id="安装arch-linux"><strong>安装Arch Linux</strong></h4><p>启动刚刚新建的虚拟机，虚拟机将会自动加载的光驱并且进入引导界面。选择Boot Arch Linux(x86_64)选项启动，进入archiso的tyy控制台界面。此时已经可以使用一些常用的Linux命令操作了，安装过程本身也是使用Linux命令完成的。在控制台中输入<code>ping baidu.com</code>，可以检测网络状态——如果ping通，则网络连接正常。否则，可能需要退出虚拟机检查Hyper-V的虚拟网卡/交换器的设置，这可以参考Microsoft Docs。</p><figure><img src="https://i.loli.net/2020/03/08/pzMEqoLRhtPk9ZY.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/03/08/pzMEqoLRhtPk9ZY.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="屏幕截图_1_.jpg" /><figcaption aria-hidden="true">屏幕截图_1_.jpg</figcaption></figure><p>使用<code>cfdisk</code>命令打开cfdisk为虚拟机进行分区。在这次实验中，我将硬盘划分为四个区域，并将它们分别挂载为不同的目录：</p><table><thead><tr class="header"><th style="text-align: center;">分区名</th><th style="text-align: center;">大小</th><th style="text-align: center;">文件系统</th><th style="text-align: center;">挂载目录</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">/dev/sda1</td><td style="text-align: center;">32GB</td><td style="text-align: center;">ext4</td><td style="text-align: center;">/mnt</td></tr><tr class="even"><td style="text-align: center;">/dev/sda2</td><td style="text-align: center;">1G</td><td style="text-align: center;">vfat</td><td style="text-align: center;">/mnt/boot</td></tr><tr class="odd"><td style="text-align: center;">/dev/sda3</td><td style="text-align: center;">4G</td><td style="text-align: center;">..</td><td style="text-align: center;">SWAP分区</td></tr><tr class="even"><td style="text-align: center;">/dev/sda4</td><td style="text-align: center;">余下所有空间</td><td style="text-align: center;">ext4</td><td style="text-align: center;">/mnt/home</td></tr></tbody></table><p>在cfdisk中，上下方向键对存储块进行选择，左右键对命令选择，回车键开始操作。完成分区操作之后要执行[Write]命令保存分区信息后方可退出。可以使用<code>lsblk</code>命令展示分区的状态。完成分区之后，需要对分区进行挂载。挂载的命令如下： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mkfs.ext4 /dev/sda1</span><br><span class="line">mkfs.vfat -F32 /dev/sda2</span><br><span class="line">mkswap /dev/sda3</span><br><span class="line">mkfs.ext4 /dev/sda4</span><br><span class="line"></span><br><span class="line">mount /dev/sda1 /mnt</span><br><span class="line">mkdir /mnt/boot</span><br><span class="line">mount /dev/sda2 /mnt/boot</span><br><span class="line">swapon /dev/sda3</span><br><span class="line">mkdir /mnt/home</span><br><span class="line">mount /dev/sda4 /mnt/home</span><br></pre></td></tr></table></figure> 这一步完成之后，再在终端中输入命令<code>genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</code>生成文件系统信息。这一步是必要的，因为生成的文件系统信息会被用来在后面的步骤生成启动引导文件。</p><figure><img src="https://i.loli.net/2020/03/08/cYJw8ZyWr9VesfO.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/03/08/cYJw8ZyWr9VesfO.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="屏幕截图_2_.jpg" /><figcaption aria-hidden="true">屏幕截图_2_.jpg</figcaption></figure><p>Arch的安装是使用<code>pacman</code>安装的，他需要接收一些必要的数据才可以安装。而国内直接连接Arch官网的速度是非常的不理想的，所以需要更换镜像站，使用国内的镜像站下载必要的文件。首先，可以在控制台中输入<code>vi /etc/pacman.d/mirrorlist</code>以使用vim打开pacman的镜像文件，然后在文件开头加入你喜欢的镜像站，比如： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Server &#x3D; http:&#x2F;&#x2F;mirrors.163.com&#x2F;archlinux&#x2F;$repo&#x2F;os&#x2F;$arch</span><br><span class="line">Server &#x3D; http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;archlinux&#x2F;$repo&#x2F;os&#x2F;$arch</span><br></pre></td></tr></table></figure> 添加后控制台执行<code>pacman -Syy</code>更新镜像源，就完成了镜像源的替换。</p><p>在终端执行<code>pacstrap -i /mnt base base-devel linux linux-firmware</code>命令，使用缺省的默认设置（<del>一路回车</del>）就可以安装Arch了。特别注意的是，因为新版的Arch基本包已经不再包含Linux内核了，所以安装过程中一定要安装linux和linux-firmware两个包。否则之后创建引导的时候会因为找不到系统而安装失败。</p><figure><img src="https://i.loli.net/2020/03/08/HLBzDiACOKWkg6F.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/03/08/HLBzDiACOKWkg6F.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="屏幕截图_4_.jpg" /><figcaption aria-hidden="true">屏幕截图_4_.jpg</figcaption></figure><p>此时，Arch Linux已经安装到了虚拟机的硬盘中，为了配置刚安装的Arch Linux，我们需要从光盘的终端中切换到安装好的系统的终端中去。实现这件事的命令是<code>arch-chroot /mnt /bin/bash</code>。archiso-tyy执行这个命令之后的行首会发生变化，很容易观察到。在新的系统的终端中，我们可以： + 配置语言区域<br />使用<code>vi etc/locale.gen</code>打开文件，删除<code>en_US.UTF-8</code>前的#号，保存之后在终端运行<code>locale-gen</code>.</p><figure><img src="https://i.loli.net/2020/03/08/xXJArmPj2SRbcQz.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/03/08/xXJArmPj2SRbcQz.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="屏幕截图_8_.jpg" /><figcaption aria-hidden="true">屏幕截图_8_.jpg</figcaption></figure><ul><li><p>配置时区<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sf &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime</span><br></pre></td></tr></table></figure></p></li><li><p>安装grub并生成引导文件<br /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -S grub </span><br><span class="line">grub-install --force /dev/sda</span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure></p></li><li><p>安装dhcpcd并配置网络<br />对于有线网络，因为Base包里已经不包括联网所需的程序，所以需要下载dhcp客户端之后才能启动服务。<br /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pacman -S dhcpcd</span><br><span class="line">systemctl <span class="built_in">enable</span> dhcpcd.service</span><br></pre></td></tr></table></figure></p></li><li><p>设置主机名<br /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> shiohalinux &gt; /etc/hostname</span><br></pre></td></tr></table></figure></p></li><li><p>将主机名增加到<code>/etc/hosts</code><br />使用vim打开这个文件，将主机名添加到这个文件的后面，大概就像这样 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1    localhost.localdomain    localhost</span><br><span class="line">::1          localhost.localdomain    localhost</span><br><span class="line">127.0.1.1    shirohalinux.localdomain shirohalinux</span><br></pre></td></tr></table></figure></p></li><li><p>设置root的密码<br />终端中输入<code>passwd</code>命令后输入两次要创建的密码就可以了。</p></li><li><p>创建登录用户并给予它sudo权限<br />终端中输入<code>useradd -m -G wheel -s /bin/bash shiroha</code>就可以创建名为shiroha的用户。这里的命令最重要的是-G：它指定了用户要加入的附加组列表；现在我们将用户加到wheel组中，之后可以在接下来的操作中给予这个组执行sudo命令的权限，可以方便使用。（<del>当然，你也可以在新用户中使用<code>su - root</code>切换到root用户执行sudo命令</del>）使用<code>passwd shiroha</code>命令可以为新用户shiroha创建密码。可以通过修改<code>/etc/sudoers</code>文件为普通用户提权，但是一般使用命令<code>visudo</code>修改。使用该命令打开sudoers之后，删除wheel组前的#就可以了。特别说明：在使用<code>visudo</code>之前，请确保系统中已经安装了vim。</p></li></ul><p>完成了对新系统的配置之后，就可以退出光驱启动而直接从硬盘启动Arch Linux了。先在当前的终端中执行<code>exit</code>退回tyy终端，再使用<code>umount -R /mnt</code>解挂载光驱，并执行<code>reboot</code>命令重启。特别说明：因为Hyper-V的解挂载并不能弹出虚拟光驱，所以不需要执行解挂载的过程，使用<code>shutdown</code>关机之后再虚拟机管理页面弹出光驱，再手动启动虚拟机就可以了。</p><figure><img src="https://i.loli.net/2020/03/08/9CRia6k78XtcOYr.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/03/08/9CRia6k78XtcOYr.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="屏幕截图_14_.jpg" /><figcaption aria-hidden="true">屏幕截图_14_.jpg</figcaption></figure><h4 id="安装图形界面"><strong>安装图形界面</strong></h4><p>如果安装Arch Linux成功完成，那么可通过控制台登录到Arch。首先可以使用root登录到Arch，输入用户名root和正确的密码即可。</p><p>图形界面是Arch Linux中额外的软件包提供的功能。所以安装图形界面就是安装和这个图形界面相关的软件包就可以了。与这个相关的软件包主要包括<code>xorg</code>,<code>sddm</code>,<code>xfce4</code>,<code>plasma</code>,<code>ifconfig</code>.当然，这一步骤还会包括安装一些使用软件。</p><ul><li><p>安装脚本： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pacman -S xorg</span><br><span class="line">pacman -S xterm</span><br><span class="line">pacman -S xorg-xinit</span><br><span class="line">pacman -S sddm</span><br><span class="line">pacman -S xfce4</span><br><span class="line">pacman -S xfce4-goodies</span><br><span class="line">pacman -S plasma</span><br><span class="line">pacman -S kde-applications</span><br></pre></td></tr></table></figure> 所有的软件包都是使用<code>pacman</code>命令安装，特别要注意的是plasma安装前必须要确保xorg已经安装到虚拟机中；此外，因为plasma桌面环境是基于KDE桌面环境的，所以需要安装kde环境常用的软件包。</p></li><li><p>配置脚本： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sddm --example-config &gt; /etc/sddm.conf</span><br><span class="line">systemctl <span class="built_in">enable</span> sddm.service</span><br></pre></td></tr></table></figure> 这步主要是配置sddm：首先生成ssdm的配置文件，随后将ssdm服务增加开机启动项。ssdm主要提供了用户登录界面。</p></li></ul><figure><img src="https://i.loli.net/2020/03/08/Whp9ZV2AEw1avye.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/03/08/Whp9ZV2AEw1avye.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="屏幕截图_21_.jpg" /><figcaption aria-hidden="true">屏幕截图_21_.jpg</figcaption></figure><p>ssdm的登陆只能使用普通用户登录。这意味着如果你在之前的步骤没有增加一个普通用户，那么你需要使用<code>useradd</code>命令为电脑增加一个用户，并使用<code>passwd</code>为其设置密码。</p><h4 id="安装常用软件包"><strong>安装常用软件包</strong></h4><p>需要安装的一些常用软件包，主要是<code>ifconfig</code>,<code>ssh</code>,<code>zsh</code>,<code>git</code>以及<code>wget</code>.安装这些所有的软件包的脚本如下： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pacman -S net-tools dnsutils inetutils iproute2</span><br><span class="line">pacman -Syy openssh</span><br><span class="line">systemctl start sshd</span><br><span class="line">ps -e | grep sshd</span><br><span class="line">systemctl <span class="built_in">enable</span> sshd.service</span><br><span class="line">pacman -S zsh</span><br><span class="line">pacman -S git</span><br><span class="line">chsh -s $(<span class="built_in">which</span> zsh)</span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span></span><br><span class="line">pacman -S wget</span><br></pre></td></tr></table></figure> 虽然pacman用作包管理已经极其方便，但是他还是缺少了一些软件包。我们可以通过安装包管理器yaourt来解决pacman软件包不全的问题。安装yaourt可以这么做： - 在<code>/etc/pacman.conf</code>文件末尾处增加镜像源：<br /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[archlinuxcn]  </span><br><span class="line">Server=https://mirrors.ustc.edu.cn/archlinuxcn/<span class="variable">$arch</span></span><br></pre></td></tr></table></figure> - 更新镜像源并安装yaourt：<br /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -Sy</span><br><span class="line">pacman -S yaourt</span><br><span class="line">pacman -S archlinuxcn-keyring</span><br></pre></td></tr></table></figure> - 使用yaourt安装软件包：<br />比如安装Chrome可以使用命令<code>yaourt google-chrome</code>。</p><p>如果使用的虚拟机是VMWare而不是Hyper-V，可以为Arch安装vmware提供的VMwarm-tools。安装过程如下： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过虚拟机软件挂载VMwarm-tools</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 挂载安装程序</span></span><br><span class="line">mount /dev/cdrom /mnt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将工具解压</span></span><br><span class="line">tar xf /mnt/VMwareTools*.tar.gz -C /home/zhaozhao/Desktop</span><br><span class="line"><span class="built_in">cd</span> /etc</span><br><span class="line">mkdir init.d</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;0,1,2,3,4,5,6&#125;; <span class="keyword">do</span> mkdir rc<span class="variable">$i</span>.d; <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到解压文件存放的位置</span></span><br><span class="line"><span class="built_in">cd</span> /home/zhaozhao/Desktop/vmware-distrid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行安装脚本</span></span><br><span class="line">./vmware-install.pl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启计算机</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure> 这个程序提供了将Windows文件夹挂载到Linux的功能，可以方便的在虚拟机和物理机的操作系统之间传输数据。如果虚拟机软件支持这个软件包，建议安装一下。但是似乎Hyper-V并不支持这个包。</p><h3 id="五实验结果">五、实验结果</h3><p><strong>安装Linux</strong>：重新启动后，虚拟机画面上出现了grub的加载界面，其中的首选项是+Arch Linux。选择该项启动后，进入了Arch Linux的登陆终端而不是archiso的tyy终端，输入设置的用户以及对应的密码可以进入终端，安装完成。</p><p><strong>安装图形界面</strong>：此步完成后，启动虚拟机，待看到了服务启动的终端输出之后，将会看到sddm提供的用户登陆界面。输入正确的用户密码后会看到plasma桌面环境的加载画面，随后进入plasma桌面环境。</p><hr /><h2 id="实验二-编译并安装linux内核">实验二： 编译并安装Linux内核</h2><h3 id="一实验描述-1">一、实验描述</h3><p>在实验一中安装的Arch Linux虚拟机中编译一个从Arch官方网站上下载的内核，并且将这个内核安装到虚拟机中。</p><h3 id="二实验设计-1">二、实验设计</h3><ol type="1"><li><p>下载、编译、安装<br />进入官网下载内核、编译内核、安装内核模块、将编译的模块复制到/boot目录</p></li><li><p>制作初始化内存盘<br />制作初始化内存盘、<del>复制System.map</del></p></li><li><p>更新引导程序<br />更新grub配置、重启验证结果</p></li></ol><h3 id="三实验原理-1">三、实验原理</h3><ol type="1"><li><p>编译内核的<code>menuconfig</code></p><p>编译内核需要一个配置文件，而获得这个配置文件有很多种方法。其中一种方法是通过<code>make menuconfig</code>命令进入一个图形化的配置页面进行对内核的自定义配置，然后生成对应的.config文件。接下来简要的介绍一下键入这个命令后系统的执行的流程：</p><figure><img src="https://i.loli.net/2020/03/08/I7M3aJXxlupErFW.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/03/08/I7M3aJXxlupErFW.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="屏幕截图_30_.jpg" /><figcaption aria-hidden="true">屏幕截图_30_.jpg</figcaption></figure><p>首先，这个过程涉及到了以下的文件：</p><blockquote><p>Linux内核根目录下的<code>/scripts</code>文件夹<br /><code>arch/$ARCH/Kconfig</code>文件、各层目录下的<code>Kconfig</code>文件<br />Linux内核根目录下的<code>makefile</code>文件、各层目录下的<code>makefile</code>文件<br />Linux内核根目录下的的<code>.config</code>文件、<code>arm/$ARCH/.config</code>文件<br />Linux内核根目录下的<code>include/generated/autoconf.h</code>文件</p></blockquote><p>首先系统读取<code>arch/$ARCH/Kconfig</code>文件，使用/scripts下的绘制图形相关的文件生成图形化的config界面。环境变量<code>$ARCH</code>是定义在根目录的makefile文件中的。</p><p><code>arch/$ARCH/configs</code>目录下存储了默认的配置。内核会默认读取根目录下的<code>.config</code>文件作为默认配置。但是为了和内核完全匹配，往往需要对这个文件进行修改。</p><p>在图形化的配置界面调整了不同的选项之后，最后保存退出时Linux内核会把新的选项新到.config中。此时将.config重命名为其它文件保存起来（当执行<code>make distclean</code>时系统会把.config文件删除）就可以在需要的时候还原这个配置了。</p></li><li><p><code>make</code>命令</p><p>当<code>make</code>命令被执行时，它会扫描当前目录下makefile文件找到目标以及其依赖。如果这些依赖自身也是目标，继续为这些依赖扫描Makefile文件并且建立其依赖关系，然后编译它们。一旦主依赖编译之后，然后就编译主目标。如果之后某个源文件发生了修改，再次执行<code>make</code>命令，它将只编译与该源文件相关的目标文件。</p><p><code>make</code>指令的命令参量： &gt;-f：指定“makefile”文件； &gt;-i：忽略命令执行返回的出错信息； &gt;-s：沉默模式，在执行之前不输出相应的命令行信息； &gt;-r：禁止使用build-in规则； &gt;-n：非执行模式，输出所有执行命令，但并不执行； &gt;-t：更新目标文件； &gt;-q：make操作将根据目标文件是否已经更新返回"0"或非"0"的状态信息； &gt;-p：输出所有宏定义和目标文件描述； &gt;-d：Debug模式，输出有关文件和检测时间的详细信息。 &gt;-C dir：在读取makefile 之前改变到指定的目录dir； &gt;-I dir：当包含其他makefile文件时，利用该选项指定搜索目录； &gt;-h：help文挡，显示所有的make选项； &gt;-w：在处理makefile之前和之后，都显示工作目录。 &gt;-j：指定编译的线程数，线程数越大理论越快。</p><p><code>make install</code>是编译后的安装过程，它从makefile中读取信息，并且将软件包安装到指定位置。可以使用<code>configure</code>生成makefile文件。往往需要<code>sudo</code>权限来向系统写入数据。有的软件包在安装之前可能需要先运行 <code>make check</code>或<code>make test</code>来进行一些测试。</p><p><code>make clean</code>命令在编译前会清除之前编译的可执行文件及配置文件。而<code>make distclean</code>命令则会在编译前删除所有之前的编译生成的文件。使用这两项命令会使得编译过程延长，但是在编译内核的时候可以保证生成的内核树的绝对清洁。</p></li></ol><h3 id="四实验步骤-1">四、实验步骤</h3><h4 id="安装前准备-1"><strong>安装前准备</strong></h4><p>在开始之前，我们需要先查看一下虚拟机上的Arch Linux的当前的内核信息。查看内核信息可以通过<code>screenfetch</code>命令。这个软件包不是Arch Linux的基本包中包含的内容，所以再使用之前需要先安装： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pacman -S screenfetch</span><br></pre></td></tr></table></figure> 安装完成后就可以使用<code>screenfetch</code>命令查看内核信息了。截图保存以与应用新自定义内核后形成对比。</p><figure><img src="https://i.loli.net/2020/03/08/ySPFAD9TOmkUj7l.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/03/08/ySPFAD9TOmkUj7l.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="屏幕截图_33_.jpg" /><figcaption aria-hidden="true">屏幕截图_33_.jpg</figcaption></figure><p>首先，可以访问<a href="https://www.kernel.org/">官网</a>选择想要安装的内核版本进行下载。但是由于国内访问官网速度较慢，也可以通过国内的开源镜像站下载，比如<a href="https://mirrors.tuna.tsinghua.edu.cn/kernel/">清华大学镜像站</a>。选择需要下载的镜像之后使用<code>wget</code>命令下载。Arch的基本包是没有wget的，所以如果之前没有安装wget则需要通过<code>pacman</code>安装。这里我选择了Linux 5.3版本的内核，执行的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.3.tar.xz</span><br><span class="line">xz -d linux-5.3.tar.xz</span><br><span class="line">tar -xvf linux-5.3.tar</span><br></pre></td></tr></table></figure><p>下载完成后，使用<code>xz</code>命令和<code>tar</code>命令解压下载的内核包。解压后使用<code>cd</code>命令进入解压得到的目录下。</p><figure><img src="https://i.loli.net/2020/03/08/VmxheM8fJ6CTrdP.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/03/08/VmxheM8fJ6CTrdP.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="屏幕截图_28_.jpg" /><figcaption aria-hidden="true">屏幕截图_28_.jpg</figcaption></figure><h4 id="编译内核"><strong>编译内核</strong></h4><p>进入目录后就可以开始编译了，编译使用的命令是<code>make</code>。它有很多的模式可以选择，比如<code>make menuconfig</code>命令会进入由Kconfig和scripts构建的图形化的配置页面，完成配置后会生成一个.config文件。这里我使用的是缺省配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcat /proc/config.gz &gt; .config</span><br></pre></td></tr></table></figure><p>复制内核配置文件之后，还需要通过修改得到的config文件的<code>CONFIG_LOCALVERSION</code>的值来修改内核版本，以避免将要编译的内核文件覆盖当前内核文件。</p><p>得到了.config文件之后就可以开始编译了。编译的命令是<code>make -j&lt;线程数&gt;</code>。可以根据虚拟机的配置修改这里线程数的值。因为内核的编译需要一段较长的时间，合理的线程数可以增加编译的速度。我使用的是<code>make -j2</code>。</p><h4 id="安装内核并验证"><strong>安装内核并验证</strong></h4><p>完成了内核的编译之后就可以开始安装内核了。安装内核主要包括这些步骤：安装内核模块-&gt;复制内核文件-&gt;制作initramfs镜像-&gt;<del>复制System.map</del>-&gt;生成新的启动引导。执行的命令脚本如下：</p><ul><li><p>安装内核模块：<br /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make modules_install </span><br></pre></td></tr></table></figure> 这条命令会将编译好的模块安装到主目录/lib/modules下。这样，会使得这些模块独立于虚拟机原有内核的模块。</p></li><li><p>复制内核文件： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对于32位(i686)内核：</span></span><br><span class="line">sudo cp -v arch/x86/boot/bzImage /boot/vmlinuz-linux53</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于64位(x86_64)内核：</span></span><br><span class="line">sudo cp -v arch/x86_64/boot/bzImage /boot/vmlinuz-linux53</span><br></pre></td></tr></table></figure> 将内核编译完成生成的bzImage（较大的压缩的内核映像，使用gzip压缩）文件复制到<code>/boot</code>目录下。</p></li><li><p>制作initramfs（初始内存盘）镜像：<br />复制并且修改mkinitcpio（一个创建initramfs的脚本）preset就可以通过官方内核一样的方式生成自定义内核的initramfs镜像。复制之后需要使用vim修改这个文件。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/mkinitcpio.d/linux.preset /etc/mkinitcpio.d/linux53.preset</span><br><span class="line">sudo vi /etc/mkinitcpio.d/linux53.preset</span><br></pre></td></tr></table></figure> 打开linux53.preset文件之后，修改部分字段使得它与新的自定义内核所匹配。需要修改的字段如下： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /etc/mkinitcpio.d/linux53.preset</span></span><br><span class="line"></span><br><span class="line">ALL_kver=<span class="string">&quot;/boot/vmlinuz-linux53&quot;</span></span><br><span class="line">default_image=<span class="string">&quot;/boot/initramfs-linux53.img&quot;</span></span><br><span class="line">fallback_image=<span class="string">&quot;/boot/initramfs-linux53-fallback.img&quot;</span></span><br></pre></td></tr></table></figure> 修改并保存之后执行<code>sudo mkinitcpio -p linux53</code>就可以使用官方内核生成的方式生成自定义内核的initramfs镜像。</p></li><li><p>复制System.map 如果虚拟机的/boot挂载到的分区的文件系统是<code>ext4</code>格式。就需要将解压目录下的System.map文件复制到/boot中，并且创建/boot/System.map，将新建的System.map软链接到复制到其中的System.map中。需要执行的命令如下： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo touch /boot/System.map</span><br><span class="line">sudo cp System.map /boot/System.map-MyKernel</span><br><span class="line">sudo ln -sf /boot/System.map-Mykernel /boot/System.map</span><br></pre></td></tr></table></figure> 但是由于本次使用的虚拟机的boot分区挂载的分区是<code>vfat</code>文件系统的，无需也不必创建软链接。</p></li><li><p>更新grub引导的配置信息 使用命令<code>grub-mkconfig -o /boot/grub/grub.cfg</code>可以生成grub默认的配置信息。它会自动地将刚添加的内核增加到启动配置中。在Ubuntu这种系统中，这个命令被包装成了<code>update-grub</code>或其他形式。</p></li></ul><figure><img src="https://i.loli.net/2020/03/08/vt2FAibpehM4NGj.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/03/08/vt2FAibpehM4NGj.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="屏幕截图_37_.jpg" /><figcaption aria-hidden="true">屏幕截图_37_.jpg</figcaption></figure><p>随后使用<code>reboot</code>命令重新启动虚拟机，使用<code>screenfetch</code>命令查看当前的系统信息，就可以看到系统的内核发生了变化。这样内核的编译和安装就完成了。</p><h3 id="五实验结果-1">五、实验结果</h3><p>实验前和试验后，对Arch Linux虚拟机使用<code>screenfetch</code>命令获得的内核信息不相同，内核信息变成了安装的内核的版本信息，说明用户的自定义内核已经成功的编译并且安装。</p><hr /><h2 id="实验三-为linux内核增加系统调用">实验三： 为Linux内核增加系统调用</h2><h3 id="一实验描述-2">一、实验描述</h3><p>在实验一的Arch Linux虚拟机的基础上，在Linux内核中增加一个系统调用，并对这个修改生成patch。将这个patch应用到一个Linux内核中，编译并安装这个自定义内核，验证对内核增加的系统调用是否已经成功的应用到操作系统。</p><h3 id="二实验设计-2">二、实验设计</h3><ol type="1"><li><p>修改内核源码<br />向内核中增加一个函数、将函数注册为系统调用</p></li><li><p>生成补丁并重新编译内核<br />使用<code>diff</code>生成补丁、安装patch补丁、编译并安装内核</p></li><li><p>测试补丁是否成功patch<br />编写调用自定义系统调用的源文件、执行源文件观察结果</p></li></ol><h3 id="三实验原理-2">三、实验原理</h3><ol type="1"><li><p>patch<br />Patch有两种常用意思： &gt; <strong>Patch文件</strong>： &gt; &gt; 也就是补丁文件。在Linux社区中，如果某人对某一个版本的Linux源码做出了一定的修改以解决某些问题，并且希望把它分享出去，他就可以为代码生成一个patch文件供社区使用。往往，patch文件的目的是用于修正已知错误或者作为一种调试手段调试代码。一般来说，patch文件可以使用<code>diff</code>指令比较原有代码和修改过的代码生成。 &gt; &gt; <strong>Patch指令</strong> &gt; &gt; 是Linux中的一个指令。可以用于将patch文件的修改应用到一个代码中。并且在此基础上可以提供一些实用的功能：比如消除父目录，检测对象代码是否已经安装过此补丁等。关于patch命令的详细使用方法可以使用<code>man</code>命令或者求助Google。</p><figure><img src="https://i.loli.net/2020/03/08/JoyiWSGrs5the9Y.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/03/08/JoyiWSGrs5the9Y.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="屏幕截图_50_.jpg" /><figcaption aria-hidden="true">屏幕截图_50_.jpg</figcaption></figure><p>本次实验需要生成一个自定义的系统调用的patch文件，并且将这个patch文件应用到内核中。生成patch文件可以使用<code>diff</code>指令： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff -Naur kernel/ kernel_new/ &gt; new.patch</span><br></pre></td></tr></table></figure> 指令中，kernel/是修改前的内核源码所在的文件夹，kernel_new/目录是修改过的内核源代码所在的文件夹。这条指令将会比较两个内核的源码的差别并且根据对比结果生成"new.patch"文件。</p><p>如果要将这个patch文件应用到一个未修改的内核，可以使用<code>patch</code>命令将patch文件中记录的改动应用到内核源码中： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp -v new.patch kernel/</span><br><span class="line"><span class="built_in">cd</span> kernel</span><br><span class="line">patch -p1 &lt; new.patch</span><br></pre></td></tr></table></figure> 首先将patch文件放在将要打补丁的源码目录下，再使用<code>patch</code>命令就可以了。由于patch文件中记录了基于原代码所在目录的名字（所在目录的绝对地址），可能和当前打补丁的源码所在目录不匹配。比如当向Linux-5.3.x打Linux-5.3的补丁，就需要使用使用-p1参数忽视文件名目录的第一个分量。</p><p>官方网站也提供了Patch包下载。这些Patch包是用于大版本内的小版本更新的。使用时，只需要将对应的Patch文件patch到对应版本的内核源码文件中，编译安装patch后的内核即可。</p></li><li><p>系统调用<br />增加最简单的系统调用主要分为增加新函数-&gt;增加新声明-&gt;将新调用增加到系统调用注册表三个步骤。</p><p>增加新的系统调用函数：比如可以向内核缓存区打印一条消息。可以使用<code>printk</code>函数实现这个功能。打印到内核缓存区的消息不会直接输出到控制台中，需要使用<code>dmesg -c</code>命令清除所有缓冲区日志并且查看内核缓存区信息。<code>printk</code>函数打印的信息将会这里显示。</p><p>增加系统调用的声明：不同的Linux发行版所需要增加声明的头文件地址不同。大体是在内核文件夹下的include/目录下的unistd.h和syscalls.h文件中。对于Arch Linux，需要修改的头文件的目录是<code>include/uapi/asm-generic/unistd.h</code>和<code>include/linux/syscalls.h</code>。可以在这个文件的对应位置增加在系统源文件（一般是sys.c）中增加的系统调用函数的声明。</p><p>注册新系统调用：不同的Linux发行版OS的系统调用表所在的位置不同，对于Arch Linux而言，系统调用注册表的位置在<code>arch/x86/entry/syscalls</code>目录下。它包含了32位系统和64位系统的注册表，分别是<code>syscall_32.tbl</code>和<code>syscall_64.tbl</code>。</p></li><li><p>内核编程相关<br />dmesg 命令: &gt; &gt; <code>dmesg</code>命令在设备故障诊断中有重要的用途。它可以用于检测硬件连接或断开的信息，可以查看内核缓存区的信息，可以使用Linux管道规定它的输出范围获得需要的数据：比如搜索和特定硬件相关的消息等。关于这个命令的使用可以参考<code>man</code>或者Google。以下只介绍基本的一些使用方法。 &gt; &gt;+ 列出所有检测到的硬件： &gt; &gt; 比如要显示所有被内核检测到的硬盘设备，可以使用<code>grep</code>参量搜索<code>sda</code>关键词。最后执行的命令是：<code>dmesg | grep sda</code>。此外，<code>grep</code>命令参量可以附加<code>-i</code>选项表示忽略搜索字符串的大小写。 &gt; &gt;+ 输出指定行数的日志： &gt; &gt; 可以通过跟随<code>head</code>或者<code>tail</code>命令参量来控制显示的日志范围。比如需要显示前20行日志，可以使用命令<code>dmesg | head  -20</code>。 &gt; &gt;+ 清空dmesg缓冲区日志 &gt; &gt; 可以使用命令<code>dmesg -c</code>来清空dmesg的日志。该命令会清空dmesg环形缓冲区中的日志。但是依然可以查看存储在‘/var/log/dmesg’文件中的日志。此时连接任何的设备都会产生dmesg日志输出。</p><p>asmlinkage修饰符： &gt; &gt;<code>asmlinkage</code>的定义： &gt; &gt; 位于<code>/usr/include/asm/linkage.h</code>中，定义内容如下： &gt;<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">define</span> asmlinkage CPP_ASMLINKAGE __attribute__((regparm(0)))</span></span><br></pre></td></tr></table></figure> &gt;<code>__attribute__</code>是关键字，是gcc的C语言扩展，<code>regparm(0)</code>表示不从寄存器传递参数。如果是<code>__attribute__((regparm(3)))</code>，那么调用函数的时候参数不是通过栈传递，而是直接放到寄存器里，被调用函数直接从寄存器取参数。 &gt; &gt;这主要涉及了函数传参的方式是否通过寄存器。<code>asmlinkage</code>表示这些函数通过堆栈而不是通过寄存器传递参数。gcc编译器在汇编过程中调用C语言函数时传递参数有两种方法：一种是通过堆栈，另一种是通过寄存器。缺省时采用寄存器。 &gt; &gt;一般来说，内核中的函数都是通过<code>asmlinkage</code>限定使用堆栈传递参数的。我们向内核源文件中增加的系统调用函数也需要使用<code>asmlinkage</code>修饰。</p></li></ol><h3 id="四实验步骤-2">四、实验步骤</h3><h4 id="准备工作"><strong>准备工作</strong></h4><p>将从官网上下载的一个Linux内核源码解压，并将解压得到的文件夹复制一份。一份作为原版源码，对另一份进行修改。这里我使用实验二中使用的Linux内核作为基础。</p><h4 id="增加系统调用"><strong>增加系统调用</strong></h4><p>进入待修改的内核源码根目录，之后所有的相对路径都建立在<strong>内核源代码根目录</strong>的基础上。使用vim打开将要增加系统调用的实现的源文件<code>kernel/sys.c</code>。这里我们要增加的是最简单的系统调用，即在内核缓冲区打印消息，所以在它的末尾增加如下函数： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">void</span> <span class="title">sys_shirohashow</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">&quot;Shiroha do your best!&quot;</span>);</span><br><span class="line">    printk(<span class="string">&quot;\n@Edit by Shiroha on 2019-11-15.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这样，我们就增加了一个系统调用函数<code>sys_shirohashow</code>的实现。</p><figure><img src="https://i.loli.net/2020/03/08/CKV98qHsIEjg5li.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/03/08/CKV98qHsIEjg5li.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="屏幕截图_51_.jpg" /><figcaption aria-hidden="true">屏幕截图_51_.jpg</figcaption></figure><p>增加完实现之后，我们还需要为这个函数增加声明。增加声明主要需要修改两个文件。首先使用vim打开<code>include/uapi/asm-generic/unistd.h</code>，在这个文件的末尾处增加宏： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_shirohashow 765</span></span><br><span class="line">__SYSCALL(__NR_shirohashow,sys_shirohashow)</span><br></pre></td></tr></table></figure> 这里的765是系统调用的编号。注意不是所有的数字都可以使用，可以在设置这个数字之前前往系统调用注册表（<code>find syscall_64.tbl</code>寻找这个文件并使用<code>vi</code>或者<code>nano</code>查看确认系统调用编号的使用情况），然后使用没有被占用的系统调用编号。</p><figure><img src="https://i.loli.net/2020/03/08/zIQlPZM8de5Ejbf.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/03/08/zIQlPZM8de5Ejbf.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="屏幕截图_52_.jpg" /><figcaption aria-hidden="true">屏幕截图_52_.jpg</figcaption></figure><p>增加宏之后，还需要再使用命令<code>vi include/linux/syscalls.h</code>打开syscalls头文件，将函数的声明<code>asmlinkage void sys_shirohashow(void);</code>增加到该头文件中<code>/* kernel/sys.c */</code>的部分中。</p><h4 id="注册系统调用"><strong>注册系统调用</strong></h4><p>完成了系统调用的声明和实现后，还需要将系统调用注册到注册表中，才可以使得它可以被正确的系统调用编号调用。系统调用注册表文件储存在<code>arch/x86/entry/syscalls</code>目录下。32位系统是<code>syscall_32.tbl</code>，64位系统是<code>syscall_64.tbl</code>。可以根据需要修改对应的注册表。这里以修改64位注册表为例，将在<code>syscall_64.tbl</code>的第435号系统调用后增加以下内容： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">765     common  shirohashow         sys_shirohashow</span><br></pre></td></tr></table></figure> 保存退出后，对内核的源文件的修改就全部完成了。</p><h4 id="生成补丁并patch"><strong>生成补丁并patch</strong></h4><p>完成上述步骤中所有的操作后，就可以生成patch补丁了。可以通过<code>diff</code>命令对比原内核代码和修改后的内核代码得到补丁文件，执行命令： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff -Naur ../../linux-5.3/kernel/ kernel/ &gt; new.patch</span><br></pre></td></tr></table></figure></p><p>可以将生成的patch文件应用到原内核源码中，也可以直接编译修改过的内核源码。（本质上，对原内核源码运行<code>patch</code>命令打得到的补丁文件变为修改过后的版本）打补丁的命令是： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp -v new.patch ../../linux-5.3/kernel/new.patch</span><br><span class="line"><span class="built_in">cd</span> ../../linux-5.3/kernel/</span><br><span class="line">patch -p1 &lt; new.patch</span><br></pre></td></tr></table></figure> 安装patch之后就可以编译安装内核了。为了得到纯净的内核树，推荐编译过程中使用<code>make clean &amp;&amp; make mrproper</code>命令，但是这样的编译速度较慢，耗时较多。</p><figure><img src="https://i.loli.net/2020/03/08/wCqbJQPxYiERsyM.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/03/08/wCqbJQPxYiERsyM.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="屏幕截图_56_.jpg" /><figcaption aria-hidden="true">屏幕截图_56_.jpg</figcaption></figure><p>编译完成之后，可以采用实验二中的步骤（安装内核模块-&gt;复制内核文件-&gt;制作initramfs镜像-&gt;生成新的启动引导）来安装新的内核。安装完成后，重启虚拟机，打过自定义补丁的内核就安装完成了。</p><h4 id="验证系统调用"><strong>验证系统调用</strong></h4><p>我们对内核的修改是增加了一条系统调用。这个系统调用会在内核缓存目录中打印一条消息。所以验证该系统调用是否被正确应用，只需要编写一个程序调用该系统调用，并观察该系统调用是否正确执行即可。</p><figure><img src="https://i.loli.net/2020/03/08/4cMniNJpfxlvUeh.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/03/08/4cMniNJpfxlvUeh.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="屏幕截图_60_.jpg" /><figcaption aria-hidden="true">屏幕截图_60_.jpg</figcaption></figure><p>首先，使用以下命令新建一个C程序源文件并使用vim打开它： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch myTest.c</span><br><span class="line">vi myTest.c</span><br></pre></td></tr></table></figure> 在新建的源文件中输入以下的编码： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/reg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    syscall(<span class="number">765</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 保存并退出vim之后，使用以下命令编译并执行： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o myTest myTest.c</span><br><span class="line">./myTest</span><br></pre></td></tr></table></figure> 执行编译生成的二进制文件之后，控制台没有任何输出。这是因为<code>printk</code>函数是向内核缓冲区打印信息而不是控制台。需要使用<code>dmesg -c</code>命令输出内核缓冲区的信息，可以检查<code>printk</code>的输出结果。</p><h3 id="五实验结果-2">五、实验结果</h3><p>在安装了patch过的内核的Arch Linux虚拟机中执行调用新系统调用的C程序，并且使用<code>dmesg -c</code>命令查看内核缓存区，发现了系统调用使用<code>printk</code>函数打印的字符串。这说明增加的系统调用成功注册，并且随着编译后的内核成功安装到了虚拟机中。</p><figure><img src="https://i.loli.net/2020/03/08/Ph31fzT67LRHUqs.jpg" class="lazyload" data-srcset="https://i.loli.net/2020/03/08/Ph31fzT67LRHUqs.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="屏幕截图_61_.jpg" /><figcaption aria-hidden="true">屏幕截图_61_.jpg</figcaption></figure><p>2020-3-8 更新： 原本的截图可以去<a href="https://github.com/ymd45921/util_assets/blob/master/post/Linux-FoDOS/Screenshots.7z">这里</a>下载。</p><hr /><h2 id="附录">附录</h2><h3 id="疑问和未解决问题">疑问和未解决问题</h3><h4 id="虚拟机分辨率问题">虚拟机分辨率问题</h4><p>采用了Microsoft Docs中提到的，在grub配置文件中修改分辨率的方法。只对虚拟机运行时的tyy终端界面有效，而无法改变图形环境的分辨率。</p><h4 id="虚拟机没有显卡">虚拟机没有显卡</h4><p>使用<code>screenfetch</code>命令查看系统信息的时候发现虚拟机没有显卡。初步判定这是导致无法改变桌面环境的分辨率以及执行OpenGL程序的原因。</p><h4 id="patch后内核编译缓慢">patch后内核编译缓慢</h4><p>使用patch对已经预编译的内核进行打补丁操作之后，使用<code>make</code>编译时，make将所有的文件重新编译。而这种情况下，<code>make</code>应当只重新编译被patch修改过的极少部分文件。</p><h3 id="参考链接">参考链接</h3><p><a href="https://www.mivm.cn/archlinux-vmware/">ArchLinux 安装/配置/美化 - 米V米</a><br /><a href="https://zhidao.baidu.com/question/1639282938155182060.html">arch里没有update-grub这个命令吗 - 百度知道</a><br /><a href="https://blog.csdn.net/sharpbladepan/article/details/80629978">Hyper-V虚拟机安装Linux后修改Linux的屏幕分辨率 - CSDN</a><br /><a href="https://blog.csdn.net/u010603798/article/details/81253115">Linux环境下root用户与普通用户切换 - CSDN</a><br /><a href="https://blog.csdn.net/kfeng632/article/details/90316171">Windows 10 hyper-v安装manjaro 18.0.4+Xfce4 后调整分辨率 - CSDN</a><br /><a href="https://www.jianshu.com/p/3d3da6b930a1">美轮美奂的Arch, 详解Arch虚拟机安装 - 简书</a><br /><a href="https://forum.ubuntu.org.cn/viewtopic.php?f=155&amp;t=447732">Arch Linux 安装指南（ArchISO 2014.10） - Ubuntu论坛</a><br /><a href="https://blog.csdn.net/u011570492/article/details/55803327">defconfig、.config、kconfig与makefile和make menuconfig流程 - CSDN</a><br /><a href="https://zhidao.baidu.com/question/1385824998294456500.html">make oldconfig和make defconfig有何区别 - 百度知道</a><br /><a href="https://blog.csdn.net/qq_34247099/article/details/50949720">Linux 内核编译 - CSDN</a><br /><a href="https://www.cnblogs.com/renweihang/p/7683250.html">zimage和bzimage有什么区别 - 博客园</a><br /><a href="https://blog.csdn.net/liujiaoyage/article/details/31781289">asmlinkage的用法 - CSDN</a><br /><a href="https://www.cnblogs.com/zhaoxuguang/p/7810651.html">dmesg七种用法 - 博客园</a><br /><a href="https://www.cnblogs.com/china_blue/archive/2010/01/15/1648523.html">关于asmlinkage - 博客园</a><br /><a href="https://blog.csdn.net/zhouyelihua/article/details/6703488">汇编语言的主程序与子程序之间的参数传递方式 - CSDN</a><br /><a href="https://wiki.archlinux.org/index.php/Mkinitcpio_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">Archlinux官方Wiki - mkinitcpio（简体中文）</a><br /><a href="https://bbs.dian.org.cn/user/leegenux">Dian团队 - 网安组@李勉学长</a><br /><a href="https://wiki.archlinux.org/index.php/Installation_guide_(简体中文)">Installation guide (简体中文) - Arch Wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 实验报告 </tag>
            
            <tag> Linux </tag>
            
            <tag> Dian </tag>
            
            <tag> Arch </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

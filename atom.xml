<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>七海の参考書</title>
  
  <subtitle>恋はとこからきて、どこに行くだろう</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shiraha.cn/"/>
  <updated>2022-03-11T06:54:54.000Z</updated>
  <id>https://shiraha.cn/</id>
  
  <author>
    <name>七海</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>对于 npm 中 Dependencies 以及一些杂项的小结</title>
    <link href="https://shiraha.cn/2022/simple-summary-of-dependencies-and-misc-in-npm/"/>
    <id>https://shiraha.cn/2022/simple-summary-of-dependencies-and-misc-in-npm/</id>
    <published>2022-03-11T06:54:54.000Z</published>
    <updated>2022-03-11T06:54:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>一些关于 <code>npm</code> 中依赖和版本号的小结。知识盲区实在是太多了！</p><h2 id="npm-中的依赖"><code>npm</code> 中的依赖</h2><p><code>npm</code> 中的依赖主要有 <code>dependencies</code>、<code>devDependencies</code> 和 <code>peerDependencies</code>。</p><h3 id="dependencies-vs.-devdependencies"><code>dependencies</code> vs. <code>devDependencies</code></h3><p>顾名思义，前者是在生产环境和开发环境中都使用的包，而后者是仅在开发环境中使用的包。</p><p>比如 <code>gulp</code>、<code>webpack</code> 就是典型的只在开发环境中使用的包，无需打包到产品中。</p><p>开发环境和生产环境，可以通过 <code>NODE_ENV=production|development</code> 来指定。</p><p>对于 <code>npm</code> 而言，安装两种不同的依赖需要指定的完整标志分别是 <code>--save</code> 和 <code>--save-dev</code>。</p><h3 id="peerdependencies"><code>peerDependencies</code></h3><p>对于一般的 <code>dependencies</code> 的场合：如果我们有包 A 引用包 B 作为依赖，而我们在我们的项目中安装了包 A 作为依赖，那么实际上只有包 A 被安装到了我们的项目的 <code>node_modules</code> 中，包 B 实际上被安装到了包 A 安装目录下的 <code>node_modules</code> 中。这带来的结果是，虽然包 A 和包 B 都安装过了，我们可以使用 <code>require</code> 引用包 A，但是却不可以直接在我们的项目中引用包 B。</p><p>但是如果在包 A 中，包 B 是作为 <code>peerDependencies</code> 引入的，那么安装包 A 时，包 B 会被同样安装到我们项目的 <code>node_modules</code> 目录下；此时就可以直接在我们的项目中引用包 B。</p><p>综上所述，<code>peerDepenedencies</code> 的含义可以理解为对包管理器的要求：如果你安装了某个包，那么我建议你也安装我的 <code>peerDependencies</code>。</p><p><code>npm2</code> 在安装包时会强制安装包的 <code>peerDependencies</code>，不需要再宿主环境中指定对于这些包的依赖；而 <code>npm3</code> 不再强制安装这些依赖，而是在安装结束后检查本次安装是否正确；如果发现安装不正确则打印 WARN。不正确包括未安装和版本不匹配两种情况。</p><p>而如果出现了这种不正确的问题，只能手动解决：比如手动将这些依赖增加到 <code>package.json</code> 或者修改它们的版本使得这些依赖可以符合要求，然后 <code>npm install --force</code>…… 太蠢了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> WARN  using --force I sure hope you know what you are doing</span><br></pre></td></tr></table></figure><h2 id="npm-版本号规则"><code>npm</code> 版本号规则</h2><p>整体来说，<code>npm</code> 的版本号的格式是 <code>&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code> 的形式。</p><h3 id="版本号匹配规则">版本号匹配规则</h3><p>出现在 <code>package.json</code> 中的各种依赖包的版本实际上是匹配规则，又被称为 <code>npm</code> 语义化版本。一般来说有以下常用的匹配规则：</p><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr class="header"><th>写法</th><th>含义</th></tr></thead><tbody><tr class="odd"><td><code>version</code></td><td>精确匹配某个特定版本</td></tr><tr class="even"><td><code>&gt;version</code><br /><code>&lt;version</code><br /><code>&gt;=version</code> <br /><code>&lt;=version</code></td><td>大于、小于、大于等于、小于等于某个特定版本；表示了一个范围<br />将两个规则连写也可以表示一个范围；如：<code>&gt;=version1 &lt;version2</code></td></tr><tr class="odd"><td><code>~version</code></td><td>大致匹配某个版本。具体来说规则如下：<br />1）指定到 <code>&lt;patch&gt;</code>：形如 <code>~a.b.c</code>；指大于当前指定的版本，但是小于下一个次版本号的所有版本<br />2）指定到 <code>&lt;minor&gt;</code>：形如 <code>~a.b</code>；指固定主版本号和次版本号，补丁版本号任意<br />3）指定到 <code>&lt;major&gt;</code>：形如 <code>~a</code>；指固定主版本号，次版本号和补丁任意</td></tr><tr class="even"><td><code>^version</code></td><td>兼容某个版本，其含义是版本号中最左的非 0 版本号的右侧版本可以任意；<br />如 <code>^a.b.c</code> 实际上等价于 <code>&gt;=a.b.c</code> 和 <code>&lt;a+1.0.0</code> 同时成立；<br />而 <code>^0.a.b</code> 则等价于 <code>&gt;=0.a.b</code> 和 <code>&lt;0.a+1.0</code> 同时成立；<br />如果缺省了某个低权重的版本号，那么缺失的位置可以任意（此时类似 <code>~version</code>）</td></tr><tr class="odd"><td>标识符 <code>x</code></td><td>标识符 <code>x</code> 的位置可以填入任何数字</td></tr><tr class="even"><td>标识符 <code>*</code></td><td>表示任意版本；等价于留空规则；严格的来说等价于 <code>&gt;=0.0.0</code></td></tr><tr class="odd"><td><code>version1 - version2</code></td><td>匹配了 <code>[version1, version2]</code> 双闭区间的版本</td></tr><tr class="even"><td><code>range1 || range2</code></td><td>操作符 <code>||</code> 可以连接多个范围，表示匹配多个范围内的版本</td></tr></tbody></table><p>由此可以看出 <code>npm</code> 语义化版本中有各种各样的模糊和范围，这为前端的工程化引入了一些问题：当某些包升级过程中没有遵循语义化版本，可能会导致每次打包生成代码都不同；所以我们需要特定项目依赖的包的版本号，为此各大包管理器都引入了 <code>lockfile</code> 的机制来锁定项目依赖的版本号。</p><p>开源的包一般都不包含 <code>lockfile</code>，其原因可能是为了避免特定过多具体的包导致引用较多开源包重复打包某个包的不同版本使得工程体积膨胀，故只能信任其依赖的包遵循语义化版本的要求，某个小版本/大版本的功能不发生过大变化而可以兼容。</p><h3 id="包管理器的-install-和-update">包管理器的 <code>install</code> 和 <code>update</code></h3><p>以 <code>npm</code> 为例，安装有 <code>install</code> 和 <code>update</code> 两种命令；它们之间的区别主要体现在两个方面：</p><h4 id="对于已安装的模糊版本">对于已安装的模糊版本</h4><p><code>install</code> 会忽略模糊版本，而 <code>update</code> 会更新模糊版本至最新版。</p><p>对于未安装的包，两者都会直接安装</p><h4 id="对于-devdependencies">对于 <code>devDependencies</code></h4><p><code>install</code> 会安装/更新 <code>devDependencies</code>，除非指定 <code>--production</code> 标志。</p><p>而 <code>update</code> 会忽略 <code>devDependencies</code>，除非指定 <code>--dev</code> 标志。</p><h2 id="参考">参考</h2><ul><li><a href="https://www.cnblogs.com/wonyun/p/9692476.html">探讨npm依赖管理之peerDependencies</a></li><li><a href="https://blog.csdn.net/chenzhi5174/article/details/100718987">NPM版本号规则以及更新策略</a></li><li><a href="https://stackoverflow.com/questions/12478679/npm-install-vs-update-whats-the-difference">npm install vs. update - what's the difference?</a></li><li><a href="https://codingwithspike.wordpress.com/2016/01/21/dealing-with-the-deprecation-of-peerdependencies-in-npm-3/">Dealing with the deprecation of peerDependencies in NPM 3</a></li></ul>]]></content>
    
    <summary type="html">
    
      最近的一些折腾，涉及到了 npm 的各种各样的依赖以及各种知识盲区。于是上网查了之后就先进行一个简单的总结。
    
    </summary>
    
    
      <category term="Web" scheme="https://shiraha.cn/categories/Web/"/>
    
      <category term="前端" scheme="https://shiraha.cn/categories/Web/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="npm" scheme="https://shiraha.cn/tags/npm/"/>
    
      <category term="Web" scheme="https://shiraha.cn/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>考研中的伽马函数</title>
    <link href="https://shiraha.cn/2021/gamma-function-in-kaoyan/"/>
    <id>https://shiraha.cn/2021/gamma-function-in-kaoyan/</id>
    <published>2021-11-03T05:04:25.000Z</published>
    <updated>2021-11-09T06:29:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先，在概率论里我们经常能遇到一个神秘的不可积的积分： <span class="math display">\[I = \int_0^{+\infty} e^{-t^2} \text dt\]</span> 这个积分既不能直接凑出来，也不能使用分部积分法消掉什么；一般，我们会使用升维的方法转化到极坐标来解决这个积分，就大概是下面这样： <span class="math display">\[I^2 = \int_0^{+\infty} e^{-x^2} \text dx \cdot \int_0^{+\infty} e^{-y^2} \text dy = \iint_D e^{-(x^2+y^2)}\text dx\text dy\]</span> 这样，使用极坐标变换可以得到： <span class="math display">\[I^2 = \int_0^\frac\pi2\text d\theta\int_0^{+\infty}re^{-r^2}\text dr = \frac\pi2\left(-\frac12e^{-r^2}\Bigg|_0^{+\infty}\right) = \frac\pi4\]</span> 显然被积函数恒大于 0，故 <span class="math inline">\(I &gt; 0\)</span>，综上所述可得：<span class="math inline">\(I = \int_0^{+\infty} e^{-t^2} \text dt = \frac{\sqrt{\pi}}2\)</span>。</p><p>每次遇到这种积分都要这样搞一遍实在是有些麻烦，有没有更系统化的方法呢？经过查阅 Wolfram Alpha，得知这种形式的积分可以使用 Gamma 函数表示。</p><h2 id="定义">定义</h2><p>伽马函数也叫欧拉第二积分，是阶乘函数在实数与复数上扩展的一类函数，是阶乘函数在复数域上的延拓。怎么理解这句话呢？首先我们知道阶乘函数定义在正整数离散点上，若对于任何一个非整数，无法使用其定义式求出它的值，因此我们需要对其进行延拓—— 最后得到了如下的定义式： <span class="math display">\[\Gamma(x) = \int_0^{+\infty}t^{x-1}e^{-t}\text dt\]</span> 现在我们只考虑其在实数域且 <span class="math inline">\(x &gt; 0\)</span> 上的情况，毕竟考研只需要这个。</p><p>Gamma 函数作为阶乘函数在更广的数域上的延拓，首先它当然满足阶乘函数本来的定义；它具有如下的性质：</p><ul><li>阶乘函数：<span class="math inline">\(\Gamma(x) = (x - 1)!\)</span></li><li>递推关系：<span class="math inline">\(\Gamma(x) = (x-1)\Gamma(x-1)\)</span></li></ul><p>那么如何证明这两个性质呢？一般有两种常见的做法：</p><h3 id="分部积分法">分部积分法</h3><p>对于 <span class="math inline">\(\Gamma(k)\)</span> 的定义式使用分部积分法： <span class="math display">\[\int_0^{+\infty}t^{k-1}e^{-t}\text dt = \frac1{k}\int_0^{+\infty}e^{-t}\text dt^{k} = \frac1{k}\left(e^{-t}t^{k}\Bigg|_0^{+\infty} + \int_0^{+\infty}e^{-t}t^{k}\text dt\right)\]</span> 显然，第一项为 0，第二项又是 <span class="math inline">\(\Gamma(k+1)\)</span> 的定义式，故： <span class="math display">\[\Gamma(k) = \frac1{k}\int_0^{+\infty}e^{-t}t^{k} = \frac{\Gamma(k + 1)}{k}\]</span> 就得到了上面性质中说到的递推关系；但是我们现在还缺乏一个初值；对于 <span class="math inline">\(\Gamma(1)\)</span>： <span class="math display">\[\Gamma(1) = \int_0^{+\infty}e^{-t}\text dt = -e^{-t}\Bigg|_0^{+\infty} = 1\]</span> 结合上面的到的递推公式，就可以得到它和阶乘函数的对应关系。</p><h3 id="展开法">展开法</h3><p>这种做法需要一定的技巧性；首先我们可以进行如下的展开： <span class="math display">\[\begin{align}&amp;\frac1{1-x} = \sum_{k=0}^\infty x^k    &amp;,\ |x| &lt; 1\\&amp;e^x = \sum_{k=0}^\infty \frac{x^k}{k!} &amp;,\ x \in \R\end{align}\]</span> 对于第一个展开式，又有： <span class="math display">\[\frac1{1-x} = \frac1{1-x}\int_0^{+\infty}e^{-t} \text dt = -\frac1{1-x}\int_0^{+\infty}e^{-(1-x)t} \text d[-(1-x)t]\]</span> 综上所述，可得： <span class="math display">\[\frac1{1-x} = \int_0^{+\infty}e^{-t}\cdot e^{xt} \text dt\]</span> 上式右侧的 <span class="math inline">\(e^{xt}\)</span> 也可以利用第二个展开式展开为无穷级数： <span class="math display">\[\frac1{1-x} = \sum_{k=0}^\infty x^k = \int_0^{+\infty}e^{-t}\cdot \sum_{k=0}^\infty \frac{(xt)^k}{k!} \text dt = \sum_{k=0}^\infty \frac{\int_0^{+\infty}e^{-t}\cdot t^k \text dt}{k!} x^k\]</span> 简单地说，就是在一致收敛域 <span class="math inline">\(|x|&lt;1\)</span> 上，有： <span class="math display">\[\sum_{k=0}^\infty x^k = \sum_{k=0}^\infty \frac{\int_0^{+\infty}e^{-t}\cdot t^k \text dt}{k!} x^k\]</span></p><p>对比系数可得 Gamma 函数的定义式： <span class="math display">\[\Gamma(k+1) = \int_0^{+\infty}e^{-t}\cdot t^k \text dt = k!\]</span> 虽然上述等式需要在一致收敛域上才成立，但是 <span class="math inline">\(k\)</span> 才是函数的参数，因此 <span class="math inline">\(k\in\R\)</span> 不受限制。</p><h2 id="应用">应用</h2><p>那么，已经知道了 Gamma 函数，我们应该怎么运用到上述的情况中呢？对于积分 <span class="math inline">\(I\)</span>，我们令 <span class="math inline">\(x = \sqrt t\)</span>： <span class="math display">\[I = \frac12\int_0^{+\infty} t^{-\frac12}e^{-t} \text dt = \frac12\Gamma(\frac12) = \Gamma(\frac32)\]</span> 因此，我们得到了关键值 <span class="math inline">\(\Gamma(\frac12) = \sqrt\pi\)</span>。其他的值都可以从这个关键值出发求出；</p><h3 id="举例">举例</h3><p>下面对于几种常见的变换进行示范：</p><h4 id="int_0infty-e-frac12x2text-dx"><span class="math inline">\(\int_0^{+\infty} e^{-\frac12x^2}\text dx\)</span></h4><p>令 <span class="math inline">\(x = \sqrt{2t}\)</span>，那么有： <span class="math display">\[\int_0^{+\infty} e^{-\frac12x^2}\text dx = \frac1{\sqrt2}\int_0^{+\infty} t^{-\frac12}e^{-t}\text dt = \frac1{\sqrt2}\Gamma(\frac12)\]</span> 我们就可以使用关键值快速求出这个积分值</p><h4 id="int_0infty-x2e-frac12x2text-dx"><span class="math inline">\(\int_0^{+\infty} x^2e^{-\frac12x^2}\text dx\)</span></h4><p>同理，令 <span class="math inline">\(x = \sqrt{2t}\)</span>，那么有： <span class="math display">\[\int_0^{+\infty} x^2e^{-\frac12x^2}\text dx = \frac2{\sqrt2}\int_0^{+\infty} t^\frac12e^{-t}\text dt = \sqrt2\Gamma(\frac32)\]</span> 关键在于使用换元法将原积分转化成 Gamma 函数定义式的形式。</p><h3 id="查表">查表</h3><p>常用的类似积分的查表。</p><table style="width:100%;"><colgroup><col style="width: 19%" /><col style="width: 30%" /><col style="width: 20%" /><col style="width: 19%" /><col style="width: 9%" /></colgroup><thead><tr class="header"><th style="text-align: center;">被积函数</th><th style="text-align: center;"><span class="math inline">\(\Gamma\)</span> 函数</th><th style="text-align: center;">在 <span class="math inline">\(\R^+\)</span> 上积分值</th><th style="text-align: center;">在 <span class="math inline">\(\R\)</span> 上的积分值</th><th style="text-align: center;">说明</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><span class="math inline">\(x^{-\frac12}e^{-x}\)</span></td><td style="text-align: center;"><span class="math inline">\(\Gamma(\frac12)\)</span></td><td style="text-align: center;"><span class="math inline">\(\sqrt\pi\)</span></td><td style="text-align: center;"><em>不存在</em></td><td style="text-align: center;"><strong>关键值</strong></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(e^{-x}\)</span></td><td style="text-align: center;"><span class="math inline">\(\Gamma(1)\)</span></td><td style="text-align: center;"><span class="math inline">\(1\)</span></td><td style="text-align: center;"><em>不存在</em></td><td style="text-align: center;">反常积分</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(x^{\frac12}e^{-x}\)</span></td><td style="text-align: center;"><span class="math inline">\(\Gamma(\frac32)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{\sqrt\pi}2\)</span></td><td style="text-align: center;"><em>不存在</em></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(xe^{-x}\)</span></td><td style="text-align: center;"><span class="math inline">\(\Gamma(2)\)</span></td><td style="text-align: center;"><span class="math inline">\(1\)</span></td><td style="text-align: center;"><em>不存在</em></td><td style="text-align: center;">可分部积分</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(e^{-x^2}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac12\Gamma(\frac12)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{\sqrt{\pi}}2\)</span></td><td style="text-align: center;"><span class="math inline">\(\sqrt\pi\)</span></td><td style="text-align: center;"><strong>关键值</strong></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(xe^{-x^2}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac12\Gamma(1)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac12\)</span></td><td style="text-align: center;"><em>不存在</em></td><td style="text-align: center;">可直接积分</td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(x^2e^{-x^2}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac12\Gamma(\frac32)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{\sqrt{\pi}}4\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{\sqrt{\pi}}2\)</span></td><td style="text-align: center;"></td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(e^{-\frac12x^2}\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac1{\sqrt2}\Gamma(\frac12)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{\sqrt{2\pi}}2\)</span></td><td style="text-align: center;"><span class="math inline">\(\sqrt{2\pi}\)</span></td><td style="text-align: center;"></td></tr><tr class="odd"><td style="text-align: center;"><span class="math inline">\(xe^{-\frac12x^2}\)</span></td><td style="text-align: center;"><span class="math inline">\(\Gamma(1)\)</span></td><td style="text-align: center;"><span class="math inline">\(1\)</span></td><td style="text-align: center;"><em>不存在</em></td><td style="text-align: center;">可直接积分</td></tr><tr class="even"><td style="text-align: center;"><span class="math inline">\(x^2e^{-\frac12x^2}\)</span></td><td style="text-align: center;"><span class="math inline">\(\sqrt2\Gamma(\frac32)\)</span></td><td style="text-align: center;"><span class="math inline">\(\frac{\sqrt{2\pi}}2\)</span></td><td style="text-align: center;"><span class="math inline">\(\sqrt{2\pi}\)</span></td><td style="text-align: center;"></td></tr></tbody></table><p>部分积分在上面已经进行了推导。</p><h3 id="速记">速记</h3><p>说是速记，其实涉及到了 Gamma 函数的另一种形式；令 <span class="math inline">\(t = u^2\)</span>： <span class="math display">\[\Gamma(x) = \int_0^{+\infty}t^{x-1}e^{-t}\text dt = 2\int_0^{+\infty}u^{2x-1}e^{-u^2}\text du\]</span> 也就得到了 Gamma 函数的另一种表现形式： <span class="math display">\[\frac12\Gamma(x) = \int_0^{+\infty}u^{2x-1}e^{-u^2}\text du\]</span> 这种情况下和原定义不同；当 <span class="math inline">\(u\)</span> 的次数增加 2，对应的 Gamma 函数的参数增加 1.</p><p>虽然看起来很显然，但是在对于考研中各种类似这个的积分，使用这种形式可以快速建立积分和 Gamma 函数之间的关系，从而使用我们记忆的关键值和定义对积分求解。</p><h2 id="后记">后记</h2><p>原来这玩意不管是在汤家凤的高数讲义上还是在张宇概率论9讲上都有提到啊…… 我学的是个寄吧（）</p><h3 id="参考资料">参考资料</h3><ul><li><a href="https://blog.csdn.net/qq_43141726/article/details/104943994">伽马函数 - 959 - CSDN博客 - 伽马函数</a></li><li><a href="https://baike.baidu.com/item/伽玛函数/3540177?fromtitle=伽马函数&amp;fromid=11217190&amp;fr=aladdin">伽玛函数_百度百科 (baidu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/427673303?utm_source=qq&amp;utm_medium=social&amp;utm_oi=692365410040811520">世界上最美丽的函数——γ函数，一颗数学皇冠上的明珠，可以回答分数阶乘的问题 - 知乎 (zhihu.com)</a></li></ul>]]></content>
    
    <summary type="html">
    
      一个比较有趣的东西，恰好在概率论里看到了，就进行一个不算是总结的总结好了。
    
    </summary>
    
    
      <category term="课业" scheme="https://shiraha.cn/categories/%E8%AF%BE%E4%B8%9A/"/>
    
    
      <category term="推导" scheme="https://shiraha.cn/tags/%E6%8E%A8%E5%AF%BC/"/>
    
      <category term="考研数学" scheme="https://shiraha.cn/tags/%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>简单数学：从约数个数和到莫比乌斯反演</title>
    <link href="https://shiraha.cn/2021/sdoi-2015-the-summation-of-divisors/"/>
    <id>https://shiraha.cn/2021/sdoi-2015-the-summation-of-divisors/</id>
    <published>2021-08-05T14:32:56.000Z</published>
    <updated>2021-08-08T07:26:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>差不多算是基础的程度的知识的数论能力，就算已经不参加弹幕神乐的巫女想必也是应该要掌握的吧。</p><p>首先来点题目链接：<a href="https://www.luogu.com.cn/problem/P3327">P3327【SDOI2015】约数个数和 - 洛谷</a> | <a href="https://loj.ac/p/2185">2185. 「SDOI2015」约数个数和 - LibreOJ</a></p><blockquote><p><span class="math inline">\(\text d(x)\)</span> 是 <span class="math inline">\(x\)</span> 的约数个数，给定 <span class="math inline">\(N, M \le 50000\)</span>，求： <span class="math display">\[\sum_{i=1}^N\sum_{j=1}^M \text{d}(ij)\]</span></p></blockquote><h2 id="莫比乌斯反演">莫比乌斯反演</h2><p>这个题要用到它，但是我还不会。所以先随便学学吧！</p><h3 id="前置名词">前置名词</h3><h4 id="数论函数">数论函数</h4><p>定义域为正整数的函数称为数论函数。</p><h4 id="积性函数">积性函数</h4><p>若 <span class="math inline">\(f(x)\)</span> 是数论函数，且对于 <span class="math inline">\(\forall a,b \and (a,b)=1\)</span> 有 <span class="math inline">\(f(ab)=f(a)f(b)\)</span>，那么这样的数论函数称为积性函数。</p><p>常见的积性函数有欧拉函数（<span class="math inline">\(\varphi\)</span>）、莫比乌斯函数（<span class="math inline">\(\mu\)</span>）和除数函数（<span class="math inline">\(\sigma_k\)</span>）</p><h4 id="完全积性函数">完全积性函数</h4><p>若积性函数不需要 <span class="math inline">\((a,b)=1\)</span> 也能有 <span class="math inline">\(f(ab)=f(a)f(b)\)</span>，那样的 <span class="math inline">\(f\)</span> 就是完全积性函数。</p><p>常见的完全积性函数：<span class="math inline">\(f(x)=x\)</span>、<span class="math inline">\(1(x)=1\)</span></p><h4 id="dirichlet-卷积">Dirichlet 卷积</h4><p>两个数论函数 <span class="math inline">\(f,g\)</span> 的 Dirichlet 卷积的定义如下： <span class="math display">\[(f*g)(n)=\sum_{d\mid n}f(d)g(\frac nd)\]</span> 卷积运算符 <span class="math inline">\(*\)</span> 满足运算的交换律结合律以及对于 <span class="math inline">\(+\)</span> 的分配律；此外，对于满足 <span class="math inline">\(h(1)\ne0\)</span> 的数论函数 <span class="math inline">\(h\)</span>，卷积运算符还满足了等式的性质，即：<span class="math inline">\(f = g \Leftrightarrow f*h=g*h\)</span>。</p><p>Dirichlet 卷积具有<strong>单位元</strong>，其单位元 <span class="math inline">\(e\)</span> 定义如下： <span class="math display">\[\varepsilon:e(n)=\left\{\begin{matrix} 1\; (n=1)\\ 0\; (n\neq 1) \end{matrix}\right.=[n=1]\]</span></p><p>这个单位元也被称为单位函数，它是一个完全积性函数。</p><p><strong>结论 1</strong>：若 <span class="math inline">\(f, g\)</span> 是积性函数，那么 <span class="math inline">\(f*g\)</span> 也是积性函数。</p><p><strong>结论 2</strong>：积性函数的逆元（对于单位元）也是积性函数。</p><h3 id="莫比乌斯函数">莫比乌斯函数</h3><p>莫比乌斯函数是积性函数。</p><h4 id="定义">定义</h4><p>记作 <span class="math inline">\(\mu\)</span>；对于一个整数 <span class="math inline">\(n\)</span>，令其标准分解形式为 <span class="math inline">\(\prod p_i^{a_i},\ i\in[1, k]\)</span>，则莫比乌斯函数可以如下定义： <span class="math display">\[\mu(n)=\begin{cases}0 &amp;,\ \exists i: a_i &gt; 1 \\(-1)^k &amp;,\ \text{else}\end{cases}\]</span></p><p>简单地说：如果 <span class="math inline">\(n\)</span> 有平方因子，那么 <span class="math inline">\(\mu(n)=0\)</span>；否则是 <span class="math inline">\((-1)^k\)</span>，<span class="math inline">\(k\)</span> 是 <span class="math inline">\(n\)</span> 互不相同的质因子个数。</p><h4 id="性质">性质</h4><p>莫比乌斯函数最重要的性质是： <span class="math display">\[\sum_{d\mid n}\mu(d) = \begin{cases}1 &amp;,\ n=1 \\0 &amp;,\ n\ne1\end{cases} = e(n)\]</span> 用 Dirichlet 卷积的形式表示，就是 <span class="math inline">\(\mu * 1 = e\)</span>.</p><h5 id="这个性质的证明">这个性质的证明</h5><blockquote><p>令 <span class="math inline">\(n\)</span> 有标准分解形式为 <span class="math inline">\(\prod p_i^{a_i},\ i\in[1, k]\)</span>，定义 <span class="math inline">\(n&#39; = \prod p_i\)</span>；那么显然有： <span class="math display">\[\sum_{d\mid n}\mu(d) = 0 + \sum_{d\mid n&#39;}\mu(d)\]</span> 而 <span class="math inline">\(n&#39;\)</span> 中是没有重复的因子的，所以 <span class="math inline">\(d\)</span> 只需要在这 <span class="math inline">\(k\)</span> 个本质不同的因子中随意选取组合即可： <span class="math display">\[\sum_{d\mid n&#39;}\mu(d) = \sum_{i=0}^k \mathbf C_k^i\cdot(-1)^i\]</span> 为每一项增加一个 <span class="math inline">\(1^{k-i}\)</span>，由二项式定理可得： <span class="math display">\[\sum_{i=0}^k \mathbf C_k^i\cdot(-1)^i\cdot1^{k-i} = (-1 + 1)^k = 0^k\]</span> 显然，当且仅当 <span class="math inline">\(k=0\)</span> 时上式取值 <span class="math inline">\(1\)</span>；其他情况下均为 <span class="math inline">\(0\)</span>。而 <span class="math inline">\(k=0\)</span> 时，<span class="math inline">\(n\)</span> 没有任何素因子，故 <span class="math inline">\(n=1\)</span>.</p></blockquote><p>除此之外，我们还有一个结论可以帮助我们将莫比乌斯函数和欧拉函数联系起来： <span class="math display">\[\sum_{d\mid n}\frac{\mu(d)}d = \frac{\varphi(n)}n\]</span> 这个待会再想办法证（</p><h4 id="线性筛求解">线性筛求解</h4><p>根据定义，稍微修改一下线性筛，我们可以写出下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> n&gt; <span class="function"><span class="keyword">auto</span> &amp;<span class="title">mobius_sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">array</span>&lt;<span class="keyword">int</span>, n + 1&gt; mu;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;n + 1&gt; vis;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) prime.push_back(i), mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; pp : prime) &#123;</span><br><span class="line">            <span class="keyword">auto</span> ipp = (llong)i * pp;</span><br><span class="line">            <span class="keyword">if</span> (ipp &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            vis[ipp] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pp == <span class="number">0</span>) &#123; </span><br><span class="line">                mu[ipp] = <span class="number">0</span>; </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125; <span class="keyword">else</span> mu[ipp] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，线性筛基本可以求所有的积性函数。</p><h3 id="莫比乌斯反演-1">莫比乌斯反演</h3><p>对于一些函数 <span class="math inline">\(f(n)\)</span>，若它本身难求但其倍数/约数和好求，那么就可以用莫比乌斯反演来简化其运算。</p><h4 id="公式">公式</h4><p>设有数论函数 <span class="math inline">\(f,g\)</span>，那么有如下公式： <span class="math display">\[\begin{align}f(n)=\sum_{d\mid n}g(d) &amp;\iff g(n) = \sum_{d\mid n}\mu(d)f(\frac nd) \\f(n)=\sum_{n\mid d}g(d) &amp;\iff g(n) = \sum_{n\mid d}\mu(\frac dn)f(d)\end{align}\]</span> 形式一是标准形式。</p><h4 id="证明">证明</h4><p>我们先利用卷积知识简易证明上述的形式一：</p><blockquote><p>首先，将上式左边看作 <span class="math inline">\(f = g*1\)</span>；然后，有 Dirichlet 卷积的运算性质，我们在等式两侧卷积 <span class="math inline">\(\mu\)</span>，有： <span class="math display">\[f * \mu = g * 1 * \mu\]</span> 又因为莫比乌斯函数的性质有 <span class="math inline">\(e = 1 * \mu\)</span>，所以上式的右侧消去单位元，得：<span class="math inline">\(g = f * \mu\)</span>，即上式右侧。</p></blockquote><p>或者通过数论变换的方式证明形式一：</p><blockquote><p>数论变换就是反着推导的过程；对于上述关系右侧等式的右侧，代入关系左侧的条件可得： <span class="math display">\[\sum_{d\mid n}\mu(d)f(\frac nd) = \sum_{d\mid n}\mu(d)\sum_{k\mid \frac nd}g(k) = \sum_{k\mid n}g(k)\sum_{d\mid \frac nk}\mu(d)\]</span> 因为 <span class="math inline">\(dk\)</span> 是 <span class="math inline">\(n\)</span> 的因数，<span class="math inline">\(d\)</span> 和 <span class="math inline">\(k\)</span> 是对于 <span class="math inline">\(dk\)</span> 的进一步划分，这里交换求和顺序可以得到上式最右侧的形态；观察这个式子的右侧，利用莫比乌斯函数的主要性质，可以将其转化为单位函数的形式： <span class="math display">\[\sum_{k\mid n}g(k)\sum_{d\mid \frac nk}\mu(d) = \sum_{k\mid n}g(k)[\frac nk = 1] = g(n)\]</span> 也就是左侧的求和只有在 <span class="math inline">\(k = n\)</span> 时取值 <span class="math inline">\(g(n)\)</span>，结果也是 <span class="math inline">\(g(n)\)</span>，和形式一右侧等式的左侧一致。</p></blockquote><p>我们也可以如法炮制的证明形式二：</p><blockquote><p>将可被 <span class="math inline">\(n\)</span> 整除的 <span class="math inline">\(d\)</span> 表示成 <span class="math inline">\(kn\)</span>，将形式二的前提代入关系右侧的等式的右侧可得： <span class="math display">\[\begin{align}g(n) &amp;= \sum_{n\mid d}\mu(\frac dn)f(d) = \sum_{k=1}^{+\infty}\mu(k)f(kn)\\&amp;= \sum_{k=1}^{+\infty}\mu(k)\sum_{kn\mid q}g(q) = \sum_{n\mid q}g(q)\sum_{k\mid \frac qn}\mu(k)\end{align}\]</span> 然后再进行如法炮制的交换求和顺序：<span class="math inline">\(kn\)</span> 是无穷的 <span class="math inline">\(q\)</span> 的因数，再进一步划分 <span class="math inline">\(kn\)</span>；再次观察最右侧的式子，并转化为单位函数： <span class="math display">\[\sum_{n\mid q}g(q)\sum_{k\mid \frac qn}\mu(k) = \sum_{n\mid q}g(q)[\frac qn=1] = g(n)\]</span> 显然，整个求和式子只有在 <span class="math inline">\(q = n\)</span> 时才能取到值，且此时的值是 <span class="math inline">\(g(n)\)</span>，和形式二右侧等式的左侧一致。</p></blockquote><p>不知道看到这里，是否对于”莫比乌斯函数是一个和容斥系数相关的函数“这句话有了什么新的理解。</p><h4 id="应用">应用</h4><p>但是一般来说构造一个 <span class="math inline">\(f(n) = \sum_{d\mid n}g(d)\)</span> 颇有难度，那个公式很多时候都意义不明。所以通常的做法都是想办法整出一个 <span class="math inline">\([\gcd(i, j)=1]\)</span> 也就是 <span class="math inline">\(e(\gcd(i,j))\)</span>，然后通过 <span class="math inline">\(\sum_{d\mid \gcd(i,j)}\mu(d)\)</span> 来计算它；而这实际上就是莫比乌斯函数的性质——这样说也是十分意义不明，所以我们说一类相对比较常见的问题作为例子：</p><blockquote><p>给定 <span class="math inline">\(n\le m\)</span>，求解： <span class="math display">\[\sum_{i=1}^n\sum_{j=1}^m f(\gcd(i, j))\]</span></p></blockquote><p>我们考虑枚举 <span class="math inline">\(d = \gcd(i, j)\)</span> 的取值，于是有了： <span class="math display">\[\sum_{i=1}^n\sum_{j=1}^m f(\gcd(i, j)) = \sum_{d=1}^n \sum_{i=1}^{\lfloor\frac nd\rfloor}\sum_{j=1}^{\lfloor\frac md\rfloor} f(d)e(\gcd(i,j))\]</span> 那么我们可以对于单位函数的部分代入莫比乌斯函数的性质——有： <span class="math display">\[\sum_{d=1}^{\min(n,m)} \sum_{i=1}^{\lfloor\frac nd\rfloor}\sum_{j=1}^{\lfloor\frac md\rfloor} f(d)[\gcd(i,j)=1] = \sum_{d=1}^n \sum_{i=1}^{\lfloor\frac nd\rfloor}\sum_{j=1}^{\lfloor\frac md\rfloor} f(d)\sum_{r\mid\gcd(i,j)}\mu(r)\]</span> 对右侧式子进行反演——或者说调换求和顺序，去枚举 <span class="math inline">\(r\)</span> 的值并将其挪到外层，有： <span class="math display">\[\sum_{d=1}^n \sum_{i=1}^{\lfloor\frac nd\rfloor}\sum_{j=1}^{\lfloor\frac md\rfloor}f(d)\sum_{r\mid\gcd(i,j)}\mu(r) = \sum_{d=1}^n \sum_{r=1}^{\min(\lfloor\frac nd\rfloor,\lfloor\frac md\rfloor)}\mu(r)\sum_{i=1}^{\lfloor\frac n{dr}\rfloor}\sum_{j=1}^{\lfloor\frac m{dr}\rfloor}f(d)\]</span> 可以注意到这个时候右侧式子中的 <span class="math inline">\(i,j\)</span> 已经不会影响到所需要求和的东西了，相当于对 1 求和： <span class="math display">\[\sum_{d=1}^n \sum_{r=1}^{\lfloor\frac nd\rfloor}\mu(r)f(d)\sum_{i=1}^{\lfloor\frac n{dr}\rfloor}\sum_{j=1}^{\lfloor\frac m{dr}\rfloor}1 = \sum_{d=1}^n \sum_{r=1}^{\lfloor\frac nd\rfloor}\mu(r)f(d)\lfloor\frac n{dr}\rfloor\lfloor\frac m{dr}\rfloor\]</span> 此时，我们假设一个 <span class="math inline">\(g(t)\)</span>： <span class="math display">\[g(t) = \sum_{d\mid t}f(d)\mu(\frac td) = f * \mu\]</span> 观察题设的公式和我们的推到结果： <span class="math display">\[\sum_{i=1}^n\sum_{j=1}^m f(\gcd(i, j)) = \sum_{d=1}^n \sum_{r=1}^{\lfloor\frac nd\rfloor}\mu(r)f(d)\lfloor\frac n{dr}\rfloor\lfloor\frac m{dr}\rfloor\]</span> 我们把 <span class="math inline">\(dr\)</span> 看作一个整体，它是 <span class="math inline">\(n\)</span> 的因数，<span class="math inline">\(d,r\)</span> 是对其进一步的划分；那么令 <span class="math inline">\(t=dr\)</span>： <span class="math display">\[\sum_{i=1}^n\sum_{j=1}^m f(\gcd(i, j)) = \sum_{t=1}^ng(t)\lfloor\frac nt\rfloor\lfloor\frac mt\rfloor\]</span></p><p>至此，我们完成了题设公式的转换，即反演；<del>但是这样做的意义，是什么呢？</del>当然是推出来的这个式子相对比较好算了！一重求和不比二重求和容易？</p><h4 id="钢筋bushi"><del>钢筋（bushi</del></h4><p>上面的部分主要说的是对于含有 <span class="math inline">\(\gcd\)</span> 的式子的处理方法：弄出一个 <span class="math inline">\([\gcd(i,j)=1]\)</span> 然后再利用它的等价式子 <span class="math inline">\(\sum_{d\mid \gcd(i,j)}\mu(d)\)</span> 代换它，并求出了一个比较通用的“公式”；那么对于这种出现了 <span class="math inline">\(\gcd\)</span> 的式子，我就是想要使用反演公式设函数套怎么办呢？套路在此：</p><p>首先，我们再写一遍莫比乌斯反演公式的某种形态： <span class="math display">\[f(n)=\sum_{n\mid d}g(d) \iff g(n) = \sum_{n\mid d}\mu(\frac dn)f(d)\]</span> 一般来说，我们设 <span class="math inline">\(g(d)\)</span> 为范围内满足 <span class="math inline">\(\gcd(i, j) = d\)</span> 的数对个数，<span class="math inline">\(f(n)\)</span> 为满足 <span class="math inline">\(n \mid \gcd(i, j)\)</span> 的数对个数，那么它们就满足了： <span class="math display">\[\begin{align}g(d)&amp;=\sum_{i=1}^N\sum_{j=1}^M[\gcd(i, j)=d]\\ f(n)&amp;=\sum_{n\mid d}g(d)=\lfloor\frac Nn\rfloor\lfloor\frac Mn\rfloor\end{align}\]</span> 关于 <span class="math inline">\(f(n)\)</span> 的两种表达式：第一个表达式是利用我们定义的 <span class="math inline">\(g(d)\)</span> 来定义；第二个表达式是根据我们的定义直接得到的——当 <span class="math inline">\(i,j\)</span> 都有确定范围的时候，满足 <span class="math inline">\(\gcd(i, j) = kn\)</span> 的数对数量当然是这个。</p><p>这样，我们就可以利用前面写的那个莫比乌斯反演公式，得到： <span class="math display">\[g(n) = \sum_{n\mid d}\mu(\lfloor\frac dn\rfloor)f(d)\]</span> 当然，裸求 <span class="math inline">\(g(d)\)</span> 是不好求的；但是 <span class="math inline">\(\mu\)</span> 可以线性筛加维护前缀和，<span class="math inline">\(f(n)\)</span> 可以数论分块；于是我们就利用反演公式将不太好求的 <span class="math inline">\(g(d)\)</span> 简化的好求了一些。</p><h3 id="例题">例题</h3><p>上面的简介仍然是比较抽象，所以还是看几个题：</p><h4 id="haoi2011problem-b"><a href="https://www.luogu.com.cn/problem/P2522">【HAOI2011】Problem b</a></h4><blockquote><p>求 <span class="math inline">\(\sum_{i=a}^b \sum_{j=c}^d [\gcd(i,j)=k]\)</span></p></blockquote><p>首先原式的求和有区间，所以很显然地将他转化为一个二维差分的形式： <span class="math display">\[\begin{align}&amp;记\ A_{n,m}=\sum_{i=1}^n \sum_{j=1}^m [\gcd(i,j)=k]\\&amp;则\ 原式 = A_{b,d} - A_{b,c-1} - A_{a-1,d} + A_{a-1,c-1}\end{align}\]</span> 那么原来的问题转化成求 <span class="math inline">\(A_{n,m}\)</span>：</p><p>参考上面运用小节推的那个比较具有代表性的”公式“——这里 <span class="math inline">\(f(x)=[x=k]\)</span>；那么我们可以根据”公式“来套路的得到： <span class="math display">\[g(t) = \sum_{d\mid t}f(d)\mu(\frac td)\]</span> 然后，将它代回那个公式里，可以得到： <span class="math display">\[\begin{align}&amp;\sum_{i=1}^n \sum_{j=1}^m [\gcd(i,j)=k]\\=&amp;\sum_{t=1}^{\min(n,m)}\sum_{d\mid t}[d=k]\mu(\frac td)\lfloor\frac nt\rfloor\lfloor\frac mt\rfloor\\=&amp;\sum_{t=1,k\mid t}^{\min(n,m)}\mu(\frac tk)\lfloor\frac nt\rfloor\lfloor\frac mt\rfloor\\=&amp;\sum_{d=1}^{\lfloor\frac {\min(n,m)}k\rfloor}\mu(d)\lfloor\frac n{dk}\rfloor\lfloor\frac m{dk}\rfloor\end{align}\]</span> 现在这个公式已经可以通过 <span class="math inline">\(\mathcal O(n)\)</span> 来计算了；但是注意到这里待求和的式子还可以使用数论分块计算，所以实际上上式的时间复杂度是 <span class="math inline">\(\mathcal O(\sqrt n)\)</span> 的。<del>如果不会数论分块可以看这个：<a href="https://shiraha.cn/2021/The-concept-of-number-theory-partition/">数论分块入门 - 七海の参考書 (shiraha.cn)</a></del></p><p>然后，我们就能写出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> mu_sum[N + <span class="number">1</span>], a, b, c, d, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mu_seq</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mu_sum[r] - mu_sum[l - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> n&gt; <span class="function"><span class="keyword">auto</span> &amp;<span class="title">mobius_sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">array</span>&lt;<span class="keyword">int</span>, n + 1&gt; mu;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;n + 1&gt; vis;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) prime.push_back(i), mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; pp : prime) &#123;</span><br><span class="line">            <span class="keyword">auto</span> ipp = (llong)i * pp;</span><br><span class="line">            <span class="keyword">if</span> (ipp &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            vis[ipp] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pp == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[ipp] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> mu[ipp] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ybb</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) swap(n, m);</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>, nk = n / k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= nk; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> nlk = n / l / k, mlk = m / l / k;</span><br><span class="line">        r = min(&#123;nk, n / (n / l), m / (m / l)&#125;);</span><br><span class="line">        ret += mu_seq(l, r) * nlk * mlk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> mu = mobius_sieve&lt;N&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++ i)</span><br><span class="line">        mu_sum[i] = mu_sum[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> T = read(); T --;) &#123;</span><br><span class="line">        a = read(), b = read(), c = read();</span><br><span class="line">        d = read(), k = read();</span><br><span class="line">        <span class="keyword">auto</span> ans = ybb(b, d) - ybb(b, c - <span class="number">1</span>) - ybb(a - <span class="number">1</span>, d) + ybb(a - <span class="number">1</span>, c - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>遇事不决开 <code>long long</code> 是吧？<code>long long</code> 不是你的电子宠物（</del></p><h4 id="yy的gcd"><a href="https://www.luogu.com.cn/problem/P2257">YY的GCD</a></h4><blockquote><p>求 <span class="math inline">\(\sum_{i=1}^n \sum_{j=1}^m [\gcd(i,j)\ \text{is}\ \text{prime}]\)</span></p></blockquote><p>令 <span class="math inline">\(n\le m\)</span>，还是很套路地把上面的式子变成枚举 <span class="math inline">\(\gcd\)</span> 的值： <span class="math display">\[原式 = \sum_{k=1}^{\min(n,m)}\sum_{i=1}^n \sum_{j=1}^m [\gcd(i, j)=k] = \sum_{k=1}^{n}\sum_{i=1}^{\lfloor\frac nk\rfloor} \sum_{j=1}^{\lfloor\frac mk\rfloor} [\gcd(i, j)=1],\ k\ \text{is}\ \text{prime}\]</span> 还是运用“应用”部分得到的公式；我们轻而易举地发现 <span class="math inline">\(f=e\)</span>，那么套路地设 <span class="math inline">\(g\)</span>： <span class="math display">\[g(t) = f * \mu = \sum_{d\mid t}e(d)\mu(\frac td)\]</span> 然后还是代回原来的那个包含 <span class="math inline">\(f\)</span> 的表达式中，可以得到： <span class="math display">\[\begin{align}&amp;\sum_{k=1}^n\sum_{i=1}^{\lfloor\frac nk\rfloor} \sum_{j=1}^{\lfloor\frac mk\rfloor} e(\gcd(i, j)),\ \ k\ \text{is}\ \text{prime}.\\=&amp;\sum_{k=1}^n\sum_{t=1}^{\lfloor\frac nk\rfloor}\sum_{d\mid t}e(d)\mu(\frac td)\lfloor\frac n{tk}\rfloor\lfloor\frac m{tk}\rfloor\\=&amp;\sum_{k=1}^n\sum_{t=1}^{\lfloor\frac nk\rfloor}\mu(t)\lfloor\frac n{tk}\rfloor\lfloor\frac m{tk}\rfloor\end{align}\]</span> 令 <span class="math inline">\(x = tk\)</span>，那么： <span class="math display">\[上式 = \sum_{x=1}^n\sum_{k\mid x}\mu(\frac xk)\lfloor\frac nx\rfloor\lfloor\frac mx\rfloor = \sum_{x=1}^n\lfloor\frac nx\rfloor\lfloor\frac mx\rfloor\sum_{k\mid x}\mu(\frac xk),\ \ k\ \text{is}\ \text{prime}.\]</span> 那么式子就推到这里；上面的式子左边可以数论分块，右边那个东西虽然看起来玄乎但是总归还是可以预处理的：只需要对于所有的质数在范围内的倍数“对数筛”即可，复杂度不明<del>不会素数定理</del>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">1e7</span> + <span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> f[N + <span class="number">1</span>], f_sum[N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f_sec</span><span class="params">(llong l, llong r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f_sum[r] - f_sum[l - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> n&gt; <span class="function"><span class="keyword">auto</span> <span class="title">mobius_sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">array</span>&lt;<span class="keyword">int</span>, n + 1&gt; mu;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;n + 1&gt; vis;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) prime.push_back(i), mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; pp : prime) &#123;</span><br><span class="line">            <span class="keyword">auto</span> ipp = (llong)i * pp;</span><br><span class="line">            <span class="keyword">if</span> (ipp &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            vis[ipp] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pp == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[ipp] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> mu[ipp] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(ref(prime), ref(mu));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">llong <span class="title">fuck</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) swap(n, m);</span><br><span class="line">    llong ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (llong l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = min(&#123;n / (n / l), m / (m / l), (llong) n&#125;);</span><br><span class="line">        ret += (llong) f_sec(l, r) * (n / l) * (m / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> [prime, mu] = mobius_sieve&lt;N&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> pp : prime)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;; ++ i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> ipp = (llong)i * pp;</span><br><span class="line">            <span class="keyword">if</span> (ipp &gt; N) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> f[ipp] += mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++ i)</span><br><span class="line">        f_sum[i] = f_sum[i - <span class="number">1</span>] + f[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> T = read(); T --;) &#123;</span><br><span class="line">        <span class="keyword">auto</span> n = read(), m = read();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; fuck(n, m) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓条条大路通罗马<del>（罗马！）</del>，直接用莫比乌斯反演公式也能推出一样的式子，看各自喜好了（</p><h2 id="思路">思路</h2><p>那么，你已经学会了莫比乌斯反演了，快上！（指做开篇的那个题</p><h3 id="关于-dx">关于 d(x)</h3><p>首先关于这个都不太熟的 <span class="math inline">\(\text d(x)\)</span>，我们有一个结论： <span class="math display">\[\text d(NM) = \sum_{i\mid N}\sum_{j\mid M}[\gcd(i, j)=1]\]</span> 这个式子为什么是正确的？首先考虑对于一个整数 <span class="math inline">\(X\)</span> 的标准分解，即 <span class="math inline">\(X = \prod p_i^{a_i}\)</span>，约数的个数为 <span class="math inline">\(\text d(X) = \prod (a_i + 1)\)</span>；这非常的好理解，它的约数必定由它的质因子构成，每个质因子 <span class="math inline">\(p_i\)</span> 有 <span class="math inline">\(a_i + 1\)</span> 种不同的选法。合数因子本身就是对于这个数字所有的质因子进行这样的选择组合而成；对于 <span class="math inline">\(NM\)</span>，我们也可以从这个角度入手考虑：</p><p>对于一个素数 <span class="math inline">\(p\)</span>，有 <span class="math inline">\(N = n\times p^x\)</span> 和 <span class="math inline">\(M=m\times p^y\)</span>；那么显然 <span class="math inline">\(p\)</span> 在 <span class="math inline">\(NM\)</span> 中出现的次数是 <span class="math inline">\(x + y\)</span> 次，关于这个质因子有 <span class="math inline">\(x + y + 1\)</span> 种选法。那么怎么枚举选法呢？显然，若枚举 <span class="math inline">\(i\mid N\)</span> 和 <span class="math inline">\(j\mid M\)</span>，得到的 <span class="math inline">\(ij \mid NM\)</span>。那么问题就在于两次不同的枚举得到的 <span class="math inline">\(ij\)</span> 的乘积可能实际上是一样的；为了避免重复，我们定义下面的取法：</p><ul><li>令对于 <span class="math inline">\(NM\)</span> 和素因子 <span class="math inline">\(p\)</span>，我们要选取其中的 <span class="math inline">\(k\)</span> 次，那么这 <span class="math inline">\(k\)</span> 个 <span class="math inline">\(p\)</span> 就要由 <span class="math inline">\(N\)</span> 和 <span class="math inline">\(M\)</span> 来提供。</li><li>当 <span class="math inline">\(k \le x\)</span> 时，我们要求 <span class="math inline">\(p\)</span> 完全由 <span class="math inline">\(N\)</span> 提供；此时可以选出 <span class="math inline">\(k = x + 1\)</span> 种不同的有序数对 <span class="math inline">\((p^k, 1)\)</span></li><li>当 <span class="math inline">\(k &gt; x\)</span> 时，我们要求超过 <span class="math inline">\(x\)</span> 的部分由 <span class="math inline">\(M\)</span> 提供，但不再在 <span class="math inline">\(N\)</span> 中选择；此时有 <span class="math inline">\(y\)</span> 种有序数对 <span class="math inline">\((1,p^{k-x})\)</span></li></ul><p>因此对于每一个因子，在上述规则的限制下，在 <span class="math inline">\(NM\)</span> 中只会选出 <span class="math inline">\(x + y + 1\)</span> 种不同的选法，符合我们的要求；而实现这样的限制条件很显然可以通过 <span class="math inline">\(\gcd(i, j)=1\)</span> 来达成目的，因为我们从来没有在 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 中同时选择 <span class="math inline">\(p\)</span>.</p><h3 id="变换">变换</h3><p>综上所述，我们要求的式子可以写成下面的形式： <span class="math display">\[\sum_{n=1}^N\sum_{m=1}^M\text d(nm) = \sum_{n=1}^N\sum_{m=1}^M\sum_{i\mid n}\sum_{j\mid m}[\gcd(i, j)=1]\]</span> 改变四层求和的枚举顺序，先枚举 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span>，那么可以得到下面的形式： <span class="math display">\[\sum_{n=1}^N\sum_{m=1}^M\text d(nm) = \sum_{i=1}^N\sum_{j=1}^M\lfloor\frac Ni\rfloor\lfloor \frac Mj\rfloor[\gcd(i,j)=1]\]</span> 那么就转化了题设的公式，可以基于这个公式进行莫比乌斯反演了。</p><h3 id="反演">反演</h3><p>根据上面的讨论，我们已经得到了一个包含了 <span class="math inline">\(e(\gcd(i, j))\)</span> 形态的公式，现在对它进行操作：</p><p>根据 Dirichlet 卷积的单位元的性质，也就是 <span class="math inline">\(e = 1*\mu\)</span>，得： <span class="math display">\[\sum_{i=1}^N\sum_{j=1}^M\lfloor\frac Ni\rfloor\lfloor \frac Mj\rfloor[\gcd(i,j)=1] = \sum_{i=1}^N\sum_{j=1}^M\lfloor\frac Ni\rfloor\lfloor \frac Mj\rfloor\sum_{d\mid\gcd(i, j)}\mu(d)\]</span> 对于最右边这个子式，我们很自然地想到枚举 <span class="math inline">\(d\)</span>；令 <span class="math inline">\(\min(N,M)=N\)</span>，调换枚举顺序： <span class="math display">\[\sum_{i=1}^N\sum_{j=1}^M\lfloor\frac Ni\rfloor\lfloor \frac Mj\rfloor\sum_{d=1}^{\min(N,M)}[d\mid\gcd(i,j)]\mu(d) = \sum_{d=1}^{N}\mu(d)\sum_{i=1}^N\sum_{j=1}^M\lfloor\frac Ni\rfloor\lfloor \frac Mj\rfloor[d\mid\gcd(i,j)]\]</span> 右边的双层枚举子式又是典型的求 <span class="math inline">\(\gcd\)</span> 是倍数的类型，进行套路地转换： <span class="math display">\[\sum_{d=1}^{N}\mu(d)\sum_{i=1}^{\lfloor\frac Nd\rfloor}\sum_{j=1}^{\lfloor\frac Md\rfloor}\lfloor\frac N{id}\rfloor\lfloor \frac M{jd}\rfloor = \sum_{d=1}^{N}\mu(d)\sum_{i=1}^{\lfloor\frac Nd\rfloor}\lfloor\frac N{id}\rfloor\sum_{j=1}^{\lfloor\frac Md\rfloor}\lfloor\frac M{jd}\rfloor\]</span> 综上所述，我们通过反演将原式转化为了： <span class="math display">\[\sum_{n=1}^N\sum_{m=1}^M\text d(nm) = \sum_{d=1}^{\min(N,M)}\mu(d)(\sum_{i=1}^{\lfloor\frac Nd\rfloor}\lfloor\frac N{id}\rfloor\cdot\sum_{j=1}^{\lfloor\frac Md\rfloor}\lfloor\frac M{jd}\rfloor)\]</span> 那么这个化简后的式子要怎么去求呢？容易发现两个子求和是近乎一致的，可以预先处理；因此我们定义函数 <span class="math inline">\(h(n)=\sum_{i=1}^n\lfloor\frac ni\rfloor\)</span>，于是有： <span class="math display">\[\sum_{n=1}^N\sum_{m=1}^M\text d(nm) = \sum_{d=1}^{\min(N,M)}\mu(d)h(\lfloor\frac Nd\rfloor)h(\lfloor\frac Md\rfloor)\]</span> 而实际上，<span class="math inline">\(h(n)\)</span> 就是约数个数函数 <span class="math inline">\(\text d(x)\)</span> 的前缀和，这个也可以用线性筛求出来维护前缀和；当然如果不想使用线性筛来维护这个，也可以直接分块计算后加起来——复杂度是 <span class="math inline">\(\mathcal O(n\sqrt n)\)</span>；</p><h3 id="代码实现">代码实现</h3><p>综上所述，我们可以用分块和分块求解上面反演得到的式子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> h[N + <span class="number">1</span>], mu_sum[N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mu_sec</span><span class="params">(llong l, llong r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mu_sum[r] - mu_sum[l - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> n&gt; <span class="function"><span class="keyword">auto</span> <span class="title">mobius_sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">array</span>&lt;<span class="keyword">int</span>, n + 1&gt; mu;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;n + 1&gt; vis;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) prime.push_back(i), mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; pp : prime) &#123;</span><br><span class="line">            <span class="keyword">auto</span> ipp = (llong)i * pp;</span><br><span class="line">            <span class="keyword">if</span> (ipp &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            vis[ipp] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pp == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[ipp] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> mu[ipp] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(ref(prime), ref(mu));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">llong <span class="title">partition</span><span class="params">(llong n)</span> </span>&#123;</span><br><span class="line">    llong ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (llong l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = min(n / (n / l), n);</span><br><span class="line">        ret += (r - l + <span class="number">1</span>) * (n / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">llong <span class="title">fuck</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) swap(n, m);</span><br><span class="line">    llong ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (llong l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = min(&#123;n / (n / l), m / (m / l), (llong)n&#125;);</span><br><span class="line">        ret += (llong) mu_sec(l, r) * h[n / l] * h[m / l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> [prime, mu] = mobius_sieve&lt;N&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++ i)</span><br><span class="line">        mu_sum[i] = mu_sum[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++ i)</span><br><span class="line">        h[i] = (<span class="keyword">int</span>) partition(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> T = read(); T --;) &#123;</span><br><span class="line">        <span class="keyword">auto</span> n = read(), m = read();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; fuck(n, m) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用线性筛维护 <span class="math inline">\(\text d(x)\)</span> 再求其前缀和 <span class="math inline">\(h(x)\)</span>，则需要引入新的线性筛：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">5e4</span> + <span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> h[N + <span class="number">1</span>], mu_sum[N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mu_sec</span><span class="params">(llong l, llong r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mu_sum[r] - mu_sum[l - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> n&gt; <span class="function"><span class="keyword">auto</span> <span class="title">mobius_sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">array</span>&lt;<span class="keyword">int</span>, n + 1&gt; mu;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;n + 1&gt; vis;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) prime.push_back(i), mu[i] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; pp : prime) &#123;</span><br><span class="line">            <span class="keyword">auto</span> ipp = (llong)i * pp;</span><br><span class="line">            <span class="keyword">if</span> (ipp &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            vis[ipp] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pp == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[ipp] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> mu[ipp] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(ref(prime), ref(mu));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> n&gt; <span class="function"><span class="keyword">auto</span> <span class="title">divisor_sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">array</span>&lt;<span class="keyword">int</span>, n + 1&gt; d, c;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;n + 1&gt; vis;</span><br><span class="line">    d[<span class="number">1</span>] = <span class="number">1</span>, c[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            prime.push_back(i);</span><br><span class="line">            d[i] = <span class="number">2</span>, c[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; pp : prime) &#123;</span><br><span class="line">            <span class="keyword">auto</span> ipp = (llong)i * pp;</span><br><span class="line">            <span class="keyword">if</span> (ipp &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> vis[ipp] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % pp == <span class="number">0</span>) &#123;</span><br><span class="line">                c[ipp] = c[i] + <span class="number">1</span>;</span><br><span class="line">                d[ipp] = d[i] / c[ipp] * (c[ipp] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> c[ipp] = <span class="number">1</span>, d[ipp] = d[i] * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(ref(prime), ref(d));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">llong <span class="title">fuck</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) swap(n, m);</span><br><span class="line">    llong ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (llong l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = min(&#123;n / (n / l), m / (m / l), (llong)n&#125;);</span><br><span class="line">        ret += (llong) mu_sec(l, r) * h[n / l] * h[m / l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> [prime, mu] = mobius_sieve&lt;N&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++ i)</span><br><span class="line">        mu_sum[i] = mu_sum[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;d = divisor_sieve&lt;N&gt;().second;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++ i)</span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] + d[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> T = read(); T --;) &#123;</span><br><span class="line">        <span class="keyword">auto</span> n = read(), m = read();</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; fuck(n, m) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，肯定是要把两个线性筛写在一起的；像上面那样写的人脑子多半是有点大病（</p><p>于是，这个问题就解决了！</p><h2 id="后记">后记</h2><p>莫比乌斯反演还是比较有趣的；这里列举的也仅仅是最基础最基础的板子题，用来加深对这个公式的推导以及这种方法的理解——也就是说有趣的题还有很多……之后有时间做了再整理一篇吧（</p><h3 id="参考资料">参考资料</h3><ul><li><a href="https://oi-wiki.org/math/mobius/">莫比乌斯反演 - OI Wiki (oi-wiki.org)</a></li><li><a href="https://zhuanlan.zhihu.com/p/106775790">数论小白入门-- 莫比乌斯反演 - 知乎 (zhihu.com)</a></li><li><a href="https://www.cnblogs.com/peng-ym/p/8647856.html">莫比乌斯反演 - pengym - 博客园 (cnblogs.com)</a></li><li><a href="https://blog.csdn.net/jjikkollp/article/details/75675590?spm=1001.2014.3001.5501">【bzoj3994】约数个数和_喵~-CSDN博客</a></li><li><a href="https://www.luogu.com.cn/blog/An-Amazing-Blog/mu-bi-wu-si-fan-yan-ji-ge-ji-miao-di-dong-xi">莫比乌斯反演-让我们从基础开始 - An_Account 的博客 - 洛谷博客 (luogu.com.cn)</a></li><li><a href="https://zhuanlan.zhihu.com/p/135211767">形形色色的素数 -- 质数定理 - 知乎 (zhihu.com)</a></li></ul>]]></content>
    
    <summary type="html">
    
      差不多算是基础程度的知识的数论能力，就算已经不参加弹幕神乐的巫女想必也是应该掌握的吧（笑）
    
    </summary>
    
    
      <category term="算法" scheme="https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="算法" scheme="https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM" scheme="https://shiraha.cn/tags/ACM/"/>
    
      <category term="数论" scheme="https://shiraha.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="莫比乌斯反演" scheme="https://shiraha.cn/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    
  </entry>
  
  <entry>
    <title>NTT 简单入门</title>
    <link href="https://shiraha.cn/2021/The-concept-of-ntt-introducing-edition/"/>
    <id>https://shiraha.cn/2021/The-concept-of-ntt-introducing-edition/</id>
    <published>2021-07-12T14:51:20.000Z</published>
    <updated>2021-07-12T14:51:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>《退役人的自我救赎系列》——其二，也就是差不多算是初等数论的知识。</p><p>一句话简介：NTT 即<strong>快速数论变换</strong>，是一种可以在 <span class="math inline">\(n\log n\)</span> 的时间内完成多项式乘法的算法——的一部分。</p><h2 id="前置知识">前置知识</h2><h3 id="fft">FFT</h3><p>可以看我之前写过的一篇文章：<a href="https://shiraha.cn/2021/The-concept-of-fft-introducing-edition/">基础知识：FFT - 简单入门 - 七海の参考書 (shiraha.cn)</a></p><p>FFT 需要使用复数——这样就无法回避大量的浮点运算，然后精度就会爆炸；但是由于已经证明了在复数域内，具有循环卷积特性的唯一变换是<strong>DFT</strong>，所以在复数域中不存在具有循环卷积性质的更简单的离散正交变换；因此，我们就提出了以数论为基础的具有循环卷积性质的<strong>快速数论变换</strong>（<strong>NTT</strong>）：它的特点在于用有限域上的单位根来取代复平面上的单位根。</p><p>上面这段话是上网抄的。虽然我现在还理解不了，但是有一件事情十分清楚——和 FFT 利用单位根的性质减少运算量一样，NTT 利用了原根的性质来减少运算量，达到了同样的复杂度。</p><h3 id="阶">阶</h3><h4 id="定义">定义</h4><p>若 <span class="math inline">\(a, p\in\N^+\)</span> 满足 <span class="math inline">\(\gcd(a, p)=1\)</span> 和 <span class="math inline">\(p&gt;1\)</span>，那么：</p><p>对于使得 <span class="math inline">\(a^n \equiv 1\ \text{mod}\ p\)</span> 成立的最小的 <span class="math inline">\(n\)</span>，我们称之为 <strong><span class="math inline">\(a\)</span> 模 <span class="math inline">\(p\)</span> 的阶</strong>，记作 <span class="math inline">\(\delta_p(a)\)</span> 或 <span class="math inline">\(\text{ord}_pa\)</span>。</p><h4 id="性质">性质</h4><h5 id="对于-iin0-delta_pa所有的-a_i-textmod-p-都互不相同">1. 对于 <span class="math inline">\(i\in[0, \delta_p(a))\)</span>，所有的 <span class="math inline">\(a_i\ \text{mod}\ p\)</span> 都互不相同</h5><p>反证法：令有 <span class="math inline">\(j\ne k\)</span> 在该范围内并且模意义下相同，那么显然有 <span class="math inline">\(a^{|j-k|}\equiv1\ \text{mod}\ p\)</span>，且 <span class="math inline">\(|j-k|\)</span> 也属于该范围内，和定义矛盾。</p><h5 id="对于任何-an-equiv-1-textmod-p有-delta_pa-mid-n">2. 对于任何 <span class="math inline">\(a^n \equiv 1\ \text{mod}\ p\)</span>，有 <span class="math inline">\(\delta_p(a) \mid n\)</span></h5><p>显然。否则，把 <span class="math inline">\(n\)</span> 表示为 <span class="math inline">\(k\delta_p(a) + m\)</span>，显然 <span class="math inline">\(m \in (0, \delta_p(a))\)</span> 且满足 <span class="math inline">\(a^m \equiv 1\ \text{mod}\ p\)</span>，和性质 1 冲突。</p><p><strong>推论 1</strong>：若有 <span class="math inline">\(\gcd(a, p)=1\)</span>，那么 <span class="math inline">\(\delta_p(a) \mid \phi(p)\)</span></p><p>由欧拉定理可知：若 <span class="math inline">\(\gcd(a, p) = 1\)</span>，则 <span class="math inline">\(a^{\phi(p)} \equiv 1 \ \text{mod} \ p\)</span>。那么由性质 2 可得 <span class="math inline">\(\delta_p(a) \mid \phi(p)\)</span>。</p><h5 id="若-qinzp-是素数那么-delta_pqidelta_pq-iff-gcddelta_pq-i1">3. 若 <span class="math inline">\(q\in\Z^+\)</span>，<span class="math inline">\(p\)</span> 是素数，那么 <span class="math inline">\(\delta_p(q^i)=\delta_p(q) \iff \gcd(\delta_p(q), i)=1\)</span></h5><p>首先，我们记 <span class="math inline">\(q^i = q^{\gcd(\delta_p(q), i)\cdot r}\)</span>，显然 <span class="math inline">\(r=\frac i{\gcd(\delta_p(q), i)} \in\Z^+\)</span></p><p><del>由性质 2 和题设条件欧拉函数的性质，可得：<span class="math inline">\(\delta_p(q) \mid \phi(p) = (p-1)\)</span> （好像没用）</del></p><p>那么，有：<span class="math inline">\((g^i)^{\frac{\delta_p(q)}{\gcd(\delta_p(q), i)}}=(g^{\delta_p(q)})^{\frac i{\gcd(\delta_p(q), i)}}=g^{r\cdot \delta_p(q)}\equiv1\ \text{mod}\ p\)</span></p><hr /><p>假设 <span class="math inline">\(\gcd(\delta_p(q), i)\ne1\)</span>，那么 <span class="math inline">\(\gcd(\delta_p(q), i)&gt;1\)</span>，那么 <span class="math inline">\(\frac{\delta_p(q)}{\gcd(\delta_p(q), i)}&lt;\delta_p(q)\)</span></p><p>因为 <span class="math inline">\((g^i)^{\frac{\delta_p(q)}{\gcd(\delta_p(q), i)}}\equiv1\ \text{mod}\ p\)</span>，由性质 2 可得 <span class="math inline">\(\delta_p(q^i)\mid\frac{\delta_p(q)}{\gcd(\delta_p(q), i)}\)</span>，因此 <span class="math inline">\(\delta_p(q^i)\le\frac{\delta_p(q)}{\gcd(\delta_p(q), i)}\)</span></p><p>综上所述，可得：<span class="math inline">\(\delta_p(q^i)\le\frac{\delta_p(q)}{\gcd(\delta_p(q), i)}&lt;\delta_p(q)\)</span></p><p>即 <span class="math inline">\(\gcd(\delta_p(q), i)\ne1\Rightarrow \delta_p(q^i)\ne\delta_p(q)\)</span>，<strong>必要条件</strong>得证。</p><hr /><p>继承上述的证明，若有 <span class="math inline">\(\gcd(\delta_p(q), i)=1\)</span>，那么 <span class="math inline">\(\frac{\delta_p(q)}{\gcd(\delta_p(q), i)}=\delta_p(q)\)</span></p><p>由上述证明就可以得到：<span class="math inline">\(\delta_p(q^i)\le\delta_p(q)\)</span></p><p>因为 <span class="math inline">\(g^{i\cdot\frac{\delta_p(q)}{\gcd(\delta_p(q), i)}}\equiv1\ \text{mod}\ p\)</span>，和性质 2 和 4 可知：<span class="math inline">\(\delta_p(q)\mid i\cdot\delta_p(q^i)\)</span></p><p>因为 <span class="math inline">\(\gcd(\delta_p(q), i)=1\)</span>，所以 <span class="math inline">\(上式\Rightarrow\delta_p(q)\mid \delta_p(q^i)\)</span>，也就是 <span class="math inline">\(\delta_p(q)\le\delta_p(q^i)\)</span></p><p>综上所述，<span class="math inline">\(\because \delta_p(q^i)\le\delta_p(q) \and \delta_p(q)\le\delta_p(q^i)\)</span>，<span class="math inline">\(\therefore \delta_p(q)=\delta_p(q^i)\)</span></p><p>即 <span class="math inline">\(\gcd(\delta_p(q), i)=1\Rightarrow \delta_p(q^i)=\delta_p(q)\)</span>，<strong>充分条件</strong>得证。</p><hr /><p>综上所述，<span class="math inline">\(\gcd(\delta_p(q), i)=1\)</span> 是 <span class="math inline">\(\delta_p(q)=\delta_p(q^i)\)</span> 的<strong>充分必要条件</strong>。</p><h5 id="delta_pab-fracdelta_pagcddelta_pa-b其中-a-p-b-in-z">4. <span class="math inline">\(\delta_p(a^b) = \frac{\delta_p(a)}{\gcd(\delta_p(a), b)}\)</span>，其中 <span class="math inline">\(a, p, b \in \Z^+\)</span></h5><p>由阶的定义可知：<span class="math inline">\((a^b)^{\delta_p(a^b)} \equiv a^{b\cdot\delta_p(a^b)}\equiv1\ \text{mod} \ p\)</span></p><p>又由性质 2，可以得到：<span class="math inline">\(\delta_p(a)\mid b\cdot\delta_p(a^b) \Rightarrow \frac{\delta_p(a)}{\gcd(\delta_p(a), b)}\mid \frac{b}{\gcd(\delta_p(a), b)}\cdot\delta_p(a^b)\)</span></p><p>显然，因为 <span class="math inline">\(\gcd(\frac{\delta_p(a)}{\gcd(\delta_p(a), b)}, \frac{b}{\gcd(\delta_p(a), b)})=1\)</span>，因此：<span class="math inline">\(上式\Rightarrow \frac{\delta_p(a)}{\gcd(\delta_p(a), b)}\mid\delta_p(a^b)\)</span></p><p>又因为定义：<span class="math inline">\(a^{b\cdot\frac{\delta_p(a)}{\gcd(\delta_p(a), b)}}\equiv a^{\delta_p(a)\cdot\frac{b}{\gcd(\delta_p(a), b)}} \equiv 1\ \text{mod}\ p\)</span>，<span class="math inline">\(\frac{b}{\gcd(\delta_p(a), b)}\)</span> 显然是整数。</p><p>所以由性质 2 可得：<span class="math inline">\(\delta_p(a^b)\mid\frac{\delta_p(a)}{\gcd(\delta_p(a), b)}\)</span></p><p>综上所述：<span class="math inline">\(\because \frac{\delta_p(a)}{\gcd(\delta_p(a), b)}\mid\delta_p(a^b)\ \and\ \delta_p(a^b)\mid\frac{\delta_p(a)}{\gcd(\delta_p(a), b)}\)</span>，<span class="math inline">\(\therefore \delta_p(a^b)=\frac{\delta_p(a)}{\gcd(\delta_p(a), b)}\)</span></p><h5 id="p-in-n-a-binzgcda-p-gcdb-p-1那么-gcddelta_padelta_pb1-iff-delta_pabdelta_padelta_pb">5. <span class="math inline">\(p \in \N^+,\ a, b\in\Z\)</span>，<span class="math inline">\(\gcd(a, p) = \gcd(b, p) = 1\)</span>，那么 <span class="math inline">\(\gcd(\delta_p(a),\delta_p(b))=1\)</span> <span class="math inline">\(\iff\)</span> <span class="math inline">\(\delta_p(ab)=\delta_p(a)\delta_p(b)\)</span></h5><p>由定义可得 <span class="math inline">\(a^{\delta_p(a)}\equiv1\ \text{mod}\ p\)</span> 和 <span class="math inline">\(b^{\delta_p(b)}\equiv1\ \text{mod}\ p\)</span>，那么：<span class="math inline">\((ab)^{\text{lcm}(\delta_p(a),\delta_p(b))}\equiv1\ \text{mod}\ p\)</span></p><p>由性质 2，可得：<span class="math inline">\(\delta_p(ab)\mid\text{lcm}(\delta_p(a),\delta_p(b))\)</span></p><p>设 <span class="math inline">\(\delta_p(ab)=\delta_p(a)\delta_p(b)\)</span> 成立，那么：<span class="math inline">\(上式 \Rightarrow \delta_p(a)\delta_p(b)\mid\text{lcm}(\delta_p(a),\delta_p(b))\)</span></p><p>又因为 <span class="math inline">\(\text{lcm}(\delta_p(a),\delta_p(b)) = \frac{\delta_p(a)\delta_p(b)}{\gcd(\delta_p(a),\delta_p(b))}\)</span>，可得 <span class="math inline">\(\gcd(\delta_p(a),\delta_p(b))=1\)</span></p><p>即 <span class="math inline">\(\delta_p(ab)=\delta_p(a)\delta_p(b)\)</span> <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\gcd(\delta_p(a),\delta_p(b))=1\)</span>，<strong>必要性</strong>得证。</p><hr /><p>又由阶的定义：<span class="math inline">\((ab)^{\delta_p(ab)}\equiv1\ \text{mod}\ p\)</span>，可以进行如下推导： <span class="math display">\[(ab)^{\delta_p(ab)}\equiv(ab)^{\delta_p(ab)\delta_p(b)}\equiv a^{\delta_p(ab)\delta_p(b)}\cdot b^{\delta_p(ab)\delta_p(b)}\equiv a^{\delta_p(ab)\delta_p(b)}\cdot 1\equiv1\ \text{mod}\ p\]</span> 由性质 2，可得：<span class="math inline">\(\delta_p(a)\mid\delta_p(ab)\delta_p(b)\)</span>；因为 <span class="math inline">\(\gcd(\delta_p(a),\delta_p(b))=1\)</span>，所以 <span class="math inline">\(\delta_p(a)\mid\delta_p(ab)\)</span></p><p>同理，可得：<span class="math inline">\(\delta_p(b)\mid\delta_p(ab)\)</span>；因为 <span class="math inline">\(\gcd(\delta_p(a),\delta_p(b))=1\)</span>，所以 <span class="math inline">\(\delta_p(a)\delta_p(b)\mid\delta_p(ab)\)</span></p><p>由定理可得：<span class="math inline">\(a^{\delta_p(a)}\equiv a^{\delta_p(a)\delta_p(b)}\equiv1\ \text{mod}\ p\)</span> 和 <span class="math inline">\(b^{\delta_p(b)}\equiv b^{\delta_p(a)\delta_p(b)}\equiv1\ \text{mod}\ p\)</span>，因此： <span class="math display">\[a^{\delta_p(a)\delta_p(b)} \cdot b^{\delta_p(a)\delta_p(b)} \equiv (ab)^{\delta_p(a)\delta_p(b)} \equiv1\ \text{mod}\ p\]</span> 由性质 2，可得 <span class="math inline">\(\delta_p(ab)\mid\delta_p(a)\delta_p(b)\)</span>；因此，可证 <span class="math inline">\(\delta_p(ab)=\delta_p(a)\delta_p(b)\)</span></p><p>即 <span class="math inline">\(\gcd(\delta_p(a),\delta_p(b))=1\)</span> <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(\delta_p(ab)=\delta_p(a)\delta_p(b)\)</span>，<strong>充分性</strong>得证。</p><hr /><p>综上所述：<span class="math inline">\(\gcd(\delta_p(a),\delta_p(b))=1\)</span> 是 <span class="math inline">\(\delta_p(ab)=\delta_p(a)\delta_p(b)\)</span> 的<strong>充分必要条件</strong>。</p><h3 id="原根">原根</h3><h4 id="定义-1">定义</h4><p><span class="math inline">\(m \in \N^+,g\in\Z\)</span>，若有 <span class="math inline">\(\delta_m(g)=\phi(m)\)</span> 且 <span class="math inline">\(\gcd(m,g)=1\)</span>，那么称 <span class="math inline">\(g\)</span> 是模 <span class="math inline">\(m\)</span> 的一个原根。</p><p>若整数 <span class="math inline">\(g\)</span> 模正整数 <span class="math inline">\(m\)</span> 的阶（这要求它们互质）和 <span class="math inline">\(\phi(m)\)</span> 相等，那么 <span class="math inline">\(g\)</span> 是模 <span class="math inline">\(m\)</span> 的一个原根。</p><h4 id="性质-1">性质</h4><p>……我一定是哪里变得奇怪了才会想着抄录全部性质并键证它们== 哪天闲的没事干再补全吧（）</p><figure><img src="https://i.loli.net/2021/07/13/H9FqkSnMxPXpQr4.jpg" class="lazyload" data-srcset="https://i.loli.net/2021/07/13/H9FqkSnMxPXpQr4.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="7Q6A_S_AWQFY__Q5NEZI_E.jpg" /><figcaption aria-hidden="true">7Q6A_S_AWQFY__Q5NEZI_E.jpg</figcaption></figure><h4 id="定理">定理</h4><h5 id="原根的存在条件">原根的存在条件</h5><p>判断对于一个整数 <span class="math inline">\(p\)</span> 是否存在原根：</p><ul><li>对于整数 <span class="math inline">\(p=2,4\)</span>，它们的原根显然存在</li><li>奇素数 <span class="math inline">\(p\)</span> 的原根存在；对于 <span class="math inline">\(\alpha\in\N^+\)</span>，<span class="math inline">\(p^\alpha\)</span> 的原根存在</li><li>对于奇素数 <span class="math inline">\(p\)</span>，<span class="math inline">\(\alpha\in\N^+\)</span>，<span class="math inline">\(2p^\alpha\)</span> 的原根存在</li><li>若 <span class="math inline">\(p\)</span> 不符合上述的任何条件，则对于 <span class="math inline">\(\forall a\in\Z\)</span> 和 <span class="math inline">\(\gcd(a, p)=1\)</span>，都有 <span class="math inline">\(\delta_p(a) &lt; \phi(p)\)</span>，即 <span class="math inline">\(p\)</span> 不存在原根</li></ul><p>与之相关的一些定理：</p><ul><li>对于奇素数 <span class="math inline">\(p\)</span>，若 <span class="math inline">\(g\)</span> 是其原根，则 <span class="math inline">\(g\)</span> <strong>或者</strong> <span class="math inline">\(g+p\)</span> 是 <span class="math inline">\(p^2\)</span> 的原根</li><li>对于奇素数 <span class="math inline">\(p\)</span>，<span class="math inline">\(\alpha \in \N^+\)</span>，若 <span class="math inline">\(g\)</span> 是模 <span class="math inline">\(p^\alpha\)</span> 的原根，则 <span class="math inline">\(g\)</span> <strong>和</strong> <span class="math inline">\(g+p^\alpha\)</span> 中的奇数是 <span class="math inline">\(2p^\alpha\)</span> 的原根</li></ul><p>简单地说，对于奇素数 <span class="math inline">\(p\)</span>，<span class="math inline">\(\alpha\in\N^+\)</span>，有原根的数包括：<span class="math inline">\(\{2,4,p^\alpha,2p^\alpha\}\)</span></p><h5 id="求法">求法</h5><p>对于一个数 <span class="math inline">\(n\)</span>，如果它存在原根，那么首先找到它的最小原根并令其为 <span class="math inline">\(g\)</span>；那么，<span class="math inline">\(n\)</span> 的所有原根都可以表示为 <span class="math inline">\(g^k\)</span>，<span class="math inline">\(k\)</span> 是正整数并且满足 <span class="math inline">\(\gcd(\phi(n),k)=1\)</span>，共 <span class="math inline">\(\phi(\phi(n))\)</span> 个。</p><p>最小原根 <span class="math inline">\(g\)</span> 的大小已经证明是不会超过 <span class="math inline">\(\sqrt[4]{n}\)</span> 的，所以可以通过暴力枚举来确定，然后按照定义要求来验证某个数字是否是原根——但是定义要求 <span class="math inline">\(\delta_n(g)=\phi(n)\)</span>，我们无法对于每一个备选 <span class="math inline">\(g\)</span> 都枚举 <span class="math inline">\(i\in[1,\phi(n))\)</span> 来计算 <span class="math inline">\(g^i\)</span>，观察它不和 <span class="math inline">\(1\)</span> 同余来判定它是阶。</p><p>注意到阶的性质 2 的推论 1，我们可以知道 <span class="math inline">\(\delta_n(g)\mid\phi(n)\)</span>；也就是说，对于备选 <span class="math inline">\(g\)</span>，如果它模 <span class="math inline">\(n\)</span> 下的阶不满足原根的要求，而是另有 <span class="math inline">\(k &lt; \phi(n)\)</span> 存在，那么它满足 <span class="math inline">\(k\mid\phi(n)\)</span>；那么，我们只需要检查 <span class="math inline">\(\phi(n)\)</span> 的所有<strong>真</strong>因数就可以找到可能存在的 <span class="math inline">\(k\)</span> 了，而不需要枚举整个 <span class="math inline">\([1,\phi(n))\)</span>；具体地，若 <span class="math inline">\(\phi(n)\)</span> 的质因子被记为 <span class="math inline">\(p_1,\dots,p_r\)</span>，那么实际上我们只需要检查所有的 <span class="math inline">\(\frac{\phi(n)}{p_i}\)</span> 即可——它覆盖了所有的真因数的倍数，检查它们等同于检查了所有的真因数。</p><p>综上所述，找到最小原根 <span class="math inline">\(g\)</span> 所需要的时间是 <span class="math inline">\(\mathcal{O}(\sqrt[4]n\cdot\log n)\)</span> 的；利用最小原根 <span class="math inline">\(g\)</span> 求出所有原根所需要的时间是 <span class="math inline">\(\mathcal O (\phi(n)\cdot\log n^{\frac{\phi(n)}4})\)</span> 的。完整代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> n&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> &amp;<span class="title">linear_sieve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; prime;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">array</span>&lt;<span class="keyword">int</span>, n + 1&gt; vis;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[i])</span><br><span class="line">            prime.push_back(i), vis[i] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;pp : prime) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((llong) i * pp &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            vis[i * pp] = pp;</span><br><span class="line">            <span class="keyword">if</span> (i % pp == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">auto</span> ret = <span class="built_in">make_pair</span>(ref(prime), ref(vis));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">llong <span class="title">fast_pow</span><span class="params">(llong a, llong b, llong mod)</span> </span>&#123;</span><br><span class="line">    llong ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1u</span>) ans = (ans * a) % mod;</span><br><span class="line">        a = (a * a) % mod, b &gt;&gt;= <span class="number">1u</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_primitive_root</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;de, llong g,</span></span></span><br><span class="line"><span class="function"><span class="params">        llong phi, llong n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fast_pow(g, phi, n) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> none_of(de.begin(), de.end(), [&amp;](<span class="keyword">int</span> p) &#123;</span><br><span class="line">            <span class="keyword">return</span> fast_pow(g, phi / p, n) == <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> [p, dc] = linear_sieve&lt;N&gt;();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> decompose = [&amp;dc = dc]</span><br><span class="line">            (llong x, <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp;de) &#123;</span><br><span class="line">        de.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ii = x; ii &gt; <span class="number">1</span>;) &#123;</span><br><span class="line">            de.insert(dc[ii]);</span><br><span class="line">            ii /= dc[ii];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;N&gt; has_primitive_root;</span><br><span class="line">    has_primitive_root.<span class="built_in">set</span>(<span class="number">1</span>).<span class="built_in">set</span>(<span class="number">2</span>).<span class="built_in">set</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (llong pp : p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pp == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> now = pp; now &lt; N; now *= pp) &#123;</span><br><span class="line">            has_primitive_root.<span class="built_in">set</span>(now);</span><br><span class="line">            <span class="keyword">if</span> (now * <span class="number">2</span> &lt; N) has_primitive_root.<span class="built_in">set</span>(now * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;llong&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> T = read(); T--;) &#123;</span><br><span class="line">        <span class="keyword">auto</span> n = read(), d = read(), phi = n;</span><br><span class="line">        <span class="keyword">if</span> (has_primitive_root[n]) &#123;</span><br><span class="line">            <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; de_n, de_phi;</span><br><span class="line">            decompose(n, de_n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> pi : de_n)</span><br><span class="line">                (phi /= pi) *= (pi - <span class="number">1</span>);</span><br><span class="line">            decompose(phi, de_phi);</span><br><span class="line">            llong g = <span class="number">0</span>, lim = n;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lim; ++ i)</span><br><span class="line">                <span class="keyword">if</span> (check_primitive_root(de_phi, i, phi, n))</span><br><span class="line">                &#123; g = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (!g) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> gi = g, i = <span class="number">1l</span>l;</span><br><span class="line">                 i &lt;= phi; ++ i, (gi *= g) %= n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (gcd(i, phi) == <span class="number">1</span>)</span><br><span class="line">                    ans.push_back(gi);</span><br><span class="line">            &#125;</span><br><span class="line">            sort(ans.begin(), ans.end());</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> id = d - <span class="number">1</span>; id &lt; ans.size(); id += d)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; ans[id] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先筛出质数，再筛出所有的可能有原根的数——这一步是 <span class="math inline">\(\mathcal O (n\log n)\)</span> 的；对于一个有原根的数 <span class="math inline">\(n\)</span>，首先利用筛的结果（当然也可以直接用线性筛直接算好了存起来）根据定义求出 <span class="math inline">\(\phi(n)\)</span>，然后再利用筛维护的数据（或者埃氏筛直接存起来）分解其质因数存好备用；暴力枚举，并且利用上面说的方法来检查其是否为原根，求出最小原根——这一步是理论 <span class="math inline">\(\mathcal O (\sqrt[4]n\log n)\)</span> 的；最后再利用最小原根生成所有的原根：这需要重复 <span class="math inline">\(\phi(n)\)</span> 次，每次使用 <span class="math inline">\(\gcd\)</span> 检查——这一步是 <span class="math inline">\(\mathcal O(\phi(n)\log n)\)</span> 的。</p><p>上面的代码可以通过 <a href="https://www.luogu.com.cn/problem/P6091">P6091 【模板】原根</a>。需要注意虽然最小原根有这个理论界限，但是求的时候只遍历到 <span class="math inline">\(\lceil n^\frac14\rceil\)</span> 似乎会暴毙……</p><h3 id="阶和原根">阶和原根</h3><p>那么如何理解这两个抽象的概念呢？</p><h2 id="后记">后记</h2><h3 id="参考资料">参考资料</h3><ul><li><a href="https://www.luogu.com.cn/blog/attack/solution-p38032">题解 P3803 【【模板】多项式乘法（NTT）】2 - attack 的博客 - 洛谷博客 (luogu.com.cn)</a></li><li><a href="https://zhuanlan.zhihu.com/p/347726949">快速数论变换（NTT）超详解 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/349128258">阶与原根 - 知乎 (zhihu.com)</a></li><li><a href="https://zhuanlan.zhihu.com/p/166043237">算法学习笔记(40): 原根 - 知乎 (zhihu.com)</a></li></ul>]]></content>
    
    <summary type="html">
    
      比 FFT 睾级一些的多项式乘法的算法。虽然但是还是要去学一下的吧。
    
    </summary>
    
    
      <category term="算法" scheme="https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="算法" scheme="https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM" scheme="https://shiraha.cn/tags/ACM/"/>
    
      <category term="数论" scheme="https://shiraha.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="FFT" scheme="https://shiraha.cn/tags/FFT/"/>
    
      <category term="NTT" scheme="https://shiraha.cn/tags/NTT/"/>
    
  </entry>
  
  <entry>
    <title>数论分块入门</title>
    <link href="https://shiraha.cn/2021/The-concept-of-number-theory-partition/"/>
    <id>https://shiraha.cn/2021/The-concept-of-number-theory-partition/</id>
    <published>2021-07-08T07:19:09.000Z</published>
    <updated>2021-07-11T14:29:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>《退役人的自我救赎系列》——其一，也就是基础的数论知识。</p><h2 id="整除分块">整除分块</h2><blockquote><p>求解 <span class="math inline">\(\sum_{i=1}^n \frac{n}i\)</span> 的值，<span class="math inline">\(n\)</span> 是 <span class="math inline">\(10^{10}\)</span> 级别。</p></blockquote><p>暴力是 <span class="math inline">\(\mathcal{O}(n)\)</span> 的，死了；但是 <span class="math inline">\(\lfloor \frac{n}i\rfloor\)</span> 的结果是根据块状分布的，且最多只会有 <span class="math inline">\(2\sqrt{n}\)</span> 种不同的值。因此，我们可以利用这个性质得到一个 <span class="math inline">\(\mathcal{O}(\sqrt{n})\)</span> 的算法。</p><p>直接地说，<span class="math inline">\(\lfloor \frac{n}i\rfloor\)</span> 的值在一段连续的区间内具有相同的值，且这个区间具有右端点 <span class="math inline">\(\lfloor \frac{n}{\lfloor\frac{n}i\rfloor}\rfloor\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">    r = min(n / (n / l), n);</span><br><span class="line">    procedure(l, r);<span class="comment">// [l, r] 的值是 n / l</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的写法需要注意的就是 <code>n / l</code> 可能为 0 导致除法除零，一般来说需要特判一下。</p><h3 id="cqoi2007余数求和"><a href="https://www.luogu.com.cn/problem/P2261">CQOI2007：余数求和</a></h3><p>那来点模板题。求的是模数和，看起来和上面的整除分块没有什么关系，但是： <span class="math display">\[\sum_{i=1}^n k\mod i = \sum_{i=1}^n k - \lfloor\frac{k}i\rfloor i = nk - \sum_{i=1}^n \lfloor\frac{k}i\rfloor i\]</span> 这样处理之后，右边的部分仍然不是我们熟悉的整出分块形式，所以还需要进一步处理；</p><p>我们已经知道了 <span class="math inline">\(\sum_{i=1}^n \lfloor\frac{k}i\rfloor\)</span> 在一定范围内具有相同的值，那么在块内我们令 <span class="math inline">\(T_j = \lfloor\frac{k}j\rfloor\)</span>，那么就可以进行如下形式的化简: <span class="math display">\[\sum_{i=1}^n \lfloor\frac{k}i\rfloor i = \sum_{i=1}^n T_i\cdot i = \sum_j\sum_{i=L}^R T_i\cdot \sum_{i=L}^R i\]</span> 这样，在每一个分块内，左边是整除分块，右边是一个公差为 1 的等差数列；块内只需要一个定值和一个很好求的和，就可以分块来做了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">auto</span> n = read(), k = read();</span><br><span class="line">    <span class="keyword">auto</span> ans = n * k;</span><br><span class="line">    <span class="keyword">for</span> (llong l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k / l) r = min(k / (k / l), n);</span><br><span class="line">        <span class="keyword">else</span> r = n;</span><br><span class="line">        ans -= (r - l + <span class="number">1</span>) * (l + r) / <span class="number">2</span> * (k / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，现在你已经学会了数论分块了！</p><h3 id="清华集训2012模积和"><a href="https://www.luogu.com.cn/problem/P2260">清华集训2012：模积和</a></h3><p>题目是要求了 <span class="math inline">\(i\ne j\)</span>，所以我们需要转化为下面的形式： <span class="math display">\[\sum_{i=1}^n\sum_{j=1}^m[i\ne j](n\ \text{mod}\ i)(m\ \text{mod}\ j) \\= \sum_{i=1}^n\sum_{j=1}^m(n\ \text{mod}\ i)(m\ \text{mod}\ j) - \sum_{i=1}^{\min(n, m)}(n\ \text{mod}\ i)(m\ \text{mod}\ i)\]</span> 然后，先处理上述式子的第一项；最直接的做法就是拆开化简： <span class="math display">\[ {align}\begin{align}原式 &amp;= \sum_{i=1}^n\sum_{j=1}^m (n-\lfloor\frac{n}i\rfloor i)(m - \lfloor\frac{m}j\rfloor j) \\&amp;= \sum_{i=1}^n\sum_{j=1}^m nm - \lfloor\frac{n}i\rfloor im - \lfloor\frac{m}j\rfloor jn + \lfloor\frac{m}j\rfloor\lfloor\frac{n}i\rfloor i j \\&amp;= n^2m^2 - nm^2\sum_{i=1}^n\lfloor\frac{n}i\rfloor i-n^2m\sum_{j=1}^m\lfloor\frac{m}j\rfloor j + nm\sum_{i=1}^n\lfloor\frac{n}i\rfloor i\cdot\sum_{j=1}^m\lfloor\frac{m}j\rfloor j\end{align}\]</span> 当然，也可以类似于上面求余数和的做法那样直接拆成： <span class="math display">\[\sum_{i=1}^n(n\ \text{mod}\ i) \cdot \sum_{j=1}^m(m\ \text{mod}\ j)\]</span> 也可以拆出相同的结果。</p><p>总而言之，上面的式子就被拆成了一些和上面模数求和一样的形式的组合，只需要分别求出两个互不相关的部分的和就可以算出题目种式子的左边部分；接下来处理右边部分，我们先约定 <span class="math inline">\(k = \min(n, m)\)</span>： <span class="math display">\[\begin{align}原式 &amp;= \sum_{i=1}^k (n-\lfloor\frac{n}i\rfloor i)(m - \lfloor\frac{m}i\rfloor i) \\&amp;= \sum_{i=1}^k(nm - m\lfloor\frac{n}i\rfloor i - n\lfloor\frac{m}i\rfloor i + \lfloor\frac{m}i\rfloor\lfloor\frac{n}i\rfloor i^2) \\&amp;= knm - m\sum_{i=1}^k\lfloor\frac{n}i\rfloor i - n\sum_{i=1}^k\lfloor\frac{m}i\rfloor i + \sum_{i=1}^k\lfloor\frac{n}i\rfloor \lfloor\frac{m}i\rfloor i^2\end{align}\]</span> 还是一样可以使用模数分块的方法求出。</p><p>此外，提一下考研常用公式：<span class="math inline">\(\sum_{i=1}^n i^2 = \frac16n(n+1)(2n+1)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> lll mod = <span class="number">19940417</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">lll <span class="title">fast_pow</span><span class="params">(lll a, lll b = mod - <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line">    lll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) (ret *= a) %= mod;</span><br><span class="line">        (a *= a) %= mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret %= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">llong <span class="title">euler_phi</span><span class="params">(llong n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span> (llong i = <span class="number">2</span>; i * i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (!(n % i)) &#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (!(n % i)) n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    lll n = read(), m = read(), k = min(n, m);</span><br><span class="line">    <span class="keyword">auto</span> nm = n * m % mod, n2m = nm * n % mod;</span><br><span class="line">    <span class="keyword">auto</span> n2m2 = nm * nm % mod, nm2 = nm * m % mod;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> calc = [](lll n, lll k) &#123;</span><br><span class="line">        lll ret = <span class="number">0</span>;</span><br><span class="line">        minimize(n, k);</span><br><span class="line">        <span class="keyword">for</span> (lll l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k / l) r = min(k / (k / l), n);</span><br><span class="line">            <span class="keyword">else</span> r = n;</span><br><span class="line">            <span class="keyword">auto</span> sum = (r - l + <span class="number">1</span>) * (l + r) / <span class="number">2</span> % mod;</span><br><span class="line">            (ret += sum * (k / l) % mod) %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret %= mod;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> sum_mod = [&amp;calc](lll n, lll k) &#123;</span><br><span class="line">        <span class="keyword">return</span> (n * k % mod - calc(n, k) + mod) % mod;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> phi_mod = euler_phi(mod) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> inv6 = fast_pow(<span class="number">6</span>, phi_mod);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> sum_i2 = [inv6](lll n) &#123;</span><br><span class="line">        <span class="keyword">return</span> n * (n + <span class="number">1</span>) % mod * (<span class="number">2</span> * n + <span class="number">1</span>) % mod * inv6 % mod;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> lp = sum_mod(n, n) * sum_mod(m, m) % mod;</span><br><span class="line">    <span class="keyword">auto</span> knm = k * nm % mod, rp = knm;</span><br><span class="line">    <span class="keyword">for</span> (lll l = <span class="number">1</span>, r; l &lt;= k; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n / l &amp;&amp; m / l)</span><br><span class="line">            r = min(&#123;n / (n / l), m / (m / l), k&#125;);</span><br><span class="line">        <span class="keyword">else</span> r = k;</span><br><span class="line">        <span class="keyword">auto</span> si2 = (sum_i2(r) - sum_i2(l - <span class="number">1</span>) + mod) % mod;</span><br><span class="line">        <span class="keyword">auto</span> inm = (n / l) * (m / l) % mod;</span><br><span class="line">        (rp += inm * si2 % mod) %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> ckn = calc(k, n), ckm = calc(k, m);</span><br><span class="line">    <span class="keyword">auto</span> tmp = (m * ckn % mod + n * ckm % mod) % mod;</span><br><span class="line">    rp = (rp + mod - tmp) % mod;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; llong((lp + mod - rp) % mod) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，<span class="math inline">\(19940417 = 7\times2848631\)</span>，并不是一个质数，所以不能用费马小定理求出模它意义下的逆元；但是 <span class="math inline">\(6\)</span> 和它互质，故应当使用<strong>欧拉定理</strong>：</p><blockquote><p><strong>欧拉定理</strong>：若 <span class="math inline">\(\gcd(a, m) = 1\)</span>，则 <span class="math inline">\(a^{\phi(m)} \equiv 1 \ (\text{mod} \ m)\)</span>。</p><p><strong>欧拉函数</strong>：<span class="math inline">\(\phi(n)\)</span>，表示了小于等于 <span class="math inline">\(n\)</span> 的正整数和 <span class="math inline">\(n\)</span> 互质的整数的个数。</p><p><strong>标准分解式</strong>：将质因数分解的结果按照大小，由小到大排列，并将相同质因数连乘以指数形式表示。</p><p>如果一个数字的标准分解式可以写成：<span class="math inline">\(n = p_1^{k_1}p_2^{k_2}\cdots p_r^{k_r}\)</span>，那么： <span class="math display">\[\phi(n) = \prod_{i=1}^rp_i^{k_i-1}(p_i-1)=\prod_{p|n}p^{\alpha_p-1}(p-1)=n\prod_{p|n}(1-\frac1p)\]</span> 可以使用上述公式计算欧拉函数。</p></blockquote><p>求解单个欧拉函数值，可以使用 Pollard Rho 算法优化后根据定义求解；多个欧拉函数值则可以使用线性筛求解。</p><h3 id="实战">实战（？）</h3><blockquote><p>给了 <span class="math inline">\(x_1, x_2, y_1, y_2\)</span>，求解： <span class="math display">\[\sum_{i=x_1}^{x_2}\sum_{j=y_1}^{y_2}(\lfloor\frac{i}{x_1}\rfloor+\lfloor\frac{x_2}i\rfloor+\lfloor\frac{j}{y_1}\rfloor+\lfloor\frac{y_2}j\rfloor)^2\]</span> 结果对 <span class="math inline">\(10^9+7\)</span> 取模。</p></blockquote><p>这是 CCPC 湘潭邀请赛 2021 的 C 题，无处补题。</p><figure><img src="https://i.loli.net/2021/07/08/ca4mpvGDIfHUPWn.jpg" class="lazyload" data-srcset="https://i.loli.net/2021/07/08/ca4mpvGDIfHUPWn.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="___MEL_9_R6YR3N0GK8937H.jpg" /><figcaption aria-hidden="true">___MEL_9_R6YR3N0GK8937H.jpg</figcaption></figure><p>首先还是直接把它们乘开： <span class="math display">\[\begin{align}原式 =&amp; (y_2-y_1+1)\sum_{i=x_1}^{x_2}(\lfloor\frac{i}{x_1}\rfloor+\lfloor\frac{x_2}i\rfloor)^2 + (x_2-x_1+1)\sum_{j=y_1}^{y_2}(\lfloor\frac{j}{y_1}\rfloor+\lfloor\frac{y_2}j\rfloor)^2 + \\ &amp;2\sum_{i=x_1}^{x_2}\sum_{j=y_1}^{y_2}(\lfloor\frac{i}{x_1}\rfloor+\lfloor\frac{x_2}i\rfloor)(\lfloor\frac{j}{y_1}\rfloor+\lfloor\frac{y_2}j\rfloor) \end{align}\]</span> 可以看出前两项是一类的，第三项是另一类的；其中，前两项又可以进行这样的拆分： <span class="math display">\[原式 = \sum_{i=x_1}^{x_2}\lfloor\frac{i}{x_1}\rfloor^2 + 2\sum_{i=x_1}^{x_2}\lfloor\frac{i}{x_1}\rfloor\lfloor\frac{x_2}i\rfloor + \sum_{i=x_1}^{x_2}\lfloor\frac{x_2}i\rfloor^2\]</span> 又可以分成三项；其中第三项是我们这里提到的整除分块问题，第一项是我们再熟悉不过的“分块”，可以直接计算；那么问题就变成了中间的一部分——在这里我想要说的是这并没有什么特殊的性质（或者是我没有发现），只需要分块再分块然后直接计算就可以了。</p><p>那么回到第一组式子的第三项；注意到 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 是互不相关的，所以直接分别计算然后乘起来就行： <span class="math display">\[原式 = \sum_{i=x_1}^{x_2}(\lfloor\frac{i}{x_1}\rfloor+\lfloor\frac{x_2}i\rfloor)\cdot\sum_{j=y_1}^{y_2}(\lfloor\frac{j}{y_1}\rfloor+\lfloor\frac{y_2}j\rfloor) \]</span> 只需要分别计算后求和，之后再在模意义下乘起来就得到了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> llong mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> lll <span class="title">fast_pow</span><span class="params">(lll a, lll b = mod - <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line">    lll ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) (ret *= a) %= mod;</span><br><span class="line">        (a *= a) %= mod, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret %= mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> lll inv6 = fast_pow(<span class="number">6</span>), inv2 = fast_pow(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="function">lll <span class="title">sum_i2</span><span class="params">(lll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n * (n + <span class="number">1</span>) % mod * (<span class="number">2</span> * n + <span class="number">1</span>) % mod * inv6 % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">lll <span class="title">sum_i</span><span class="params">(lll n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (n + <span class="number">1</span>) * n % mod * inv2 % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">lll <span class="title">xi2</span><span class="params">(lll l, lll n, lll k)</span> </span>&#123;</span><br><span class="line">    lll ret = <span class="number">0</span>;</span><br><span class="line">    minimize(n, k);</span><br><span class="line">    <span class="keyword">for</span> (lll r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k / l) r = min(k / (k / l), n);</span><br><span class="line">        <span class="keyword">else</span> r = n;</span><br><span class="line">        <span class="keyword">auto</span> val = (k / l) * (k / l) % mod;</span><br><span class="line">        (ret += (r - l + <span class="number">1</span>) * val % mod) %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">lll <span class="title">xi</span><span class="params">(lll l, lll n, lll k)</span> </span>&#123;</span><br><span class="line">    lll ret = <span class="number">0</span>;</span><br><span class="line">    minimize(n, k);</span><br><span class="line">    <span class="keyword">for</span> (lll r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k / l) r = min(k / (k / l), n);</span><br><span class="line">        <span class="keyword">else</span> r = n;</span><br><span class="line">        (ret += (r - l + <span class="number">1</span>) * (k / l) % mod) %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">lll <span class="title">sum_ix</span><span class="params">(lll n, lll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> m = n % x + <span class="number">1</span>, d = n / x;</span><br><span class="line">    <span class="keyword">if</span> (!d) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    lll ret = x * sum_i(d - <span class="number">1</span>) % mod;</span><br><span class="line">    (ret += m * d % mod) %= mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">lll <span class="title">sum_ix2</span><span class="params">(lll n, lll x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> m = n % x + <span class="number">1</span>, d = n / x;</span><br><span class="line">    <span class="keyword">if</span> (!d) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    lll ret = x * sum_i2(d - <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="keyword">auto</span> d2 = d * d % mod;</span><br><span class="line">    (ret += m * d2 % mod) %= mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">lll <span class="title">ix</span><span class="params">(lll l, lll r, lll k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (sum_ix(r, k) + mod - sum_ix(l - <span class="number">1</span>, k)) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">lll <span class="title">ix2</span><span class="params">(lll l, lll r, lll k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (sum_ix2(r, k) + mod - sum_ix2(l - <span class="number">1</span>, k)) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">lll <span class="title">ix_xi</span><span class="params">(lll l, lll n, lll x1, lll x2)</span> </span>&#123;</span><br><span class="line">    lll ret = <span class="number">0</span>;</span><br><span class="line">    minimize(n, x2);</span><br><span class="line">    <span class="keyword">for</span> (lll r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x2 / l) r = min(x2 / (x2 / l), n);</span><br><span class="line">        <span class="keyword">else</span> r = n;</span><br><span class="line">        <span class="keyword">auto</span> tmp = ix(l, r, x1);</span><br><span class="line">        (ret += tmp * (x2 / l) % mod) %= mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> T = read(); T --;) &#123;</span><br><span class="line">        <span class="keyword">auto</span> x1 = read(), x2 = read(), y1 = read(), y2 = read();</span><br><span class="line">        <span class="keyword">auto</span> dy = y2 - y1 + <span class="number">1</span>, dx = x2 - x1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">auto</span> part1 = ix2(x1, x2, x1) + xi2(x1, x2, x2) + ix_xi(x1, x2, x1, x2) * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> part2 = ix2(y1, y2, y1) + xi2(y1, y2, y2) + ix_xi(y1, y2, y1, y2) * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> part3L = (ix(x1, x2, x1) + xi(x1, x2, x2)) % mod;</span><br><span class="line">        <span class="keyword">auto</span> part3R = (ix(y1, y2, y1) + xi(y1, y2, y2)) % mod;</span><br><span class="line">        <span class="keyword">auto</span> part3 = part3L * part3R % mod * <span class="number">2</span> % mod;</span><br><span class="line">        <span class="keyword">auto</span> part12 = (part1 %= mod) * dy % mod + (part2 %= mod) * dx % mod;</span><br><span class="line">        <span class="keyword">auto</span> ans = (part12 + part3) % mod;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (llong)ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已通过五组测试样例。</p><h2 id="后记">后记</h2><h3 id="参考资料">参考资料</h3><ul><li><a href="https://www.cnblogs.com/GDOI2018/p/13541520.html#:~:text=什么是二维数论分块？%20举个例子，如果我们要在求%20⌊%20n%20i%20⌋%20的同时求出%20⌊,F%20(%20p%20i%20k%20i)%20。%20又称%22狄利克雷卷积%22。">学习总结-莫比乌斯反演 - __allenge - 博客园 (cnblogs.com)</a></li><li><a href="https://www.cnblogs.com/henry-1202/p/10121854.html">数论分块 - henry_y - 博客园 (cnblogs.com)</a></li></ul>]]></content>
    
    <summary type="html">
    
      不会吧，不会吧，不会有人学算法学到现在还不完全会数论分块吧！真是笑稀了家人们！
    
    </summary>
    
    
      <category term="算法" scheme="https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="算法" scheme="https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM" scheme="https://shiraha.cn/tags/ACM/"/>
    
      <category term="数论" scheme="https://shiraha.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络实验报告（三合一）</title>
    <link href="https://shiraha.cn/2021/computer-network-experiment-report-3-in-1/"/>
    <id>https://shiraha.cn/2021/computer-network-experiment-report-3-in-1/</id>
    <published>2021-06-16T13:31:27.000Z</published>
    <updated>2021-06-16T13:31:27.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本报告涉及到的源代码的位置：<a href="https://github.com/ma-hunter/cn_exp" class="uri">https://github.com/ma-hunter/cn_exp</a></p></blockquote><table><thead><tr class="header"><th>班级</th><th>姓名</th><th>学号</th></tr></thead><tbody><tr class="odd"><td>软件工程 18XX 班</td><td>XXX</td><td>U2018XXXXX</td></tr></tbody></table><h2 id="实验一wireshark-抓包工具使用">实验一：Wireshark 抓包工具使用</h2><table><thead><tr class="header"><th>系统环境</th><th>软件版本</th></tr></thead><tbody><tr class="odd"><td>Windows 10 Pro 21H1</td><td>WIRE<strong>SHARK</strong> Version 3.4.6 (v3.4.6-0-g6357ac1405b8)</td></tr></tbody></table><h3 id="一实验目的">一、实验目的</h3><ol type="1"><li>学习 Wireshark 抓包工具的使用</li><li>了解 Wireshark 抓包工具的功能</li><li>通过学习，进一步理解协议及网络体系结构思想</li></ol><h3 id="二实验内容">二、实验内容</h3><p>使用 Wireshark，并学习使用它进行网络包分析。</p><h3 id="三实验原理">三、实验原理</h3><p>Wireshark 是网络包分析工具；网络包分析工具的主要作用是尝试捕获网络包，并尝试显示包的尽可能详细的情况。Wireshark 常见的应用如下：</p><ul><li>网络管理员用来解决网络问题</li><li>网络安全工程师用来检测安全隐患</li><li>开发人员用来测试协议执行情况</li></ul><p>这里，我们通过 Wireshark 来学习常见的网络协议。</p><h3 id="四实验过程">四、实验过程</h3><p>包含了从安装 Wireshark 开始到使用 Wireshark 观察一些现象的过程：</p><h4 id="下载-wireshark">4.1 下载 Wireshark</h4><p>Wireshark 的官方网站是：<a href="https://www.wireshark.org/" class="uri">https://www.wireshark.org/</a>，下载地址是<a href="https://2.na.dl.wireshark.org/win64/Wireshark-win64-3.4.6.exe" class="uri">https://2.na.dl.wireshark.org/win64/Wireshark-win64-3.4.6.exe</a></p><h4 id="准备工作">4.2 准备工作</h4><p>再 Powershell 中输入 <code>ipconfig</code> 查询本机的 IP 信息：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/查看IP地址.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/查看IP地址.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="查看IP地址" /><figcaption aria-hidden="true">查看IP地址</figcaption></figure><p>在同局域网下打开另一台设备，启动一个服务器：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/局域网内开启服务器.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/局域网内开启服务器.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="局域网内开启服务器" /><figcaption aria-hidden="true">局域网内开启服务器</figcaption></figure><p>查看局域网内的这台设备的 IP 地址：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/检查局域网内服务器IP.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/检查局域网内服务器IP.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="检查局域网内服务器IP" /><figcaption aria-hidden="true">检查局域网内服务器IP</figcaption></figure><p>可以得到的信息汇总如下：</p><table><thead><tr class="header"><th>机器</th><th>IP(v4) 地址</th><th>子网掩码</th><th>默认网关</th></tr></thead><tbody><tr class="odd"><td>主机</td><td>192.168.3.2</td><td>255.255.255.0</td><td>192.168.3.1</td></tr><tr class="even"><td>服务器</td><td>192.168.3.71</td><td>255.255.255.0</td><td>192.168.3.1</td></tr></tbody></table><p>因为只需要这些信息，所以直接在 Powershell 中获取；需要更详细的信息也可以通过网络适配器选项中来获得。接下来使用 Wireshark 捕获两者之间的通讯数据包，并且进行分析。</p><h4 id="启动-wireshark">4.3 启动 Wireshark</h4><p>首先需要先选择监听的网络设备：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/打开网络设备.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/打开网络设备.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="打开网络设备" /><figcaption aria-hidden="true">打开网络设备</figcaption></figure><p>然后，就可以开始捕获以太网的通信数据包：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/正在捕获以太网.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/正在捕获以太网.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="正在捕获以太网" /><figcaption aria-hidden="true">正在捕获以太网</figcaption></figure><p>接下来，可以进行捕获通过它的特定报文，并且分析内容。</p><h4 id="tcp握手">4.4 TCP握手</h4><p>浏览器访问上面查询到的服务器的地址 <code>http://192.168.3.71</code>，并且在 Wireshark 中设定限制条件（过滤器） <code>ip.src == 192.168.3.71 or ip.dst == 192.168.3.71</code> 来只捕获来自这两个 IP 地址之间的通信。</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/TCP握手.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/TCP握手.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="TCP握手" /><figcaption aria-hidden="true">TCP握手</figcaption></figure><p>高亮的部分就是 TCP 的三次握手。</p><h4 id="tcp报文分析示例">4.5 TCP报文分析示例</h4><p>这是上述三次握手过程中的第二次握手的报文的详细信息：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/报文详细分析.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/报文详细分析.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="报文详细分析" /><figcaption aria-hidden="true">报文详细分析</figcaption></figure><table><thead><tr class="header"><th>项目</th><th>信息</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>源端口</td><td>80</td><td>服务器的 HTTP 默认端口，服务确实开在 80 端口上</td></tr><tr class="even"><td>目的端口</td><td>61577</td><td>用户浏览器当前开启的用于和服务器通信的端口</td></tr><tr class="odd"><td>TCP 段长度</td><td>0</td><td>该报文不携带数据</td></tr><tr class="even"><td>Sequence 数字</td><td>0</td><td><code>Seq=0</code></td></tr><tr class="odd"><td>Acknowledge 数字</td><td>1</td><td>期望收到的下一个报文满足 <code>Seq=1</code></td></tr><tr class="even"><td>首部长度</td><td>32 bytes (8)</td><td>8 * 4B = 32 bytes</td></tr><tr class="odd"><td>标志</td><td>0x012</td><td>SYN 和 ACK 位为 1</td></tr><tr class="even"><td>校验和</td><td>0x5426</td><td>校验和为 0x5426，未验证</td></tr></tbody></table><h4 id="http报文分析">4.6 HTTP报文分析</h4><p>在 TCP 握手完成之后，服务器将使用 HTTP 协议传输数据到浏览器；我们在紧接着握手完成后面的位置找到了使用 HTTP 协议传输的数据包；可以打开查看其详细信息：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/HTTP报文.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/HTTP报文.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="HTTP报文" /><figcaption aria-hidden="true">HTTP报文</figcaption></figure><table><colgroup><col style="width: 28%" /><col style="width: 71%" /></colgroup><thead><tr class="header"><th>内容</th><th>信息</th></tr></thead><tbody><tr class="odd"><td><code>GET / HTTP/1.1</code></td><td>操作类型：GET；遵循了 HTTP 1.1 版本的协议</td></tr><tr class="even"><td><code>Host: 192.168.3.71</code></td><td>主机名：192.168.3.71；当绑定域名的场合下会是主机的域名</td></tr><tr class="odd"><td><code>Connection: keep-alive</code></td><td>连接类型是保持持久连接</td></tr><tr class="even"><td><code>User-Agent: ...</code></td><td>用户的客户端信息；这里有个 <code>Mozilla/5.0 (Windows NT 10.0 ...)</code> 说明是运行在 Windows 10 上的火狐浏览器</td></tr><tr class="odd"><td>……</td><td>……</td></tr></tbody></table><p>HTTP 头能塞的东西还挺多的，这里就不全部说明了；当然，这里所包含的项目也未必完整。</p><h3 id="五思考题">五、思考题</h3><p><strong>网络工程师能通过 Wireshark 做哪些工作？</strong></p><ul><li>检查网络协议的执行情况</li><li>排查网络故障，解决网络问题</li><li>网络攻防，检测网络安全隐患</li></ul><h2 id="实验二winpcap-编程">实验二：WinPcap 编程</h2><table><thead><tr class="header"><th>系统环境</th><th>开发环境</th></tr></thead><tbody><tr class="odd"><td>Windows 10 Pro 21H1</td><td>CLion 2021.1; CMake 3.19; tdm-gcc 9.3; NpCap SDK 1.07</td></tr></tbody></table><h3 id="一实验目的-1">一、实验目的</h3><ul><li>了解 NpCap 架构和运行逻辑</li><li>学习使用 NpCap SDK 进行编程</li></ul><h3 id="二实验内容-1">二、实验内容</h3><p>通过学习 NpCap SDK，编写一个网络抓包程序</p><h3 id="三实验原理-1">三、实验原理</h3><p>本实验主要基于 NpCap 完成，所以这里主要是关于 NpCap 的介绍：</p><h4 id="npcap概述">3.1 NpCap概述</h4><p>WinPcap 是一个基于Win32平台的，用于捕获网络数据包并进行分析的开源库；在 Linux 上也有对应的 LibPcap；目前 WinPcap 已经处于无人维护的状态，对于 Windows 10 有更新的且目前有人维护的开源项目 NpCap。</p><p>大多数网络应用程序通过被广泛使用的操作系统元件来访问网络，比如 sockets——这是一种简单的实现方式，因为操作系统已经妥善处理了底层具体实现细节（比如协议处理，封装数据包等等工作），并且提供了一个与读写文件类似的，令人熟悉的接口；但是有些时候，这种“简单的实现方式”并不能满足需求，因为有些应用程序需要直接访问网络中的数据包：也就是说原始数据包——即没有被操作系统利用网络协议处理过的数据包。而 WinPcap/NpCap 则为 Win32 应用程序提供了这样的接口：</p><ul><li>捕获原始数据包；无论它是发往某台机器的，还是在其他设备（共享媒介）上进行交换的</li><li>在数据包发送给某应用程序前，根据指定的规则过滤数据包</li><li>将原始数据包通过网络发送出去</li><li>收集并统计网络流量信息</li></ul><p>SDK 提供的这些功能需要借助运行在 Win32 内核中的网络设备驱动程序来实现；在安装完成驱动之后，SDK 将这些功能作为一个接口表现出来以供使用。</p><h4 id="要使用的接口">3.2 要使用的接口</h4><p>以下介绍了实现后文提到的 demo 所需要使用的 NpCap API 的简单介绍：</p><h5 id="pcap_findalldevs">3.2.1 <code>pcap_findalldevs</code></h5><p>NpCap 提供了 <code>pcap_findalldevs_ex</code> 和 <code>pcap_findalldevs</code> 函数来获取计算机上的网络接口设备的列表；此函数会为传入的 <code>pcap_if_t</code> 赋值——该类型是一个表示了设备列表的链表头；每一个这样的节点都包含了 <code>name</code> 和 <code>description</code> 域来描述设备。</p><p>除此之外，<code>pcap_if_t</code> 结构体还包含了一个 <code>pcap_addr</code> 结构体；后者包含了一个地址列表、一个掩码列表、一个广播地址列表和一个目的地址的列表；此外，<code>pcap_findalldevs_ex</code> 还能返回远程适配器信息和一个位于所给的本地文件夹的 pcap 文件列表。</p><h5 id="pcap_open">3.2.2 <code>pcap_open</code></h5><p>用来打开一个适配器，实际调用的是 <code>pcap_open_live</code>；它接受五个参数：</p><ul><li><code>name</code>：适配器的名称（GUID）</li><li><code>snaplen</code>：制定要捕获数据包中的哪些部分。在一些操作系统中 (比如 xBSD 和 Win32)，驱动可以被配置成只捕获数据包的初始化部分：这样可以减少应用程序间复制数据的量，从而提高捕获效率；本次实验中，将值定为 <code>65535</code>，比能遇到的最大的MTU还要大，因此总能收到完整的数据包。</li><li><code>flags</code>：主要的意义是其中包含的混杂模式开关；一般情况下，适配器只接收发给它自己的数据包， 而那些在其他机器之间通讯的数据包，将会被丢弃。但混杂模式将会捕获所有的数据包——因为我们需要捕获其他适配器的数据包，所以需要打开这个开关。</li><li><code>to_ms</code>：指定读取数据的超时时间，以毫秒计；在适配器上使用其他 API 进行读取操作的时候，这些函数会在这里设定的时间内响应——即使没有数据包或者捕获失败了；在统计模式下，<code>to_ms</code> 还可以用来定义统计的时间间隔：设置为 <code>0</code> 说明没有超时——如果没有数据包到达，则永远不返回；对应的还有 <code>-1</code>：读操作立刻返回。</li><li><code>errbuf</code>：用于存储错误信息字符串的缓冲区</li></ul><p>该函数返回一个 <code>pcap_t</code> 类型的 handle。</p><h5 id="pcap_loop">3.2.3 <code>pcap_loop</code></h5><p>API 函数 <code>pcap_loop</code> 和 <code>pcap_dispatch</code> 都用来在打开的适配器中捕获数据包；但是前者会已知捕获直到捕获到的数据包数量达到要求数量，而后者在到达了前面 API 设定的超时时间之后就会返回（尽管这得不到保证）；前者会在一小段时间内阻塞网络的应用，故一般项目都会使用后者作为读取数据包的函数；虽然在本次实验中，使用前者就够了。</p><p>这两个函数都有一个回调函数；这个回调函数会在这两个函数捕获到数据包的时候被调用，用来处理捕获到的数据包；这个回调函数需要遵顼特定的格式。但是需要注意的是我们无法发现 CRC 冗余校验码——因为帧到达适配器之后，会经过校验确认的过程；这个过程成功，则适配器会删除 CRC；否则，大多数适配器会删除整个包，因此无法被 NpCap 确认到。</p><h5 id="pcap_datalink">3.2.4 <code>pcap_datalink</code></h5><p>用于对 MAC 层进行了检测，以确保在处理一个以太网络，确保 MAC 首部是14位的。IP 数据包的首部就位于 MAC 首部的后面，将从 IP 数据包的首部解析到源 IP 地址和目的 IP 地址。</p><h5 id="pcap_compile-pcap_setfilter">3.2.5 <code>pcap_compile</code> &amp; <code>pcap_setfilter</code></h5><p>用来设置过滤器，以避免处理一些无用的包，提高包处理的效率。在本次实验中我们需要将过滤器字符串设置成 <code>ip and udp</code>，使得我们传入的回调只处理基于 IPv4 的 UDP 数据包；大大简化了解析过程和回调函数的调用次数。</p><h4 id="其他的补充">3.3 其他的补充</h4><p>处理 UDP 数据包的首部时存在一些困难：因为 IP 数据包的首部的长度并不是固定的，但是可以通过 IP 数据包的 <code>length</code> 域来得到它的长度；一旦知道了 UDP 首部的位置，就能解析到源端口和目的端口。</p><h3 id="四实验过程-1">四、实验过程</h3><p>从安装 NpCap 到运行 NpCap 示例程序的全部过程；</p><h4 id="安装-npcap">4.1 安装 NpCap</h4><p>NpCap 是 WinPcap for Windows 10；它的官方下载页面是 <a href="https://nmap.org/npcap/#download">Npcap: Windows Packet Capture Library &amp; Driver (nmap.org)</a>；在这里我们需要下载：</p><ul><li>NpCap 内核驱动：<a href="https://nmap.org/npcap/dist/npcap-1.31.exe">Npcap 1.31 installer</a></li><li>NpCap SDK 文件：<a href="https://nmap.org/npcap/dist/npcap-sdk-1.07.zip">Npcap SDK 1.07</a></li></ul><p>安装完成驱动后，再在 IDE 中为项目配置导入 NpCap SDK 文件。NpCap SDK 文件包中包括了使用 NpCap 实现的基本功能的 demo。</p><h4 id="使用-npcap-的功能">4.2 使用 NpCap 的功能</h4><p>项目的文件结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CMake target: if_list udp_dump basic_dump_ex</span><br><span class="line">(root)</span><br><span class="line">├ module</span><br><span class="line">│ └ (NpCap Library files)NpCap SDK 库文件</span><br><span class="line">├ src</span><br><span class="line">│ ├ basic_dump_ex.c目标 basic_dump_ex 的源文件</span><br><span class="line">│ ├ if_list.c目标 if_list 的源文件</span><br><span class="line">│ └ udp_dump.c目标 udp_dump 的源文件</span><br><span class="line">└ CMakeList.txtCMake 项目定义文件</span><br></pre></td></tr></table></figure><p>这些使用 NpCap 功能的 demo 的实现代码都位于：<a href="https://github.com/ma-hunter/cn_exp" class="uri">https://github.com/ma-hunter/cn_exp</a></p><h3 id="五实验结果">五、实验结果</h3><p>上述代码包括的，使用 NpCap 实现的几项基本功能的运行结果（非截图）。</p><h4 id="读取网络设备列表">5.1 读取网络设备列表</h4><p>使用 CMake，构建并运行上述项目中的目标 <code>if_list</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;D:\Program Files\JetBrains\Toolbox\apps\CLion\ch-0\211.6693.114\bin\cmake\win\bin\cmake.exe&quot; --build D:\Workspaces\CLion\cn_exp\cmake-build-debug --target if_list -- -j 4</span><br><span class="line">Scanning dependencies of target if_list</span><br><span class="line">[ 50%] Building C object CMakeFiles&#x2F;if_list.dir&#x2F;src&#x2F;if_list.c.obj</span><br><span class="line">[100%] Linking C executable if_list.exe</span><br><span class="line">[100%] Built target if_list</span><br><span class="line"></span><br><span class="line">构建已完成</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">D:\Workspaces\CLion\cn_exp\cmake-build-debug\if_list.exe \Device\NPF_&#123;5C8B26D4-9439-4304-B8FB-48A81CB33CF9&#125;</span><br><span class="line">        Description: WAN Miniport (Network Monitor)</span><br><span class="line">        Loopback: no</span><br><span class="line"></span><br><span class="line">\Device\NPF_&#123;C21F9683-BA8A-4AFE-827A-166030BB1466&#125;</span><br><span class="line">        Description: WAN Miniport (IPv6)</span><br><span class="line">        Loopback: no</span><br><span class="line"></span><br><span class="line">\Device\NPF_&#123;1C99E263-4855-4786-97ED-ECAC30A11761&#125;</span><br><span class="line">        Description: WAN Miniport (IP)</span><br><span class="line">        Loopback: no</span><br><span class="line"></span><br><span class="line">\Device\NPF_&#123;1A386F2B-3A3E-49A7-B899-2629C46C4FB3&#125;</span><br><span class="line">        Description: Hyper-V Virtual Ethernet Adapter #2</span><br><span class="line">        Loopback: no</span><br><span class="line">        Address Family: #23</span><br><span class="line">        Address Family Name: AF_INET6</span><br><span class="line">        Address Family: #2</span><br><span class="line">        Address Family Name: AF_INET</span><br><span class="line">        Address: 172.26.112.1</span><br><span class="line">        Netmask: 0.240.255.255</span><br><span class="line">        Broadcast Address: 255.31.112.1</span><br><span class="line"></span><br><span class="line">\Device\NPF_&#123;A30B9DA2-E755-4DF6-8BD4-010B6590B072&#125;</span><br><span class="line">        Description: Hyper-V Virtual Ethernet Adapter</span><br><span class="line">        Loopback: no</span><br><span class="line">        Address Family: #23</span><br><span class="line">        Address Family Name: AF_INET6</span><br><span class="line">        Address Family: #2</span><br><span class="line">        Address Family Name: AF_INET</span><br><span class="line">        Address: 172.26.0.1</span><br><span class="line">        Netmask: 0.240.255.255</span><br><span class="line">        Broadcast Address: 255.31.0.1</span><br><span class="line"></span><br><span class="line">\Device\NPF_&#123;21EAB23F-F3E5-48E0-B370-35B69F40B833&#125;</span><br><span class="line">        Description: Bluetooth Device (Personal Area Network) #3</span><br><span class="line">        Loopback: no</span><br><span class="line">        Address Family: #23</span><br><span class="line">        Address Family Name: AF_INET6</span><br><span class="line">        Address Family: #2</span><br><span class="line">        Address Family Name: AF_INET</span><br><span class="line">        Address: 169.254.62.143</span><br><span class="line">        Netmask: 0.0.255.255</span><br><span class="line">        Broadcast Address: 255.255.62.143</span><br><span class="line"></span><br><span class="line">\Device\NPF_&#123;5CCBE082-6FB3-4754-B27A-3659F98979BE&#125;</span><br><span class="line">        Description: Realtek RTL8188EU Wireless LAN 802.11n USB 2.0 Network Adapter</span><br><span class="line">        Loopback: no</span><br><span class="line">        Address Family: #23</span><br><span class="line">        Address Family Name: AF_INET6</span><br><span class="line">        Address Family: #2</span><br><span class="line">        Address Family Name: AF_INET</span><br><span class="line">        Address: 169.254.125.212</span><br><span class="line">        Netmask: 0.0.255.255</span><br><span class="line">        Broadcast Address: 255.255.125.212</span><br><span class="line"></span><br><span class="line">\Device\NPF_&#123;E919BE86-5601-4998-B187-2C629DE1F9B9&#125;</span><br><span class="line">        Description: Microsoft Wi-Fi Direct Virtual Adapter #2</span><br><span class="line">        Loopback: no</span><br><span class="line">        Address Family: #23</span><br><span class="line">        Address Family Name: AF_INET6</span><br><span class="line">        Address Family: #2</span><br><span class="line">        Address Family Name: AF_INET</span><br><span class="line">        Address: 169.254.194.126</span><br><span class="line">        Netmask: 0.0.255.255</span><br><span class="line">        Broadcast Address: 255.255.194.126</span><br><span class="line"></span><br><span class="line">\Device\NPF_&#123;FF7337C5-5DA3-4AF4-8C55-5A066C578D65&#125;</span><br><span class="line">        Description: Microsoft Wi-Fi Direct Virtual Adapter</span><br><span class="line">        Loopback: no</span><br><span class="line">        Address Family: #23</span><br><span class="line">        Address Family Name: AF_INET6</span><br><span class="line">        Address Family: #2</span><br><span class="line">        Address Family Name: AF_INET</span><br><span class="line">        Address: 169.254.180.74</span><br><span class="line">        Netmask: 0.0.255.255</span><br><span class="line">        Broadcast Address: 255.255.180.74</span><br><span class="line"></span><br><span class="line">\Device\NPF_&#123;43524049-AA60-4F6E-A89E-8AE5BA1EAA93&#125;</span><br><span class="line">        Description: Realtek PCIe GbE Family Controller</span><br><span class="line">        Loopback: no</span><br><span class="line">        Address Family: #23</span><br><span class="line">        Address Family Name: AF_INET6</span><br><span class="line">        Address Family: #2</span><br><span class="line">        Address Family Name: AF_INET</span><br><span class="line">        Address: 192.168.3.2</span><br><span class="line">        Netmask: 0.255.255.255</span><br><span class="line">        Broadcast Address: 255.168.3.2</span><br><span class="line"></span><br><span class="line">\Device\NPF_Loopback</span><br><span class="line">        Description: Adapter for loopback traffic capture</span><br><span class="line">        Loopback: yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">进程已结束，退出代码为 0</span><br></pre></td></tr></table></figure><p>于此同时可以看到控制面板下的网络适配器页面；可以看到基本的适配器信息是一致的：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/网络适配器.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/screenshots/网络适配器.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="网络适配器.png" /><figcaption aria-hidden="true">网络适配器.png</figcaption></figure><p>我们的 demo 输出的更多是因为包含了一些被操作系统用户级别隐藏的接口。</p><h4 id="打开设别并抓包监听">5.2 打开设别并抓包监听</h4><p>使用 CMake，构建并运行上述项目中的目标 <code>basic_dump_ex</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;D:\Program Files\JetBrains\Toolbox\apps\CLion\ch-0\211.6693.114\bin\cmake\win\bin\cmake.exe&quot; --build D:\Workspaces\CLion\cn_exp\cmake-build-debug --target basic_dump_ex -- -j 4</span><br><span class="line">Scanning dependencies of target basic_dump_ex</span><br><span class="line">[ 50%] Building C object CMakeFiles&#x2F;basic_dump_ex.dir&#x2F;src&#x2F;basic_dump_ex.c.obj</span><br><span class="line">[100%] Linking C executable basic_dump_ex.exe</span><br><span class="line">[100%] Built target basic_dump_ex</span><br><span class="line"></span><br><span class="line">构建已完成</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">D:\Workspaces\CLion\cn_exp\cmake-build-debug\basic_dump_ex.exe</span><br><span class="line">1. \Device\NPF_&#123;5C8B26D4-9439-4304-B8FB-48A81CB33CF9&#125; (WAN Miniport (Network Monitor))</span><br><span class="line">2. \Device\NPF_&#123;C21F9683-BA8A-4AFE-827A-166030BB1466&#125; (WAN Miniport (IPv6))</span><br><span class="line">3. \Device\NPF_&#123;1C99E263-4855-4786-97ED-ECAC30A11761&#125; (WAN Miniport (IP))</span><br><span class="line">4. \Device\NPF_&#123;1A386F2B-3A3E-49A7-B899-2629C46C4FB3&#125; (Hyper-V Virtual Ethernet Adapter #2)</span><br><span class="line">5. \Device\NPF_&#123;A30B9DA2-E755-4DF6-8BD4-010B6590B072&#125; (Hyper-V Virtual Ethernet Adapter)</span><br><span class="line">6. \Device\NPF_&#123;21EAB23F-F3E5-48E0-B370-35B69F40B833&#125; (Bluetooth Device (Personal Area Network) #3)</span><br><span class="line">7. \Device\NPF_&#123;5CCBE082-6FB3-4754-B27A-3659F98979BE&#125; (Realtek RTL8188EU Wireless LAN 802.11n USB 2.0 Network Adapter)</span><br><span class="line">8. \Device\NPF_&#123;E919BE86-5601-4998-B187-2C629DE1F9B9&#125; (Microsoft Wi-Fi Direct Virtual Adapter #2)</span><br><span class="line">9. \Device\NPF_&#123;FF7337C5-5DA3-4AF4-8C55-5A066C578D65&#125; (Microsoft Wi-Fi Direct Virtual Adapter)</span><br><span class="line">10. \Device\NPF_&#123;43524049-AA60-4F6E-A89E-8AE5BA1EAA93&#125; (Realtek PCIe GbE Family Controller)</span><br><span class="line">11. \Device\NPF_Loopback (Adapter for loopback traffic capture)</span><br><span class="line">Enter the interface number (1-11):10</span><br><span class="line"></span><br><span class="line">listening on Realtek PCIe GbE Family Controller...</span><br><span class="line">13:36:31,027242 len:208</span><br><span class="line">13:36:31,068904 len:1071</span><br><span class="line">13:36:31,122063 len:54</span><br><span class="line">13:36:31,423026 len:60</span><br><span class="line">13:36:31,423094 len:54</span><br><span class="line">13:36:31,750427 len:336</span><br><span class="line">13:36:31,750466 len:320</span><br><span class="line">13:36:31,782177 len:66</span><br></pre></td></tr></table></figure><p>程序将会运行到被外部中断阻止后才会停止运行。</p><h4 id="捕获udp包并分析">5.3 捕获UDP包并分析</h4><p>使用 CMake，构建并运行上述项目中的目标 <code>basic_dump_ex</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;D:\Program Files\JetBrains\Toolbox\apps\CLion\ch-0\211.6693.114\bin\cmake\win\bin\cmake.exe&quot; --build D:\Workspaces\CLion\cn_exp\cmake-build-debug --target udp_dump -- -j 4</span><br><span class="line">[100%] Built target udp_dump</span><br><span class="line"></span><br><span class="line">构建已完成</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">D:\Workspaces\CLion\cn_exp\cmake-build-debug\udp_dump.exe</span><br><span class="line">1. \Device\NPF_&#123;5C8B26D4-9439-4304-B8FB-48A81CB33CF9&#125; (WAN Miniport (Network Monitor))</span><br><span class="line">2. \Device\NPF_&#123;C21F9683-BA8A-4AFE-827A-166030BB1466&#125; (WAN Miniport (IPv6))</span><br><span class="line">3. \Device\NPF_&#123;1C99E263-4855-4786-97ED-ECAC30A11761&#125; (WAN Miniport (IP))</span><br><span class="line">4. \Device\NPF_&#123;1A386F2B-3A3E-49A7-B899-2629C46C4FB3&#125; (Hyper-V Virtual Ethernet Adapter #2)</span><br><span class="line">5. \Device\NPF_&#123;A30B9DA2-E755-4DF6-8BD4-010B6590B072&#125; (Hyper-V Virtual Ethernet Adapter)</span><br><span class="line">6. \Device\NPF_&#123;21EAB23F-F3E5-48E0-B370-35B69F40B833&#125; (Bluetooth Device (Personal Area Network) #3)</span><br><span class="line">7. \Device\NPF_&#123;5CCBE082-6FB3-4754-B27A-3659F98979BE&#125; (Realtek RTL8188EU Wireless LAN 802.11n USB 2.0 Network Adapter)</span><br><span class="line">8. \Device\NPF_&#123;E919BE86-5601-4998-B187-2C629DE1F9B9&#125; (Microsoft Wi-Fi Direct Virtual Adapter #2)</span><br><span class="line">9. \Device\NPF_&#123;FF7337C5-5DA3-4AF4-8C55-5A066C578D65&#125; (Microsoft Wi-Fi Direct Virtual Adapter)</span><br><span class="line">10. \Device\NPF_&#123;43524049-AA60-4F6E-A89E-8AE5BA1EAA93&#125; (Realtek PCIe GbE Family Controller)</span><br><span class="line">11. \Device\NPF_Loopback (Adapter for loopback traffic capture)</span><br><span class="line">Enter the interface number (1-11):10</span><br><span class="line"></span><br><span class="line">listening on Realtek PCIe GbE Family Controller...</span><br><span class="line">13:38:26.314222 len:181 192.168.3.2.7726 -&gt; 180.97.33.12.8829</span><br><span class="line">13:38:26.339699 len:163 180.97.33.12.8829 -&gt; 192.168.3.2.7726</span><br><span class="line">13:38:28.517235 len:361 223.166.151.86.8000 -&gt; 192.168.3.2.4017</span><br><span class="line">13:38:28.517526 len:97 192.168.3.2.4017 -&gt; 223.166.151.86.8000</span><br><span class="line">13:38:29.100916 len:82 192.168.3.2.60173 -&gt; 192.168.3.1.53</span><br><span class="line">13:38:29.151404 len:149 192.168.3.1.53 -&gt; 192.168.3.2.60173</span><br><span class="line">13:38:30.577642 len:129 223.166.151.86.8000 -&gt; 192.168.3.2.4017</span><br></pre></td></tr></table></figure><p>程序将会运行到被外部中断阻止后才会停止运行。</p><h3 id="六思考题">六、思考题</h3><p><strong>WINPCAP是否能实现服务质量的控制？</strong></p><p>不能。WinPcap 可以独立地通过主机协议发送和接受数据，如同TCP/IP；这就意味着 WinPcap 不能阻止、过滤或操纵同一机器上的其他应用程序的通讯：它仅仅能简单地“监视”在网络上传输的数据包。所以，它不能提供类似网络流量控制、服务质量调度和个人防火墙之类的支持，因而不能实现服务质量的控制。</p><h2 id="实验三协议分析流量统计程序的编写">实验三：协议分析&amp;流量统计程序的编写</h2><table><thead><tr class="header"><th>系统环境</th><th>开发环境</th></tr></thead><tbody><tr class="odd"><td>Windows 10 Pro 21H1</td><td>CLion 2021.1; CMake 3.19; tdm-gcc 9.3; NpCap SDK 1.07</td></tr></tbody></table><h3 id="一实验目的-2">一、实验目的</h3><ul><li>理解协议在通信中的作用，掌握常见 IP 协议；</li><li>掌握基于 NpCap 的抓包软件的开发；</li><li>掌握协议解析和流量统计的编程方法；</li></ul><h3 id="二实验内容-2">二、实验内容</h3><p>利用 NpCap 编写协议分析工具；输出抓取的包和协议分析结构，并统计 IP 的流量（即包的数量）。</p><p>功能要求：</p><ol type="1"><li>利用 NpCap 捕获数据包，并可根据要求进行数据包过滤。</li><li>根据IP协议，解析每个数据包的PCI，展示其在不同网络层次所使用的协议结构和具体信息。</li><li>根据IP地址，统计源自该IP地址的流量，即捕获到的数据包的数量。</li></ol><p>运行程序后将捕获的信息输出到标准输出流中。</p><h3 id="三实验原理-2">三、实验原理</h3><p>实验的设计依据的原理，包括协议的概念和 NpCap 的接口使用逻辑。</p><h4 id="协议说明">3.1 协议说明</h4><p>下面的内容包含了本次实验所涉及到的协议类型的说明。</p><h5 id="协议栈分析">3.1.1 协议栈分析</h5><p>因为 TCP/IP 协议采用分层的结构，所以网络通信时，要传输的数据在发送端是一个逐层封装的过程；而相应地在接收端则是一个逐层分解的过程；如下图所示：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/协议栈分析.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/协议栈分析.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="协议栈分析" /><figcaption aria-hidden="true">协议栈分析</figcaption></figure><p>在接收端的逐层分解，就是上述封装的逆过程；</p><h5 id="以太网协议">3.1.2 以太网协议</h5><p>以太网 II 格式时一种帧格式，应用最为广泛，几乎成为了当前以太网的现行标准；它由 RFC894 定义，如下图所示：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/以太网协议.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/以太网协议.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="以太网协议.png" /><figcaption aria-hidden="true">以太网协议.png</figcaption></figure><h5 id="ip-协议">3.1.3 IP 协议</h5><p>IP 协议是 Internet 的核心协议，它工作在网络层，提供了不可靠无连接的数据传送服务；协议格式如图所示：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/IP协议.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/IP协议.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="IP协议" /><figcaption aria-hidden="true">IP协议</figcaption></figure><h5 id="icmp协议">3.1.4 ICMP协议</h5><p>ICMP 的全称是 Internet 控制信息协议 (Internet Control Message Protocol)。它提供了很多 Internet 的信息描述服务：例如能够检测网络的运行状况，通知协议有用的网络状态信息；ICMP 是基于 IP 协议的，ICMP 协议格式如图所示：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/ICMP协议.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/ICMP协议.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="ICMP协议.png" /><figcaption aria-hidden="true">ICMP协议.png</figcaption></figure><h5 id="tcp协议">3.1.5 TCP协议</h5><p>TCP协议是基于连接的可靠的协议：它负责发收端的协定，然后保持正确可靠的数据传输服务；它在 IP 协议上运行，而 IP 无连接的协议，所以TCP丰富了IP协议的功能，使它具有可靠的传输服务；TCP 协议格式如图所示：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/TCP协议.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/TCP协议.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="TCP协议.png" /><figcaption aria-hidden="true">TCP协议.png</figcaption></figure><p>可以看到 TCP 报文段结构由以下的部分组成：</p><ul><li>源端口：指定了发送端的端口</li><li>目的端口：指定了接受端的端口号</li><li>序号：指明了段在即将传输的段序列中的位置</li><li>确认号：规定成功收到段的序列号，确认序号包含发送确认的一端所期望收到的下一个序号</li><li>TCP 偏移量：指定了段头的长度。段头的长度取决与段头选项字段中设置的选项</li><li>保留：指定了一个保留字段，以备将来使用</li><li>标志：<code>SYN</code>、<code>ACK</code>、<code>PSH</code>、<code>RST</code>、<code>URG</code>、<code>FIN</code><ul><li><code>SYN</code>： 表示同步</li><li><code>ACK</code>： 表示确认</li><li><code>PSH</code>： 表示尽快的将数据送往接收进程</li><li><code>RST</code>： 表示复位连接</li><li><code>URG</code>： 表示紧急指针</li><li><code>FIN</code>： 表示发送方完成数据发送</li></ul></li><li>窗口：指定关于发送端能传输的下一段的大小的指令</li><li>校验和：校验和包含 TCP 段头和数据部分，用来校验段头和数据部分的可靠性</li><li>紧急指针：指明段中包含紧急信息，只有当 U R G 标志置1时紧急指针才有效</li><li>选项：指定了公认的段大小，时间戳，选项字段的末端，以及指定了选项字段的边界选项</li></ul><p>TCP 连接的建立和释放采用了三步握手法，如下图所示：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/TCP连接建立.jpg" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/TCP连接建立.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="TCP连接建立.jpg" /><figcaption aria-hidden="true">TCP连接建立.jpg</figcaption></figure><p>其过程可以描述如下步骤：</p><ol type="1"><li>主机一发出连接序号为 x（<code>seq=x</code>）</li><li>主机二应答接受主机一的连接请求，并声明自己的序号为 y（<code>sqe=y</code>，<code>ACK=x+1</code>）</li><li>主机一收到确认后，发送第一个数据 TPDU 并确认主机二的序号（<code>seq=x</code>，<code>ACK=y+1</code>）</li></ol><p>至此，整个连接建立过程正常结束，数据传输已经正式开始。</p><h5 id="udp-协议">3.1.6 UDP 协议</h5><p>用户数据报协议 UDP 是在 IP 协议上的传输层协议，它提供了无连接的协议服务；它在IP协议基础上提供了端口的功能，因此既可让应用程序之间进行通信了。UDP 协议格式如图3.7所示：</p><figure><img src="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/UDP协议.png" class="lazyload" data-srcset="https://cdn.jsdelivr.net/gh/ma-hunter/cn_exp@main/img/UDP协议.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="UDP协议.png" /><figcaption aria-hidden="true">UDP协议.png</figcaption></figure><h4 id="协议处理">3.2 协议处理</h4><p>NpCap 按照一定的规则提供了 API，和本次实验相关的逻辑如下：</p><h5 id="npcap-处理流程">3.2.1 NpCap 处理流程</h5><p>NpCap 的工作周期可以被描述为如下序列：</p><ul><li><code>pcap_findalldevs</code> &amp; <code>pcap_findalldevs_ex</code>：获得网络接口设备的列表</li><li><code>pcap_open</code> &amp; <code>pcap_dump_open</code> &amp; <code>pcap_open_live</code>：打开设备/打开设备数据包</li><li><code>pcap_freealldevs</code>：释放获得的设备列表结构所占用的内存</li><li><code>pcap_compile</code> &amp; <code>pcap_setfilter</code>：编译并设置过滤器</li><li><code>pcap_loop</code>：根据设定的数量来循环捕获数据包，并调用指定的回调处理数据包</li><li><code>packet_handler</code>：传入 loop 的回调函数，用来处理被捕获的数据包</li><li><code>pcap_close</code>：关闭 NpCap 句柄（即打开的网络设备）</li></ul><p>简单地说，使用 NpCap 获得网络接口列表后，我们打开一个设备，并设定循环次数，传入指定类型的回调函数来处理被捕获的数据包，并在程序退出之前关闭设备。</p><h5 id="回调函数设计">3.2.2 回调函数设计</h5><p>因为上述协议栈分析中提到了，接收端分析包的内容就是一个逆封装的过程，所以我们可以采用逐层递归的方法来设计我们的回调函数；基本设计如下：</p><ul><li><code>(pkt)</code>：用来传入 NpCap 循环的，帧处理函数</li><li><code>(ethernet)</code>：用来处理以太网协议的部分</li><li><code>(ipv4)</code> &amp; <code>(ipv6)</code> &amp; <code>(arp)</code>：处理 IPv4、IPv6、ARP 协议的报头</li><li><code>(icmp)</code> &amp; <code>(tcp)</code> &amp; <code>(udp)</code>：处理 ICMP、TCP、UDP 的报文</li></ul><p>根据设计需求，在判断上一层的协议类型后，将待处理的报文递归给下一层的处理函数即可。</p><h3 id="四实验设计">四、实验设计</h3><p>关于代码实现方面的设计：</p><h4 id="项目组成">4.1 项目组成</h4><p>项目可以分为 <code>handlers</code>、<code>helpers</code> 和 <code>utils</code> 三个部分组成；</p><ul><li><code>utils</code> 包含了可复用的无后效逻辑的实现，尽量避免重复代码片段</li><li><code>handlers</code> 包含了传给 NpCap 的回调函数以及递归下降法实现的逆封装函数</li><li><code>helpers</code> 包含了要实现的额外功能，比如本次实验中的流量统计</li></ul><p>这三个部分分别使用独立的头文件和源文件组成，被 <code>main</code> 模块引用。</p><h4 id="预定义">4.2 预定义</h4><p>项目所需要的类型定义都包含在 <code>definitions.h</code> 中；包含了根据协议的组成而设计的报文和报头的类型定义；因为最后捕获的数据包是指向一片连续内存块的指针，这里的定义必须保证指定的内存块可以完全转化为对应的包类型才行；因此，需要保证顺序和使用的基本数据类型完全和定义符合。</p><h4 id="项目结构">4.3 项目结构</h4><p>最后，整个项目的文件结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CMake target: cn_exp</span><br><span class="line">(root)</span><br><span class="line">├ module</span><br><span class="line">│ └ (NpCap Library files)NpCap SDK 库文件</span><br><span class="line">├ include</span><br><span class="line">│ ├ definitions.h 预定义的类型声明</span><br><span class="line">│ ├ handlers.h递归下降法的包处理回调函数的声明</span><br><span class="line">│ ├ helpers.h流量统计相关方法的声明</span><br><span class="line">│ └ utils.h可复用模块的函数声明</span><br><span class="line">├ src</span><br><span class="line">│ ├ utils.cpp可复用模块的函数实现</span><br><span class="line">│ ├ helpers.cpp流量统计相关方法的实现</span><br><span class="line">│ └ handlers.cpp递归下降法的包处理回调函数的实现</span><br><span class="line">├ CMakeList.txtCMake 项目定义文件</span><br><span class="line">└ main.cpp主进程文件</span><br></pre></td></tr></table></figure><p>使用 CMake 加载项目，并构建运行 <code>cn_exp</code> 即可生成目标。</p><h3 id="五实现代码">五、实现代码</h3><p>Github 链接：<a href="https://github.com/ma-hunter/cn_exp" class="uri">https://github.com/ma-hunter/cn_exp</a></p><h3 id="六实验结果">六、实验结果</h3><p>完成实现上文所述的程序后，运行程序，可以得到下面的结果：</p><h4 id="运行结果">6.1 运行结果</h4><p>因为上传截图非常的麻烦，这里仅粘贴标准输出的文本。</p><h5 id="选择网络设备">6.1.1 选择网络设备</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Hello, World! Hello NpCap!</span><br><span class="line">1.\Device\NPF_&#123;5C8B26D4-9439-4304-B8FB-48A81CB33CF9&#125;WAN Miniport (Network Monitor)</span><br><span class="line">2.\Device\NPF_&#123;C21F9683-BA8A-4AFE-827A-166030BB1466&#125;WAN Miniport (IPv6)</span><br><span class="line">3.\Device\NPF_&#123;1C99E263-4855-4786-97ED-ECAC30A11761&#125;WAN Miniport (IP)</span><br><span class="line">4.\Device\NPF_&#123;1A386F2B-3A3E-49A7-B899-2629C46C4FB3&#125;Hyper-V Virtual Ethernet Adapter #2</span><br><span class="line">5.\Device\NPF_&#123;A30B9DA2-E755-4DF6-8BD4-010B6590B072&#125;Hyper-V Virtual Ethernet Adapter</span><br><span class="line">6.\Device\NPF_&#123;21EAB23F-F3E5-48E0-B370-35B69F40B833&#125;Bluetooth Device (Personal Area Network) #3</span><br><span class="line">7.\Device\NPF_&#123;5CCBE082-6FB3-4754-B27A-3659F98979BE&#125;Realtek RTL8188EU Wireless LAN 802.11n USB 2.0 Network Adapter</span><br><span class="line">8.\Device\NPF_&#123;E919BE86-5601-4998-B187-2C629DE1F9B9&#125;Microsoft Wi-Fi Direct Virtual Adapter #2</span><br><span class="line">9.\Device\NPF_&#123;FF7337C5-5DA3-4AF4-8C55-5A066C578D65&#125;Microsoft Wi-Fi Direct Virtual Adapter</span><br><span class="line">10.\Device\NPF_&#123;43524049-AA60-4F6E-A89E-8AE5BA1EAA93&#125;Realtek PCIe GbE Family Controller</span><br><span class="line">11.\Device\NPF_LoopbackAdapter for loopback traffic capture</span><br><span class="line">Enter the interface number (1-11):</span><br></pre></td></tr></table></figure><h5 id="设置监听循环的次数">6.1.2 设置监听循环的次数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Enter the interface number (1-11):10</span><br><span class="line"> listening on Realtek PCIe GbE Family Controller....</span><br><span class="line">Please input the num of packets you want to catch(0 for keeping catching):</span><br></pre></td></tr></table></figure><h5 id="tcp协议解析示例">6.1.3 TCP协议解析示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Time: 12:54:00, 129446Length: 60</span><br><span class="line">Type: 0x800 (IPv4)</span><br><span class="line">Destination address: c:c:b:6:c:e</span><br><span class="line">Source address: 8:a:0:c:6:c</span><br><span class="line">Version: 5</span><br><span class="line">Header length: 5 (20B)</span><br><span class="line">Type of service: 96</span><br><span class="line">Total length: 40</span><br><span class="line">Identification: 22603</span><br><span class="line">Flags: 0</span><br><span class="line">Fragment offset: 64 (512 B)</span><br><span class="line">Protocol: TCP</span><br><span class="line">Checksum: 32469</span><br><span class="line">Source IP address: 39.96.132.69</span><br><span class="line">Destination IP address: 192.168.3.2</span><br><span class="line">Source port: 443</span><br><span class="line">Destination port: 55308</span><br><span class="line">Sequence: 744910189</span><br><span class="line">Acknowledgement: 846425137</span><br><span class="line">Data offset: 0 (0 B)</span><br><span class="line">Flags: ACK</span><br><span class="line">Window: 28927</span><br><span class="line">Checksum: 54318</span><br><span class="line">Urgent pointer: 0</span><br></pre></td></tr></table></figure><h5 id="udp协议解析示例">6.1.4 UDP协议解析示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Time: 12:54:00, 148551Length: 106</span><br><span class="line">Type: 0x800 (IPv4)</span><br><span class="line">Destination address: 8:a:0:c:6:c</span><br><span class="line">Source address: c:c:b:6:c:e</span><br><span class="line">Version: 5</span><br><span class="line">Header length: 5 (20B)</span><br><span class="line">Type of service: 0</span><br><span class="line">Total length: 92</span><br><span class="line">Identification: 21792</span><br><span class="line">Flags: 0</span><br><span class="line">Fragment offset: 0 (0 B)</span><br><span class="line">Protocol: UDP</span><br><span class="line">Checksum: 0</span><br><span class="line">Source IP address: 192.168.3.2</span><br><span class="line">Destination IP address: 112.32.50.208</span><br><span class="line">Source port: 7726</span><br><span class="line">Destination port: 28078</span><br><span class="line">Length: 72</span><br><span class="line">Checksum: 26356</span><br></pre></td></tr></table></figure><h5 id="流量统计示例">6.1.5 流量统计示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flow counts: </span><br><span class="line">IP                                         Flow</span><br><span class="line">111.206.210.75                              3</span><br><span class="line">112.32.50.208                               2</span><br><span class="line">13.107.136.9                               53</span><br><span class="line">192.168.3.2                                34</span><br><span class="line">39.96.132.69                                8</span><br></pre></td></tr></table></figure><h4 id="构建记录">6.2 构建记录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;D:\Program Files\JetBrains\Toolbox\apps\CLion\ch-0\211.6693.114\bin\cmake\win\bin\cmake.exe&quot; -DCMAKE_BUILD_TYPE&#x3D;Debug -G &quot;CodeBlocks - MinGW Makefiles&quot; D:\Workspaces\CLion\cn_exp</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: D:&#x2F;Workspaces&#x2F;CLion&#x2F;cn_exp&#x2F;cmake-build-debug</span><br><span class="line"></span><br><span class="line">&quot;D:\Program Files\JetBrains\Toolbox\apps\CLion\ch-0\211.6693.114\bin\cmake\win\bin\cmake.exe&quot; --build D:\Workspaces\CLion\cn_exp\cmake-build-debug --target cn_exp -- -j 4</span><br><span class="line">Scanning dependencies of target cn_exp</span><br><span class="line">[ 20%] Building CXX object CMakeFiles&#x2F;cn_exp.dir&#x2F;src&#x2F;handlers.cpp.obj</span><br><span class="line">[ 40%] Linking CXX executable cn_exp.exe</span><br><span class="line">[100%] Built target cn_exp</span><br><span class="line"></span><br><span class="line">构建已完成</span><br></pre></td></tr></table></figure><h3 id="七思考题">七、思考题</h3><p><strong>应用WINPCAP能实现哪些网络应用?</strong></p><ul><li>捕获原始数据包。不管这个包是发往本地机，还是其他机器之间的交换包</li><li>在数据包被发送到应用程序之前，通过用户定义的规则过滤</li><li>向网络发送原始数据包</li><li>对网络通信量做出统计</li></ul><h2 id="参考资料">参考资料</h2><ul><li><a href="https://blog.csdn.net/lee1hong/article/details/106893706">计算机网络 | 实验一 wireshark抓包工具使用_哆啦一泓的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/lee1hong/article/details/106893772">计算机网络 | 实验二 WINPCWP编程_哆啦一泓的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/lee1hong/article/details/106893837">计算机网络 | 实验三 协议分析程序的编写_哆啦一泓的博客-CSDN博客</a></li><li><a href="https://blog.csdn.net/include_IT_dog/article/details/106813645">Winpcap进行抓包，分析数据包结构并统计IP流量_include的博客-CSDN博客</a></li></ul>]]></content>
    
    <summary type="html">
    
      华中科技大学计算机网络三个实验的实验报告合集。
    
    </summary>
    
    
      <category term="课业" scheme="https://shiraha.cn/categories/%E8%AF%BE%E4%B8%9A/"/>
    
    
      <category term="课内作业" scheme="https://shiraha.cn/tags/%E8%AF%BE%E5%86%85%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="实验报告" scheme="https://shiraha.cn/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
      <category term="计算机网络" scheme="https://shiraha.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="Wireshark" scheme="https://shiraha.cn/tags/Wireshark/"/>
    
      <category term="抓包" scheme="https://shiraha.cn/tags/%E6%8A%93%E5%8C%85/"/>
    
      <category term="NpCap" scheme="https://shiraha.cn/tags/NpCap/"/>
    
  </entry>
  
  <entry>
    <title>使用 Nginx 和 Keepalived 部署一个高可用的负载均衡的 web 应用</title>
    <link href="https://shiraha.cn/2021/use-nginx-and-keepalived-to-host-a-web-server/"/>
    <id>https://shiraha.cn/2021/use-nginx-and-keepalived-to-host-a-web-server/</id>
    <published>2021-06-08T16:06:59.000Z</published>
    <updated>2021-06-08T16:06:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>一般的 Web 应用是将写好的程序使用手段放在服务器上，然后在服务器上运行这些程序；这样其他计算机访问这台服务器的时候就可以使用这个应用。但是这样有一个明显的缺点就是一台主机的性能存在上限，当业务规模扩大，且业务要求提高的情况下，这种简单的部署形式就不能满足要求了。</p><p>实验环境：Ubuntu 20.04 电脑两台，处于同一局域网下。</p><p>首先，关于 Nginx 是什么和 Keepalived 是什么就不再赘述；这里仅简单说明实验操作过程：</p><h2 id="nginx-开启负载均衡">Nginx 开启负载均衡</h2><p>具体来说可以按照以下步骤进行；我的第一台主机作为常用机，其上已经运行了 <code>apache2</code> 的服务；那么此时如果要再使用 <code>nginx</code> 的负载均衡，就需要先关闭原有的 <code>apache2</code> 以释放 80 端口。之后设置 <code>nginx</code> 的转发规则就可以实现负载均衡了；</p><h3 id="安装基本的工具">安装基本的工具</h3><p>即使是像 Ubuntu 这样已经成熟的发行版，也需要安装相当多的工具才能进行服务器的搭建：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install net-tools nginx vim</span><br></pre></td></tr></table></figure><p>最主要的是第一项的 <code>net-tools</code>，它包含了重要的工具 <code>ifconfig</code> 可以用来查看 Linux 网络接口的信息；再完成了安装之后，我们可以运行下面的命令，来启动防火墙和 <code>nginx</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw app list<span class="comment"># 列出所有可用的预设配置</span></span><br><span class="line">sudo ufw allow <span class="string">&#x27;Nginx Full&#x27;</span><span class="comment"># 允许 Nginx 的所有 HTTP/HTTPS 链接</span></span><br><span class="line">sudo ufw <span class="built_in">enable</span><span class="comment"># 根据设置的规则启用 UFW 防火墙</span></span><br><span class="line">sudo service nginx start</span><br></pre></td></tr></table></figure><p>但是因为我的主机上同时还运行了 <code>apache2</code> 占用了 80 端口，所以需要先处理它，才能重新运行 Nginx；</p><h3 id="关闭-apache2如果存在">关闭 Apache2（如果存在</h3><p>我在尝试关闭 <code>apache2</code> 的时候遇到了如何关闭都无法解放端口占用的问题；后来通过修改 <code>apache2</code> 的监听端口+重启主机才释放了 80 端口给 <code>nginx</code> 使用。</p><figure><img src="https://i.loli.net/2021/06/09/csNPLQkrnIaFW87.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/csNPLQkrnIaFW87.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="修改 apache2 的监听端口1.png" /><figcaption aria-hidden="true">修改 apache2 的监听端口1.png</figcaption></figure><figure><img src="https://i.loli.net/2021/06/09/5rtkXBwRGEpxZCN.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/5rtkXBwRGEpxZCN.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="修改 apache2 的监听端口2.png" /><figcaption aria-hidden="true">修改 apache2 的监听端口2.png</figcaption></figure><p>根据 Ubuntu apache 默认页面，可以知道 <code>apache2</code> 的配置文件位于 <code>/etc/apache2</code> 目录下；首先需要修改 <code>port.conf</code> 中的端口监听信息，然后再根据文件的提示修改 <code>sites-enabled/</code> 下的站点的监听信息。</p><p>做完这些重启 <code>apache2</code> 服务之后，就可以释放 <code>apache2</code> 对于端口 80 的占用了；此时运行 <code>nginx</code> 就可以正常启动服务了；</p><h3 id="检查-nginx-正常运行">检查 Nginx 正常运行</h3><p>使用 <code>service</code> 命令或者 <code>systemctl</code> 命令检查 <code>nginx</code> 的状态，可以看到如下页面：</p><figure><img src="https://i.loli.net/2021/06/09/RBXpqVuJFt23nmy.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/RBXpqVuJFt23nmy.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Nginx 已经正常运行.png" /><figcaption aria-hidden="true">Nginx 已经正常运行.png</figcaption></figure><p>此时，<code>apache2</code> 和 <code>nginx</code> 同时运行，分别监听 8080 和 80 端口；分别访问这两个端口，可以在响应头中看到它们的响应分别来自不同的服务器：</p><figure><img src="https://i.loli.net/2021/06/09/92ZrXejm6DQCfyN.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/92ZrXejm6DQCfyN.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="apache2 的服务器.png" /><figcaption aria-hidden="true">apache2 的服务器.png</figcaption></figure><center>Apache2 监听的 8080 端口</center><figure><img src="https://i.loli.net/2021/06/09/Ri482WgxvtEAZqa.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/Ri482WgxvtEAZqa.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="nginx 的服务器.png" /><figcaption aria-hidden="true">nginx 的服务器.png</figcaption></figure><center>Nginx 监听的 80 端口</center><p>至于为什么两个页面都是 “Apache2 Ubuntu Default Page”，是因为我先安装了 <code>apache2</code>，所以后安装的 <code>nginx</code> 创建的 <code>index.html</code> 被改名了；所以我们需要观察响应标头来判断相应的来源。</p><h3 id="启动两个服务器">启动两个服务器</h3><p>首先，我们需要写一个简单的页面，然后再把它们假设起来；这里也使用 Nginx 感觉有点麻烦了，所以使用了 <code>Node.js</code> 提供的简易 HTTP 服务器工具 <code>serve</code>；如果没有安装，需要先安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install npm</span><br><span class="line">sudo npm i -g serve</span><br></pre></td></tr></table></figure><p>之后，我们需要写一个简单的网页：</p><figure><img src="https://i.loli.net/2021/06/09/1JiLlRTbHt3xuBZ.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/1JiLlRTbHt3xuBZ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="写一个网页.png" /><figcaption aria-hidden="true">写一个网页.png</figcaption></figure><p>然后复制两份，分别修改端口的标记；</p><figure><img src="https://i.loli.net/2021/06/09/PhrU5E3nxGLDqFV.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/PhrU5E3nxGLDqFV.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="复制两份并且修改端口标记.png" /><figcaption aria-hidden="true">复制两份并且修改端口标记.png</figcaption></figure><p>修改完成后，使用 <code>serve</code> 分别将服务启动在对应的端口，终端最后如下：</p><figure><img src="https://i.loli.net/2021/06/09/I8dsOr2tnDBSaX5.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/I8dsOr2tnDBSaX5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="启动两个简易的 HTTP.png" /><figcaption aria-hidden="true">启动两个简易的 HTTP.png</figcaption></figure><p>在浏览器分别访问两个端口，以确认可以正常访问：</p><figure><img src="https://i.loli.net/2021/06/09/TzmOtCAsForKecU.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/TzmOtCAsForKecU.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="两个端口都可以正常运行.png" /><figcaption aria-hidden="true">两个端口都可以正常运行.png</figcaption></figure><p>这样，我们就将这个简单的网页部署到了“两个不同的服务器”上了，接下来需要通过 Nginx 来实现负载均衡。</p><h3 id="配置-nginx">配置 Nginx</h3><p>实现负载均衡需要先在配置文件中指定一个 <code>upstream</code>，其中包含了负载的服务器集群和它们的权重；Nginx 支持你选择特定的负载均衡的算法，如果不指定就是默认的轮询的方法；我们在 <code>/etc/nginx/conf.d/</code> 下创建 <code>nginx.conf</code>；配置文件如下：</p><figure><img src="https://i.loli.net/2021/06/09/fTMbPCWFIn87l5Z.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/fTMbPCWFIn87l5Z.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="nginx 配置文件.png" /><figcaption aria-hidden="true">nginx 配置文件.png</figcaption></figure><p>完成配置文件的编写之后，使用 <code>sudo nginx -t</code> 来检查配置文件是否有误或产生了冲突；如果没有意外，则重启 <code>nginx</code> 服务，就可以看到 80 端口会根据设置的权重自动转发到两个简易 HTTP 服务器上。</p><h4 id="需要注意的是">需要注意的是……</h4><p>Nginx 有一个默认的服务器配置，位于 <code>/etc/nginx/sites-enabled/</code> 目录下；这个服务器也是默认监听 80 端口的，会和我们已有的服务器产生冲突，所以要先移除；此外，<strong>不</strong>需要将我们创建的配置文件软链接到该目录，因为这样 Nginx 会扫描两次这个文件，从而继续得出端口冲突的结论。</p><figure><img src="https://i.loli.net/2021/06/09/E5ldTtz6PIw1k8o.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/E5ldTtz6PIw1k8o.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="移除多余的默认服务器，否则服务将无法启动.png" /><figcaption aria-hidden="true">移除多余的默认服务器，否则服务将无法启动.png</figcaption></figure><p>可以看到如果不删除这个配置文件，是无法通过 Nginx 的配置文件的测试的。同时，删除的只是链接到 <code>sites-available</code> 目录下的配置文件的软连接，并不会丢失这个配置；可以随时通过创建软连接的方式将这个配置文件拉回来。</p><h3 id="大功告成">大功告成！</h3><p>接下来，本机访问 <code>localhost</code> 或局域网内访问 <code>http://192.168.3.2/</code>（本机 IP），反复刷新，就可以看到端口标识根据配置文件中设置的权重反复横跳；</p><p>因为不好放视频，所以这里就不放了（</p><h2 id="keepalived-实现高可用">Keepalived 实现高可用</h2><p>keepalived 的高可用基于多台 Nginx 服务器共用一个虚拟网关，当其中的一台炸了的时候，会自动从这个虚拟的地址中退出，从而保证了对于这个虚拟地址的访问总是有效的（只要有一台服务器在正常运行）；因此，这要求至少将这样的 nginx 部署到多个服务器上形成 nginx 服务器集群；因此，首先我们要像上一部分所做的那样在另一个服务器上操作一遍；</p><h3 id="安装基本软件以远程操作">安装基本软件以远程操作</h3><p>比起上面的软件，还需要额外安装 SSH 服务器，以在第一台主机上访问第二台主机：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install vim nginx net-tools openssh-server</span><br></pre></td></tr></table></figure><p>安装完成后使用 <code>ifconfig</code> 获得第二台主机在局域网中的 IP，就可以在第一台主机上访问了：</p><figure><img src="https://i.loli.net/2021/06/09/GnUMIrhD1m5XCde.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/GnUMIrhD1m5XCde.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="连接 SSH 到第二台服务器.png" /><figcaption aria-hidden="true">连接 SSH 到第二台服务器.png</figcaption></figure><p>完成了基本软件安装后，启动 <code>nginx</code>，浏览器访问局域网 IP，可以看到 Nginx 欢迎页面，说明 Nginx 安装成功：</p><figure><img src="https://i.loli.net/2021/06/09/K3LaVm9yhYGFZ4q.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/K3LaVm9yhYGFZ4q.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="第二台服务器 Nginx 配置成功.png" /><figcaption aria-hidden="true">第二台服务器 Nginx 配置成功.png</figcaption></figure><p>因为这台主机上没有先装 <code>apache2</code>，所以 NginX 完成安装后就自动启动了；</p><h3 id="配置-nginx-的负载均衡并测试">配置 Nginx 的负载均衡并测试</h3><p>按照上一个部分部署完负载均衡之后，发现在第一台服务器上无法访问我们部署的页面：</p><figure><img src="https://i.loli.net/2021/06/09/HeS3Cita1dIoZPc.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/HeS3Cita1dIoZPc.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="发现第二台服务器无法访问.png" /><figcaption aria-hidden="true">发现第二台服务器无法访问.png</figcaption></figure><p>在第二台主机上尝试直接访问 <code>http://192.168.3.2:1919</code> 和 <code>http://192.168.3.2:9191</code> 会发现无法打开页面，再联想到安装 Nginx 之后自动配置的防火墙，判断 1919 和 9191 端口被 ufw 屏蔽；所以在第一台主机上手动开放这两个端口，第二台服务器上的负载均衡就可以正常使用了。</p><figure><img src="https://i.loli.net/2021/06/09/hO4F1lSHGY9oEC3.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/hO4F1lSHGY9oEC3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="在第一台服务器上修改防火墙配置开放端口，成功.png" /><figcaption aria-hidden="true">在第一台服务器上修改防火墙配置开放端口，成功.png</figcaption></figure><p>使用 <code>ufw</code> 开放端口可以使用 <code>sudo ufw allow &lt;port&gt;</code> 来实现。</p><h3 id="安装-keepalived">安装 Keepalived</h3><p>在两台主机上安装 <code>keepalived</code> 并尝试运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install keepalived</span><br><span class="line">sudo service keepalived start</span><br></pre></td></tr></table></figure><p>会发现它们无法启动，因为缺少了配置文件：</p><figure><img src="https://i.loli.net/2021/06/09/z71fK6LDGYIJwsU.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/z71fK6LDGYIJwsU.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="无法启动keepalived，因为没有配置文件.png" /><figcaption aria-hidden="true">无法启动keepalived，因为没有配置文件.png</figcaption></figure><p>因此我们需要为它们添加配置文件；</p><h3 id="配置-keepalived">配置 Keepalived</h3><p>这一步主要是为第一台主机（主机）和第二台主机（从机）分别增加 Keepalived 配置文件和对于 Nginx 服务器的监控脚本；这使得它们在可以正常工作的状态下连接了同一个虚拟网关，且在检测到 Nginx 服务器出现异常时即使退出，保持虚拟地址的访问总是可用的。</p><h4 id="配置文件">配置文件</h4><p>配置文件主要需要指明本机 IP、检测脚本和虚拟网关三个部分，其他部分都可以照葫芦画瓢（）本机 IP 在进行前面的操作的时候我们已经都知道了，而检测脚本是可以直接 CV 的<del>（bushi</del>；虚拟网关需要在对应的主机上使用 <code>ifconfig</code> 查看你的 IP 是由哪一个名字的接口提供的；就像下面的图片中一样——<code>192.168.3.2</code> 这一局域网 IP 是由 <code>enp2s0</code> 提供的，所以虚拟网关的接口是该接口；</p><figure><img src="https://i.loli.net/2021/06/09/FNwJd73s6SYlHMQ.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/FNwJd73s6SYlHMQ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="编写 keepalived 配置文件，利用 ifconfig 查看网卡.png" /><figcaption aria-hidden="true">编写 keepalived 配置文件，利用 ifconfig 查看网卡.png</figcaption></figure><p>除此之外，还需要找到一个没有被占用的局域网 IP 地址作为对外暴露的虚拟地址，以隐藏背后的 Nginx 服务器集群；在这里，我选择的是没有被使用过的 <code>192.168.3.216</code>；最后的主从机配置文件分别如下：</p><figure><img src="https://i.loli.net/2021/06/09/fWlyPopSiM9YXBe.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/fWlyPopSiM9YXBe.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Master 的 keepalived.png" /><figcaption aria-hidden="true">Master 的 keepalived.png</figcaption></figure><center>主机的配置文件</center><p>注意 <code>virtual_ipaddress</code> 的值实际上是 <code>192.168.3.216</code> 这一没有被任何主机占用的局域网 IP，并且和下面从机配置的虚拟 IP 地址保持一致。这里的截图里是错误示范（</p><figure><img src="https://i.loli.net/2021/06/09/W8ReOfu9FtoKBIN.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/W8ReOfu9FtoKBIN.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="Slave 的 keepalived.png" /><figcaption aria-hidden="true">Slave 的 keepalived.png</figcaption></figure><center>从机的配置文件</center><p>因为从机只有一个 USB 网卡，所以 <code>interface</code> 和一般的 Ubuntu 主机的默认网卡不一样。</p><h4 id="检测脚本">检测脚本</h4><p>用来检测 Nginx 服务器是否增长工作的脚本；我不懂，直接网上 CV 来的：</p><figure><img src="https://i.loli.net/2021/06/09/iKkIv2co9DO3FwS.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/iKkIv2co9DO3FwS.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="检查 Nginx 是否正常运行的脚本.png" /><figcaption aria-hidden="true">检查 Nginx 是否正常运行的脚本.png</figcaption></figure><p>遵循上面的配置文件，我们将这个脚本放在和配置文件同一个目录下，然后使用 <code>chmod</code> 赋予它可执行的权限，并运行一次——如果 Niginx 服务器当前正在正常运行，那么这个脚本会直接退出。</p><h3 id="大功告成-1">大功告成！</h3><p>完成这些操作之后，使用 <code>service</code> 或 <code>systemctl</code> 命令启动 <code>keepalived</code> 服务，就完成了部署：</p><figure><img src="https://i.loli.net/2021/06/09/Q3Vu1aPBnzZCwKt.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/Q3Vu1aPBnzZCwKt.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="增加权限并启动 keeplalived.png" /><figcaption aria-hidden="true">增加权限并启动 keeplalived.png</figcaption></figure><p>此时，我们使用 <code>ip a</code> 可以观察到在我们指定的网络接口下多了额外的虚拟 IP 地址：</p><figure><img src="https://i.loli.net/2021/06/09/SqNJPzsD9Vf5137.png" class="lazyload" data-srcset="https://i.loli.net/2021/06/09/SqNJPzsD9Vf5137.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="观察到虚拟 IP.png" /><figcaption aria-hidden="true">观察到虚拟 IP.png</figcaption></figure><p>现在，将主机和从机中的任意一个的 Nginx 服务中止，访问虚拟网关还是可以打开这个页面（并且包含了负载均衡）；Web 应用的可用性提高了！</p><h2 id="总结">总结</h2><p>首先，我们使用多个服务器部署了我们的 Web 应用；然后使用多台安装了 Nginx 的服务器部署负载均衡——这个集群中的每一台服务器都可以根据设定的权重将来自外部的请求分配到部署了 Web 应用的服务器上；同时，这些 Nginx 服务器通过 Keepalived，通过一个公共的虚拟网关对外部开放；当这些服务器中的任何一个机能出现了故障时，Keepalived 都会通过预先编写的脚本察觉到问题并立即使该服务器断开和虚拟网关的连接直到恢复，保证了来自外部的请求都会通过这个虚拟网关到达正常工作的服务器上，从而实现了高可用。</p><h3 id="参考资料">参考资料</h3><p>历史记录丢失</p>]]></content>
    
    <summary type="html">
    
      云计算的第二次作业是我来负责的；好久没有做过课内的上机作业了啊！不过这与其说是一个记录指南，不如说是一篇充满了图片的水文（
    
    </summary>
    
    
      <category term="课业" scheme="https://shiraha.cn/categories/%E8%AF%BE%E4%B8%9A/"/>
    
    
      <category term="课内作业" scheme="https://shiraha.cn/tags/%E8%AF%BE%E5%86%85%E4%BD%9C%E4%B8%9A/"/>
    
      <category term="实验报告" scheme="https://shiraha.cn/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
      <category term="nginx" scheme="https://shiraha.cn/tags/nginx/"/>
    
      <category term="Linux" scheme="https://shiraha.cn/tags/Linux/"/>
    
      <category term="Web" scheme="https://shiraha.cn/tags/Web/"/>
    
      <category term="Ubuntu" scheme="https://shiraha.cn/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>2020 NWERC 回顾</title>
    <link href="https://shiraha.cn/2021/2020-nwerc/"/>
    <id>https://shiraha.cn/2021/2020-nwerc/</id>
    <published>2021-05-21T15:30:21.000Z</published>
    <updated>2021-05-22T02:35:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目链接：<a href="https://codeforces.com/gym/103049" class="uri">https://codeforces.com/gym/103049</a><br />习题册文档：<a href="https://2020.nwerc.eu/files/nwerc2020problems.pdf" class="uri">https://2020.nwerc.eu/files/nwerc2020problems.pdf</a><br />题解文档：<a href="https://2020.nwerc.eu/files/nwerc2020slides.pdf" class="uri">https://2020.nwerc.eu/files/nwerc2020slides.pdf</a></p></blockquote><p>唉，要是国内区域赛的网页也能像国外的这些这样就好了（）赛后关闭服务器不能说离谱，只能说非常离谱==</p><h2 id="前言">前言</h2><p>银川站你科表现喜人，但是相应地，对于我这种目前还没有什么奖项的队伍而言的压力也是非同一般。更何况沈阳也因为疫情原因延期了<del>我已经承受了太多</del>，队内总体士气低下，所以就以欢乐赛的形式进行这一次周周练，希望可以找找比赛的感觉——</p><p>也许是受了刺激<del>不能再碌碌无为了！</del>，在真机上装了 Ubuntu，这是第一次在较为接近现场赛的环境下作答（</p><p>虽然但是，接下来还有下个赛季的邀请赛，还要好好打才行！要加油了！</p><h2 id="反思">反思</h2><p>首先是这次 VP 的成绩：</p><table><thead><tr class="header"><th style="text-align: center;">Penalty</th><th style="text-align: center;">A</th><th style="text-align: center;">B</th><th style="text-align: center;">C</th><th style="text-align: center;">D</th><th style="text-align: center;">E</th><th style="text-align: center;">F</th><th style="text-align: center;">G</th><th style="text-align: center;">H</th><th style="text-align: center;">I</th><th style="text-align: center;">J</th><th style="text-align: center;">K</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">713</td><td style="text-align: center;"><font color="#999">-1</font></td><td style="text-align: center;"></td><td style="text-align: center;"><font color="#0a0">+</font></td><td style="text-align: center;"><font color="#0a0">+3</font></td><td style="text-align: center;"></td><td style="text-align: center;"><font color="#0a0">+1</font></td><td style="text-align: center;"></td><td style="text-align: center;"><font color="#0a0">+</font></td><td style="text-align: center;"></td><td style="text-align: center;"></td><td style="text-align: center;"><font color="#0a0">+</font></td></tr></tbody></table><p>因为性质上是欢乐赛，所以打的挺懒散的——一直拖到三点半才开，中途甚至还有打了一半队友补了个觉的恶性事件以及打了一半队友泡方便面吃的鬼事情，所以总归是在意料之中；五个题也和最近 VP 这场的几个实力相近的队伍差不太多，所以倒也问题不大（</p><p>唯一感觉有点发寒的就是大量的低级错误……只能说是我太久没有写代码没有读英文了，唉，我自裁（</p><h2 id="题解">题解</h2><h3 id="k---keyboardd">K - <a href="https://codeforces.com/gym/103049/problem/K">Keyboardd</a></h3><blockquote><p>给了俩字符串，其中一个是另一个字符串中部分字符重复后得到的；得到所有重复了的字符（只输出一次）</p></blockquote><p>虽然是模拟，但是实现还是没有那么直接；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">&quot;/home/nanami/CLionProjects/untitled/input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="built_in">string</span> a, b, ans;</span><br><span class="line">    getline(<span class="built_in">cin</span>, a);</span><br><span class="line">    getline(<span class="built_in">cin</span>, b);</span><br><span class="line">    <span class="keyword">auto</span> al = a.length(), bl = b.length();</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; out;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k, l; i &lt; al;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (l = i; l &lt; al; ++ l)</span><br><span class="line">            <span class="keyword">if</span> (a[i] != a[l]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (k = j; k &lt; bl; ++ k)</span><br><span class="line">            <span class="keyword">if</span> (b[k] != a[i]) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (k - j &gt; l - i) out.insert(a[i]);</span><br><span class="line">        j = k, i = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : out) <span class="built_in">putchar</span>(ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟的话就好好地用最正确的做法，不要无谓地浪费时间！当然，熟练度上来了就可以写出更漂亮的实现就是了。</p><h3 id="c---contest-struggles">C - <a href="https://codeforces.com/gym/103049/problem/C">Contest Struggles</a></h3><blockquote><p>给了 <span class="math inline">\(n\)</span> 个数字的平均值和其中大小为 <span class="math inline">\(k\)</span> 的子集的平均值，求剩余部分的平均值。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, k, d, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = read(); k = read(); d = read(); s = read();</span><br><span class="line">    <span class="keyword">if</span>(n == k) <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">double</span> ans = (<span class="keyword">long</span> <span class="keyword">double</span>) (n * d - s * k) / (<span class="keyword">long</span> <span class="keyword">double</span>) (n - k);</span><br><span class="line">        <span class="keyword">if</span>(ans &gt;= <span class="number">0</span> &amp;&amp; ans &lt;= <span class="number">100</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%.7Lf\n&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没什么好说的。</p><h3 id="h---hot-springs">H - <a href="https://codeforces.com/gym/103049/problem/H">Hot Springs</a></h3><blockquote><p>重新排序长度为 <span class="math inline">\(n \leq 2\cdot10^5\)</span> 的数组，使得其差分数组的绝对值递增。</p></blockquote><p>排序之后找到中间一个位置，然后左右横跳就行了；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> t[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;/home/nanami/CLionProjects/untitled/input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        t[i] = read();</span><br><span class="line">    sort(t + <span class="number">1</span>, t + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">int</span> mid = n / <span class="number">2</span> + <span class="number">1</span>, l = mid - <span class="number">1</span>, r = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t[mid];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; t[l --];</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; t[r ++];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意别跳出边界了就行。</p><h3 id="d---dragon-balls">D - <a href="https://codeforces.com/gym/103049/problem/D">Dragon Balls</a></h3><blockquote><p>大小为 <span class="math inline">\(10^6\times10^6\)</span> 的平面上有不超过七个龙珠；每次你可以询问一个位置 <span class="math inline">\((x, y)\)</span>，交互器会回答其中与你给出的位置直线距离最近的龙珠和你给出的点的距离；如果你询问了一个龙珠的位置，那么视为你已经将它收集，它不再出现在平面上；要求在 <span class="math inline">\(1000\)</span> 次询问内收集所有龙珠。</p></blockquote><p>虽然但是，龙珠只能在整点上；而众所周知，一个圆上的整点数量是极其有限的；所以我们随便问一个点，得到半径之后就遍历所有的可行的整点就可以找到了。<del>更何况这个题时间限制足足给了 9s，还有和 7 一点关系都看不出来的 1000 次询问，我觉得这明摆着就是教我暴力（</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line">llong ii[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;/home/nanami/CLionProjects/untitled/input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++ i)</span><br><span class="line">        ii[i] = (llong)i * i;</span><br><span class="line">    <span class="keyword">auto</span> n = read();</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;llong, <span class="keyword">int</span>&gt; mem;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;0 0&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        llong d = read(), lim = d / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (!d) &#123; -- n; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mem[d]; ii[i] &lt;= lim; ++ i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> pos = lower_bound(ii, ii + N, d - ii[i]) - ii;</span><br><span class="line">            <span class="keyword">auto</span> res = ii[pos];</span><br><span class="line">            <span class="keyword">if</span> (res + ii[i] != d) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; pos &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span> (!read()) &#123; -- n; mem[d] = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">            <span class="keyword">if</span> (res == ii[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span> (!read()) &#123; -- n; mem[d] = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是非常不凑巧的是，我最开始的代码会在某些情况下处理完所有的龙珠之后继续询问，导致一开始 T 的飞起，我甚至一度怀疑我的判断是否合理（）只能说蠢到家了 == 实际上理性分析，每一次遍历一个圆，时间复杂度实际上是 <span class="math inline">\(\mathcal{O}(10^6\log10^6)\)</span> 的，最多只有 7 个圆但是却 9s 的时间；就算询问次数爆了，也不会超时而是 WA 才对；这样一来怎么想都不可能超时……所以一定是逻辑写错了（）看来还是因为最近训练的不够多，导致对于这种问题不太敏感了==</p><h4 id="一些思路">一些思路</h4><p>除了这种暴力的办法，我们当然可以想到一些更加“理智”的办法来求解；只是代码会难写许多：</p><ul><li><strong>随机取俩点，然后测试圆的交点</strong>：不难想象交点极可能是龙珠，不是的情况是引入了其他龙珠的干扰</li><li><strong>“伪四分树”</strong>：每次找到一个点，找到半径之后试探上下左右半径，这样半径总是在缩小；只是要注意不要测试的四个点都到平面外面去了，要规范一下它的最大值保证至少有一个边界出现在平面内</li><li><strong>平面上的二分、三分</strong>：这就给我整不会了……</li></ul><p>这些想法在比赛时 T 飞了的情况下都有考虑，但是最后几乎都因为代码不太好写而作罢……属实不是很行；实际上第二种思路也写了代码，只是也没有处理这个问题导致同样 T 飞了（）</p><h3 id="f---flight-collision">F - <a href="https://codeforces.com/gym/103049/problem/F">Flight Collision</a></h3><blockquote><p>有 <span class="math inline">\(n \leq 2\cdot10^5\)</span> 个点在一条直线上做匀速直线运动；第 <span class="math inline">\(i\)</span> 个点的 <span class="math inline">\(x\)</span>-<span class="math inline">\(t\)</span> 方程是 <span class="math inline">\(x_i = d_i + v_i\cdot t\)</span>；如果某个时刻，有两个点在同一个位置，那么这两个点就会湮灭；问最后可以存活的点的数量，并按照顺序输出。题目保证不会有任何时刻三个或更多的点出现在同一位置。</p></blockquote><p>首先要发现，相撞的点必须是初始位置相邻的点——不然中间那个点又没有撞，却变成小透明让它左右的两个点穿过它并相撞，岂不是很滑稽——题目也限定了不可能出现三个点相撞的情况，所以完全不考虑这个问题。</p><p><del>要是考虑三个或更多点同时相撞的话，这题可就给我整不会力</del></p><p>因此，我们就可以将所有相邻的两个点相撞的时间先算出来，然后塞到一个堆里；每次取出最先相撞的两个点，它们湮灭后，将新成为的邻居相撞的时间计算出来；维护的过程中，可能会出现两个点其中有一个死点的情况，此时要记得直接弹栈不做处理；</p><p>然后是最基础的：速度相等的话不可能相撞，直接不入堆；相撞时间是负数，说明它们相背而行，也不管。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> x[N], v[N], l[N], r[N];</span><br><span class="line"><span class="built_in">bitset</span>&lt;N&gt; dead;</span><br><span class="line"></span><br><span class="line"><span class="function">ldouble <span class="title">solve</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v[i] == v[j]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    ldouble dx = x[j] - x[i], dv = v[i] - v[j];</span><br><span class="line">    <span class="keyword">return</span> dx / dv;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;/home/nanami/CLionProjects/untitled/input.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        x[i] = read(), v[i] = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++ i)</span><br><span class="line">        l[i] = i - <span class="number">1</span>, r[i] = i + <span class="number">1</span>;</span><br><span class="line">    l[<span class="number">1</span>] = r[n] = <span class="number">-1</span>, r[<span class="number">1</span>] = <span class="number">2</span>, l[n] = n - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;tuple&lt;ldouble, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i] != v[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = solve(i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; <span class="number">0</span>) heap.emplace(-t, i, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!heap.empty()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> [<span class="keyword">_t</span>, ll, rr] = heap.top();</span><br><span class="line">        heap.pop();</span><br><span class="line">        <span class="keyword">if</span> (dead[ll] || dead[rr]) <span class="keyword">continue</span>;</span><br><span class="line">        dead.<span class="built_in">set</span>(ll), dead.<span class="built_in">set</span>(rr);</span><br><span class="line">        <span class="keyword">auto</span> nl = l[ll], nr = r[rr];</span><br><span class="line">        <span class="keyword">if</span> (nl &lt; <span class="number">0</span> || nr &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> r[nl] = nr, l[nr] = nl;</span><br><span class="line">        <span class="keyword">if</span> (v[nl] != v[nr]) &#123;</span><br><span class="line">            <span class="keyword">auto</span> nt = solve(nl, nr);</span><br><span class="line">            <span class="keyword">if</span> (nt &gt; <span class="number">0</span>) heap.emplace(-nt, nl, nr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> ans = n - dead.count();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!dead[i]) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察代码，大概能发现有一个名字怪异的变量 <code>_t</code>；因为这个题的一发罚时就交在它上——这个变量本没有什么用处，但是却屏蔽了全局空间里的 <code>t</code>，带来了错误…… <strong>写代码要养成好习惯！</strong>以后这种没有用处的变量都要用这种不容易输入的名字，相当于直接屏蔽了（（</p><h3 id="a---atomic-energy">A - <a href="https://codeforces.com/gym/103049/problem/A">Atomic Energy</a></h3><blockquote><p>假设原子内有 <span class="math inline">\(x\)</span> 个中子，那么它分解后释放的能量有如下关系： <span class="math display">\[\begin{cases}a_x &amp;, x \in [1, n] \\\min_{i + j = x}(a_i + a_j) &amp;, x &gt; n\end{cases}\]</span> 现在给定 <span class="math inline">\(n \leq 100\)</span> 以及对应的数组 <span class="math inline">\(a\)</span>，进行 <span class="math inline">\(q\)</span> 次询问：每次询问有 <span class="math inline">\(x \leq 10^9\)</span> 个中子的核释放能量。</p></blockquote><p>首先，如果这个 <span class="math inline">\(x\)</span> 没有那么大，那么可以使用 DP 维护出上界之内所有核释放的能量；但是因为题目里这个 <span class="math inline">\(x\)</span> 极端地大，所以这种做法 pass（</p><p>让我们贪心地考虑：如果存在某个 <span class="math inline">\(m \in [1, n]\)</span> 使得 <span class="math inline">\(\frac{a_m}m\)</span> 最小，那么为了使得最后的分解能量尽可能地小，我们要尽可能的选择分解得到 <span class="math inline">\(m\)</span>；但是这样存在一个问题：用 <span class="math inline">\(m\)</span> 并不能凑出所有的范围内的正整数；因此，我们需要选择其他的核，但这样就需要抉择优解了。</p><p>不难想象，当 <span class="math inline">\(x\)</span> 大到一定程度之后，它一定可以被表示为一些 <span class="math inline">\(m\)</span> 和一些其他的核的组成；相应地，在一定范围内，<span class="math inline">\(x\)</span> 可能存在不使用 <span class="math inline">\(m\)</span> 的分解方式，而这种方式最优。因此，一种比较理智的思路就是找到这样的一个范围，在这个范围（如果可以接受）内使用严谨的 DP；而在这个范围外，则贪心地使用 <span class="math inline">\(m\)</span> 直到剩余的中子数落到范围之内，再使用范围内存储的值拼出答案。</p><p>这里，首先给出结论：<font color="red">在不少于 <span class="math inline">\(m\)</span> 个正整数中，一定存在一个子集使得子集的和被 <span class="math inline">\(m\)</span> 整除；</font>对应到这个问题里来看，就是这个子集的所有核都可以换成 <span class="math inline">\(m\)</span>，从而使得单位能量更低；那么接下来来说明这个结论的正确性：</p><p>首先，我们将这 <span class="math inline">\(m\)</span> 个数字按照某种方式任意排序，然后对于得到的数组求前缀和；接下来，我们使用 <span class="math inline">\(pre_i\)</span> 表示对于这个数组长度为 <span class="math inline">\(i\)</span> 的前缀和，我们就得到了一个长度为 <span class="math inline">\(m\)</span> 的 <span class="math inline">\(pre\)</span> 数组；然后，我们在 <span class="math inline">\(\text{mod}\ m\)</span> 的意义下对于数组 <span class="math inline">\(pre\)</span> 分类：</p><ul><li>如果 <span class="math inline">\(\equiv 0\)</span> 类不为空，那么就说明存在某个前缀满足其和可以被 <span class="math inline">\(m\)</span> 整除，符合约束条件</li><li>否则，这就意味着 <span class="math inline">\(m\)</span> 个元素要被放在余数为 <span class="math inline">\([1, m - 1]\)</span> 共 <span class="math inline">\(m - 1\)</span> 个类中；由抽屉原理可知，一定有一个类中放了两个元素——也就是有两个不同的前缀和具有相同的余数</li><li>此时，我们只需要将这两个前缀做差，得到的就是一段连续区间的和，显然它的余数为 <span class="math inline">\(0\)</span></li></ul><p>至此，我们已经证明了给出的结论；对于这个题目而言，这意味着只要 <span class="math inline">\(x\)</span> 不可能被分解成少于 <span class="math inline">\(m\)</span> 个数字，那么就一定可以被 <span class="math inline">\(m\)</span> 代替；而 <span class="math inline">\(m - 1\)</span> 个数字可以组成的最大的数字是 <span class="math inline">\((m - 1)n\)</span>；</p><p>是不是做到这里，这个边界就找到了呢？我们先考虑一个很显然的情况：我们能否将 <span class="math inline">\(x\)</span> 分解成 <span class="math inline">\(x\)</span> 个 <span class="math inline">\(1\)</span> 呢？显然，除非 <span class="math inline">\(n = 1\)</span>，否则一定会分解出一个非 <span class="math inline">\(1\)</span> 的数字，因为最后一次分裂一定是 <span class="math inline">\(x&#39; &gt; n\)</span> 分解为 <span class="math inline">\(i,j &lt; n\)</span>；也就是说对于 <span class="math inline">\(x\)</span> 的分解序列，如果它满足本题要求，那么一定存在 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 使得 <span class="math inline">\(i + j &gt; n\)</span>；这一部分无关最小能量，是这个分解符合题意的基本条件。</p><p>那么，我们要怎么修正我们的严谨边界呢？因为这个要求也最多影响到两个基础分裂结果，所以只要在我们的边界上加上它就可以了；两个基础数最大是 <span class="math inline">\(2n\)</span>，我们现在的边界是 <span class="math inline">\((m + 1)n\)</span>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>, M = <span class="number">12315</span>;</span><br><span class="line">llong a[N], f[M], inf = <span class="number">1e18</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ii = a[i] * j, jj = a[j] * i;</span><br><span class="line">    <span class="keyword">if</span> (ii == jj) <span class="keyword">return</span> i &lt; j;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ii &lt; jj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = read(), q = read(), _[N];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = read();</span><br><span class="line">    iota(_, _ + n, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">auto</span> m = *min_element(_, _ + n, compare);</span><br><span class="line">    <span class="keyword">auto</span> lim = (m + <span class="number">1</span>) * n;</span><br><span class="line">    fill(f + <span class="number">1</span>, f + <span class="number">1</span> + lim, inf);</span><br><span class="line">    <span class="built_in">memcpy</span>(f + <span class="number">1</span>, a + <span class="number">1</span>, <span class="keyword">sizeof</span>(llong) * n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= lim; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            f[i] = min(f[i], f[i - j] + a[j]);</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = read();</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= lim) <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[x]);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> t = (x - lim + m - <span class="number">1</span>) / m;</span><br><span class="line">            <span class="keyword">int</span> mt = m * t, res = x - mt;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[res] + a[m] * t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实完全没有必要想这么多；因为著名的 <span class="math inline">\(x \cdot y - x - y\)</span> 问题<del>（大概是这个式子吧，不排除我记错了的可能）</del>我们都有常识：使用一些正整数组成更大的正整数，在某个边界之后可以组成任何正整数；虽然不完全一样，但是这并不影响我们想到上面的猜想；至于这个边界，去取一个足够大但是又时间足够求出的范围就完全没问题（）就算再蠢想不到贪心 <span class="math inline">\(m\)</span>，检查所有的元素作为首要替代也可以通过此题…… 只能说确实拉了==</p><h3 id="e---endgame">E - <a href="https://codeforces.com/gym/103049/problem/E">Endgame</a></h3><blockquote><p>有一个 <span class="math inline">\(n\times n\)</span> 的棋盘，有 <span class="math inline">\(n\)</span> 个二维向量；现在 <code>Alice</code> 和 <code>Bob</code> 各有一个棋子，在不同的位置；接下来他们按顺序选择下面操作之一执行：</p><ul><li>从 <span class="math inline">\(n\)</span> 个向量中带放回地选择两个作为位移并顺次执行；吃掉经过位置的敌方棋子</li><li>瞬移到某个没有放置棋子的位置</li><li>什么也不做</li></ul><p><code>Alice</code> 现在想知道他是否可以吃到 <code>Bob</code> 的棋子，或者在吃不到的情况下是否能通过瞬移回避被 <code>Bob</code> 吃掉。</p></blockquote><p>首先考虑 <code>Bob</code> 是否能被 <code>Alice</code> 抓到；如果要暴力搜索那复杂度是 <span class="math inline">\(\mathcal{O}(n^2)\)</span> 的，大概是过不了的；但是对于这种搜索有一种很经典的做法就是两端搜索——这样复杂度就是 <span class="math inline">\(\mathcal{O}(n)\)</span> 的；对于两个点求出合法的 <span class="math inline">\(n\)</span> 个转移中点，然后进行匹配即可。</p><p>那么现在应该如何确定是否可以瞬移到 <code>Bob</code> 抓不到的地方呢？对于每一个位置都进行测试？未免也太蠢了一些；考虑以下从 <span class="math inline">\(n\)</span> 种操作中选出两个，可以有 <span class="math inline">\(n^2\)</span> 种不同的排列；然而除去自交的 <span class="math inline">\(n\)</span> 种，剩下的部分都是对称的，可以到达的位置是相同的；所以总共可以到达的位置是 <span class="math inline">\(\frac{n(n-1)}2 + 2n\)</span> 种；观察式子，不难发现：</p><ul><li><span class="math inline">\(n \leq 3\)</span> 时，<span class="math inline">\(\frac{n(n-1)}2 + 2n \geq n^2\)</span>；此时可能 <code>Alice</code> 无处可逃，但也仅限于少数情况。</li><li><span class="math inline">\(n \to \infty\)</span> 时，<span class="math inline">\(\frac{n(n-1)}2 + 2n \to \frac{n^2}2\)</span>；即使在极端情况下，<code>Alice</code> 也总是有的放矢。</li></ul><p>所以一种理智的方法就是当 <span class="math inline">\(n\)</span> 较小的时候，就暴力地检查每一个位置是否可达；否则，则可以进行有限次数的随机坐标；因为 <span class="math inline">\(n\)</span> 较大的时候，在极端的情况下不可达的位置占比接近 <span class="math inline">\(\frac12\)</span>，如果进行 <span class="math inline">\(k\)</span> 次随机，那么找不到不可达位置的几率将无限接近 <span class="math inline">\(0\)</span>；事实上，在实现上，我们也可以设置随机直到找到一个逃逸位置后中断。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">coord</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    coord <span class="keyword">operator</span>+(coord rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x + rhs.x, y + rhs.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    coord <span class="keyword">operator</span>-(coord rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;x - rhs.x, y - rhs.y&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(coord rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x == rhs.x &amp;&amp; y == rhs.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>!=(coord rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x != rhs.x || y != rhs.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    coord() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    coord(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : x(x), y(y) &#123;&#125;</span><br><span class="line">&#125; d[N], a, b;</span><br><span class="line"></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; ta[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> valid(x, y) ((x) &gt; 0 &amp;&amp; (x) <span class="meta-string">&lt;= n &amp;&amp; (y) &gt; 0 &amp;&amp; (y) &lt;= n)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        ta[i].clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">(coord S, coord T, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S == T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = S + d[i];</span><br><span class="line">        <span class="keyword">if</span> (t == T) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (valid(t.x, t.y)) ta[t.x].insert(t.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> t = T - d[i];</span><br><span class="line">        <span class="keyword">if</span> (valid(t.x, t.y) &amp;&amp; ta[t.x].count(t.y))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">createRandomMachine</span><span class="params">(<span class="keyword">int</span> lb, <span class="keyword">int</span> rb)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lb &gt; rb) swap(lb, rb);</span><br><span class="line">    <span class="function">uniform_real_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">dm</span> <span class="params">(lb, rb)</span></span>;</span><br><span class="line">    random_device rd;</span><br><span class="line">    <span class="function">default_random_engine <span class="title">rm</span><span class="params">(rd())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> [=]() <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> (<span class="keyword">int</span>) dm(rm); &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">coord <span class="title">gen</span><span class="params">(<span class="keyword">const</span> function&lt;<span class="keyword">int</span>()&gt;&amp; rand_int)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = rand_int(), y = rand_int();</span><br><span class="line">    <span class="keyword">while</span> (vis[x].count(y)) x = rand_int(), y = rand_int();</span><br><span class="line">    <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = read();</span><br><span class="line">    a.x = read(), a.y = read();</span><br><span class="line">    b.x = read(), b.y = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        d[i].x = read(), d[i].y = read();</span><br><span class="line">    <span class="keyword">if</span> (test(a, b, n)) <span class="built_in">puts</span>(<span class="string">&quot;Alice wins&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = coord(i, j);</span><br><span class="line">                <span class="keyword">if</span> (t != a &amp;&amp; t != b) &#123;</span><br><span class="line">                    clear(n);</span><br><span class="line">                    <span class="keyword">auto</span> res = test(b, t, n);</span><br><span class="line">                    <span class="keyword">if</span> (!res)  &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;tie %d %d\n&quot;</span>, t.x, t.y);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Bob wins&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vis[b.x].insert(b.y);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> rd = createRandomMachine(<span class="number">1</span>, n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> tt = <span class="number">100</span>; tt; -- tt) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = gen(rd);</span><br><span class="line">            vis[t.x].insert(t.y), clear(n);</span><br><span class="line">            <span class="keyword">auto</span> res = test(b, t, n);</span><br><span class="line">            <span class="keyword">if</span> (!res)  &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;tie %d %d\n&quot;</span>, t.x, t.y);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Bob wins&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要随机的合理，那么随机也是算法！</p><h3 id="i---island-tour">I - <a href="https://codeforces.com/gym/103049/problem/I">Island Tour</a></h3><blockquote><p>有一个环形公路，路边有 <span class="math inline">\(n\)</span> 个风景；现在有三个人准备从某个景区出发，顺时针绕环形公路欣赏所有风景，且彼此不希望被其他人打扰；现在已知风景 <span class="math inline">\(i \to i + 1\)</span> 的路途需要用时 <span class="math inline">\(d_i\)</span> 的时间（当然，<span class="math inline">\(n \to 1\)</span>），第 <span class="math inline">\(j\)</span> 个人想要在第 <span class="math inline">\(i\)</span> 处风景停留时间 <span class="math inline">\(t_{i, j}\)</span>；当一个人看完了所有的风景，他将瞬移回酒店；</p><p>现在要调度三人的出发景点以尽量满足他们的愿望；求是否存在一种安排，满足他们不会互相打扰；</p></blockquote><p>考虑以下暴力怎么做：我们枚举安排 <span class="math inline">\((i, j, k)\)</span>，然后在线性时间内模拟出三人的行程安排，再用线性时间去检查是否发生了冲突；显然，这样做的复杂度是 <span class="math inline">\(\mathcal{O}(n^4)\)</span> 的，不合题意；因此，我们可以考虑使用一些方法来加快这个模拟的进程，或者说省去没有必要的暴力。</p><p>注意到如果三个人发生了冲突，那么一定可以规约成其中两个人的冲突；而暴力枚举两个人行程的冲突的情况只需要 <span class="math inline">\(\mathcal{O}(n^3)\)</span> 的时间复杂度；因此，我们可以对于每两个人暴力枚举一次，并记录冲突情况；然后再遍历三人的安排情况，就可以 <span class="math inline">\(\mathcal{O}(1)\)</span> 地求出三人的冲突的情况，从而解出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">405</span>;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="built_in">bitset</span>&lt;N&gt;, N&gt; ab, ac, bc;</span><br><span class="line"><span class="keyword">int</span> d[N], a[N], b[N], c[N];</span><br><span class="line">llong iil[N], iir[N], jjl[N], jjr[N];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> step(x) ((x) % n + 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> assign(x) (x##x##l[x] = x##l, x##x##r[x] = x##r)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> calcL(x) (x##l = x##r + d[x])</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> calcR(x) (x##r = x##l + x##t[x])</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">simulator</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *it, <span class="keyword">const</span> <span class="keyword">int</span> *jt,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> i0, <span class="keyword">int</span> j0, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i0 == j0) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> i = i0, j = j0;</span><br><span class="line">    llong il = <span class="number">0</span>, jl = <span class="number">0</span>, ir, jr;</span><br><span class="line">    calcR(i), calcR(j);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; n; ++ t) &#123;</span><br><span class="line">        assign(i), assign(j), calcL(i), calcL(j);</span><br><span class="line">        i = step(i), j = step(j), calcR(i), calcR(j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; ++ x)</span><br><span class="line">        <span class="keyword">if</span> (iil[x] &lt; jjr[x] &amp;&amp; jjl[x] &lt; iir[x])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) d[i] = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) a[i] = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) b[i] = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) c[i] = read();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j) &#123;</span><br><span class="line">            ab[i][j] = simulator(a, b, i, j, n);</span><br><span class="line">            ac[i][j] = simulator(a, c, i, j, n);</span><br><span class="line">            bc[i][j] = simulator(b, c, i, j, n);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++ k)</span><br><span class="line">                <span class="keyword">if</span> (!(ab[i][j] || ac[i][k] || bc[j][k]))</span><br><span class="line">                    <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d\n&quot;</span>, i, j, k), <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>突然感觉这一场是不是实际上挺水的……这也是聪明的暴力啊（</p><h3 id="g---great-expectations">G - <a href="https://codeforces.com/gym/103049/problem/G">Great Expectations</a></h3><blockquote><p>你要速通一个游戏，它目前的记录是 <span class="math inline">\(r\)</span>；你现在设想了一种通关方式，如果一切顺利只需要 <span class="math inline">\(n &lt; r\)</span> 的时间；这种通关方式路径上有 <span class="math inline">\(m\)</span> 个高难点，对于第 <span class="math inline">\(i\)</span> 个点：它预期出现在 <span class="math inline">\(t_i\)</span> 时间，你有 <span class="math inline">\(p_i\)</span> 的把握可以成功通过，如果失败你将浪费 <span class="math inline">\(d_i\)</span> 的时间。</p><p>因为是你一个人在刷记录，所以如果你一轮失误过多，你会考虑重置游戏，从最初开始进行进程；但没有人想重复劳动，如果失误在可控制的范围内，你也会考虑就这样继续游戏；现在要求出你能刷新记录的最少的期望时间——这个时间是你从开始尝试直到打破纪录所花费的时间。</p></blockquote><p>在开始之前，我们先做如下定义；游戏开始时存在一个事件 <span class="math inline">\((t_0, p_0, d_0)\)</span>，其中 <span class="math inline">\(t_0 = 0\)</span>，<span class="math inline">\(p_0 = 1.0\)</span>；当然，惩罚时间没有意义；游戏结束时存在一个事件 <span class="math inline">\((t_E, p_E, d_E)\)</span>，其中同样有 <span class="math inline">\(t_E = n\)</span>，<span class="math inline">\(p_E = 1.0\)</span>；此外，我们计算两个事件之间所需要消耗的时间 <span class="math inline">\(\text{d}t_i = t_{i + 1} - t_i\)</span>；特殊地，有 <span class="math inline">\(\text{d}t_n = t_E - t_n\)</span>。</p><p>此外，考虑我们对于重开和继续游戏的抉择——我们有一个最大可容忍的犯错时间 <span class="math inline">\(r - n - 1\)</span>；我们暂且将它记为犯错边界 <span class="math inline">\(M\)</span>；如果我们犯错的时间尚未超过它，那么可以考虑重开和继续游戏的最佳预期时间；否则，我们只能重开，因为继续游戏已然毫无意义。</p><p>因此，我们可以考虑一个 DP：令 <span class="math inline">\(f_{i, j}\)</span> 表示即将面对第 <span class="math inline">\(i\)</span> 个事件，在这之前已经浪费了 <span class="math inline">\(j\)</span> 的时间的情况下，速通还需要的期望时间；显然，我们要求的答案就是从最开始进行游戏的时间，也就是 <span class="math inline">\(f_{0, 0}\)</span>；根据这个定义，我们也不难想到下面的转换： <span class="math display">\[f_{i, j} \to\begin{cases}f_{i + 1, j} + \text{d}t_i  &amp;, \text{success} \\f_{0, 0} &amp;, \text{failed} \ \and \  j + d_i &gt; M \\\min(f_{0, 0}, \text{d}t_i + d_i+ f_{i + 1, j + d_i}) &amp;, \text{failed} \ \and \  j + d_i \leq M\end{cases}\]</span> 实现上，不难想到这样的 DP 应该从后向前更新答案，最后求出 <span class="math inline">\(f_{0, 0}\)</span>；但是注意到转移的过程中是需要 <span class="math inline">\(f_{0, 0}\)</span> 作为参数的，而这个值是我们最后才能求出的，形成了一个循环；对于这种类似方程的情况，我们可以考虑使用二分的方法，猜测一个 <span class="math inline">\(F_{0, 0}\)</span> 作为参数先代入转移，并与最后求出的 <span class="math inline">\(f&#39;_{0, 0}\)</span> 对比，直到两者足够接近。</p><p>因此，将上述的转移套上概率 <span class="math inline">\(p_i\)</span> 之后就可以写出一个对于 <span class="math inline">\(F_{0, 0}\)</span> 的 check 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> trick = tuple&lt;<span class="keyword">int</span>, <span class="keyword">double</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5050</span>, M = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">double</span> f[M][N], tt[N];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sgn</span><span class="params">(T x)</span> </span>&#123;<span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="number">-1</span> : x &gt; <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fabs</span>(a - b) &lt; eps ? <span class="number">0</span> : sgn(a - b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>), <span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n, r, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; r &gt;&gt; m;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;trick&gt; <span class="title">ts</span><span class="params">(n + <span class="number">2</span>)</span></span>;</span><br><span class="line">    ts[<span class="number">0</span>] = make_tuple(<span class="number">0</span>, <span class="number">1.0</span>, <span class="number">0</span>);</span><br><span class="line">    ts[m + <span class="number">1</span>] = make_tuple(n, <span class="number">1.0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;[t, p, d] = ts[i];</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; t &gt;&gt; p &gt;&gt; d;</span><br><span class="line">        tt[i] = t - get&lt;<span class="number">0</span>&gt;(ts[i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    tt[m + <span class="number">1</span>] = n - get&lt;<span class="number">0</span>&gt;(ts[m]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> margin = r - n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> binary = [&amp;](<span class="keyword">double</span> f00) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= margin; ++ j) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [t, p, d] = ts[i];</span><br><span class="line">                f[i][j] = p * (tt[i + <span class="number">1</span>] + f[i + <span class="number">1</span>][j]);</span><br><span class="line">                <span class="keyword">if</span> (j + d &gt; margin) f[i][j] += (<span class="number">1</span> - p) * f00;</span><br><span class="line">                <span class="keyword">else</span> f[i][j] += (<span class="number">1</span> - p) * min(f00, tt[i + <span class="number">1</span>] + d + f[i + <span class="number">1</span>][j + d]);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> compareTo(f00, f[<span class="number">0</span>][<span class="number">0</span>]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">double</span> ll = <span class="number">0</span>, rr = <span class="number">3e18</span>;</span><br><span class="line">    <span class="keyword">while</span> (compareTo(ll, rr) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">auto</span> mm = (ll + rr) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (binary(mm)) ll = mm;</span><br><span class="line">        <span class="keyword">else</span> rr = mm - eps;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; fixed &lt;&lt; setprecision(<span class="number">7</span>) &lt;&lt; ll &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法——<strong>二分解方程</strong>——确实算是一个比较有意思的技巧；学到了许多（）此外对于概率论 DP 的题目而言，还是要注意不要陷入了误区——比如考虑重来是不是未来成功的可能性更高更加省时间这种；因为这样带来的优势无法量化，所以也就无从考察；而概率或者说是成本则是一个理智的量化标准——不用想别的，只要考它就好（</p><p>当然，上面说的这些也非常的主观……只能说之后有了更好的理解再来补充说明吧（</p><h3 id="j---joint-excavation">J - <a href="https://codeforces.com/gym/103049/problem/J">Joint Excavation</a></h3><blockquote><p>有一张图，首先你需要从中选出一些点组成一个 <code>non-self-intersecting path</code>，然后将剩下来的点平均分成 A 和 B 两组。要求整张图不存在任何一条边，使得这条边的两个端点一个属于 A 而另一个属于 B。</p></blockquote><p>没有太看懂题，，只能说英语或者说理解能力属实不是很行（）最后对着答案才算搞懂题目是什么意思==</p><p>在图中怎么样动态地维护一条边？当然是 DFS 了啊！在图中怎么样保证两种节点不直接连接？当然把连接到链上的一棵子树全部划给一个组啊！于是，就有了标准题解的构造方法：</p><ul><li>首先，将所有的节点都划给组 A；设 #A 表示 A 组的容量，#B 同上；此时 #A = n，#B = 0</li><li>从任何一个点开始 DFS；当有 #A &lt; #B 成立时，重复下面的步骤：<ul><li>若访问了一个新节点，则将它加入到 path 中——既不属于 A，也不属于 B，但是必须成链</li><li>若退出了一个节点，则将它从 path 末端移出，加入组 B</li></ul></li><li>当 #A = #B 时，退出 DFS；已经求得了满足题目要求的 A 和 B 和简单路 path</li></ul><p>这相当于我们使得 path 总是经过我们选择的根节点，然后将不同的子树根据 A 和 B 实时的大小关系分配给它们；因为总是从下而上分配，所以粒度是小的；又因为 DFS 是单点步进的，所以得到的 path 是一条简单路。而从过程的最开始，A 和 B 就不可能公用一条边。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> belong[N], A, B;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="built_in">bitset</span>&lt;N&gt; vis;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fws</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> edge = <span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; head;</span><br><span class="line">    <span class="built_in">vector</span>&lt;edge&gt; e;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renew</span><span class="params">(<span class="keyword">size_t</span> siz)</span> </span>&#123;</span><br><span class="line">        head.resize(siz), e.clear();</span><br><span class="line">        fill(head.begin(), head.end(), <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="function">edge <span class="title">tmp</span><span class="params">(v, head[u])</span></span>;</span><br><span class="line">        head[u] = (<span class="keyword">int</span>) e.size();</span><br><span class="line">        e.emplace_back(move(tmp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; g;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[u] &amp;&amp; A != B) &#123;</span><br><span class="line">        belong[u] = <span class="number">0</span>;</span><br><span class="line">        path.push_back(u);</span><br><span class="line">        -- A;</span><br><span class="line">    &#125;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = g.head[u]; i &gt;= <span class="number">0</span>;</span><br><span class="line">        i = g.e[i].second) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = g.e[i].first;</span><br><span class="line">        <span class="keyword">if</span> (vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        dfs(v);</span><br><span class="line">        <span class="keyword">if</span> (A != B) &#123;</span><br><span class="line">            path.pop_back();</span><br><span class="line">            belong[v] = <span class="number">-1</span>;</span><br><span class="line">            ++ B;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = read(), m = read();</span><br><span class="line">    g.renew(n + <span class="number">1</span>), g.e.reserve(m * <span class="number">2</span> + <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m; i --;) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = read(), v = read();</span><br><span class="line">        g.add_edge(u, v);</span><br><span class="line">        g.add_edge(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">    fill(belong, belong + <span class="number">1</span> + n, <span class="number">1</span>);</span><br><span class="line">    A = n, B = <span class="number">0</span>, dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; aa, bb;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (belong[i] &lt; <span class="number">0</span>) bb.push_back(i);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (belong[i]) aa.push_back(i);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; path.size() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; A &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : path) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : aa) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : bb) <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要是需要更加不巧妙的方法，也可以维护子树大小和，然后保证递归处理分裂的只有一颗子树（因为 path 必须是简单链）——这可以通过最后处理重儿子来保证。</p><h3 id="b---bulldozer">B - <a href="https://codeforces.com/gym/103049/problem/B">Bulldozer</a></h3><blockquote><p>有一些方块堆的高高；现在你每次操作可以推/拉一个方块，使得它的上面，右边发生一个位移；位移之后收到重力影响方块可能会下落。水平空间无限，问你使得所有的方块落到平面上需要最小的操作次数。</p><p>注意：这里的推拉操作相对之前的类似的题目要随意许多；你可以拉动任意连续的方块，也可以从夹缝中推动方块（而不需要这一面空出来）</p></blockquote><p>瞄了一眼题解，这个题竟然还是个最短路……麻了麻了，想摸了，有时间在补吧（）</p><h2 id="后记">后记</h2><p>补了这么多题目之后，感觉这套题其实真的不错——指的是比较适合我们这种基础不扎实的队伍；因为绝大多数的题目都是意在考察思维能力，而不是考察某种数据结构或者是知识点；如果区域赛是这种形式的，我们发挥正常的可能性也相对而言是更高的。当然，这一场还是很拉就是了（</p><figure><img src="https://i.loli.net/2021/05/22/jRNOvLPlYwTX7pf.gif" class="lazyload" data-srcset="https://i.loli.net/2021/05/22/jRNOvLPlYwTX7pf.gif" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="L_O2R3_1QZCDBV0DO909UMX.gif" /><figcaption aria-hidden="true">L_O2R3_1QZCDBV0DO909UMX.gif</figcaption></figure><p>此外，队伍的配合也存在相当的问题——我能明显的感受到我和队友之间羁绊的不足；因为英文阅读能力低下的原因，我基本也只能被动地听队友给讲题意，但是这样就会因为不默契导致交流效率的低下（）此外，我个人的精神力也十分弱小——或许我真的应该正视——我能不能够集中注意力地坐五个小时还保持思维的敏捷性——这个问题了……</p><p>更多的话也不想说了；也许是因为各种各样的事情，这个月可以说过的很摸了——上一篇博文还是三周之前……回头月度总结的时候再哈好说说吧（）</p>]]></content>
    
    <summary type="html">
    
      为了从颓废不振的状态恢复过来而进行的一次训练；虽然说是欢乐赛，但是真打的拉了倒也属实快乐不起来…… 还是应该严格要求自己，认真对待每一次训练（（
    
    </summary>
    
    
      <category term="题解" scheme="https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="算法" scheme="https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM" scheme="https://shiraha.cn/tags/ACM/"/>
    
      <category term="Codeforces" scheme="https://shiraha.cn/tags/Codeforces/"/>
    
      <category term="Gym" scheme="https://shiraha.cn/tags/Gym/"/>
    
  </entry>
  
  <entry>
    <title>关于 Ubuntu 20.04 的自用配置</title>
    <link href="https://shiraha.cn/2021/some-self-use-configure-for-ubuntu-20-04/"/>
    <id>https://shiraha.cn/2021/some-self-use-configure-for-ubuntu-20-04/</id>
    <published>2021-05-18T17:26:14.000Z</published>
    <updated>2021-05-24T17:42:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>5 月就快要结束了，因为各种各样的原因，这个月可以说是几乎没有怎么训练的（）所以就演变成了交一篇这样子的水文的模样。</p><p><del>实际上这篇水文也写了一个星期，只能说不愧是我</del></p><h2 id="安装">安装</h2><h3 id="背景说明">背景说明</h3><p>为了能够更好地模拟 XCPC 大多数区域赛现场的比赛环境<del>恰好又受到了金川的刺激</del>，有因为手头边恰好有一个笔记本上拆下来的 SSD，所以就决定这么给台式机上整一个 Ubuntu 的双系统了。</p><h3 id="准备">准备</h3><p>现在的 Ubuntu 官方镜像已经十分智能了，基本上官方的安装向导已经可以满足绝大多数情况下的要求了；所以这里也就不没事找事了；需要准备两个硬盘——一个一般的 U 盘用来制作启动盘，另一个速度快一点（至少得是移动硬盘）的硬盘作为安装目标盘。</p><p>制作启动盘就是先从<a href="https://cn.ubuntu.com/download">官网</a>下载镜像，然后用免费的 Ultra ISO 写入硬盘镜像即可；制作完启动盘之后先关机进入 BIOS，暂时关闭安全启动——因为这会阻止我们从安装介质启动电脑；然后再重启，进入临时启动菜单，从制作的启动盘启动即可；</p><p>第一次进入系统，Ubuntu 需要先检查各种文件，所以会需要较长的时间；之后就会进入到熟悉的安装界面——然后对着向导点点点就行了；分区什么的也非常智能，安装向导已经预制了双系统和全新安装两种默认配置，只需要拖动 GUI 组建就可以完成分区——当然，swap 什么的它都帮你做好了。如果有网络的话，可以直接在安装的时候选择安装必要的驱动，这样也省的进了系统之后还要手动（（</p><p>安装完成之后，先进 BIOS 重新打开安全启动，再将默认启动顺序改回先 Windows 再 Ubuntu；这样每次进 Ubuntu 只需要先插上 SSD，然后进临时启动菜单选择 Ubuntu 的引导就可以了。</p><h2 id="配置-偏好">配置 &amp; 偏好</h2><p>以下部分的内容都是个人偏好的配置，仅供参考（）大概会持续更新把（</p><h3 id="系统设置相关">系统设置相关</h3><p>GNOME 桌面的设置已经提供了相当多的配置选项；直接修改既方便，也直接影响了使用体验；下面的内容就设置的每一个大栏目下要做的事情简要的说明一下：</p><h4 id="键盘快捷键">键盘快捷键</h4><p><strong>声音和媒体</strong>：如果你使用的是 Windows 键盘，那么可以将键盘上的媒体键在这里手动绑定——比如播放/暂停，上一首下一首和调节音量这种。</p><p><strong>截图</strong>：和 Windows 的习惯不一样，但是个人觉得功能比 Windows 全多了；可以把对应的公共按钮调成和 Windows 一致的按钮（比如复制（选区）截图到剪切板换成 <code>shift</code> + <code>super</code> + <code>S</code>）</p><figure><img src="https://i.loli.net/2021/05/25/eg8WkErHbVs6nR1.png" class="lazyload" data-srcset="https://i.loli.net/2021/05/25/eg8WkErHbVs6nR1.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>这是个人关于屏幕截图快捷键的偏好，如果更新了大概会换掉这张图吧（</p><p>还有要提一嘴的就是，Ubuntu 的截图，虽然看起来很高级（比如这些截取窗口，都是直接绘图甚至还保留了窗口阴影的透明度），但是并不能实现“抓拍”——并不是按下 <code>Print</code> 键就会截图==</p><h4 id="显示器">显示器</h4><p>主要是为了设置缩放；就算是 2018 年的电脑，一般都大概是笔记本 1080p 或者是台式机 1400p；不管是哪种 Windows 设置的都是 125% 缩放；但是 Ubuntu 的分数缩放做得很怪，所以如果怕麻烦的话 100% 也挺好（）否则，要先开启下面的 Fractional Scaling 才能选择 125%</p><figure><img src="https://i.loli.net/2021/05/24/JyQ1YAwoD7nFvzO.png" class="lazyload" data-srcset="https://i.loli.net/2021/05/24/JyQ1YAwoD7nFvzO.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2021-05-24 21-32-09 的屏幕截图.png" /><figcaption aria-hidden="true">2021-05-24 21-32-09 的屏幕截图.png</figcaption></figure><p>看到这个选项没被汉化，下面还有 <code>May increase power usage, lower speed, or reduce display sharpness</code> 就觉得不太对劲；这种不好的预感主要体现在各种第三方软件上（）因为实际上 Ubuntu 似乎只会整数倍数缩放，分数的缩放是先将你的逻辑分辨率放大到 2 倍下的对应尺寸，然后再压缩到你物理屏幕上的——比如我的电脑两个屏幕都是 2560*1440 的，开启 1.25 缩放就是先将逻辑分辨率设为 4096*2304（也就是 1.6 倍，两倍缩放下的 0.8），再压缩到物理分辨率来的；所以不管是显卡驱动还是其他应用程序（甚至系统自带的截图）“看到”的分辨率都是 4096*2304；此时，如果应用程序不支持缩放，那么 100% 的缩放在屏幕上看起来就只有原来大小的 80%，十分痛苦==</p><h4 id="外观">外观</h4><p>强烈建议选择 Dark；如果默认，那么 VS Code 就会黑色窗口下有白色工具栏；白色的话不是很适合写代码</p><figure><img src="https://i.loli.net/2021/05/25/98KDWTsdx6QL3fu.png" class="lazyload" data-srcset="https://i.loli.net/2021/05/25/98KDWTsdx6QL3fu.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>总而言之要选择纯色（）另一个想要吐槽的就是 Dock 栏不能像 Windows 一样一个在左边一个在右边==</p><p>自动隐藏 Dock 栏总归还是不太方便，更何况 GNOME 的 Dock 没有那么舒服的可以被调出来，所以最好还是一直显示；和 Windows 看齐，将 Dock 栏的图标大小调到 <code>32*32</code> 就不会显得那么占地方了。</p><h3 id="终端">终端</h3><p>关于 zsh，你可以参考我的<a href="http://shiraha.cn/2020/use-zsh-in-windows-10-with-wtd-and-vscode/">这篇文章</a>和我的朋友的<a href="https://tmc0210.github.io/Mac%E7%9A%84%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96/">那篇文章</a>；</p><h4 id="安装-oh-my-zsh">安装 oh-my-zsh</h4><p>Ubuntu 官方镜像的 <code>apt</code> 使用的已经是国内访问起来较为舒服的源了，所以不需要换源，使用 <code>sudo apt install zsh</code> 安装 <code>zsh</code>；</p><p>完成之后，运行对应的脚本以安装 <code>oh-my-zsh</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)</span>&quot;</span></span><br><span class="line"><span class="comment"># ↑ 通过 curl 或者 通过 wget ↓</span></span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>之后输入密码修改默认终端为 <code>zsh</code> 即可；Ubuntu 20.04 似乎要求重启之后，默认的终端才会自动进入 <code>zsh</code>.</p><p>为了方便以后使用，这里再把安装 <a href="https://github.com/romkatv/powerlevel10k">powerlevel10k</a> 的操作复述一次：</p><ul><li>克隆代码仓库：<code>git clone https://github.com/romkatv/powerlevel10k.git $ZSH_CUSTOM/themes/powerlevel10k</code></li><li>修改 <code>~/.zshrc</code>：<code>ZSH_THEME="powerlevel10k/powerlevel10k"</code></li><li>回到 <code>zsh</code>，自动或手动使用 <code>p10k configure</code> 更换终端主题风格，详情参考其文档</li></ul><p>然后，我们需要为 <code>zsh</code> 安装最低限度所需要的插件：<a href="https://github.com/zsh-users/zsh-syntax-highlighting">zsh-syntax-highlighting</a> 和 <a href="https://github.com/zsh-users/zsh-autosuggestions">zsh-autosuggestions</a></p><ul><li><p>运行下面的命令以安装 zsh-syntax-highlighting：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.oh-my-zsh</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source <span class="variable">$&#123;(q-)PWD&#125;</span>/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot;</span> &gt;&gt; <span class="variable">$&#123;ZDOTDIR:-<span class="variable">$HOME</span>&#125;</span>/.zshrc</span><br><span class="line"><span class="built_in">source</span> ./zsh-syntax-highlighting/zsh-syntax-highlighting.zsh</span><br></pre></td></tr></table></figure></li><li><p>克隆 zsh-autosuggestions 的源代码：<code>git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</code></p></li><li><p>修改 <code>~/.zshrc</code>：<code>plugins=(git zsh-autosuggestions)</code></p></li><li><p>重启 <code>zsh</code> 或者打开一个新的会话，就会发现插件已经成功应用了</p></li></ul><p>安装 zsh-syntax-highlighting 之前要先进入一个合理的目录，用来存放其源代码。</p><h4 id="终端字体">终端字体</h4><p>此外，Ubuntu 默认的字体并不支持 Powerline 的众多图标；解决方法就是更换字体——既可以使用上一篇文章中介绍的 <a href="https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/Hack.zip">Hack Nerd Font</a>，也可以用 <a href="https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/UbuntuMono.zip">Ubuntu Nerd Font</a> <del>不过字体图标比例感人</del>；下载后安装，然后在终端中新建配置文件，选择字体即可。</p><figure><img src="https://i.loli.net/2021/05/25/36OLwPs9DReyAMY.png" class="lazyload" data-srcset="https://i.loli.net/2021/05/25/36OLwPs9DReyAMY.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>如果觉得一个个安装这些字体文件很麻烦，可以先在终端中将这些字体文件复制到 <code>/usr/share/fonts/</code> 下的某个子目录中，然后再运行下面的命令刷新字体缓存即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkfontscale</span><br><span class="line">sudo mkfontdir</span><br><span class="line">sudo <span class="built_in">fc</span>-cache -fv</span><br></pre></td></tr></table></figure><p>这样，应该就可以在其他的程序中看到这些字体了；最终终端看起来就像下面这样：</p><figure><img src="https://i.loli.net/2021/05/25/Rl4yC2qiW5Bcm8L.png" class="lazyload" data-srcset="https://i.loli.net/2021/05/25/Rl4yC2qiW5Bcm8L.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h4 id="别名">别名</h4><p>现在，我们默认使用 <code>zsh</code> 作为默认终端，而作为 Linux 终端，<code>zsh</code> 也支持使用 <code>alias</code> 指令为一些命令增加别名；如果我们将这些 <code>alias</code> 指令放在 <code>zsh</code> 的 rc 文件中，这些别名就会在 <code>zsh</code> 启动的时候装载，我们就可以直接使用了；</p><p><code>zsh</code> 有两个 rc 文件；一个全局级别的 <code>/etc/zsh/zshrc</code>，修改它需要 su 权限；另一个用户级别的 <code>~/.zshrc</code>，可以方便的修改；为了方便，我们都修改用户级别的 rc 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> cls=<span class="string">&quot;clear&quot;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="string">&quot;cd..&quot;</span>=<span class="string">&quot;cd ..&quot;</span></span><br><span class="line"><span class="built_in">alias</span> py=<span class="string">&quot;python3&quot;</span></span><br><span class="line"><span class="comment"># alias reload=&quot;source ~/.zshrc &amp; source /etc/zsh/zshrc&quot; # WSL 上正常，但是 Ubuntu 上似乎不能正常工作</span></span><br><span class="line"><span class="built_in">alias</span> omzsh=<span class="string">&quot;vim ~/.zshrc&quot;</span></span><br><span class="line"><span class="built_in">alias</span> zshrc=<span class="string">&quot;sudo vim /etc/zsh/zshrc&quot;</span></span><br><span class="line"><span class="built_in">alias</span> explorer=<span class="string">&quot;nautilus&quot;</span></span><br></pre></td></tr></table></figure><p>值得提一嘴的是 GNOME 默认的文件管理器是 <code>Nautilus file manager</code>，但是 Windows 上默认的是 Windows 资源管理器（<code>explorer</code>）；为了不去记这个奇怪的名字，我们可以制定一个别名== 别的就持续更新之后再说吧！</p><h3 id="开发环境">开发环境</h3><p>当然，既然是为了用来打 XCPC 而准备的 Ubuntu 环境，那么开发环境当然是必定不会少了：</p><h4 id="基本">基本</h4><p>首先是一些基本的程序，Ubuntu 未必全部预装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install wget curl vim git</span><br></pre></td></tr></table></figure><p>然后就是一些编译工具，主要就是 CMake、OpenJDK、Python 等等</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install build-essential cmake</span><br><span class="line">sudo apt install openjdk-14-jdk openjdk-14-jre </span><br><span class="line">sudo apt install python3-pip nodejs</span><br></pre></td></tr></table></figure><p>Ubuntu 内置了 <code>python3</code>，但是不能通过 <code>python</code> 命令唤起；我们可以为它创建一个软连接：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s &#x2F;usr&#x2F;bin&#x2F;python3 &#x2F;usr&#x2F;bin&#x2F;python </span><br><span class="line">sudo ln -s &#x2F;usr&#x2F;bin&#x2F;pip3 &#x2F;usr&#x2F;bin&#x2F;pip </span><br></pre></td></tr></table></figure><p>这样执行 <code>python</code> 和 <code>pip</code> 就会默认运行 <code>python3</code> 相关的程序了。</p><h4 id="关于-node.js">关于 Node.js</h4><p>除了从官网下载之外，还有一种相对比较简单的方式，可以方便地通过 <code>apt</code> 下载并安装 Node.js：</p><ul><li>首先，使用 <code>apt</code> 安装 <code>npm</code>：<code>sudo apt install npm</code></li><li>然后，使用 <code>npm</code> 安装 <code>n</code> —— 一个用来安装 Node.js 的工具：<code>sudo npm install n -g</code></li><li>然后，再使用 <code>n</code> 安装最新的 LTS 版本 Node.js：<code>sudo n lts</code></li><li>安装完成之后，运行 <code>PATH="$PATH"</code> 或者重开终端，刷新系统变量，就可以检查 <code>node -v</code> 了</li></ul><p>这个工具会自动从官网下载 <code>tar.xz</code> 包并自动安装最新的 Node.js。</p><h3 id="日用软件">日用软件</h3><p>只有开发软件当然还是远远不够的；这里列出的大多数日用软件都只需要按照官网的或者是网上到处流传的说明安装就不会出什么问题，这里只是作为列表列出防止忘记（</p><h4 id="microsoft-edge">Microsoft Edge</h4><p>Firefox 当然很好用，但是 Edge 承载了大量的同步书签之类的，而且 Chromium 内核的浏览器的表现也确实比 Firefox 要好；所以也确实得装一个：</p><p>官方网址：<a href="https://www.microsoftedgeinsider.com/zh-cn/download" class="uri">https://www.microsoftedgeinsider.com/zh-cn/download</a></p><p>下载 <code>*.deb</code> 包之后使用 <code>sudo dpkg -i</code> 安装即可。</p><h4 id="visual-studio-code">Visual Studio Code</h4><p>可以从 <code>snap</code> 商店安装；但是听说 <code>snap</code> 安装的版本无法使用中文输入法，所以还是要从官网上下载包来手动安装；前半句话我实践了，是真的；但是后半句话懒得测试了，测试完了再更新文章吧！</p><p>个人偏好：安装了插件 <code>C/C++</code>、<code>Chinese (Simplified) Language Pack for Visual Studio Code</code>、<code>vscode-icons</code>、<code>CMake Tools</code>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;workbench.iconTheme&quot;</span>: <span class="string">&quot;vscode-icons&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;files.autoSave&quot;</span>: <span class="string">&quot;afterDelay&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;editor.fontSize&quot;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">&quot;terminal.integrated.fontFamily&quot;</span>: <span class="string">&quot;Hack Nerd Font&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;terminal.integrated.fontSize&quot;</span>: <span class="number">16</span>,</span><br><span class="line">    <span class="attr">&quot;git.confirmSync&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;http.proxyAuthorization&quot;</span>: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后这里是自用的 VS Code 的配置文件；如果之后有改动再更新这里吧！</p><h4 id="jetbrains-toolbox">Jetbrains Toolbox</h4><p>用来快速地安装所有的 Jetbrains IDE，教育版可以登陆账号之后一键全部激活；</p><p>官方网址：<a href="https://www.jetbrains.com/zh-cn/toolbox-app/download/download-thanks.html" class="uri">https://www.jetbrains.com/zh-cn/toolbox-app/download/download-thanks.html</a></p><p>下载的是个 <code>*.appimage</code>，给执行权限之后打开就会自动安装到电脑，之后就可以使用它安装 JB IDE 了；</p><p>它默认将 IDE 安装到 <code>~/.local/share</code> 目录下，所以如果要创建快捷方式，可以在 <code>~/.local/share/applications/</code> 目录下看到对应的 <code>*.desktop</code> 文件；复制到桌面允许运行即可。</p><h4 id="其他一般通过软件">其他一般通过软件</h4><p>因为基本都没什么坑，所以这里就列个表记录一下算了：</p><table><colgroup><col style="width: 9%" /><col style="width: 38%" /><col style="width: 9%" /><col style="width: 41%" /></colgroup><thead><tr class="header"><th>软件名</th><th>来源</th><th>类型</th><th>备注</th></tr></thead><tbody><tr class="odd"><td>Typora</td><td><a href="https://typora.io/#linux" class="uri">https://typora.io/#linux</a></td><td>apt</td><td>Markdown 编辑器，还可以搭配 PicGo <del>可惜输入法太拉了，没什么写博客的体验</del></td></tr><tr class="even"><td>QQ 音乐</td><td><a href="https://y.qq.com/download/download.html">QQ 音乐下载页</a></td><td>deb/appim行age</td><td></td></tr><tr class="odd"><td>FileZilla</td><td>snap 商店</td><td>snap</td><td>功能完备的 FTP 客户端</td></tr><tr class="even"><td>百度网盘</td><td><a href="https://pan.baidu.com/download">客户端下载</a></td><td>deb</td><td></td></tr><tr class="odd"><td>Sublime Text 3</td><td>snap 商店</td><td>snap</td><td></td></tr><tr class="even"><td>XMind 2020</td><td><a href="https://www.xmind.cn/download/">下载页面</a></td><td>deb</td><td>思维导图软件</td></tr></tbody></table><p>截至 2021-05-25，这些软件更新的时间还是比较阳间的。</p><h3 id="花里胡哨">花里胡哨</h3><p>当然，毕竟是把整块 SSD 都用来作为 Ubuntu 的系统盘了，所以不搞点花里胡哨似乎也不是很对劲；</p><h4 id="网易云音乐">网易云音乐</h4><p>官方下载网址：<a href="https://music.163.com/#/download" class="uri">https://music.163.com/#/download</a>，在某个不起眼的小角落可以下载 deb 包；Ubuntu 20.04 双击大概是装不了的，乖乖 <code>sudo dpkg -i</code> 吧（）</p><p>缓存首次启动就会发现有缩放问题，修改 <code>desktop</code> 文件（位于 <code>/usr/share/applications</code>）里的执行命令 <code>--force-device-scale-factor</code> 不起作用，但是直接终端运行带上这个参数有作用（？）；<a href="https://blog.csdn.net/a1171936767/article/details/114324666">分析</a>发现执行的实际上是一个脚本 <code>/opt/netease/netease-cloud-music/netease-cloud-music.bash</code>，而且是一个 Qt 程序；因此考虑使用针对 Qt 程序的办法）——在执行脚本中加入一个环境变量 <code>QT_SCALE_FACTOR</code> 表示缩放，如下图：</p><figure><img src="https://i.loli.net/2021/05/25/b9pTdAgWzOcK7rv.png" class="lazyload" data-srcset="https://i.loli.net/2021/05/25/b9pTdAgWzOcK7rv.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2021-05-25 04-27-08 的屏幕截图.png" /><figcaption aria-hidden="true">2021-05-25 04-27-08 的屏幕截图.png</figcaption></figure><p>之后再安装一个依赖 <code>sudo apt install libcanberra-gtk-module -y</code>，就可以正常使用网易云音乐了。</p><p>这种做法对于所有 Qt 程序都有效，<del>只要你能够找到程序的运行脚本在哪里（</del></p><h4 id="steam">Steam</h4><p>可以官网下载 <code>deb</code> 包，也可以直接使用 <code>apt</code> 安装；</p><p>首次启动大概缩放是有问题的，而且万<del>不</del>用的 <code>--force-device-scale-factor</code> 不起作用；此时需要打开它的 <code>desktop</code> 文件，修改它的启动命令，在前面加上环境变量 <code>GDK_SCALE=2</code></p><figure><img src="https://i.loli.net/2021/05/25/d9qRmQUtCAOxWM5.png" class="lazyload" data-srcset="https://i.loli.net/2021/05/25/d9qRmQUtCAOxWM5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>这样的修改大概还是不起作用的，但是非常玄学的是进去之后，调成大屏幕模式，再退出大屏幕模式，之后的缩放就一直正确了；不说奇怪只能说是非常奇怪（（（</p><p><code>GDK_SCALE</code> 听说好像是 Chromium 相关的参数，看来 Steam 客户端的 GUI 可能是浏览器套壳）</p><h3 id="杂项">杂项</h3><p>一些各种各样的小问题以及一些小操作：</p><h4 id="偏好字体">偏好字体</h4><p>首先，可以从 Windows 的字体目录 <code>C:\WINDOWS\Fonts</code> 目录下拷贝字体到 <code>/usr/share/fonts</code> 目录下，然后运行 <code>sudo fc-cache -fv</code> 来生成新的字体缓存。</p><table><colgroup><col style="width: 18%" /><col style="width: 81%" /></colgroup><thead><tr class="header"><th>字体</th><th>下载链接</th></tr></thead><tbody><tr class="odd"><td>PingFang SC</td><td><a href="https://github.com/45921/font-collection/tree/main/PingFangSC" class="uri">https://github.com/45921/font-collection/tree/main/PingFangSC</a></td></tr><tr class="even"><td>Hack Nerd Font</td><td><a href="https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/Hack.zip" class="uri">https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/Hack.zip</a></td></tr><tr class="odd"><td>Fira Code</td><td><a href="https://github.com/tonsky/FiraCode/releases/tag/5.2" class="uri">https://github.com/tonsky/FiraCode/releases/tag/5.2</a></td></tr></tbody></table><p>这里先放置一些必用字体的下载链接吧；但是只是这些是不够的，不过日后遇到了问题再说吧！</p><h4 id="和-windows-同步时间">和 Windows 同步时间</h4><p>Ubuntu 和 Windows 对于 BIOS 时间的处理方式不同；Ubuntu 认为 BIOS 上的时间就是 UTC 时间，然后会根据用户的设置的时区加上对应的偏移时间得到系统显示的时间；而 Windows 认为 BIOS 上的时间就是本地时间，不会做任何处理就会直接读取到系统上显示给用户——这导致的问题就是 Ubuntu 同步时间之后，Windows 的时间慢了八个小时。</p><p>因此，作为副系统的 Ubuntu 需要适应 Windows 的时间管理方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ntpdate</span><br><span class="line">sudo ntpdate time.windows.com</span><br><span class="line">sudo hwclock --localtime --systohc</span><br></pre></td></tr></table></figure><p>这样，再从 Ubuntu 进入 Windows 后的系统时间就是正常的了！</p><h4 id="处理图片">处理图片</h4><p>Ubuntu 上有两个很好用的命令行工具，可以用来压缩图片文件的大小；分别是 <code>jpegoptim</code> 和 <code>optipng</code>：它们都可以通过 <code>apt</code> 来安装，并支持使用参数控制输出的质量；</p><p>可以使用 <code>find . -type f -name "*.png" -exec optipng &#123;&#125; \;</code> 来递归的处理目录下的图片。</p><p>此外，文件管理器 nautilus 也有一个不错的插件 <code>nautilus-image-converter</code> 可以用来调整图片的尺寸，并且也可以方便地通过 <code>apt</code> 安装；安装完成后运行 <code>nautilus -q; nautilus &amp;</code> 重启文件管理器服务，找到任意一张图片，右击打开上下文菜单，可以看到出现了 <code>Resize Image</code> 的选项：</p><figure><img src="https://i.loli.net/2021/05/25/OqpIS2nuNaiQmHc.png" class="lazyload" data-srcset="https://i.loli.net/2021/05/25/OqpIS2nuNaiQmHc.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2021-05-25 04-00-39屏幕截图.png" /><figcaption aria-hidden="true">2021-05-25 04-00-39屏幕截图.png</figcaption></figure><p>单击打开之后，就可以缩放图像：</p><figure><img src="https://i.loli.net/2021/05/25/TuXCniBWtxePZlQ.png" class="lazyload" data-srcset="https://i.loli.net/2021/05/25/TuXCniBWtxePZlQ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2021-05-25 03-59-18 的屏幕截图.png" /><figcaption aria-hidden="true">2021-05-25 03-59-18 的屏幕截图.png</figcaption></figure><p>此外，如果还需要对于图像进行基本的编辑（比如裁剪），还需要安装 <code>gthumb</code>；它也可以通过 <code>apt</code> 安装。</p><h3 id="代理服务器设置">代理服务器设置</h3><p>因为需要访问校园网内网，所以需要设置代理（迫真</p><p>还不会搞，等以后会搞了再更新吧 ==</p><h2 id="一些说明">一些说明</h2><p>有些东西感觉放在上一板块显得过于冗长，但是感觉又不能不写；所以就开了一个这样的分块</p><h3 id="桌面图标-快捷方式">桌面图标 / 快捷方式</h3><p>Linux 没有一个明确的桌面标准，但是现在大家都在用的发行版大多都遵循了类似的规则；比如 GNOME 或者大家耳熟能详的 KDE Plasma、xorg 等等；它们显示的图标都是一类赋予了可执行权限的 <code>*.desktop</code> 文件；这些文件一般都在 <code>/usr/share</code> 的目录下，有的也会在 <code>/opt</code> 目录下；如果你通过 Jetbrains Toolbox 来安装 JB 全家桶的话，那么它安装的默认地址是 <code>~/.local/share</code> 下；<code>snap</code> 商店有的时候也会安装在 <code>/snap</code> 目录下。</p><p>一般创建快捷方式的方法，就是到这些目录下，复制出对应的 <code>.desktop</code> 文件，然后属性给可执行，并允许执行即可；使用文本方式打开这个文件，还可以看到它实际运行的命令；在有必要的情况下可以对其进行修改。</p><p>也许之后可以使用一些办法得到 GNOME 桌面获得的应用程序列表的文件来源（</p><h3 id="关于缩放">关于缩放</h3><p>前面的内容已经或多或少地提到了 Ubuntu 桌面混乱的缩放；在我的桌面环境下，实际只有 2560*1440 的屏幕上实际上跑着 4096*2304 的分辨率，100% 的程序肉眼可见的只有 80% 的大小。不仅对于没有很好适配的应用程序，对于浏览器呈现的页面来说也是这样——</p><p>Ubuntu 是有一个算是比较通用的强制缩放的开关 <code>--force-device-scale-factor=2</code>；可惜经过我的尝试，对于绝大多数软件来说都不起作用（（</p><h3 id="文件系统">文件系统</h3><p>在双系统的 Ubuntu 下，是可以通过自带文件管理器看到 Windows 下的盘符的（实际上是物理硬盘），并可以从其中读取文件，但是不能写入——这并不是因为 Ubuntu 不支持 NTFS——实际上，你插入任何一个 NTFS 移动硬盘都是可以正常读写的；导致 Ubuntu 将系统硬盘看作只读文件系统的原因是因为 Windows 默认开启快速启动，导致硬盘上写入了缓存，这会影响到 Ubuntu 对于它的访问。</p><p>当然，毕竟 Windows 是主要操作系统，为了 Ubuntu 稍微舒服一点就大改 Windows 的设置显得非常的没有必要，所以这里也就不再多作评论了（（</p><p>有待考据……如果发现什么问题之后再来更新吧！</p><h3 id="安装应用程序">安装应用程序</h3><p>一般而言，在 Ubuntu 里有几种安装程序的途径：</p><h4 id="apt">APT</h4><p><del>本 APT 具有超级牛力</del></p><p>非常熟悉；通过它可以方方便便地安装很多命令行应用和非命令行应用；通过增加 GPG 和仓库可以使得它更加广泛，可以安装更多的程序；比如 <code>deepin-wine</code> 就可以通过引入仓库后使用 <code>apt</code> 安装；</p><p>在使用 WSL 的时候，它自带的 <code>apt</code> 其实并不全面，很多软件都需要导入外部的仓库才能安装——比如说 <code>yarn</code> 又比如说 <code>openjdk</code> 等等；但是 Ubuntu 20.04 的 <code>apt</code> 已经很全面了，说实话确实省了许多功夫。</p><h4 id="dpkg">dpkg</h4><p><code>dpkg</code> 用来安装 <code>*.deb</code> 的包；很多时候下载的 <code>*.deb</code> 文件双击并不能正确安装；这个时候就需要在终端中 <code>sudo dpkg -i</code> 来安装它；当然，运行起来是什么样就保证不了了（（</p><h4 id="可执行文件">可执行文件</h4><p>诸如流行的 <code>*.appimage</code> 以及一些 <code>*.run</code> 或者 <code>*.app</code> 的文件，只需要在属性中赋予它可执行的权限就可以执行，并打开一个 GUI 窗口；有的是直接原位置运行了，有的会直接给安装到电脑中。比如 Jetbrains Toolbox 和 Qt 等程序。</p><h3 id="命令查表">命令查表</h3><p>一些不那么常用的，但是确实有可能用到的命令；硬要说肯定是可以围绕着它们写文章的，但是因为我很懒等各种客观因素，这里就先放在这里——以后补充说明的时候再更新吧！</p><table><thead><tr class="header"><th>命令</th><th>说明</th><th>备注</th></tr></thead><tbody><tr class="odd"><td><code>nvidia-smi</code></td><td>查看 Nvidia 独立显卡的运行状态</td><td></td></tr><tr class="even"><td><code>optipng &lt;file&gt; -out &lt;file&gt;</code></td><td>使用 <code>optipng</code> 压缩图片的文件大小</td><td>需要先安装 <code>optipng</code></td></tr><tr class="odd"><td><code>scrcpy</code></td><td>使用 <code>adb</code> 使得 Android 手机投屏</td><td>之后再开篇文章讲</td></tr></tbody></table><p>实际上它们如果变得常用了，我很大概率会给它们弄个别名吧（（</p><h2 id="后记">后记</h2><p>这篇文章是在安装好之后的 Ubuntu 上写的；只能说是非常难受了…… 一看输入法还是 2011-2012…… 只能说很努力了，这个年份的微软拼音还在玩泥巴呢（（</p><figure><img src="https://i.loli.net/2021/05/24/IVMp3l7Xk6YSQ9U.png" class="lazyload" data-srcset="https://i.loli.net/2021/05/24/IVMp3l7Xk6YSQ9U.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="2021-05-24 20-50-43 的屏幕截图.png" /><figcaption aria-hidden="true">2021-05-24 20-50-43 的屏幕截图.png</figcaption></figure><p>不过，虽然打字万分难受，但是还是把这篇文章写完了（</p><h3 id="屏幕截图">屏幕截图</h3><figure><img src="https://i.loli.net/2021/05/25/zDIjcugWbEQHiLo.png" class="lazyload" data-srcset="https://i.loli.net/2021/05/25/zDIjcugWbEQHiLo.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="temp.png" /><figcaption aria-hidden="true">temp.png</figcaption></figure><h3 id="尚未解决的问题">尚未解决的问题</h3><p>当然，毕竟是 Ubuntu，想要用的和 Windows 一样舒服还是有一些距离的（</p><table><thead><tr class="header"><th>名称</th><th>说明</th></tr></thead><tbody><tr class="odd"><td>有道词典缩放问题</td><td>经典不适配系统缩放导致观感 80%；通用的做法无效</td></tr><tr class="even"><td>Typora 不显示在 Dock</td><td>不仅仅是从命令行启动的 <code>typora</code>，从 GNOME 启动的也会先不显示图标</td></tr><tr class="odd"><td>Wine TIM 无字体</td><td>安装了多个字体均无效，当然缩放也有问题（</td></tr></tbody></table><p>如果以后有解决办法，再在后续的更新中说明吧！</p><h3 id="更新历史">更新历史</h3><p>记录了本文件从创建以来进行的更新：</p><table><thead><tr class="header"><th>日期</th><th>更新内容</th></tr></thead><tbody><tr class="odd"><td>2021-05-19</td><td>创建了本文档，更新了网易云音乐的缩放调整方法，更新了 Node 和快捷方式的说明</td></tr><tr class="even"><td>2021-05-25</td><td>增加了终端的配置说明，增加了一些截图，整理成文章</td></tr></tbody></table><p>大概下次有机会再整一个配置文件的备份仓库吧，Jetbrains IDE 每次重新配置老实说挺麻烦的（（</p>]]></content>
    
    <summary type="html">
    
      好久都没有完整的写文章了，没想到最先更新的竟然是这样的一篇水文（）大概这篇文章只适用于个人的记录吧==
    
    </summary>
    
    
      <category term="折腾记录" scheme="https://shiraha.cn/categories/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Linux" scheme="https://shiraha.cn/tags/Linux/"/>
    
      <category term="Ubuntu" scheme="https://shiraha.cn/tags/Ubuntu/"/>
    
      <category term="持续更新" scheme="https://shiraha.cn/tags/%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>Educational Codeforces Round 108 回顾</title>
    <link href="https://shiraha.cn/2021/codeforces-educational-round-108/"/>
    <id>https://shiraha.cn/2021/codeforces-educational-round-108/</id>
    <published>2021-05-03T10:54:58.000Z</published>
    <updated>2021-05-03T10:54:58.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>补题链接：<a href="https://codeforces.com/contest/1519" class="uri">https://codeforces.com/contest/1519</a></p></blockquote><h2 id="记录">记录</h2><p>竟然足足一周没有正经的训练了…… 唉，这样可不行啊</p><p>这一场的话 ABC 肯定是没啥问题的，D 能不能做出来心里还真的没底；毕竟正式 CF 也不会允许我打了三个题然后出去吃顿饭什么的，所以只能说悬（</p><h2 id="题解">题解</h2><h3 id="a---red-and-blue-beans">A - <a href="https://codeforces.com/contest/1519/problem/A">Red and Blue Beans</a></h3><p>有手就行<del>没手不行（</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T, r, b, d;</span><br><span class="line">    <span class="keyword">for</span> (input, T; T --;) &#123;</span><br><span class="line">        input, r, b, d;</span><br><span class="line">        longs times = min(r, b);</span><br><span class="line">        longs delta = <span class="built_in">abs</span>(r - b);</span><br><span class="line">        <span class="keyword">bool</span> ok = delta &lt;= times * d;</span><br><span class="line">        output, ok ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>, <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记得开 <code>long long</code> （</p><h3 id="b---the-cake-is-a-lie">B - <a href="https://codeforces.com/contest/1519/problem/B">The Cake Is a Lie</a></h3><p>稍微手玩一会就会发现其实答案是固定的值；所以只需要计算答案之后比较大小就行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> null = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> sum[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">105</span>; ++ i)</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + i;</span><br><span class="line">    <span class="keyword">int</span> n, m, k, T;</span><br><span class="line">    <span class="keyword">for</span> (input, T; T --;) &#123;</span><br><span class="line">        input, n, m, k;</span><br><span class="line">        <span class="keyword">int</span> sq = min(n, m);</span><br><span class="line">        <span class="keyword">int</span> cost = <span class="built_in">abs</span>(n - m) * sq;</span><br><span class="line">        cost += sum[sq] * <span class="number">2</span> - sq - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> ok = cost == k;</span><br><span class="line">        output, ok ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>, <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手玩正方形，发现固定显然；再手玩长方形，发现多余的部分安哪里都一样，所以（</p><h3 id="c---berland-regional">C - <a href="https://codeforces.com/contest/1519/problem/C">Berland Regional</a></h3><blockquote><p>有 <span class="math inline">\(n \leq 2\cdot10^5\)</span> 个学生，每个学生都有自己所属的大学 <span class="math inline">\(u_i\)</span> 和实力 <span class="math inline">\(s_i\)</span>；设一组有 <span class="math inline">\(k\)</span> 人，第 <span class="math inline">\(j\)</span> 所大学一共有 <span class="math inline">\(\#j\)</span> 人：那么每个大学将会派出自己所属的实力最强的 <span class="math inline">\(\lfloor \frac{\#j}k\rfloor \cdot k\)</span> 人参加比赛；设比赛的影响力是所有参赛者的实力之和，求出 <span class="math inline">\(k \in [1, n]\)</span> 时赛站的实力。</p></blockquote><p>对于某个大学，它只能对 <span class="math inline">\(k \in [1, \# j]\)</span> 的比赛做出贡献——直接计算后累加就可以了；但是因为还要对每个大学的所有学生的实力进行排序，所以总复杂度是 <span class="math inline">\(\mathcal{O}(n\log n)\)</span> 的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = $.nextInt(), n, m, x;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;longs, <span class="keyword">int</span>&gt;&gt; heap;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        $(n, m, x).nextArray(h + <span class="number">1</span>, h + <span class="number">1</span> + n);</span><br><span class="line">        sort(h + <span class="number">1</span>, h + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i) &#123;</span><br><span class="line">            ans[n - i] = i + <span class="number">1</span>;</span><br><span class="line">            heap.push(&#123; -h[n - i], i + <span class="number">1</span> &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - m; i; -- i) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [value, id] = heap.top();</span><br><span class="line">            heap.pop();</span><br><span class="line">            ans[i] = id, value -= h[i];</span><br><span class="line">            heap.push(&#123; value, id &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        longs mi = INT64_MAX, ma = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!heap.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [value, id] = heap.top();</span><br><span class="line">            minimize(mi, -value);</span><br><span class="line">            maximize(ma, -value);</span><br><span class="line">            heap.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ma - mi &lt;= x) $.put(<span class="string">&quot;YES&quot;</span>).putArray(ans + <span class="number">1</span>, ans + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">else</span> $.put(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案其实挺显然的，但是我还是想了半天（</p><h3 id="d---maximum-sum-of-products">D - <a href="https://codeforces.com/contest/1519/problem/D">Maximum Sum of Products</a></h3><blockquote><p>给了长度为 <span class="math inline">\(n \leq 5000\)</span> 的数组 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>，现在你可以翻转数组 <span class="math inline">\(a\)</span> 的一个连续子区间，问 <span class="math inline">\(\sum_{i = 1}^n a_i \cdot b_i\)</span> 的最大值</p></blockquote><p>暴力枚举反转区间 <span class="math inline">\([i, j]\)</span>，时间复杂度是 <span class="math inline">\(\mathcal{O}(n^3)\)</span> 的；考虑字符串算法中处理回文串的一些做法，我们可以枚举中间位置 <span class="math inline">\(i\)</span>，然后左右拓展翻转的区间，这样就可以使翻转的复杂度降维；总复杂度 <span class="math inline">\(\mathcal{O}(n^2)\)</span>；</p><h4 id="实现">实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> ll[N], rr[N], lc[N], rc[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = $.nextInt(), n, l, r;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        $(n, l, r).nextArray(ll + <span class="number">1</span>, ll + <span class="number">1</span> + l)</span><br><span class="line">            .nextArray(rr + <span class="number">1</span>, rr + <span class="number">1</span> + r);</span><br><span class="line">        <span class="built_in">memset</span>(lc, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">memset</span>(rc, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= l; ++ i) ++ lc[ll[i]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; ++ i) ++ rc[rr[i]];</span><br><span class="line">        <span class="keyword">int</span> lp = <span class="number">0</span>, rp = <span class="number">0</span>, lct = <span class="number">0</span>, rct = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">int</span> ded = min(lc[i], rc[i]);</span><br><span class="line">            lc[i] -= ded, rc[i] -= ded;</span><br><span class="line">            lp += lc[i] / <span class="number">2</span>, lct += lc[i];</span><br><span class="line">            rp += rc[i] / <span class="number">2</span>, rct += rc[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ded = min(lp, rp), ans = <span class="number">0</span>;</span><br><span class="line">        lct -= ded * <span class="number">2</span>, rct -= ded * <span class="number">2</span>;</span><br><span class="line">        lp -= ded, rp -= ded, ans += ded * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (lct &gt; rct) swap(lct, rct), swap(lp, rp);</span><br><span class="line">        <span class="keyword">int</span> more = rct - lct;</span><br><span class="line">        ded = min(more / <span class="number">2</span>, rp);</span><br><span class="line">        ans += ded, more -= ded * <span class="number">2</span>, rct -= ded * <span class="number">2</span>, rp -= ded;</span><br><span class="line">        <span class="keyword">if</span> (rct &gt; lct) &#123;</span><br><span class="line">            ded = more / <span class="number">2</span>, more = <span class="number">0</span>;</span><br><span class="line">            rct -= ded, lct += ded, ans += ded;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += rct;</span><br><span class="line">        $.put(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比赛中的话我真的能写出来吗？应该把，应该把（</p><h3 id="e---off-by-one">E - <a href="https://codeforces.com/contest/1519/problem/E">Off by One</a></h3><blockquote><p>二维平面的第一象限上有 <span class="math inline">\(n \leq 2\cdot10^5\)</span> 个点；每次操作，你可以选择两个没有被选中过的点，分别将它们向右或者向上移动一个单位，如果这两个点和原点三点共线，那么这次操作是有效的。问你最多可以执行的有效操作数量，并输出一种可能的操作序列。</p></blockquote><p>看起来很没有办法，但是涉及到简单平面几何，能想到的关键字也就那么多。但是即使这样，我也属实没有考虑到这实际上是一个暴力搜索的题目（</p><p>我们将每个点经过两种不同的移动之后得到的位置计算出来；那么，如果两个点可以进行一次有效的操作，就等价于它们变换得到的一个位置到原点的斜率是相等的；一个点可以进行两种不同的移动，就意味这一个点可以关联两种不同的斜率：这样，我们就得到了一张以斜率为点，而以每个可操作节点为边的图。</p><p>那么，问题就变成了找到最多的边对，它们之间共享了一个端点；或者说将每一条边分给一个端点，令端点 <span class="math inline">\(i\)</span> 分到的边数为 <span class="math inline">\(v_i\)</span>，那么答案就是 <span class="math inline">\(\sum\lfloor\frac{v_i}2\rfloor\)</span>；这是一个非常经典的问题，一种解决思路就是 DFS：对于点 <span class="math inline">\(i\)</span>，如果 <span class="math inline">\(v_i\)</span> 是奇数，就把从父亲到自己的边给自己，否则就给父亲；这样就完成了对树边的分配：</p><p>那么 DFS 树中的其他边呢？因为这是一个无向图，对于其中的每一个连通块而言，其 DFS 都是一个生成树，也就是说不存在跨越边——剩下的边对于父亲来说是前向边，对于后代来说是后向边。那么对于这些边，为了实现方便，全部都给父亲即可——而且这样也可以显然得到，这种方案只会在总边数为奇数的时候，在根节点处浪费一条边。</p><p>很经典，就是利用到父亲的边平衡子树的奇偶性；最多浪费的那条边也就是连通块生成树的根节点，<strong>他没有父亲</strong>，所以如果真的不能匹配也就只能浪费掉了。</p><h4 id="实现-1">实现</h4><p>因为斜率是铁分数，所以需要离散化（标号）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">using</span> Frac::frac;</span><br><span class="line"><span class="built_in">pair</span>&lt;frac, frac&gt; p[N];</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, N&gt; vis;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt; g;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [v, ii] : g[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[v] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> now = ii;</span><br><span class="line">        <span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = dfs(v);</span><br><span class="line">            <span class="keyword">if</span> (tmp != <span class="number">-1</span>) &#123;</span><br><span class="line">                ans.emplace_back(now, tmp);</span><br><span class="line">                now = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (now != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="number">-1</span>) &#123;</span><br><span class="line">                ans.emplace_back(cur, now);</span><br><span class="line">                cur = <span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> cur = now;</span><br><span class="line">        <span class="keyword">else</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vis[u] = <span class="number">2</span>, cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = $.nextInt(), a, b, c, d;</span><br><span class="line">    g.resize(<span class="number">2</span> * n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">map</span>&lt;frac, <span class="keyword">int</span>&gt; id;</span><br><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> one = frac(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        $(a, b, c, d);</span><br><span class="line">        <span class="keyword">auto</span> x = frac(a, b), y = frac(c, d);</span><br><span class="line">        p[i] = <span class="built_in">pair</span>(x.reduce(), y.reduce());</span><br><span class="line">        <span class="keyword">auto</span> k1 = (y + one) / x, k2 = y / (x + one);</span><br><span class="line">        k1.normal(), k2.normal();</span><br><span class="line">        <span class="keyword">if</span> (!id[k1]) id[k1] = ++ tot;</span><br><span class="line">        <span class="keyword">if</span> (!id[k2]) id[k2] = ++ tot;</span><br><span class="line">        g[id[k1]].emplace_back(id[k2], i);</span><br><span class="line">        g[id[k2]].emplace_back(id[k1], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) dfs(i);</span><br><span class="line">    $.put(ans.size());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [a, b] : ans) $.put(a, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现意外简单（</p><h3 id="f---chests-and-keys">F - <a href="https://codeforces.com/contest/1519/problem/F">Chests and Keys</a></h3><blockquote><p>有 <span class="math inline">\(n\)</span> 个宝箱，其中第 <span class="math inline">\(i\)</span> 个包含了 <span class="math inline">\(a_i\)</span> 个硬币；有 <span class="math inline">\(m\)</span> 把钥匙，其中第 <span class="math inline">\(j\)</span> 把可以卖 <span class="math inline">\(b_j\)</span> 个硬币。这些钥匙分别对应了不同种类的锁；如果要在第 <span class="math inline">\(i\)</span> 个箱子上安装可以用第 <span class="math inline">\(j\)</span> 把钥匙打开的锁，需要 <span class="math inline">\(c_{i, j}\)</span> 的成本；如果一个箱子上挂了多把锁，那么只有持有所有的这些钥匙才可以打开宝箱。</p><p>现在，Alice 持有这些宝箱和钥匙，并付出一定的成本来为箱子上锁；随后，Bob 会花一些硬币购买钥匙，并打开可以打开的所有宝箱以拿走其中的硬币；如果最后 Bob 的净利润严格大于 0，Bob 胜利；否则 Alice 胜利；现在，要求求出 Alice 必定胜利所需要付出的最少成本。</p><p>数据范围： <span class="math inline">\(1\leq n, m \leq 6\)</span>；<span class="math inline">\(1\leq a_i, b_j \leq 4\)</span>；<span class="math inline">\(1\leq c_{i, j} \leq 10^7\)</span>；</p></blockquote><p>只能说看到这个题目，是非常的没有想法了；但是数据又很小，像极了乱搞……那么问题就是怎么乱搞了（</p><p>首先，在解决这个问题之前，我们先解决一个经过劣化后的问题—— 如果 Alice 上锁的方式已经确定，那么 Bob 要怎么购买钥匙才能获得最大的收益呢？</p><p>为了解决这个劣化后的问题，我们对题目中描述的模型进行建模：将宝箱全部看作连接了源点的节点，且和源点连边容量为 <span class="math inline">\(a_i\)</span>；将钥匙全部看作链接了汇点的节点，且连边的容量为 <span class="math inline">\(b_j\)</span>；根据宝箱的上锁情况，从宝箱出发到对应的钥匙连边，边权是 <span class="math inline">\(\infin\)</span>；这样，我们就将上面的问题变成了一个网络流的问题。</p><p>那么，这个网络流的含义是什么呢？首先，我们可以获得的最大的收益是所有箱子的硬币之和，我们所支出的成本最多是所有的钥匙的价格之和；每当上锁，我们就相当于增加一个箱子打开的门槛—— 对于一个具体的箱子，我们打开它的成本是它所使用到的锁的钥匙的价格总和，但是不超过箱子能提供的硬币数量—— 没有人会去做一件亏本的事情。初始情况下，我们可以免费打开所有的箱子，但是因为上锁，所以我们需要付出额外的成本：因此，连边就代表了上锁带来的额外成本——这个箱子的成本需要由它上的锁对应的钥匙分担；综上所述，确定了上锁方案的情况下，Bob 得到的最大收益是： <span class="math display">\[\sum_{i = 1}^n a_i - \text{maxFlow}\]</span> 如果一个箱子的收益完全被需要用来开它的钥匙抵消了，那么就没有开的价值了；但是如果一把钥匙承担了超过它本身价值的收益的话，那么这把钥匙就有买的必要；一种达到这个最大收益的办法是购买所有出边满流的钥匙，但是购买的钥匙数量未必是最少的。</p><p>虽然，这种建模方法和常见的<del>裸的</del>网络流并不一样：因为钥匙和箱子的关系是 <code>&amp;</code> 的，因此如果按照代价建模的话，网络流可以恰好地考虑到钥匙开锁的性质和成本。</p><p>但是，即使数据范围像本题这样小，上锁方案还是有 <span class="math inline">\(nm\)</span> 种；如果要枚举所有的上锁方案，其时间复杂度是 <span class="math inline">\(\mathcal{O}(2^{nm})\)</span> 的；因此，我们回到这个问题本身：注意到，如果 Bob 总是按照最大收益来进行操作的话，那么 Bob 的收益是不可能为负数的——因为 Bob 总是可以选择不购买任何钥匙，不打开任何的箱子，这样最后的总收入是 0；那么带入到上面的网络流模型中，就是所有的宝箱的价值都作为成本流量流入了汇点；换句话说，这个网络流的一个最小割是源点和其他所有节点。</p><p>那么考虑上述的网络流中没有任何上锁的连边，我们现在来考虑在这张图中连边；我们用状态 <span class="math inline">\([F_{1..n}, L, R, P]\)</span> 来表示当前的网络流图的连边状态：<span class="math inline">\(F_i\)</span> 代表从源点到宝箱 <span class="math inline">\(i\)</span> 的连边流出的成本，<span class="math inline">\(L\)</span> 表示当前考虑的宝箱，<span class="math inline">\(R\)</span> 表示当前考虑的钥匙编号 <span class="math inline">\(j\)</span>，<span class="math inline">\(P\)</span> 表示从钥匙 <span class="math inline">\(j\)</span> 到汇点的连边流入的成本；现在，我们考虑所有的 <span class="math inline">\(i \to j\)</span> 的连边，进行动态规划：</p><ul><li>跳过 <span class="math inline">\(i \to j\)</span>：也就是这条边不上锁</li><li>利用这条边转移一些成本：这条边上锁，但是转移的一部分流量</li></ul><p>如果使用这条边转移流量，那么需要满足 <span class="math inline">\(S \to i\)</span> 和 <span class="math inline">\(j \to T\)</span> 的边都还有足够的流量剩余；更新状态之后，若所有的 <span class="math inline">\(F_i\)</span> 都已经满流了，则说明成本已经足够抵消所有的宝箱了，更新答案；同时，按照一个特定的顺序考虑 <span class="math inline">\([L, R]\)</span>，将下一对要考虑的点对更新到状态中。如果状态合法，就更新到 dp 数组中。</p><p>简单地说，因为数据范围小，我们枚举所有满足了约束条件的转移方法导致的状态，并计算所有的流空的状态的花费的最小值。因为流量最多为 <span class="math inline">\(4\)</span>，而最多的情况下也只有 <span class="math inline">\(36\)</span> 条边，在考虑到每条边容量的约束条件，实际上状态数是相当有限的。</p><h4 id="实现-2">实现</h4><p>一些小细节：我们考虑 <span class="math inline">\([L, R]\)</span> 的顺序是先改变 <span class="math inline">\(L\)</span> 再改变 <span class="math inline">\(R\)</span>，这需要体现到映射函数中。</p><p>此外，因为考虑使用边运输流量的过程，一定是 <span class="math inline">\(S\)</span> 流出的递增的过程，所以在映射函数中这一部分的值总是在最高位；</p><p>因为每次要将所有的 <span class="math inline">\([L, R]\)</span> 的状态考虑周全，所以流出流量 <span class="math inline">\(P\)</span> 在映射函数中是最低位的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, a[<span class="number">10</span>], b[<span class="number">10</span>], c[<span class="number">10</span>][<span class="number">10</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> F = <span class="number">4e7</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> dp[F];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; flow&#123;&#125;;</span><br><span class="line">    <span class="keyword">int</span> lf&#123;&#125;, rt&#123;&#125;, push&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    state() = <span class="keyword">default</span>;</span><br><span class="line">    state(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;flow, <span class="keyword">int</span> lf, <span class="keyword">int</span> rt, <span class="keyword">int</span> push)</span><br><span class="line">    : flow(flow), lf(lf), rt(rt), push(push) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">std</span>:</span>:hash&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; :</span><br><span class="line">        <span class="keyword">public</span> __hash_base&lt;<span class="keyword">size_t</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;x)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> _hashcode = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> el : x) _hashcode = _hashcode * <span class="number">5</span> + el;</span><br><span class="line">        <span class="keyword">return</span> _hashcode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> hashcode) <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _ret(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">            _ret[i] = <span class="keyword">int</span>(hashcode % <span class="number">5</span>), hashcode /= <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">return</span> _ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">std</span>:</span>:hash&lt;state&gt; :</span><br><span class="line">        <span class="keyword">public</span> __hash_base&lt;<span class="keyword">size_t</span>, state&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> state &amp;x)</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> _hashcode = hash&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&#123;&#125;(x.flow);</span><br><span class="line">        _hashcode = _hashcode * <span class="number">6</span> + x.rt;</span><br><span class="line">        _hashcode = _hashcode * <span class="number">6</span> + x.lf;</span><br><span class="line">        _hashcode = _hashcode * <span class="number">5</span> + x.push;</span><br><span class="line">        <span class="keyword">return</span> _hashcode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    state <span class="keyword">operator</span>[](<span class="keyword">size_t</span> hashcode) <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> _push = <span class="keyword">int</span>(hashcode % <span class="number">5</span>);</span><br><span class="line">        <span class="keyword">auto</span> _lf = <span class="keyword">int</span>((hashcode /= <span class="number">5</span>) % <span class="number">6</span>);</span><br><span class="line">        <span class="keyword">auto</span> _rt = <span class="keyword">int</span>((hashcode /= <span class="number">6</span>) % <span class="number">6</span>);</span><br><span class="line">        <span class="keyword">return</span> state(</span><br><span class="line">                hash&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&#123;&#125;[hashcode /= <span class="number">6</span>],</span><br><span class="line">                _lf, _rt, _push);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    $(n, m).nextArray(a, a + n).nextArray(b, b + m);</span><br><span class="line">    const vector&lt;int&gt; va(a, a + n), vb(b, b + m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        $.nextArray(c[i], c[i] + m);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="keyword">int</span> ans = inf; dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; F; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == inf) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">auto</span> s = hash&lt;state&gt;&#123;&#125;[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> f : &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.flow[s.lf] + f &gt; a[s.lf] ||</span><br><span class="line">                s.push + f &gt; b[s.rt]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> pay = !f ? <span class="number">0</span> : c[s.lf][s.rt];</span><br><span class="line">            <span class="keyword">auto</span> now = s;</span><br><span class="line">            now.flow[s.lf] += f, now.push += f;</span><br><span class="line">            <span class="keyword">if</span> (s.lf + <span class="number">1</span> == n) &#123;</span><br><span class="line">                now.lf = now.push = <span class="number">0</span>;</span><br><span class="line">                now.rt = s.rt + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> now.lf = s.lf + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (now.flow == va) minimize(ans, dp[i] + pay);</span><br><span class="line">            <span class="keyword">if</span> (now.rt &lt; m) &#123;</span><br><span class="line">                <span class="keyword">auto</span> id = hash&lt;state&gt;&#123;&#125;(now);</span><br><span class="line">                minimize(dp[id], dp[i] + pay);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    $.put(ans == inf ? <span class="number">-1</span> : ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能说从网络流建模，到最后的那个 DP 求解，没有一个是现在的我能想出来的（）图论，网络流，恐怖如斯——这也不是我近来第一次被网络流题目锤了== 得想点办法才行。</p><p>实际上，这个题涉及到的东西远不止这篇题解胡说八道的这么点，与之相关的知识点比想象中还是要多出许多的。</p><h2 id="后记">后记</h2><p>没什么特别想说的，一周不写代码手感属实全无了== 实际上 E 也不算是什么难题<del>虽然我也没有想到极角排序什么的</del>，但是为什么每一次遇到这种题（不管是我自己打 cf 还是在线下训练中遇到了）都做的非常的费劲呢——还是做题思维的问题吧，ACM 之所以我这种人也能勉强打打，就是因为比起 OI 而言它会更加的注重思维水平；所以还是得多想多学（</p><p>此外，我的图论属实有些拉跨——这个 F 实际上还有很多关键词相关联：比如什么最大权闭合子图啊，什么霍尔定理啊，什么二分图匹配啊之类的，但是十分恐怖的是<strong>我都不会</strong>；就算是偏向思维的比赛，也是要建立在你有足够的知识积累的基础上，只能说这样属实不行（）得花个专门的时间搞搞图论才行啊 ==</p>]]></content>
    
    <summary type="html">
    
      没有实际去打的一场，但是如果实际去打了能不能顺利做出 ABCD 呢？我觉得大概有些难度——虽然这些题本身并不难就是了（
    
    </summary>
    
    
      <category term="题解" scheme="https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="算法" scheme="https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM" scheme="https://shiraha.cn/tags/ACM/"/>
    
      <category term="Codeforces" scheme="https://shiraha.cn/tags/Codeforces/"/>
    
  </entry>
  
  <entry>
    <title>在 Windows 10 设备上启动 FTP 服务</title>
    <link href="https://shiraha.cn/2021/host-a-ftp-server-on-your-windows-10-pc/"/>
    <id>https://shiraha.cn/2021/host-a-ftp-server-on-your-windows-10-pc/</id>
    <published>2021-04-25T16:15:25.000Z</published>
    <updated>2021-04-25T16:15:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>一些关于在 Windows 电脑上折腾 FTP 文件传输的记录。毕竟虽然但是，华科大内网的连接速度还是非常可以的，如果能够很好的借助 FTP 传输文件的话，倒也省得我带着移动硬盘在寝室和实验室来回跑了（</p><p>本文的服务器端仅使用 Windows 10 自带的 IIS 控制面板。</p><h2 id="前置准备">前置准备</h2><p>一些开始教程之前的准备；</p><h3 id="增加-windows-功能">增加 Windows 功能</h3><p>使用 Win + R 运行 <code>optionalfeatures</code>，或者在搜索菜单中搜索“启用或关闭 Windows 功能”；</p><p>找到 <code>Internet Information Services</code>，将其下的“FTP 服务器”的所有子选项勾选，并勾选“Web 管理工具”下的“IIS 管理控制台”。</p><figure><img src="https://i.loli.net/2021/04/26/STQwHnEW4BG7YJP.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/STQwHnEW4BG7YJP.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>打开设置，进入应用 <code>-&gt;</code> 应用与功能，点击“可选功能”；搜索 <code>OpenSSH</code>，找到并安装“OpenSSH 服务器”和“OpenSSH 客户端”。</p><figure><img src="https://i.loli.net/2021/04/26/fHKQxUYBG7NCMX5.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/fHKQxUYBG7NCMX5.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>现在，你应该可以通过计算机管理，或者搜索菜单找到“Internet Information Services (IIS) 管理器” 了。IIS 管理器就有点像之前的云服务器面板一样，不过是 Windows 自带的就是了（</p><p>但是因为 Windows 自身也是有防火墙的，我们要先允许 FTP 服务通过 Windows 的防火墙；在搜索菜单中搜索“允许应用通过 Windows 防火墙”，点更改设置，找到并勾选“FTP 服务器”；然后点击窗口右下角的“允许其他应用”按钮，浏览路径，找到 <code>C:\Windows\System32\svchost.exe</code>，并添加，确定。</p><p><del>其实在配置远程桌面服务的时候也需要在这里配置这一项目</del></p><h3 id="ftp-sftp-ftps">FTP &amp; SFTP &amp; FTPS</h3><p>其实你要我说也说不太清楚，截至今天我总共已经翘了 2/2（100%）节计算机网络的课了；但是一些常识性的东西还是能简单的说说的：</p><table><thead><tr class="header"><th>协议类型</th><th>端口</th><th>备注</th></tr></thead><tbody><tr class="odd"><td>FTP</td><td>21</td><td>Windows 资源管理器唯一支持的 FTP 形式；明文传输，安全性差，但是很方便</td></tr><tr class="even"><td>SFTP</td><td>22</td><td>使用 <code>sshd</code> 作为守护进程；安全，但是传输效率较为低下</td></tr><tr class="odd"><td>FTPS（Explicit）</td><td>21</td><td>需要一个证书；客户端先发起一个明文的请求，然后再切换到加密连接进行</td></tr><tr class="even"><td>FTPS（Implicit）</td><td>990</td><td>同样需要证书；全程加密连接，服务端会拒绝掉所有尝试不通过加密的请求</td></tr></tbody></table><p>实际上 FTP 开放的端口并不止一个——有命令通道和数据通道，21 一般指命令通道；FTP 的连接分为主动模式（Standard）和被动模式（Passive）：</p><ul><li>主动模式下，客户端首先通过 TCP-21 端口和服务器连接；客户端需要接受数据的时候发送 PORT 命令告诉服务器客户端用来接收数据的端口，然后服务器使用 TCP-20 端口与客户端建立连接，也就是数据通道；</li><li>被动模式下，通过 TCP-21 建立连接后发送 PASV 命令；服务端接收命令后打开一个临时端口并通知客户端，客户端再连接服务器的此端口，进行数据传送；</li></ul><p>一般来说，由于防火墙一般不允许接受外部发起的连接，所以外网的客户端可能无法使用 Passive 模式连接；</p><p>FTP 家族比较混乱，一般来说都用 SFTP 了；FTP 协议由于非常的不安全，近年来主流的浏览器都已经放弃了在浏览器中内置 FTP 的支持了——毕竟基础的支持 Windows 资源管理器也提供了。</p><h2 id="配置服务器">配置服务器</h2><p>对于 FTP、SFTP、FTPS 三种服务器的配置方法：</p><h3 id="ftp">FTP</h3><p>进入 IIS 管理器，在左侧的连接栏中找到“网站”，右键增加 FTP 站点；</p><figure><img src="https://i.loli.net/2021/04/26/hftqrD7uyjIONa3.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/hftqrD7uyjIONa3.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>在弹出的窗口中指定名称和映射的物理地址，点下一步：</p><figure><img src="https://i.loli.net/2021/04/26/dUsW42MiIbk9Qtp.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/dUsW42MiIbk9Qtp.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>关于 IP 地址，你可以填写你的 IP；如果你不知道<del>填写哪一级别的 IP</del>，你也可以默认“全部为分配”，相当于填入了通配符 <code>*</code>；如果设置了其他的端口，那么访问时的 IP 地址需要带上端口号；如果提供了虚拟主机名，那么访问时还需要加上虚拟主机名，因为没有必要所以这里统统默认。</p><p>因为我们现在还不是配置 FTPS，所以选择“无 SSL”。</p><p>接下来是配置权限的页面；如果是作为一个公开的 FTP 服务器，可以勾选匿名身份验证，授权全部用户读写权限（当然，这是不可能的）；否则需要进行配置密码：</p><h4 id="windows-专业版">Windows 专业版</h4><p>用户组策略设置只有专业版的 Windows 10 才有；在计算机管理中的本地用户和组菜单中可以新建用户（组），并且进行细致的组策略管理。我们新建一个一般用户，并设置用户名和密码</p><figure><img src="https://i.loli.net/2021/04/26/P7VXZEbWmIknhej.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/P7VXZEbWmIknhej.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>注意需要取消勾选用户下次登陆时须更改密码，不然会比较麻烦。</p><figure><img src="https://i.loli.net/2021/04/26/QZOHk8Fq2bRtWBN.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/QZOHk8Fq2bRtWBN.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>然后我们回到 IIS 面板，进入我们刚才创建的服务器的主页；首先进入 FTP 身份验证页面，并且关闭匿名验证：</p><figure><img src="https://i.loli.net/2021/04/26/DuLHyEPdgCQ9jik.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/DuLHyEPdgCQ9jik.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><figure><img src="https://i.loli.net/2021/04/26/inXVkgLwtl6N4W8.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/inXVkgLwtl6N4W8.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>然后再进入到旁边的 FTP 授权规则页面，增加允许规则，并选择我们刚创建的用户（们）：</p><figure><img src="https://i.loli.net/2021/04/26/VjF2BmJD5pRNbKT.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/VjF2BmJD5pRNbKT.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>不出意外，现在已经可以正常在 Windows 资源管理器里输入 <code>ftp://localhost/</code> 来输入密码访问了。</p><h4 id="windows-家庭版">Windows 家庭版</h4><p>Windows 10 家庭版不支持组策略管理，但是支持创建账户；我们可以直接在设置页面创建一个本地的标准账户，并赋予密码，也可以在这里设置允许规则；唯一的问题就是无法进行精细的权限管理，当然，作为一个实用派的萌新，倒也没有必要搞过于精细的权限管理；真要怕被日用时开不用时关就行了，而且 FTP 一个明晃晃的明文传输，人家要真想抓包搞你你也没有什么办法（</p><p>还有一种做法是在服务器主页的右侧栏中的基本设置里（如下）的连接为中设置用户名密码，而在服务器设置里设置允许所有用户：</p><figure><img src="https://i.loli.net/2021/04/26/DXl9igdMo1kCUGF.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/DXl9igdMo1kCUGF.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>但是因为我实在是不太理解微软的权限管理，所以这里也就没有尝试，不多废话了。</p><hr /><p>当然，如果你怕麻烦<del>而且心很大</del>，也可以使用你当前的账户直接连接到 FTP 服务器；此时你的账号名可以通过在 <code>CMD</code> 中运行 <code>echo %username%</code> 获得；如果你当前使用的账户连接到了 Microsoft 账户，那么也可以使用 <code>MicrosoftAccount/your@email.com</code> 作为你的用户名，登陆密码作为你的密码。</p><h3 id="ftps">FTPS</h3><p>FTPS 是 FTP over SSL 的简称，分为显式和隐式两种；很遗憾 XFTP 7 学生版并不支持<del>似乎标准版也不支持</del>，所以如果你想要通过 FTPS 连接你的 FTP 服务器，那么你需要下载合适的客户端：</p><ul><li><a href="https://www.filezilla.cn/download">FileZilla 客户端</a></li><li><del>ES 文件浏览器</del></li></ul><h4 id="ssl-证书">SSL 证书</h4><p>当然，既然是走 SSL，那么你首先要有一个 SSL 证书；可以自签，也可以绑了域名后申请一个免费的；因为我有在 DNSpod 上托管腾讯云买的域名，所以可以直接方便地申请到免费的证书；下面介绍腾讯云的证书使用方法：</p><p>下载 SSL 证书压缩包后，可以看到其中包含了一个 IIS 专用证书的目录；我们进入 IIS 面板，选择计算机名称进入到服务器主页，进入服务器证书页面：</p><figure><img src="https://i.loli.net/2021/04/26/LQpHyba3gzB7MUJ.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/LQpHyba3gzB7MUJ.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>然后再右侧栏中选择导入证书，选择下载的证书文件；然后根据你的 SSL 证书提供商的说明来填入相应的信息。</p><figure><img src="https://i.loli.net/2021/04/26/waprUiXDcMlKj1Z.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/waprUiXDcMlKj1Z.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>增加完成后，你就可以在所有的需要使用 SSL 的证书的地方找到你刚增加的 SSL 证书了。当然，如果要使用这种来自运营商颁发的证书，建议在 DNS 处增加一条解析记录，这样访问也更加优雅。</p><h4 id="修改服务器配置">修改服务器配置</h4><p>进入你创建的 FTP 服务器的主页，打开 FTP SSL 设置：</p><figure><img src="https://i.loli.net/2021/04/26/83o6xaXUbZmI5Rt.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/83o6xaXUbZmI5Rt.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>进入之后就可以指定 SSL 策略了；如果选择允许 SSL 连接，那么使用 Windows 资源管理器等软件的基本 FTP 的访问将还可以进行（当然，它们依然不安全）；如果选择需要 SSL 连接，等于强制 FTPS，此时只能通过支持 FTPS 协议的客户端来访问 FTP 服务器，当然，也相对更加安全。</p><h4 id="隐式-ftps">隐式 FTPS</h4><p>因为 FTPS 隐式是通过一个固定的端口 <code>990</code> 来确立安全连接的，所以我们需要使得我们的服务器允许来自 990 端口的连接；进入 FTP 服务器主页，在右侧的操作栏中找到“绑定”并进入；增加对 990 端口的监听，并将类型设置为 ftp，就像下面这样：</p><figure><img src="https://i.loli.net/2021/04/26/eTs6juVnYmqhKDX.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/eTs6juVnYmqhKDX.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p>这样重启服务器后，我们就可以通过支持 FTPS 的客户端，使用隐式的方式访问 FTP 服务器了；当然，即使不做这一步操作，我们也可以通过显式的方式使用 FTPS 协议访问 FTP 服务器。</p><h3 id="sftp">SFTP</h3><p>SFTP 和 FTP 完全不是一个东西；它借助了 <code>sshd</code> 运行，是 SSH 套件中的一个。所以在使用它之前，我们首先要在设置菜单中增加 OpenSSH 服务器功能；</p><p>然后，我们可以在管理员权限下的 Powershell 中运行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net <span class="built_in">start</span> sshd</span><br></pre></td></tr></table></figure><p>来启动 SSH 的守护进程；现在，我们应该可以在其他电脑上是用 SSH 或者客户端访问它了；使用支持 SFTP 的客户端（比如 Xftp 7）来访问它，可以直接访问到整个电脑的根目录。</p><p>当然，也可以像在 Linux 中修改 <code>sshd</code> 的配置文件一样修改；在 Windows 10 中，这个配置文件的绝对路径一般是 <code>C:\ProgramData\ssh\sshd_config</code>；</p><h4 id="限定某用户只能访问固定文件夹">限定某用户只能访问固定文件夹</h4><p>比如我们限制 <code>ftpuser</code> 只能访问 D 盘</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Match User ftpuser</span><br><span class="line">       ChrootDirectory D:\</span><br></pre></td></tr></table></figure><p>可以把上面的内容增加到 <code>sshd_config</code> 的末尾。</p><h4 id="限制本机-ssh-只能用来-sftp">限制本机 SSH 只能用来 SFTP</h4><p>将下面这句话增加到配置文件的末尾：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ForceCommand internal-sftp</span><br></pre></td></tr></table></figure><p>当然也可以配合缩进，限制特定用户的 SSH 功能（像上面那样）</p><h2 id="一些吐槽">一些吐槽</h2><p>配置过程中出现的一些神秘问题的记录</p><ul><li><p>XFTP 竟然不支持 FTPS，这是我万万没有想到的（</p></li><li><p>博主最开始尝试在 IIS 增加用户允许规则的时候甚至没有发挥作用，但是重新创建一个 FTP 服务器就没有问题了；只能说是十分神秘了（</p></li><li><p>SFTP 查看的文件列表似乎存在不全的情况，比如下图： <img src="https://i.loli.net/2021/04/26/SROZN2vk9Qrx3nI.png" class="lazyload" data-srcset="https://i.loli.net/2021/04/26/SROZN2vk9Qrx3nI.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="image.png" /></p><p>可以稳定地在各种客户端上复现，不知道是什么原因（）不然就用 SFTP 算了，谁搁着 FTPS 呢==</p></li></ul><p>哎，不能再折腾了，凑合着能用就要干活了，那这篇文章先到这里；如果有什么错误的话欢迎指正，如果可以解释上面的这些神秘问题的话也欢迎补充（）</p>]]></content>
    
    <summary type="html">
    
      因为学校校园网有大内网，所以一直就有用 RDP；但是在 RDP 里使用 QQ 传文件总显得非常的啥b，所以现在考虑使用 Windows 自带的 IIS 管理器启用 FTP 服务。
    
    </summary>
    
    
      <category term="折腾记录" scheme="https://shiraha.cn/categories/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="水" scheme="https://shiraha.cn/tags/%E6%B0%B4/"/>
    
      <category term="Windows 10" scheme="https://shiraha.cn/tags/Windows-10/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round#717 div.2 回顾</title>
    <link href="https://shiraha.cn/2021/codeforces-round-717-div2/"/>
    <id>https://shiraha.cn/2021/codeforces-round-717-div2/</id>
    <published>2021-04-23T18:51:18.000Z</published>
    <updated>2021-04-23T18:51:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="记录">记录</h2><p>比赛的那天 <a href="https://ksmeow.moe/">KS</a> 酱办生日聚会，所以玩的有点晚——于是为了避免掉分就又开了个小号——结果还真的算是预防成功了（（只能说不愧是我==</p><p>和<a href="https://shiraha.cn/2021/codeforces-round-716-div2/">上一场</a>一样的出题人，也是熟悉的五个题目；但是这场总感觉比之前那一场要难一些——可能出题人不经意间触及了我较多的知识盲区吧（</p><h2 id="题解">题解</h2><h3 id="a---tit-for-tat">A - <a href="https://codeforces.com/contest/1516/problem/A">Tit for Tat</a></h3><p>右手就行<del>可是我白给了一发</del>；只要取出前面的加到最后一个元素上就行了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = $.nextInt(), n, k;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        input, n, k;</span><br><span class="line">        $.nextArray(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span> (k &amp;&amp; l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">auto</span> ded = min(k, a[l]);</span><br><span class="line">            k -= ded, a[l] -= ded, a[r] += ded;</span><br><span class="line">            ++ l;</span><br><span class="line">        &#125;</span><br><span class="line">        $.putArray(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到底是什么样的小天才才能写出 <code>++ l, -- r</code> 这种代码呢？以为很对称🐎（</p><h3 id="b---agaga-xooorrr">B - <a href="https://codeforces.com/contest/1516/problem/B">AGAGA XOOORRR</a></h3><p>考虑到最后只可能剩下两个相同的元素或三个相同的元素——因为更多的元素都可以合并到这两种情况上，所以只需要分别处理即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2060</span>;</span><br><span class="line">uint a[N], sum[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = $.nextInt(), n;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        $(n).nextArray(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] ^ a[i];</span><br><span class="line">        <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (sum[i] == (sum[n] ^ sum[i]))</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; ++ j)</span><br><span class="line">                <span class="keyword">if</span> (sum[i] == (sum[j] ^ sum[i]) &amp;&amp;</span><br><span class="line">                    sum[i] == (sum[n] ^ sum[j]))</span><br><span class="line">                found = <span class="literal">true</span>;</span><br><span class="line">        $.put(found ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之前白给成了直接排除一个元素，显然这是不科学的（</p><h3 id="c---baby-ehab-partitions-again">C - <a href="https://codeforces.com/contest/1516/problem/C">Baby Ehab Partitions Again</a></h3><blockquote><p>提供长度为 <span class="math inline">\(n \leq 100\)</span> 的数组 <span class="math inline">\(a\)</span>，你要从中删除一些元素，使得不可以将这个数组拆分成两个部分，使得两个部分的和相等；要求最小化删除元素的数量并输出删除元素的坐标。</p></blockquote><p>首先，显然当 <span class="math inline">\(\sum_{i = 1}^n a_i\)</span> 是奇数的时候不用删除任何元素；然后，为偶数情况下可以进行背包 <span class="math inline">\(DP\)</span> 来判断是否可能完成这样的划分；如果可以，那么问题就变成了如何删除元素。</p><p>不难想到最多只会删除一个元素，那么问题就是删除什么样的元素；我最开始因为删除最小的元素然后白给了一<strong>些</strong>罚时，因为这样是不正确的——比如删除 <code>2</code>，可以通过交换两个 <code>2</code> 和一个 <code>5</code> 来使得再次平衡；那么我们在考虑其他的一定可行的情况，就不难想到删除一个奇数。</p><p>如果整个数组都是偶数怎么办？那么我们可以整体右移 <span class="math inline">\(1\)</span> 位，显然和原数组是等价的；我们可以一直右移，直到我们找到了可以删除的奇数为止；显然，这一定可以找到；</p><p>从右移等价，我们可以联想到整个数组除以任何同一个数都是等价的；所以，一个最简单的方法就是首先约去整个数组的 <span class="math inline">\(\gcd\)</span>，然后找到一个奇数删除就行了——因为是等价的，所以这样的删除是合理的；</p><h5 id="代码实现">代码实现</h5><p>这个使用 <code>bitset</code> 的可行性背包实现属实颇有雅趣（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2050</span>, M = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = accumulate(a + <span class="number">1</span>, a + <span class="number">1</span> + n, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sum % <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;N * M&gt; dp;</span><br><span class="line">    dp.<span class="built_in">set</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        dp |= (dp &lt;&lt; a[i]);</span><br><span class="line">    <span class="keyword">return</span> dp[sum / <span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> n = $.nextInt();</span><br><span class="line">    $.nextArray(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">if</span> (check(n)) &#123;</span><br><span class="line">        <span class="keyword">int</span> g = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            g = gcd(g, a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (a[i] / g % <span class="number">2</span>) &#123;</span><br><span class="line">                $.put(<span class="number">1</span>).put(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> $.put(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是这个卵题我白给了近十发，，我是真的菜（</p><h3 id="d---cut">D - <a href="https://codeforces.com/contest/1516/problem/D">Cut</a></h3><blockquote><p>给一个长度为 <span class="math inline">\(n \leq 10^5\)</span> 的数组 <span class="math inline">\(a\)</span>，进行 <span class="math inline">\(q\leq10^5\)</span> 次询问：每次询问关于一个区间 <span class="math inline">\([l, r]\)</span>，将它分成的最少的段数，使得每一段的 <span class="math inline">\(\text{LCM}\)</span> 都和连乘的乘积相等；求这个段数。</p></blockquote><p>首先，不难意识到 <span class="math inline">\(\text{LCM}\)</span> 和连乘积相等就是说这一段的 <span class="math inline">\(\gcd\)</span> 为 <span class="math inline">\(1\)</span>。那么问题就转化为了对于任意段 <span class="math inline">\([l, r]\)</span>，将它划分成互质的最小的段数。</p><p>那么一种很显然的想法就是对于范围内的所有质数（约 <span class="math inline">\(9600\)</span> 个）分别维护一个列表，包含了包含它为质因数的数字的下标；然后对于一个位置，对于它的每一个质因子在对应的表上二分查找出下一个位置，取最小值作为下一个区间开始的备选位置；但是这样做显然非常的啥b，因为有显而易见地简单优化<del>但是我也显而易见的没有想到</del>：</p><ul><li>我们可以倒着维护每一个质数的下一个位置，这样就不用对每个质数二分查找了</li><li>倒着转移的时候也考虑后一个位置的备选位置，这样就不用考虑到备选区间之间的冲突了</li></ul><p>那么这样，我们就可以维护出一个表 <span class="math inline">\(F_i\)</span>，表示从 <span class="math inline">\(i\)</span> 开始可以转移到的最远的备选位置；</p><p>但是这样还存在一个问题：如果所有的数字都是 <span class="math inline">\(1\)</span>，那么上面的做法会被卡成 <span class="math inline">\(n^2\)</span>；因此，为了能够快速的跳转求出区段数，我们可以利用倍增的思想，维护下两个、下四个备选位置；这样，就可以在 <span class="math inline">\(\log n\)</span> 的时间内完成转移，并且像二进制拆位那样构造出任何一个数字。</p><h5 id="代码实现-1">代码实现</h5><p>使用类筛的方法完成质因数分解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">9600</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], f[<span class="number">20</span>][N], to[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">decomposition</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">de</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (de[i].empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j += i)</span><br><span class="line">                de[j].push_back(i);</span><br><span class="line">            p.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(ref(p), ref(de));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, q, l, r;</span><br><span class="line">    $(n, q).nextArray(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">auto</span> [p, de] = decomposition(N);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; desc;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> ps = p.size();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> bound = n + <span class="number">1</span>;</span><br><span class="line">    desc.reserve(ps * <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ps; ++ i) &#123;</span><br><span class="line">        desc[p[i]] = i, to[i] = bound;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>][bound] = bound;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; -- i) &#123;</span><br><span class="line">        f[<span class="number">0</span>][i] = f[<span class="number">0</span>][i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> j : de[a[i]]) &#123;</span><br><span class="line">            minimize(f[<span class="number">0</span>][i], to[desc[j]]);</span><br><span class="line">            to[desc[j]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">20</span>; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= bound; ++ j)</span><br><span class="line">            f[i][j] = f[i - <span class="number">1</span>][f[i - <span class="number">1</span>][j]];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        $(l, r);</span><br><span class="line">        uint ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">            <span class="keyword">if</span> (f[i][l] &lt;= r) &#123;</span><br><span class="line">                ans += (<span class="number">1u</span> &lt;&lt; i);</span><br><span class="line">                l = f[i][l];</span><br><span class="line">            &#125;</span><br><span class="line">        $.put(ans + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即使可以想到正确的维护方法，但是倍增的思想也不能不说是十分的高妙…… 学到许多（</p><h3 id="e---baby-ehab-plays-with-permutations">E - <a href="https://codeforces.com/contest/1516/problem/E">Baby Ehab Plays with Permutations</a></h3><blockquote><p>现在有长度为 <span class="math inline">\(n \leq 10^9\)</span> 的排列 <span class="math inline">\(\{1, \dots,n\}\)</span>，可以进行对于两个不同的下标两两交换的操作 <span class="math inline">\(k \leq 200\)</span> 次；问对于 <span class="math inline">\([1, k]\)</span> 次操作可以得到的不同的排列数量；</p></blockquote><p>首先，先说明一种贪心地将长度为 <span class="math inline">\(n\)</span> 的排序 <span class="math inline">\(p\)</span> 复位的做法——对于排列的最后一个位置 <span class="math inline">\([n]\)</span>：</p><ul><li>如果 <span class="math inline">\(p_n = n\)</span>，那么可以忽略这个位置；将原排列看作长度为 <span class="math inline">\(n - 1\)</span></li><li>否则，将 <span class="math inline">\(p_n\)</span> 和 <span class="math inline">\(p_{p_n}\)</span> 交换位置；此时至少可以使得 <span class="math inline">\(p_n\)</span> 复位，继续递归，但是操作次数 <span class="math inline">\(+1\)</span></li></ul><p>可以证明，这样处理完整个序列就可以得到将序列 <span class="math inline">\(p\)</span> 复位的最小操作次数。</p><p>那么，基于这种思想，我们可以构造出一种递推关系——假设 <span class="math inline">\(F_{n, j}\)</span> 表示了进行 <span class="math inline">\(j\)</span> 次交换后可以复位的、长度为 <span class="math inline">\(n\)</span> 的排列（或者说从复位的排列开始，进行 <span class="math inline">\(j\)</span> 次交换可以产生的排列）的数量：</p><ul><li><span class="math inline">\(j = 0\)</span>：此时，只有初始复位的排列一种情况；因此总是为 <span class="math inline">\(1\)</span></li><li>现在，我们考虑通过 <span class="math inline">\(F_{n - 1}\)</span> 向 <span class="math inline">\(F_n\)</span> 转移；即每次将 <span class="math inline">\(n\)</span> 放入长度为 <span class="math inline">\(n - 1\)</span> 的排列中：<ul><li>如果新放入的 <span class="math inline">\(n\)</span> 不进行交换，那么对答案没有贡献：可以直接转移</li><li>如果和前面的 <span class="math inline">\(n - 1\)</span> 个位置中的一个进行交换：那么贡献 <span class="math inline">\(1\)</span> 次次数，有 <span class="math inline">\(n - 1\)</span> 种转移方法</li></ul></li><li>综上所述，可以得到递推公式 <span class="math inline">\(F_{n, j} = F_{n - 1, j} + (n - 1) \cdot F_{n - 1, j - 1}\)</span>；</li></ul><p>那么，基于这个动态规划，我们可以有两种不同的做法：</p><h4 id="阳间做法">阳间做法</h4><p>注意到题目中的 <span class="math inline">\(k\)</span> 非常的小，所以即使进行 <span class="math inline">\(k\)</span> 次交换，最多只会使得 <span class="math inline">\(2k\)</span> 个位置错位；所以我们每次只需要能选出错位的位置长度，然后对于在这个范围内的长度求 <span class="math inline">\(F_{n, j}\)</span> 即可；那么，一种很显然的做法就是确定一个允许的错位位置的长度 <span class="math inline">\(i\)</span>，对于这个长度求 <span class="math inline">\(F\)</span>，最后统一考虑——</p><p>那么，答案长下面这样吗？ <span class="math display">\[\text{ans?}_{j} = \sum_{i = 0}^{\min(2j, n)} \mathbf{C}_n^{i} \times F_{i, j}\]</span> 不，当然不对——因为我们的 <span class="math inline">\(F_{n, j}\)</span> 可能实际上只变动了其中很少一部分的位置——而这样的话就会不可避免的和其他情况重合，导致计数的不准确；所以为了解决这个问题，我们可以考虑在<a href="https://shiraha.cn/2021/The-concept-of-dearangement-problems/">错排问题</a>种采用的解决方法——使用容斥原理包含/排除重复的部分：</p><ul><li>现在，我们定义 <span class="math inline">\(G_{n, j}\)</span> 和 <span class="math inline">\(F_{n, j}\)</span> 类似，但是每一个位置都是错排的情况数量</li><li>然后，我们在 <span class="math inline">\(F_{n, j}\)</span> 中选择一个位置固定，然后剩下的位置的任何排序就都符合要求，需要排除</li><li>但是这样的话，就会导致两个位置固定的情况被多排除了一次，需要重新包含</li><li>……</li></ul><p>所以，我们就可以在 <span class="math inline">\(\mathcal{O}(k^2)\)</span> 的时间内完成一次 <span class="math inline">\(G\)</span> 的求解；算法总复杂度是 <span class="math inline">\(\mathcal{O}(k^3)\)</span>。</p><h5 id="代码实现-2">代码实现</h5><p>一个很容易注意到的事情就是 <span class="math inline">\(\text{ans}_i\)</span> 可以由 <span class="math inline">\(\text{ans}_{i - 2}\)</span> 转移过来——因为你可以连续两次进行相同的交换来浪费两次交换机会== 由此，也很容易联想到奇偶分开（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">longs inv[N], c[N][N], f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initInverse</span><span class="params">(<span class="keyword">int</span> n, longs p)</span> </span>&#123;</span><br><span class="line">    inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        inv[i] = (p - p / i) * inv[p % i] % p;</span><br><span class="line">    inv[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">longs <span class="title">nCr</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    longs ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - r + <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        ret = ret * i % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; ++ i)</span><br><span class="line">        ret = ret * inv[i] % mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = $.nextInt(), k = $.nextInt();</span><br><span class="line">    c[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * k; ++ i) &#123;</span><br><span class="line">        f[i][<span class="number">0</span>] = <span class="number">1</span>, c[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * k; ++ j) &#123;</span><br><span class="line">            f[i][j] = (f[i - <span class="number">1</span>][j] + (i - <span class="number">1</span>) * f[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">            c[i][j] = (c[i - <span class="number">1</span>][j] + c[i - <span class="number">1</span>][j - <span class="number">1</span>]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    initInverse(<span class="number">2</span> * k, mod);</span><br><span class="line">    longs ans[] = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++ j) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> lim = min(n, <span class="number">2</span> * j);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= lim; ++ i) &#123;</span><br><span class="line">            longs cnt = <span class="number">0</span>, fix, fl;</span><br><span class="line">            <span class="keyword">for</span> (fix = <span class="number">0</span>, fl = <span class="number">1</span>; fix &lt;= i; ++ fix, fl = -fl) &#123;</span><br><span class="line">                cnt = cnt + fl * c[i][fix] * f[i - fix][j] % mod;</span><br><span class="line">                <span class="keyword">do</span> cnt = (cnt + mod) % mod; <span class="keyword">while</span> (cnt &lt; <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            ans[j % <span class="number">2</span>] = (ans[j % <span class="number">2</span>] + nCr(n, i) * cnt) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        out.push_back((<span class="keyword">int</span>) ans[j % <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    $.putArray(out.begin(), out.end());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些说明：很显然 <span class="math inline">\(\mathbf{C}_i^j = \mathbf{C}_{i - 1}^j + \mathbf{C}_{i - 1}^{j - 1}\)</span>；</p><h4 id="阴间做法">阴间做法</h4><p>首先，我们需要先观察上面得到的那个递推公式，并考虑更深刻的理解它：</p><ul><li>考虑到 <span class="math inline">\(F_{n, 0} = 1\)</span>，除了递推的转移引入之外，都是通过 <span class="math inline">\(n - 1\)</span> 的形式引入的；</li><li>什么情况下会引入 <span class="math inline">\(n - 1\)</span>？当新加入的 <span class="math inline">\(n\)</span> 不放在 <span class="math inline">\([n]\)</span> 而是参与了与前面的位置交换的场合下；</li><li>引入时产生了什么副作用？因为进行了交换，所以奉献了一次交换次数，<span class="math inline">\(j = j + 1\)</span>；</li><li>所以，我们可以将 <span class="math inline">\(F_{n, j}\)</span> 看作从“下标”集合 <span class="math inline">\([0, n - 1]\)</span> 中选出一个大小 <span class="math inline">\(j\)</span> 的子集求积后求和的结果；</li></ul><p>形式化的说，我们可以得到下面的 <span class="math inline">\(F_{n, j}\)</span> 的表示形式： <span class="math display">\[F_{n, j} = \sum_{s \subset [0, n - 1] \and |s| = j} \ \prod_{i = 1}^j s_i\]</span> 那么接下来，对于全部需要的 <span class="math inline">\(j\)</span>，我们考虑从 <span class="math inline">\(F_{n}\)</span> 转移到 <span class="math inline">\(F_{2n}\)</span>：</p><ul><li><p>一个很显然的想法，就是我们从 <span class="math inline">\([0, n - 1]\)</span> 中选择 <span class="math inline">\(l\)</span> 个，从 <span class="math inline">\([n, 2n - 1]\)</span> 中选出剩下的，组成上面所提到的从集合 <span class="math inline">\([0, 2n-1]\)</span> 中选出的大小为 <span class="math inline">\(j\)</span> 子集；形式化地说就是将两部分的结果乘起来</p></li><li><p>前半部分的答案很显然是 <span class="math inline">\(F_{n, l}\)</span>，而后半部分的答案我们没有维护；但是我们可以把它看作从 <span class="math inline">\([0, n - 1]\)</span> 中选择了 <span class="math inline">\(j - l\)</span> 个，然后对于每一个都加上了 <span class="math inline">\(n\)</span>，也就是下面这样： <span class="math display">\[F&#39;_{n, j&#39;} = \sum_{s\subset [n, 2n-1] \and |s| = j&#39;} \ \prod_{i = 0}^{j&#39;}s_{i} = \sum_{s\subset [0, n-1] \and |s| = j&#39;} \ \prod_{i = 0}^{j&#39;}(s_{i} + n)\]</span> 那么这个式子展开是什么样的呢？因为这个连乘长得非常像二项式展开<del>但是不是，残念（</del>，所以我们可以想象一下它展开后的样子： <span class="math display">\[F&#39;_{n, j&#39;} = \sum_{l = 0}^{j&#39;} \mathbf{C}_{n - l}^{j&#39;-l} \times n^{j&#39;-l} \times \sum_{s\subset [0, n-1] \and |s| = l} \prod_{i = 0}^{l}s_i\]</span> 上面的式子中，有 <span class="math inline">\(\mathbf{C}_{n - l}^{j&#39; - l} = \mathbf{C}_n^{j&#39;} \times \mathbf{C}_{j&#39;}^l\)</span>；首先是选出坐标的组合数，然后乘上“二项式系数”。</p></li><li><p>然后，观察上面的式子的后半部分，我们会惊喜地发现它就是 <span class="math inline">\(F_{n, l}\)</span>，是我们已经维护的东西！</p></li></ul><p>综上所述，我们可以通过下面的转移方程完成从 <span class="math inline">\(F_{n}\)</span> 到 <span class="math inline">\(F_{2n}\)</span> 的转移： <span class="math display">\[F_{2n, J} = \sum_{j = 0}^J F_{n, j} \times F&#39;_{n, j&#39;},  \ \ j + j&#39; = J\]</span> 上式中的 <span class="math inline">\(F&#39;_{n, j}\)</span> 可以通过 <span class="math inline">\(F_{n, j}\)</span> 通过下面的多项式乘法转移得到： <span class="math display">\[F&#39;_{n, j} = \sum_{l = 0}^j \mathbf{C}_{n - l}^{j - l} \times n^{j - l} \times F_{n, l}\]</span> 当然，基础的从 <span class="math inline">\(F_{n - 1, j}\)</span> 和 <span class="math inline">\(F_{n - 1, j - 1}\)</span> 向 <span class="math inline">\(F_{n, j}\)</span> 的转化仍然有效；因此我们可以转化到任何的 <span class="math inline">\(n\)</span>：相当于我们从 <span class="math inline">\(n = 1\)</span> 出发，然后使用 <span class="math inline">\(\times2\)</span> 和 <span class="math inline">\(+1\)</span> 操作构造任何的 <span class="math inline">\(n\)</span> ——在构造的过程中完成上面的转移就可以了；一种很显然的思路就是二进制拆位，然后按位构造 <span class="math inline">\(n\)</span>：</p><h5 id="代码实现-3">代码实现</h5><p>基本的思路就是每次扩增 <span class="math inline">\(\times2\)</span>，如果这一位为 <code>1</code> 就再额外进行一次 <span class="math inline">\(+1\)</span> 扩增：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">longs inv[N], f[N], big[N], np[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initInverse</span><span class="params">(<span class="keyword">int</span> n, longs p)</span> </span>&#123;</span><br><span class="line">    inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        inv[i] = (p - p / i) * inv[p % i] % p;</span><br><span class="line">    inv[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">longs <span class="title">nCr</span><span class="params">(longs n, longs r)</span> </span>&#123;</span><br><span class="line">    longs ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = n - r + <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        ret = ret * i % mod;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= r; ++ i)</span><br><span class="line">        ret = ret * inv[i] % mod;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculateBig</span><span class="params">(<span class="keyword">int</span> k, longs n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(big, <span class="number">0</span>, <span class="keyword">sizeof</span>(longs) * (k + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(np, <span class="number">0</span>, <span class="keyword">sizeof</span>(longs) * (k + <span class="number">1</span>));</span><br><span class="line">    np[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++ i)</span><br><span class="line">        np[i] = n * np[i - <span class="number">1</span>] % mod;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> lim = min((longs)k, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= lim; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++ j) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = nCr(n - j, i - j) * f[j] % mod * np[i - j] % mod;</span><br><span class="line">            big[i] = (big[i] + t) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = $.nextInt(), k = $.nextInt();</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">bitset</span>&lt;32&gt; binary = n;</span><br><span class="line">    initInverse(N - <span class="number">1</span>, mod);</span><br><span class="line">    longs now = f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">30</span> - __builtin_clz(n); i &gt;= <span class="number">0</span>; -- i) &#123;</span><br><span class="line">        calculateBig(k, now);</span><br><span class="line">        <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(longs) * (k + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= k; ++ s)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> b = <span class="number">0</span>; b &lt;= k; ++ b)</span><br><span class="line">                <span class="keyword">if</span> (s + b &lt;= k)</span><br><span class="line">                    tmp[s + b] = (tmp[s + b] + f[s] * big[b]) % mod;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(f, tmp, <span class="keyword">sizeof</span>(longs) * (k + <span class="number">1</span>));</span><br><span class="line">        now *= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (binary.test(i)) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span>(longs) * (k + <span class="number">1</span>));</span><br><span class="line">            tmp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++ j)</span><br><span class="line">                tmp[j] = (f[j] + now * f[j - <span class="number">1</span>]) % mod;</span><br><span class="line">            <span class="built_in">memcpy</span>(f, tmp, <span class="keyword">sizeof</span>(longs) * (k + <span class="number">1</span>));</span><br><span class="line">            ++ now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    longs ans[] = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++ j) &#123;</span><br><span class="line">        ans[j % <span class="number">2</span>] = (ans[j % <span class="number">2</span>] + f[j]) % mod;</span><br><span class="line">        out.push_back((<span class="keyword">int</span>) ans[j % <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    $.putArray(out.begin(), out.end());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中的 <code>30 - __builtin_clz(n)</code> 的含义是： <code>int</code> 类型的 <code>n</code> 的最高位的 <code>1</code> 的所在的位置的低一位的下标；我们使用它作为扩增起点——不使用最高位的原因是我们已经从 <span class="math inline">\(1\)</span> 出发了，所以不需要对于首位的 <span class="math inline">\(1\)</span> 进行额外的扩增。</p><p>当然，上面的实现中的每次转移的时间复杂度是 <span class="math inline">\(\mathcal{O}(k^2)\)</span> 的，进行 <span class="math inline">\(\log_2n\)</span> 次转移；如果可以使用各种手段加快单次转移的速度，理论上可以做到 <span class="math inline">\(k \leq 10^5\)</span>（时间复杂度 <span class="math inline">\(\mathcal{O}(k\cdot \log k\log n)\)</span>）<del>但是我不会，原作者也不会</del></p><h2 id="后记">后记</h2><p>罚时是真的多，，明明还是可以回到 1700 的场嗯给我打成了防掉分场，只能说非常地不行了（</p><figure><img src="https://i.loli.net/2021/04/24/gTZwqeCs2iHVomn.jpg" class="lazyload" data-srcset="https://i.loli.net/2021/04/24/gTZwqeCs2iHVomn.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="JVS2TR2_F28UCRC3K_YG_3B.jpg" /><figcaption aria-hidden="true">JVS2TR2_F28UCRC3K_YG_3B.jpg</figcaption></figure><p>最近的准度不行啊，还是以后要多加注意才行；补题也要进行的更加迅速才行，不然题目真的补不完力<del>昨天半夜的 Div.1 + Div.2 还没有下落呜呜</del>（呜呜呜</p>]]></content>
    
    <summary type="html">
    
      新的小号袭来——本来以为开小号只是杞人忧天，但是没想到或许还真的防到了……？这不对劲（
    
    </summary>
    
    
      <category term="题解" scheme="https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="算法" scheme="https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM" scheme="https://shiraha.cn/tags/ACM/"/>
    
      <category term="Codeforces" scheme="https://shiraha.cn/tags/Codeforces/"/>
    
  </entry>
  
  <entry>
    <title>基础知识：错排问题</title>
    <link href="https://shiraha.cn/2021/The-concept-of-dearangement-problems/"/>
    <id>https://shiraha.cn/2021/The-concept-of-dearangement-problems/</id>
    <published>2021-04-22T12:12:51.000Z</published>
    <updated>2021-04-22T12:12:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>什么是错排问题？<strong>重排</strong>指的是在排列组合中，一个排列的所有的元素都不在原来的位置上；更加地形式化说明的话，就是对于一个包含 <span class="math inline">\(1\cdots n\)</span> 全部 <span class="math inline">\(n\)</span> 个元素的排列 <span class="math inline">\(p\)</span>，按照 <span class="math inline">\(1\)</span>-下标方法，对于任何 <span class="math inline">\(i \in [1, n]\)</span> 都满足 <span class="math inline">\(p_i \ne i\)</span>；这类问题常见的应用有信封问题（经典原型），书架问题（换皮原型）等。</p><p>那么，这篇文章着眼于如何推出错排问题的式子，以及它的简化式子展开介绍：</p><h2 id="递推公式">递推公式</h2><p>现在，我们假设有一个包含 <span class="math inline">\(1\cdots n\)</span> 全部 <span class="math inline">\(n\)</span> 个元素的排列 <span class="math inline">\(p\)</span>，并且按照 <span class="math inline">\(1\)</span>-下标方法定位；最开始时，对于任何 <span class="math inline">\(i \in [1, n]\)</span> 都满足 <span class="math inline">\(p_i = i\)</span>；那么我们对它进行操作，将它变成一个重排：</p><ul><li><p>首先从原来的序列中取出一个下标；因为不管选择哪个都是等价的，我们选择 <span class="math inline">\([n]\)</span> 位置，取出 <span class="math inline">\(n\)</span></p></li><li><p>再从剩下来的 <span class="math inline">\(n - 1\)</span> 个正确的位置中，选择一个位置 <span class="math inline">\([k]\)</span>；我们将要把 <span class="math inline">\(n\)</span> 放入 <span class="math inline">\([k]\)</span> 位置，取出 <span class="math inline">\(k\)</span></p><p>显然，这一步对于位置 <span class="math inline">\([k]\)</span> 的选择有 <span class="math inline">\(n - 1\)</span> 种不同的选择。</p></li><li><p>接下来，我们要将 <span class="math inline">\(k\)</span> 放回序列中；我们有两种选择：</p><ul><li><p>将 <span class="math inline">\(k\)</span> 放入位置 <span class="math inline">\([n]\)</span>；这样相当于交换了 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(k\)</span> 的位，使得了这两个位置符合了错排的考虑</p><p>现在还剩下 <span class="math inline">\(n - 2\)</span> 个位置，它们都是有序的；可以被作为一个子问题递归地处理</p></li><li><p>将 <span class="math inline">\(k\)</span> 放入位置 <span class="math inline">\([i \ne n]\)</span>，也就是不放入位置 <span class="math inline">\([n]\)</span>；这种情况下，我们可以这样考虑：</p><ul><li>对于位置 <span class="math inline">\([k] = n\)</span>，已经是确定的了，所以可以忽略它</li><li>我们暂时将 <span class="math inline">\(k\)</span> 放入 <span class="math inline">\([n]\)</span>，因为最终会将 <span class="math inline">\(k\)</span> 放到其他位置上，所以可以认为此时是未重排状态</li><li>此时，剩下的排列包含了 <span class="math inline">\(n - 1\)</span> 个元素，它们都“未经过重排”，可看作一个子问题递归</li></ul></li><li><p>综上所述，第一种选择是作为 <span class="math inline">\(n - 2\)</span> 的子问题，第二种选择 <span class="math inline">\(n - 1\)</span> 的子问题递归。</p></li></ul></li><li><p>那么，由于乘法法则和加法法则；令 <span class="math inline">\(D_n\)</span> 表示长度为 <span class="math inline">\(n\)</span> 的重排排列的数量，那么可得到：</p></li></ul><p><span class="math display">\[D_n = (n - 1) \cdot (D_{n - 1} + D_{n - 2})\]</span></p><p>且特殊地存在 <span class="math inline">\(D_0 = 1\)</span> 和 <span class="math inline">\(D_1 = 0\)</span>；这就是我们得到的第一个递推式子；</p><h3 id="化简">化简</h3><p>这一步的化简网上一般有两种做法；作者选择了她喜欢的一种详细介绍：</p><hr /><p>对于上述得到的重排公式，我们在等式的两侧同时减去 <span class="math inline">\(nD_{n -1}\)</span>，可得： <span class="math display">\[\begin{align}D_n - nD_{n - 1} &amp;= -D_{n - 1} + (n - 1)D_{n - 2} \\                 &amp;= -[D_{n - 1} - (n - 1)D_{n - 2}] \\                 &amp;= (-1)^2[D_{n - 2} - (n - 2)D_{n - 3}] \\                 &amp;= \cdots \\                 &amp;= (-1)^{n - 1}(D_1 - D_0) \\                 &amp;= (-1)^n\end{align}\]</span> 所以，可以得到化简后的递推公式：<span class="math inline">\(D_n = nD_{n - 1} + (-1)^n\)</span>，特别地 <span class="math inline">\(D_1 = 0\)</span>；</p><hr /><p>另一种的做法假设 <span class="math inline">\(D_n = n!M_n\)</span>，那么 <span class="math inline">\(M_1 = 0\)</span>，<span class="math inline">\(M_2 = \frac12\)</span>；</p><p>对于 <span class="math inline">\(n \geq 3\)</span> 的场合，将第一个递推公式 <span class="math inline">\(D_n = (n - 1) \cdot (D_{n - 1} + D_{n - 2})\)</span> 根据定义拆分： <span class="math display">\[\begin{align}n!M_n &amp;= (n - 1)(n - 1)!M_{n - 1} + (n - 1)(n - 2)!M_{n - 2} \\      &amp;= n!M_{n - 1} - (n - 1)!M_{n - 1} + (n - 1)!M_{n - 2} \\n!M_n - n!M_{n - 1} &amp;= -((n - 1)!M_{n - 1} - (n - 1)!M_{n - 2}) \\M_n - M_{n - 1} &amp;= -\frac1n(M_{n - 1} - M_{n - 2}) \\\end{align}\]</span> 其实这种推导和上面的是完全等价的——不如说看起来几乎完全没有怎么化简；只是因为这种推导方法在得到通项公式的时候更加的自然<del>再推导一步就得到通项公式了，所以删了（</del>。</p><h2 id="通项公式">通项公式</h2><p>只有递推公式有的时候是不够的，所以我们还需要依据上面求出的递推公式求出通项公式；这里作者提供了三种不同的推导方法：</p><h3 id="套公式">套公式</h3><p>对于形如 <span class="math inline">\(f(n) = g(n)f(n - 1) + h(n)\)</span> 的递推方程，经过暴力展开，可以得到下面的公式： <span class="math display">\[f(n) = \prod_{i = 1}^n g(i) \cdot [f(0) + \sum_{i = 1}^n \frac{h(i)}{\prod_{j = 1}^ig(j)}]\]</span> 对于我们求得的递推公式 <span class="math inline">\(D_n = nD_{n - 1} + (-1)^n\)</span>，不难通过观察得出三个部分是 <span class="math inline">\(f(x) = D_x\)</span>、<span class="math inline">\(g(x) = x\)</span>、<span class="math inline">\(h(x) = (-1)^x\)</span>；带入上面的暴力公式中，可以求出： <span class="math display">\[D_n = n! \cdot [1 + \sum_{k = 1}^n \frac{(-1)^k}{k!}] = n! \cdot \sum_{k = 0}^n \frac{(-1)^k}{k!}\]</span> 那么就得到了错排数量的通项公式。</p><h3 id="继续推导">继续推导</h3><p>在板块一提到的第二种方法化简得到的：<span class="math inline">\(M_n - M_{n - 1} = -\frac1n(M_{n - 1} - M_{n - 2})\)</span>；我们将代入多个 <span class="math inline">\(n\)</span> 并将得到的式子的左侧和右侧全部相加，可以得到： <span class="math display">\[\begin{align}M_n - M_1 &amp;= (-1)^2\frac1{2!} + (-1)^3\frac1{3!}+\dots+(-1)^n\frac1{n!} \\M_n &amp;= \sum_{k = 2}^n (-1)^n\frac1{k!} + 1 + (-1)\frac1{1!} \\M_n &amp;= \sum_{k = 0}^n (-1)^n\frac1{k!}\end{align}\]</span> 又因为 <span class="math inline">\(D_n = n!M_n\)</span>，所以 <span class="math inline">\(D_n = n!\cdot\sum_{k = 0}^n (-1)^n\frac1{k!}\)</span>，和上面的化简结果一样。</p><h3 id="容斥定理">容斥定理</h3><p>对于长度为 <span class="math inline">\(n\)</span> 的排列，一共有 <span class="math inline">\(n!\)</span> 种不同的排列；我们要求的重排排列是它的子集；因此我们考虑，如果我们将所有不是重排排列的情况去除，那么剩下的就全部是重排排列了！</p><p>假定排列的长度为 <span class="math inline">\(n\)</span>，我们令 <span class="math inline">\(A_i\)</span> 为满足 <span class="math inline">\(p[i] = i\)</span> 的排列种数，那么显然可以得到： <span class="math display">\[\begin{align}|A_i| &amp;= (n - 1)! \\|A_i \cap A_j| &amp;= (n - 2)! \\|A_i \cap A_j \cap A_k| &amp;= (n - 3)! \\&amp;\vdots\end{align}\]</span></p><p>因此，每个元素都不在对应位置的时间就是对于 <span class="math inline">\(1 \leq i \leq n\)</span> 的 <span class="math inline">\(\overline{A_i}\)</span>： <span class="math display">\[\begin{align}\bigcap_{i = 1}^n \overline{A_i} &amp;= n! - \mathbf{C}_n^1(n - 1)! + \mathbf{C}_n^2(n - 2)! - \cdots \mp \mathbf{C}_n^{n - 1}2! \pm \mathbf{C}_n^n1! \\&amp;= \sum_{k = 0}^n (-1)^k \cdot \mathbf{C}_n^k(n - k)! \\&amp;= n!\sum_{k = 0}^n (-1)^k \cdot \frac1{k!}\end{align}\]</span> 显然，这也和之前的推导结果是一致的；</p><hr /><p>那么我们可以怎么理解式子中的加加减减呢？我们首先删除以每一个 <span class="math inline">\(i\)</span> 不满足的位置，但是这样对于排列中出现了两个不满足的位置的情况额外减了一次，所以要加回来——首先组合选出两个位置，然后其他的位置全排列；但是这样又会导致有三个不满足的位置的情况多加了…… 以此类推直到所有的位置都不正确的唯一情况。</p><h3 id="母函数方法">母函数方法</h3><figure><img src="https://i.loli.net/2021/04/22/aSxhz4twsqeZD7f.jpg" class="lazyload" data-srcset="https://i.loli.net/2021/04/22/aSxhz4twsqeZD7f.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="阿哲，一下子给我整不会了.jpg" /><figcaption aria-hidden="true">阿哲，一下子给我整不会了.jpg</figcaption></figure><p><a href="https://baike.baidu.com/item/%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98/3849290#2_2">百度百科的证法</a>实在是太过玄妙，，如果有看懂了的欢迎讲给博主听（</p><h2 id="化简公式">化简公式</h2><p>但是在算法竞赛中使用这样的超级复杂的多项式通项公式约等于没有，甚至效率不如直接递推；所以我们需要使用起来更加方便的通项公式：</p><p>首先我们考虑 <span class="math inline">\(e^x\)</span> 的幂级数展开（麦克劳林公式/泰勒展开）： <span class="math display">\[\forall x \in \mathbb{C}, \ e^x = \sum_{n = 0}^{+\infty}\frac{x^n}{n!} \approx 1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} + \cdots + \frac{x^n}{n!}\]</span></p><p>泰勒展开后面还带一个余项，不过这我就真的不会了<del>高数早就还给微积分老师力</del>（</p><p>对于 <span class="math inline">\(x = -1\)</span>，我们可以得到如下的泰勒展开式： <span class="math display">\[e^{-1} = \sum_{i = 0}^n \frac{(-1)^i}{i!} + R_n \ , \ R_n = \frac{e^{-c}(c - 1)^n}{(n + 1)!} \ , \ c \in [0, 1]\]</span> 所以，我们可以认为：<span class="math inline">\(e^{-1} = \frac{D_n}{n!} + R_n\)</span>，或者 <span class="math inline">\(n!e^{-1} - D_n = n!R_n\)</span>；又因为余项 <span class="math inline">\(R_n\)</span> 在 <span class="math inline">\(c\)</span> 取 <span class="math inline">\(c = 0\)</span> 时取到上界 <span class="math inline">\(\frac1{(n + 1)!}\)</span>，因此可以得到： <span class="math display">\[|n!\cdot e^{-1} - D_n| = |n!\cdot R_n| \leq \frac{n!}{(n + 1)!} = \frac1{n + 1}\]</span> 在我们的通项公式的可行域 <span class="math inline">\(n \geq 1\)</span> 中，显然满足 <span class="math inline">\(\frac1{n + 1} \leq \frac12\)</span>；因此我们可以认为 <span class="math inline">\(D_n\)</span> 和最接近 <span class="math inline">\(\frac{n!}e\)</span> 的整数相同；所以最后我们可以将化简后的通项公式写成下面这样： <span class="math display">\[D_n = \lfloor \frac{n!}e + \frac12\rfloor\]</span> 向下取整在代码中实现也非常方便，就达到化简通项公式的目的。</p><h2 id="练习题">练习题</h2><p>这种裸题应该还是挺多的；所以我就随便挂一个经典原型了：</p><h3 id="cses.fi-1717"><a href="https://cses.fi/problemset/task/1717/"><code>cses.fi</code> 1717</a></h3><blockquote><p>有 <span class="math inline">\(n\)</span> 个小盆友，每个小盆友都买了一个圣诞礼物与其他的小盆友交换；要求每个小盆友都要得到来自其他小盆友的礼物；问一共有多少种交换方式。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n; input, n;</span><br><span class="line">    ans[<span class="number">0</span>] = ans[<span class="number">2</span>] = <span class="number">1</span>, ans[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (longs i = <span class="number">3</span>; i &lt;= n; ++ i)</span><br><span class="line">        ans[i] = <span class="keyword">int</span>((ans[i - <span class="number">1</span>] + ans[i - <span class="number">2</span>])</span><br><span class="line">                        % mod * (i - <span class="number">1</span>) % mod);</span><br><span class="line">    output, ans[n], <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为数据范围很小，所以只需要使用递推公式就可以通过此题了。</p><h2 id="后记">后记</h2><p>虽然推的时候还是很痛苦的，但是写博文的时候又觉得言之无物，，看来还是昨天晚上睡少了（</p><p>如果有机会的话再完善一下关于错排生成算法的东西吧……</p><h3 id="参考资料">参考资料</h3><ul><li><a href="https://blog.csdn.net/Ber_Bai/article/details/77112975" class="uri">https://blog.csdn.net/Ber_Bai/article/details/77112975</a></li><li><a href="https://baike.baidu.com/item/%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98/3849290" class="uri">https://baike.baidu.com/item/%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98/3849290</a></li></ul>]]></content>
    
    <summary type="html">
    
      一个很基本的问题，但是确实是我的知识盲区…… 用某有人的话说，这全国卷 II 的数学老师都会提及的经典问题，而我作为全国卷 I 地区的人竟然不知道，属实有些可怕（
    
    </summary>
    
    
      <category term="算法" scheme="https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="算法" scheme="https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM" scheme="https://shiraha.cn/tags/ACM/"/>
    
      <category term="组合数学" scheme="https://shiraha.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="推导" scheme="https://shiraha.cn/tags/%E6%8E%A8%E5%AF%BC/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round#716 div.2 回顾</title>
    <link href="https://shiraha.cn/2021/codeforces-round-716-div2/"/>
    <id>https://shiraha.cn/2021/codeforces-round-716-div2/</id>
    <published>2021-04-21T06:15:36.000Z</published>
    <updated>2021-04-21T06:15:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>补题地址：<a href="https://codeforces.com/contest/1514" class="uri">https://codeforces.com/contest/1514</a></p></blockquote><h2 id="记录">记录</h2><p>就是我上一篇博文中提到的那个因为记错时间而忘记打的 Div2；顺便一提，这一场的下一场也是非经典时间 21:35 开始，希望可以正常打起来吧……？</p><p>曾经也在本博客的博文里登场的学弟打了 ABD 三个题，C 题奇妙的被 hack 了（）着实有点恐怖；本以为我至少也能打个 ABCD 的，没想到 CD 全都挂了，，属实不行==</p><h2 id="题解">题解</h2><h3 id="a---perfectly-imperfect-array">A - <a href="https://codeforces.com/contest/1514/problem/A">Perfectly Imperfect Array</a></h3><p>逻辑关系略绕，但是也没啥好说的（）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">120</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; pre;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = $.nextInt(), n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1e4</span>; ++ i)</span><br><span class="line">        pre.insert(i * i);</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        $(n).nextArray(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            found |= !pre.count(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        output, found ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>, <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该算是有手就行吧，主要就是看能几分钟写出来了）</p><h3 id="b---and-0-sum-big">B - <a href="https://codeforces.com/contest/1514/problem/B">AND 0, Sum Big</a></h3><p>因为要求和最大，把每一个数字按照二进制拆分，那么就是每一位的 <span class="math inline">\(1\)</span> 尽可能的多；又因为所有的数的按位与的和为 <span class="math inline">\(0\)</span>，所以每一个位都要有一个 <span class="math inline">\(0\)</span>，那么问题就变成将每一位的 <span class="math inline">\(0\)</span> 分配到不同的数字中了。显然，对于总长度为 <span class="math inline">\(k\)</span> 二进制数字，每一位都可以安放在任何数字中，总共有 <span class="math inline">\(n^k\)</span> 种。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">longs <span class="title">fastPow</span><span class="params">(longs a, longs b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    longs ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1u</span>) ans = (ans * a) % mod;</span><br><span class="line">        a = (a * a) % mod;</span><br><span class="line">        b &gt;&gt;= <span class="number">1u</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, k, T;</span><br><span class="line">    input, T;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        input, n, k;</span><br><span class="line">        output, fastPow(n, k), <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经典看样例猜做法（</p><h3 id="c---product-1-modulo-n">C - <a href="https://codeforces.com/contest/1514/problem/C">Product 1 Modulo N</a></h3><blockquote><p>给 <span class="math inline">\(n \leq 10^5\)</span>；现在要求求出 <span class="math inline">\(1, \dots, n-1\)</span> 的最长子序列 <span class="math inline">\(a\)</span>，满足 <span class="math inline">\(\prod a_i \mod n \equiv 1\)</span>；输出子序列 <span class="math inline">\(a\)</span> 的长度以及它包含的元素；</p></blockquote><p>一种很显然的想法是现将它们都乘起来，然后取余数，再将余数的数字从列表中删除（当然，如果为 1 就算了）从而得到了答案序列；如果再打表的话还会意识到如果 <span class="math inline">\(n\)</span> 是素数，那么答案是 <span class="math inline">\(1, \dots, n-2\)</span>；但是再稍微打表就会意识到，如果 <span class="math inline">\(n\)</span> 不是素数，那么你删除模数之后的乘积未必是 1，于是这种做法显而易见的错误了——毕竟就连样例都过不了（</p><p>稍事思考：对于任何数 <span class="math inline">\(n\)</span> 都显然有 <span class="math inline">\(\gcd(1, n) = 1\)</span>；由辗转相除法的转移式子 <code>gcd(a, b) = gcd(b, a % b)</code> 可知 <span class="math inline">\(\gcd(\prod a_i \mod n, n) = \gcd(\prod a_i, n)\)</span>；联立一下就是我们选择的序列的乘积和 <span class="math inline">\(n\)</span> 互素：如果这样，那么选择的序列中的每一个 <span class="math inline">\(a_i\)</span> 都应该和 <span class="math inline">\(n\)</span> 互素（这是必要条件）；在这样的基础上，我们先以此作为标准，过滤掉所有和 <span class="math inline">\(n\)</span> 不互质的数字。</p><p>同理，我们可以通过将剩下的数字全部乘起来取模，得到这个很大的数字和 <span class="math inline">\(n\)</span> 的最大公因数；因为现在所有的数字都和 <span class="math inline">\(n\)</span> 互素，所以这个因子一定出现在了我们选择的数字中；此时我们只要把它移除就可以了；<del>当然，如果你打表，你也能发现在删除了所有的不互质的数字之外还需要删除一个数字（</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = $.nextInt();</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    longs tmp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">        <span class="keyword">if</span> (gcd(i, n) == <span class="number">1</span>) &#123;</span><br><span class="line">            ans.insert(i);</span><br><span class="line">            tmp = tmp * i % n;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (tmp != <span class="number">1</span>) ans.erase((<span class="keyword">int</span>)tmp);</span><br><span class="line">    $.put(ans.size()).putArray(ans.begin(), ans.end());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看代码也能看出来这个过程实际上非常的自然；但是说又说不清楚…… 只能说需要补习数论了==</p><h3 id="d---cut-and-stick">D - <a href="https://codeforces.com/contest/1514/problem/D">Cut and Stick</a></h3><blockquote><p>定义“好序列”是其中没有元素出现的次数超过 <span class="math inline">\(\lceil \frac{n}2 \rceil\)</span>，其中 <span class="math inline">\(n\)</span> 是序列的长度；对于一个序列，如果它不是好序列，但你可以将它划分为 <span class="math inline">\(m\)</span> 个子序列，它们都是好序列，那么这个序列的权值是 <span class="math inline">\(m\)</span>；显然，对于一个好序列自身而言，它的权值是 <span class="math inline">\(1\)</span>。</p><p>现提供长度为 <span class="math inline">\(n \leq 3 \cdot 10^5\)</span> 的序列；进行 <span class="math inline">\(q \leq 3 \cdot 10^5\)</span> 次询问：每次询问 <span class="math inline">\([l, r]\)</span> 区间的字串序列的权值。</p></blockquote><p>可以说是一个很乱搞的题目了；如果有差不多的算法素养或者代码能力的话应该就能写出来的<del>只可惜我没有，残疾人竟是我自己</del>。下面介绍一下这个题目的三种思路：</p><hr /><p>首先，如果暴力移动区间，显然每次扩张和收缩都可以 <span class="math inline">\(O(1)\)</span> 完成：需要维护的是区间内每个数字出现的次数，以及这个次数出现的次数；因为每次移动只会使得某数字出现的次数变化 1，所以转移一定可以直接完成。</p><p>那么，对于这种询问次数很大，又可以这样暴力维护的问题，而且还没有在线的要求；我们就可以考虑使用莫队算法离线维护；时间复杂度是 <span class="math inline">\(\mathcal{O}(n \sqrt n)\)</span> 的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> MO &#123;</span><br><span class="line">    <span class="keyword">int</span> block_size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">query</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> l, r, id;</span><br><span class="line"></span><br><span class="line">        query() = <span class="keyword">default</span>;</span><br><span class="line">        query(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> id) : l(l), r(r), id(id) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> query &amp;rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (l / block_size == </span><br><span class="line">                rhs.l / block_size)</span><br><span class="line">                <span class="keyword">return</span> r &lt; rhs.r;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> l &lt; rhs.l;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;query&gt; req;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">int</span> cnt[N], tim[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">step</span><span class="params">(<span class="keyword">int</span> pos, <span class="keyword">int</span> sig, <span class="keyword">int</span> &amp;now)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;times = tim[a[pos]];</span><br><span class="line">        <span class="keyword">if</span> (times &gt;= <span class="number">0</span>) -- cnt[times];</span><br><span class="line">        times += sig;</span><br><span class="line">        <span class="keyword">if</span> (times &gt;= <span class="number">0</span>) ++ cnt[times];</span><br><span class="line">        <span class="keyword">if</span> (sig &gt; <span class="number">0</span>) maximize(now, times);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">while</span> (!cnt[now]) -- now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>, tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> increase = [&amp;](<span class="keyword">int</span> pos) &#123; step(pos, +<span class="number">1</span>, tmp); &#125;;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> decrease = [&amp;](<span class="keyword">int</span> pos) &#123; step(pos, <span class="number">-1</span>, tmp); &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [ql, qr, qid] : req) &#123;</span><br><span class="line">            <span class="keyword">while</span> (ql &lt; l) increase(-- l);</span><br><span class="line">            <span class="keyword">while</span> (qr &gt; r) increase(++ r);</span><br><span class="line">            <span class="keyword">while</span> (ql &gt; l) decrease(l ++);</span><br><span class="line">            <span class="keyword">while</span> (qr &lt; r) decrease(r --);</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">auto</span> len = qr - ql + <span class="number">1</span>;</span><br><span class="line">            ans[qid] = max(<span class="number">1</span>, <span class="number">2</span> * tmp - len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        ans.resize(m + <span class="number">1</span>);</span><br><span class="line">        block_size = (<span class="keyword">int</span>) n / <span class="built_in">sqrt</span>(m * <span class="number">2</span> / <span class="number">3</span>);</span><br><span class="line">        stable_sort(req.begin(), req.end());</span><br><span class="line">        solve(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = scanner.nextInt(),</span><br><span class="line">        m = scanner.nextInt();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        a[i] = scanner.nextInt();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = scanner.nextInt(),</span><br><span class="line">            r = scanner.nextInt();</span><br><span class="line">        MO::req.emplace_back(l, r, i);</span><br><span class="line">    &#125;</span><br><span class="line">    MO::run(n, m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">        println(MO::ans[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特别说明：分块的方法没有采用经典的 <span class="math inline">\(\lceil \sqrt{n} \rceil\)</span>，写法采用的分块方法在本题的表现更好<del>其实是抄学弟的</del>；</p><p>虽然这样修改分块方法已经使得我的莫队运行时间从 <code>2200ms</code> 变成了 <code>1800ms</code>，但是学弟原本的代码跑到了令人发指的 <code>900ms</code>…… MSYS2 这么拉的嘛（）</p><hr /><p>虽然如果要求众数，只能使用莫队这种优雅的暴力来维护；但是我们还是应该敏感地注意到众数和“过半数”的微妙的区别；虽然前者没办法用树形数据结构维护，但是后者是可以的——考虑将两个区间的结果合并成的大区间的结果：显然大区间的“过半数”必为两个子区间的“过半数”中的一个，因此可以使用线段树维护。</p><p>那么我们应该如何合并结果呢？查找一个数字在区间 <span class="math inline">\([l, r]\)</span> 中出现的次数，我们可以将这些位置存进数组里，然后使用二分查找确定上下界，那么两界之差就是我们要求的结果；这个询问的时间复杂度是 <span class="math inline">\(\mathcal{O}(\log n)\)</span> 的。</p><p>确定了合并策略，我们就可以写出下面的代码<del>什么嘛，合并策略这个抽象不是挺好用的嘛</del>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">seg_tree</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> merge_method = function&lt;T(T, T, <span class="keyword">int</span>, <span class="keyword">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> siz;</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt; t;</span><br><span class="line">    merge_method merge;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">const</span> T *arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123; t[id] = arr[l]; <span class="keyword">return</span>; &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        build(id * <span class="number">2</span> + <span class="number">1</span>, l, m, arr);</span><br><span class="line">        build(id * <span class="number">2</span> + <span class="number">2</span>, m, r, arr);</span><br><span class="line">        t[id] = merge(t[id * <span class="number">2</span> + <span class="number">1</span>], t[id * <span class="number">2</span> + <span class="number">2</span>], l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ll, <span class="keyword">int</span> rr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ll &gt;= rr) <span class="keyword">return</span> (T)<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ll == l &amp;&amp; rr == r) <span class="keyword">return</span> t[id];</span><br><span class="line">        <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> lv = query(id * <span class="number">2</span> + <span class="number">1</span>, l, m, ll, min(rr, m));</span><br><span class="line">        <span class="keyword">auto</span> rv = query(id * <span class="number">2</span> + <span class="number">2</span>, m, r, max(m, ll), rr);</span><br><span class="line">        <span class="keyword">return</span> merge(lv, rv, ll, rr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">seg_tree</span><span class="params">(<span class="keyword">int</span> n, merge_method m)</span> </span></span><br><span class="line">    : siz(n), merge(move(m)) &#123; t.resize(4 * n); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> T *arr)</span> </span>&#123; <span class="keyword">return</span> build(<span class="number">0</span>, <span class="number">0</span>, siz + <span class="number">1</span>, arr); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">int</span> ll, <span class="keyword">int</span> rr)</span> </span>&#123; <span class="keyword">return</span> query(<span class="number">0</span>, <span class="number">0</span>, siz + <span class="number">1</span>, ll, rr); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, q, l, r;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> count = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> ll = lower_bound(pos[i].begin(), pos[i].end(), l);</span><br><span class="line">        <span class="keyword">auto</span> rr = lower_bound(pos[i].begin(), pos[i].end(), r);</span><br><span class="line">        <span class="keyword">return</span> rr - ll;</span><br><span class="line">    &#125;;</span><br><span class="line">    $(n, q).nextArray(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        pos[a[i]].push_back(i);</span><br><span class="line">    <span class="function">seg_tree&lt;<span class="keyword">int</span>&gt; <span class="title">t</span><span class="params">(n + <span class="number">1</span>, [&amp;](<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> l, <span class="keyword">int</span> r) -&gt; <span class="keyword">int</span> &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="keyword">auto</span> aa = count(l, r, a), bb = count(l, r, b);</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">return</span> aa &gt; bb ? a : b;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line">    t.build(a);</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        $(l, r);</span><br><span class="line">        <span class="keyword">auto</span> id = t.query(l, r + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">auto</span> ans = count(l, r + <span class="number">1</span>, id);</span><br><span class="line">        ans = ans * <span class="number">2</span> - (r + <span class="number">1</span> - l);</span><br><span class="line">        $.put(max(ans, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线段树总体的复杂度大概是 <span class="math inline">\(\mathcal{O}(n\log n \cdot X)\)</span> 的，其中 <span class="math inline">\(X\)</span> 是合并策略的单次操作的复杂度；那么这个问题的整体复杂度是 <span class="math inline">\(\mathcal{O}(n \log^2n)\)</span> 的，倒也可以接受。</p><hr /><p>还有一种比较野的思路，就是随机化：对于每次询问，我们在区间 <span class="math inline">\([l, r]\)</span> 中随机选择一个位置，并假定它的值的出现次数最多，并更新答案，重复多次；如果重复选择的次数足够多，就可以将出错的概率降到很低：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>, T = <span class="number">40</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, q, l, r, ans, t;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> count = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> i) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> ll = lower_bound(pos[i].begin(), pos[i].end(), l);</span><br><span class="line">        <span class="keyword">auto</span> rr = upper_bound(pos[i].begin(), pos[i].end(), r);</span><br><span class="line">        <span class="keyword">return</span> rr - ll;</span><br><span class="line">    &#125;;</span><br><span class="line">    $(n, q).nextArray(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        pos[a[i]].push_back(i);</span><br><span class="line">    <span class="function">mt19937 <span class="title">rng</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        chrono::steady_clock::now()</span></span></span><br><span class="line"><span class="function"><span class="params">        .time_since_epoch().count()</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (q --) &#123;</span><br><span class="line">        $(l, r), ans = <span class="number">1</span>, t = T;</span><br><span class="line">        <span class="keyword">while</span> (t --) &#123;</span><br><span class="line">            <span class="keyword">int</span> gen = a[uniform_int_distribution&lt;<span class="keyword">int</span>&gt;(l, r)(rng)];</span><br><span class="line">            maximize(ans, <span class="number">2</span> * count(l, r, gen) - (r - l + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        $.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么是真正的乱搞啊（战术后仰）因为我们求的权值是可以像最大值那样合并的，所以这样做非常合理；算法整体的时间复杂度是 <span class="math inline">\(\mathcal{O}(qT\log n)\)</span> 的，其中 <span class="math inline">\(T\)</span> 是重复随机的次数。</p><hr /><p>据出题人说，这个题还可以使用某种方法做到 <span class="math inline">\(\mathcal{O}(n\log n)\)</span>，这我就真不会了（）如果会的话欢迎教我==</p><h3 id="e---baby-ehabs-hyper-apartment">E - <a href="https://codeforces.com/contest/1514/problem/E">Baby Ehab's Hyper Apartment</a></h3><blockquote><p>有 <span class="math inline">\(n \leq 100\)</span> 个节点，每对节点之间都有一条有向边；现在你可以进行以下两种询问：</p><ul><li>询问 <span class="math inline">\(u \to v\)</span> 的方向，正向返回 <code>1</code>，否则 <code>0</code>；不超过 <span class="math inline">\(9n\)</span> 次</li><li>询问 <span class="math inline">\(u \to \{a_1, \dots, a_n\}\)</span> 中是否存在到其中任一通路，全部不可达返回 <code>0</code>，否则 <code>1</code>；不超过 <span class="math inline">\(2n\)</span> 次</li></ul><p>要求你在规定的询问次数内求出 <span class="math inline">\(n \times n\)</span> 矩阵 <span class="math inline">\(M\)</span>，<span class="math inline">\(M_{i, j}\)</span> 代表 <span class="math inline">\(i \to j\)</span> 是否可达。</p></blockquote><p>完全没有思路，，看了题解才发现需要的知识基本也都还给离散老师了，直接埋了吧（无慈悲</p><p>首先，我们考虑只使用其中的一部分边来完成所有的转移——其他的边都是多余的；然后，发现这张图是一个竞赛图：因此它必定存在一条按照某种顺序可以到达所有的点仅一次的哈密顿通路；在这条哈密顿通路上，处于偏序位置较低的点可以到达任何偏序位置较高的点。</p><p>那么，在这样的基础上，我们只需要考虑从偏序位置较高的点到达较低的点即可；假设从某个高位置 <span class="math inline">\(i\)</span> 可以到达的最低的位置是 <span class="math inline">\(p\)</span>，那么所有在 <span class="math inline">\(p\)</span> 点上，在 <span class="math inline">\(i\)</span> 点下的位置都可以从 <span class="math inline">\(i\)</span> 出发到达，而在 <span class="math inline">\(p\)</span> 点下的位置不可到达；因此，只需要找到所有位置可以到达的最低的位置，就可以知道 <span class="math inline">\(i\)</span> 点到达其他任何节点的可达情况。</p><p>那么我们应该怎么样实现呢？在竞赛图中，我们将每一条有向边都看作是一对偏序关系，然后使用归并排序，就可以得到一条哈密顿路（所代表的偏序顺序）；这也很好理解：假设我们将所有的节点分成两个部分，它们内部都已经找到了哈密顿路的偏序；那么我们就比较两个部分的最低点——它们之间一定存在偏序关系——找到其中较低的插入待求的偏序中；因为它比接下来的两个部分的最低点都要低，所以可以继续将更低的点插入其中。</p><p>在 C++ STL 中，已经有了默认的归并排序的实现 <code>stable_sort</code>，直接调用，并将第一种询问作为排序方式即可完成哈密顿路的求解。显然，这样最多会询问 <span class="math inline">\(n\log_2n\)</span> 次，对于 <span class="math inline">\(n \leq 100\)</span> 显然满足小于 <span class="math inline">\(9n\)</span>。</p><p>然后，我们维护一个指针 <span class="math inline">\(p\)</span>，指向当前可以到达的最低位置；我们只需要使用第二种询问询问在 <span class="math inline">\(p\)</span> 之前的前缀是否可以包含可以到达的位置，就可以判断是否继续将 <span class="math inline">\(p\)</span> 左移。这样，对于每个前缀位置 <span class="math inline">\(p\)</span>，都会存在一次询问的返回为 <code>1</code> 从而使得 <span class="math inline">\(p\)</span> 左移；对于每个位置 <span class="math inline">\(i\)</span>，都有一次询问返回 <code>0</code> 说明当前的 <span class="math inline">\(p\)</span> 为它可以到达的最低距离，所以询问次数也是满足 <span class="math inline">\(2n\)</span> 的限制的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">askTheEdge</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = $.put(<span class="number">1</span>, a, b).flush().nextInt();</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> (<span class="keyword">bool</span>) res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">askEdges</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = $.print(<span class="number">2</span>, <span class="string">&#x27; &#x27;</span>, a, <span class="string">&#x27; &#x27;</span>, b.size(), <span class="string">&#x27; &#x27;</span>).</span><br><span class="line">                putArray(b.begin(), b.end()).flush().</span><br><span class="line">                nextInt();</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> (<span class="keyword">bool</span>) res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = $.nextInt(), n;</span><br><span class="line">    <span class="built_in">bitset</span>&lt;128&gt; g[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = $.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">            g[i].reset(), g[i] = ~g[i];</span><br><span class="line">        vector&lt;int&gt; path(n), tmp;</span><br><span class="line">        iota(path.begin(), path.end(), <span class="number">0</span>);</span><br><span class="line">        stable_sort(path.begin(), path.end(), askTheEdge);</span><br><span class="line">        <span class="keyword">int</span> p = n - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> makeTmp = [&amp;](<span class="keyword">int</span> p) -&gt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; &#123;</span><br><span class="line">            tmp.assign(path.begin(), path.begin() + p + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> tmp;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == i) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++ j)</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; n; ++ k)</span><br><span class="line">                        g[path[k]][path[j]] = <span class="literal">false</span>;</span><br><span class="line">                -- p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (askEdges(path[i], makeTmp(p))) -- p;</span><br><span class="line">        &#125;</span><br><span class="line">        $.put(<span class="number">3</span>).putArray(<span class="number">0</span>, n, [&amp;](<span class="keyword">int</span> i, cquery $) &#123;</span><br><span class="line">            $.putArray(<span class="number">0</span>, n, [&amp;i](<span class="keyword">int</span> j, cquery $) &#123;</span><br><span class="line">                $.print(g[i].test(j) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">            &#125;, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;&quot;</span>).flush();</span><br><span class="line">        <span class="keyword">int</span> res = $.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == res) <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，第二种询问还可以使用缓存减少一定的询问次数，不过优势不明显，也实在没有必要就是了（</p><h2 id="后记">后记</h2><p>做 C 题的时候，博主也和恰好在旁边的同学 <a href="https://tmc0210.github.io">tmc</a> 讨论了为什么会想不出来——得到的回复是只是单纯的对于数论不够敏感，换句话说就是做的少了（）真的得多加注意了==</p><p>年轻人的第一个莫队题目竟然是在这样的场合…… 只能说对比就是生产力啊（</p>]]></content>
    
    <summary type="html">
    
      之前因为看错时间没有打的 Div2，本来以为痛失上分机会，但是实际做了一次之后才发现如果打了就真的要绿名了（
    
    </summary>
    
    
      <category term="题解" scheme="https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="算法" scheme="https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM" scheme="https://shiraha.cn/tags/ACM/"/>
    
      <category term="Codeforces" scheme="https://shiraha.cn/tags/Codeforces/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round#715 div.2 回顾</title>
    <link href="https://shiraha.cn/2021/codeforces-round-715-div2/"/>
    <id>https://shiraha.cn/2021/codeforces-round-715-div2/</id>
    <published>2021-04-19T18:28:13.000Z</published>
    <updated>2021-04-19T18:28:13.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>补题链接：<a href="https://codeforces.com/contest/1509" class="uri">https://codeforces.com/contest/1509</a></p></blockquote><h2 id="记录">记录</h2><p>其实本来今天晚上是有一个 <a href="https://codeforces.com/blog/entry/89771">Codeforces Round #716 (Div.2)</a> 的；但是因为我盲目确信它的开始时间是传统艺能 22:35，而忽略了它的开始时间和往常不同，所以最后没有打成== 但是也因此，本懒狗可以好好地补完上一场拉跨的不行的 Div2 了。</p><p>这一场可以说非常的拉跨，ABC 选手都没有当成；明明才 1700 分的我都能直接俯冲 100 分，只能说使得本菜鸡本就不高的 rating 雪上加霜（）话虽这么说，补完了发现只是自己傻逼……这是不是有点似曾相识？</p><h2 id="题解">题解</h2><h3 id="a---average-height">A - <a href="https://codeforces.com/contest/1509/problem/A">Average Height</a></h3><p>没什么好说的，偶数和奇数分别放在一起就完事了（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2050</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt();</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            a[i] = scanner.nextInt();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (a[i] % <span class="number">2</span>) ans.push_back(a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (a[i] % <span class="number">2</span> == <span class="number">0</span>) ans.push_back(a[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ii : ans)</span><br><span class="line">            print(ii, <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="b---tmt-document">B - <a href="https://codeforces.com/contest/1509/problem/B">TMT Document</a></h3><p>也没啥难度，总的来说只要时刻保证前缀的 <code>T</code> 比 <code>M</code> 多，并且保证最后 <code>T</code> 和 <code>M</code> 的比例正确，且每一个 <code>M</code> 的后面都一定出现了一个 <code>T</code> 就可以保证合法性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">4</span>;</span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt(), n;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        scanner(n, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">3</span>) &#123;</span><br><span class="line">            println(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> cntT = <span class="number">0</span>, cntM = <span class="number">0</span>, close = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">bool</span> ok = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;T&#x27;</span>) &#123;</span><br><span class="line">                ++ cntT;</span><br><span class="line">                <span class="keyword">if</span> (close &lt; cntM) ++ close;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> ++ cntM;</span><br><span class="line">            <span class="keyword">if</span> (cntM &gt; cntT) ok = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cntM * <span class="number">2</span> != cntT || close &lt; cntM)</span><br><span class="line">            ok = <span class="literal">false</span>;</span><br><span class="line">        println(ok ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说是这么说，可是我还是因为没有长手所以白给一发<del>残疾人竟是我自己</del>（</p><h3 id="c---the-sports-festival">C - <a href="https://codeforces.com/contest/1509/problem/C">The Sports Festival</a></h3><blockquote><p>给一个长度为 <span class="math inline">\(n &lt; 2000\)</span> 的数组，现在要求你对这个数组进行重排序，使得下列式子的值最小： <span class="math display">\[\sum_{i=1}^n\max_{j=1}^i a_j - \min_{j=1}^i a_j\]</span> 要求输出上面式子的最小值。</p></blockquote><p>这个题做的过程可以说是十分丑陋了（）尽显本人菜逼本质 == 本弱鸡甚至能在考虑出了 <span class="math inline">\(\mathcal{O}(n^2)\)</span> 的贪心的假做法的情况下不自知，甚至还迷之自信的交了一二三四发，只能说是十分地滑稽可笑了。</p><p>当然，本题的正确做法也是 <span class="math inline">\(\mathcal{O}(n^2)\)</span> 的，只不过是比贪心更加合理的多的 DP；</p><p>首先，就像我的假做法考虑到的那样：首先对于这个数组排序，然后答案的构造方法一定是从中间的某个位置向两侧发散；考虑 <span class="math inline">\(dp_{l..r}\)</span> 表示当前已经扩散到了区间 <span class="math inline">\([l, r]\)</span> 时，上面的式子的最小值；那么它只有两种转移来源——要不是加入了新的最小值 <span class="math inline">\(a_l\)</span>，又或者是加入了新的最大值 <span class="math inline">\(a_r\)</span>；所以不难得到下面的转移关系： <span class="math display">\[dp_{l..r} = (a_r - a_l) + \min(dp_{l+1..r}, dp_{l..r-1})\]</span> 那么就可以写出代码通过此题了；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2060</span>;</span><br><span class="line">longs dp[N][N], s[N], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    $(n).nextArray(s + <span class="number">1</span>, s + <span class="number">1</span> + n);</span><br><span class="line">    sort(s + <span class="number">1</span>, s + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; n; ++ k)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= n; ++ l)</span><br><span class="line">            <span class="keyword">if</span> (l + k &gt; n) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> r = l + k;</span><br><span class="line">                dp[l][r] = s[r] - s[l] + min(dp[l + <span class="number">1</span>][r], dp[l][r - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">    output, dp[<span class="number">1</span>][n], <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当初辅导某学长机试时，我苦口婆心地说“找到递推关系就是动态规划”的神态还历历在目，结果自己却深陷这样一个简单的 DP 而不自知，为自己的 <span class="math inline">\(\mathcal{O}(n^2)\)</span> 贪心假做法而沾沾自喜，属实是个小丑（</p><h3 id="d---binary-literature">D - <a href="https://codeforces.com/contest/1509/problem/D">Binary Literature</a></h3><blockquote><p>给你一个长度 <span class="math inline">\(n \leq 10^5\)</span>，以及三个长度为 <span class="math inline">\(2n\)</span> 的 01 字符串；现在你要构造一个 01 字符串，要求它至少以子序列的方式包含提供的三个字符串中的两个，且长度不能超过 <span class="math inline">\(3n\)</span>；保证这种构造一定是成立的。</p></blockquote><p>首先，考虑两个长度为 <span class="math inline">\(2n\)</span> 的字符串；我们一定可以构造出长度为 <span class="math inline">\(4n - L\)</span> 的满足子序列包含它们的串；其中 <span class="math inline">\(L\)</span> 的含义是这两个字符串的最长公共子串（LCS）。构造方法也非常的简单：对于 LCS 中的 <span class="math inline">\(L\)</span> 个字符，只插入构造的串中一次，其他的字符按照正确的顺序全部插入结果串即可。</p><p>但是众所周知，求 LCS 的算法的复杂度是 <span class="math inline">\(\mathcal{O}(n^2)\)</span> 的，而这个题目显然不允许这样的复杂度；但是因为题目中的字符串是 01 串，所以我们可以利用它的性质来考虑：</p><ul><li>01 串中不是 <code>0</code> 就是 <code>1</code>，所以长度为 <span class="math inline">\(2n\)</span> 的 01 串中至少有一个字符出现的次数大于等于 <span class="math inline">\(n\)</span></li><li>因为我们有三个这样的 01 串，所以至少有两个字符串中的某个相同的字符出现次数大于等于 <span class="math inline">\(n\)</span></li></ul><p>综上所述，我们找到这样的两个字符串；将这个字符出现的位置作为 LCS 的字符；然后使用上面的构造方法，就可以构造出长度为 <span class="math inline">\(4n - L \leq 3n\)</span>，其中 <span class="math inline">\(L \geq n\)</span> 的目标串了。</p><hr /><p>在这种思想的基础上，我们还有一种更加优雅的构造方法：首先，维护三个指针，分别指向三个字符串，并且最开始都初始化为指向串首；然后，对于每一个位置，都选择较多的字符加入答案串，并推进对应的指针；这样，当一个字符串已经完全被加入答案串之后，我们假设答案串的长度为 <span class="math inline">\(k\)</span>：</p><ul><li>因为有一个长度为 <span class="math inline">\(2n\)</span> 的字符串被完全推入了，所以 <span class="math inline">\(k \geq 2n\)</span>；</li><li>因为每次推入字符都要求了至少两个字符串当前位置为该字符，所以至少消耗了 <span class="math inline">\(2k\)</span> 个字符；</li><li>这样，三个字符串总共有 <span class="math inline">\(6n\)</span> 个字符，现在最多剩下 <span class="math inline">\(6n - 2k\)</span> 个字符，分配在两个串中；</li><li>这样，其中剩余较少的那个串最多包含 <span class="math inline">\(3n - k\)</span> 个字符；</li></ul><p>综上所述，如果我们将那个剩余最少的字符串完全推入答案串，那么答案串至少会包含这两个已经压入的字符串作为子序列，并且答案串的长度最大为 <span class="math inline">\(k + 3n - k = 3n\)</span>，符合题意；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[N * <span class="number">2</span>], b[N * <span class="number">2</span>], c[N * <span class="number">2</span>];</span><br><span class="line"><span class="keyword">char</span> ans[N * <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = $.nextInt(), n, p;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> concat = [&amp;](<span class="keyword">char</span> *aa, <span class="keyword">char</span> *bb) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> na = <span class="built_in">strlen</span>(aa), nb = <span class="built_in">strlen</span>(bb);</span><br><span class="line">        <span class="built_in">strcpy</span>(ans + p, na &lt; nb ? aa : bb);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        $(n, a, b, c);</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n2 = n * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">auto</span> ae = a + n2, be = b + n2, ce = c + n2;</span><br><span class="line">        <span class="keyword">auto</span> pa = a, pb = b, pc = c;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (pa != ae &amp;&amp; pb != be &amp;&amp; pc != ce) &#123;</span><br><span class="line">            <span class="keyword">int</span> cnt1 = *pa + *pb + *pc - <span class="string">&#x27;0&#x27;</span> * <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">int</span> ch = (cnt1 &gt;= <span class="number">2</span>) + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            pa += (ch == *pa), pb += (ch == *pb), pc += (ch == *pc);</span><br><span class="line">            ans[p ++] = (<span class="keyword">char</span>) ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pa == ae) concat(pb, pc);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pb == be) concat(pa, pc);</span><br><span class="line">        <span class="keyword">else</span> concat(pa, pb);</span><br><span class="line">        $.println(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实真要说的话，我觉得在知道 LCS 是哪些位置的情况下构造这样一个串还挺……不好写的；至少写出来大概都不会太好看；更何况还要使用那个 <span class="math inline">\(\mathcal{O}(n^2)\)</span> 的 DP 求出 LCS 的位置；实际上的写法只能说是很高妙了（</p><h3 id="e---almost-sorted">E - <a href="https://codeforces.com/contest/1509/problem/E">Almost Sorted</a></h3><blockquote><p>现在定义差不多有序的排序指对于任意下标 <span class="math inline">\(i\)</span>，都满足 <span class="math inline">\(p_{i+1} \geq p_i - 1\)</span>；现在给长度为 <span class="math inline">\(n\)</span> 的初始排列（即字典序最小的排列 <span class="math inline">\(1\dots n\)</span>，要求求出字典序第 <span class="math inline">\(k\)</span> 小的差不多有序的排序；</p></blockquote><p>这题我从最开始就没往正确的地儿想；我最开始想要打表找规律，但是实际上我想找的那个规律可以说是显然的，但是更高级的规律可以说打表什么也看不出来…… <code>zcysky</code> 提示我要画树我也没领会他的意思，盲目地漫无目的地思考了一会就缴械投降了，看到题解才发现是真的高：</p><p>首先，我们要正确的理解题目的定义：差不多有序的排序，如果出现了下降的情况，定义只允许步长为 1 的递减；所以，一个差不多有序的序列可以被表示为多个公差为 1 的递减区块；而且，我们可以用反证法证明——一旦确定了序列的递减区块的划分方法，那么这个序列是唯一的——且是初始排列按照这个划分方式划分之后，将每一个区间都翻转得到的序列。</p><p>那么接下来我们考虑 <span class="math inline">\(k\)</span>-大问题：因为每个区块都是由初始排序倒转区块得到的，所以我们可以贪心的考虑，第一个区块的大小越小，那么处理后得到的序列最小；同时，再确定了第一个区块的长度之后，我们将它从原排序中移除，那么就得到了一个长度缩小的子问题；我们可以递归地处理这个问题。</p><p>然后，我们考虑对于长度为 <span class="math inline">\(n\)</span> 的排序，差不多有序的序列数量：假设我们现在有一个和这个排序等长的 01 序列，且初始它的每一位都已经置零；对于每一个划分后的区块 <span class="math inline">\([l, r]\)</span>，我们将 <span class="math inline">\(l\)</span> 位置为 1；那么可以看到除了第 0 位必须为 1，其他的每一位都可以为 1/0；因此，一共有 <span class="math inline">\(2^{n-1}\)</span> 种不同的差不多有序的序列。</p><hr /><p>至此，我们已经可以使用上面说的递归的方法来求解本题了；但是实际上还有一种更加优秀的构造方法：</p><p>考虑上面说的标记 01 序列的方法：首先我们将上面的 01 序列看作一个二进制数；并且翻转下标的对应关系——让更小的下标对应更高的位；然后改为标记右边界，即区块中最低的位；然后翻转标记方法：即初值为 1，标记的位为 0；这样就可以得到满足上面所有约束；第 <span class="math inline">\(k\)</span> 小的排列就是 <span class="math inline">\(k-1\)</span> 的二进制表示左移 1 位（最低位始终为 0）对应的二进制表示所代表的划分方式；我们根据它构造答案即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], tmp[N];</span><br><span class="line">lll fact[N];</span><br><span class="line"><span class="built_in">bitset</span>&lt;N&gt; x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    longs T = $.nextInt(), n, k;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        input, n, k;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">128</span>) &#123;</span><br><span class="line">            lll cnt = <span class="number">1</span>;</span><br><span class="line">            cnt &lt;&lt;= uint(n - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (k &gt; cnt) &#123;</span><br><span class="line">                output, <span class="number">-1</span>, <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> x.reset();</span><br><span class="line">        x = k - <span class="number">1</span>, x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        iota(a, a + n, <span class="number">1</span>);</span><br><span class="line">        reverse(a, a + n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (!x.test(i)) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (j &lt; n &amp;&amp; x.test(j)) ++ j;</span><br><span class="line">                reverse(a + i, a + j);</span><br><span class="line">                i = j - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        reverse(a, a + n);</span><br><span class="line">        $.putArray(a, a + n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常地巧妙；不管是证明了划分和排列的对应性还是划分和二进制表示的对应性都非常的巧妙（）这不比你最开始考虑的先映射 <span class="math inline">\(k\)</span> 和排序的关系，再用康托展开要阳间多了？更何况康托展开是 <span class="math inline">\(\mathcal{O}(n^2)\)</span> 的呢！</p><h3 id="f---complete-the-mst">F - <a href="https://codeforces.com/contest/1509/problem/F">Complete the MST</a></h3><blockquote><p>现在给你一个有 <span class="math inline">\(n \leq 2 \cdot 10^5\)</span> 的节点的无向完全图；其中有 <span class="math inline">\(m\)</span> 条连边已经有权值（保证这部分的边的数量不超过 <span class="math inline">\(2 \cdot 10^5\)</span>），部分边没有权值（保证至少有一条边没有权值）；现在要求你为这些没有权值的边赋非负值的权值，并且整张图所有边的权值异或和为 <span class="math inline">\(0\)</span>，且图的 MST 的权值和最少。</p></blockquote><p>看起来麻烦的一匹<del>实际上也麻烦的一匹</del>，首先进行一些思考：首先，我们一定最多只给一条边赋非零值——因为把它拆分给多条边完全没有任何好处；然后，MST 肯定是尽可能的用没有权值的边——因为如果条件允许，我们可以把我们选作 MST 的边全部赋值为 0；其次，我们赋值的那条边的权值，一定是所有有权值的边的权值的异或和。</p><p>那么，我们可以通过下面的过程来求解：</p><ul><li>首先，考虑在空边构成的图上 DFS，以求出仅使用空边可以维系的连通块；<ul><li>如果在选出这些边之后仍有未使用的空边，那么我们可以把异或和赋给它：这样对权值和无贡献；</li><li>否则，我们先暂记异或和，作为将要赋给某条空边的值；</li></ul></li><li>然后，我们考虑使用 MST 算法，使用实边将第一步求出的连通块连成一个生成树；</li><li>如果一条实边不能被选入 MST，但是它连接了两个本需要依靠空边连接的连通块，那么：<ul><li>如果这条边的权值比将要赋值给空边的权值要少，那么我们可以将空边赋给这条边，并取代它；</li><li>否则，那么还是维持原判，忽略这条边；</li></ul></li><li>实际上，这个取代的过程可以通过缩小这个待赋值空边权值代销来实现。</li></ul><p>这样，我们就可以使用我们的思考，构造出这个题目的答案<del>虽然有些过程显得非常玄学就是了</del>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; disc, adj[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n, m, u, v, w;</span><br><span class="line">    input, n, m;</span><br><span class="line">    <span class="keyword">auto</span> res = (longs) n * (n - <span class="number">1</span>) / <span class="number">2</span> - m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) disc.insert(i);</span><br><span class="line">    ya_dsu all(n + 1), real(n + 1);</span><br><span class="line">    <span class="built_in">vector</span>&lt;tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; edge;</span><br><span class="line">    <span class="keyword">const</span> function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; dfs = [&amp;](<span class="keyword">int</span> u) &#123;</span><br><span class="line">        disc.erase(u);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>;;) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = disc.lower_bound(v);</span><br><span class="line">            <span class="keyword">if</span> (it == disc.end()) <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">else</span> v = *it;</span><br><span class="line">            <span class="keyword">if</span> (!adj[u].count(v)) &#123;</span><br><span class="line">                all.connect(u, v);</span><br><span class="line">                dfs(v), --res;</span><br><span class="line">            &#125;</span><br><span class="line">            ++v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    uint xs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        input, u, v, w;</span><br><span class="line">        adj[u].insert(v), adj[v].insert(u);</span><br><span class="line">        edge.emplace_back(w, u, v);</span><br><span class="line">        xs ^= (uint) w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (disc.count(i)) dfs(i);</span><br><span class="line">    <span class="keyword">if</span> (res &gt; <span class="number">0</span>) xs = <span class="number">0</span>;</span><br><span class="line">    sort(edge.begin(), edge.end());</span><br><span class="line">    longs ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>[w, u, v] : edge) &#123;</span><br><span class="line">        <span class="keyword">if</span> (all.connect(u, v)) &#123;</span><br><span class="line">            ans += w;</span><br><span class="line">            real.connect(u, v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (real.connect(u, v))</span><br><span class="line">            minimize(xs, (uint)w);</span><br><span class="line">    &#125;</span><br><span class="line">    output, ans + xs, <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 DFS 就显得尤其离谱……在 <span class="math inline">\(n = \sqrt{N}\)</span> 的准完全图里，它最坏的情况下会跑掉 <span class="math inline">\(\mathcal{\Theta}(n^2\log n)\)</span>，在其他的情况下我甚至都无法分析它的复杂度（算法设计课全还给院长了），但是就是可以过，所以…… 等我会证明它的复杂度的时候再补充说明把（</p><p>此外还值得一提的就是它的标程提供了一种优雅的路径压缩+按秩合并的并查集实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ya_dsu</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; fa;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[u] &gt; fa[v]) swap(u, v);</span><br><span class="line">        fa[u] += fa[v], fa[v] = u;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">ya_dsu</span><span class="params">(<span class="keyword">int</span> n)</span> : <span class="title">fa</span><span class="params">(n, <span class="number">-1</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; fill(fa.begin(), fa.end(), <span class="number">-1</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123; <span class="keyword">return</span> fa[u] &lt; <span class="number">0</span> ? u : fa[u] = id(fa[u]); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        u = id(u), v = id(v);</span><br><span class="line">        <span class="keyword">if</span> (u == v) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> join(u, v), <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123; <span class="keyword">return</span> -fa[id(u)]; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简单的说就是那个数组非根节点记录根节点的编号，而根节点为负数，且绝对值等于连通块的大小；比起我之前的经典实现节约了一个 <code>siz</code> 数组的大小，本彩笔惊为天人，高，实在是高（</p><h2 id="后记">后记</h2><p>这周，准确地说应该是上周，因为各种各样的事情——比如博客的花里胡哨啊等等——导致了我在考研复习和训练上投入的时间大幅减少；这是一个危险的信号，这周需要尽量避免。</p><p>欲辩已忘言，，明明在开始写这篇文章的时候还是感觉有好多的废话想要说的，，但是现在却对着窗口发呆，一句话也说不出来…… 唉，四点了，今天的墨墨背单词的卡又打不成了（）……因为实在是太晚了所以就不再多说些啥了，早点休息力 ==</p><p>最后送给自己一句话： <em>自分の光になれ！</em> 没有任何的典故，只是想对自己这么说而已——</p>]]></content>
    
    <summary type="html">
    
      可以说打的非常拉跨了，，我只不过是一两天没有正经训练而已，为什么要让我承受掉一百分这样的痛苦呢（）我错了，下次再也不敢力==
    
    </summary>
    
    
      <category term="题解" scheme="https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="算法" scheme="https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM" scheme="https://shiraha.cn/tags/ACM/"/>
    
      <category term="Codeforces" scheme="https://shiraha.cn/tags/Codeforces/"/>
    
  </entry>
  
  <entry>
    <title>使用 pandoc 正确渲染多行 MathJax 公式</title>
    <link href="https://shiraha.cn/2021/use-pandoc-to-render-multiline-formulas-correctly/"/>
    <id>https://shiraha.cn/2021/use-pandoc-to-render-multiline-formulas-correctly/</id>
    <published>2021-04-18T08:04:03.000Z</published>
    <updated>2021-04-18T08:04:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着 Hexo 的发展，有越来越多的小伙伴使用 Hexo 搭建技术博客，其中不乏大量包含数学公式的场合：为了满足这种需要，一般是在 Markdown 中使用部分 <span class="math inline">\(\LaTeX\)</span> 语法书写数学公式，Hexo 也支持使用 <code>Mathjax</code> 渲染这些公式；本是一件很舒服的事情，但是当编写多行公式的时候，会发现渲染出现错误：</p><p>比如下面的数学公式：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;bmatrix&#125;</span></span></span><br><span class="line">1 &amp; x_0 &amp; x_0^2 &amp; <span class="tag">\<span class="name">cdots</span></span> &amp; x_0^n <span class="tag">\<span class="name">\</span></span></span><br><span class="line">1 &amp; x_1 &amp; x_1^2 &amp; <span class="tag">\<span class="name">cdots</span></span> &amp; x_1^n <span class="tag">\<span class="name">\</span></span></span><br><span class="line"><span class="tag">\<span class="name">vdots</span></span> &amp; <span class="tag">\<span class="name">vdots</span></span> &amp; <span class="tag">\<span class="name">vdots</span></span> &amp; <span class="tag">\<span class="name">ddots</span></span> &amp; <span class="tag">\<span class="name">vdots</span></span> <span class="tag">\<span class="name">\</span></span></span><br><span class="line">    1 &amp; x_n &amp; x_n^2 &amp; <span class="tag">\<span class="name">cdots</span></span> &amp; x_n^n  </span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;bmatrix&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;bmatrix&#125;</span></span></span><br><span class="line">a_0 <span class="tag">\<span class="name">\</span></span> a_1 <span class="tag">\<span class="name">\</span></span> <span class="tag">\<span class="name">vdots</span></span> <span class="tag">\<span class="name">\</span></span> a_n</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;bmatrix&#125;</span></span></span><br><span class="line">=</span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;bmatrix&#125;</span></span></span><br><span class="line">y_0 <span class="tag">\<span class="name">\</span></span> y_1 <span class="tag">\<span class="name">\</span></span> <span class="tag">\<span class="name">vdots</span></span> <span class="tag">\<span class="name">\</span></span> y_n</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;bmatrix&#125;</span></span></span><br></pre></td></tr></table></figure><p>是一个和范德蒙矩阵相关的算式；它正确渲染后的样子应该是这样的： <span class="math display">\[\begin{bmatrix}    1 &amp; x_0 &amp; x_0^2 &amp; \cdots &amp; x_0^n \\    1 &amp; x_1 &amp; x_1^2 &amp; \cdots &amp; x_1^n \\    \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\    1 &amp; x_n &amp; x_n^2 &amp; \cdots &amp; x_n^n  \end{bmatrix}\begin{bmatrix}    a_0 \\ a_1 \\ \vdots \\ a_n\end{bmatrix}=\begin{bmatrix}    y_0 \\ y_1 \\ \vdots \\ y_n\end{bmatrix}\]</span> 但是实际上，渲染出来的结果很有可能是下面这样…… <span class="math display">\[\begin{bmatrix}    1 &amp; x_0 &amp; x_0^2 &amp; \cdots &amp; x_0^n \    1 &amp; x_1 &amp; x_1^2 &amp; \cdots &amp; x_1^n \    \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \    1 &amp; x_n &amp; x_n^2 &amp; \cdots &amp; x_n^n  \end{bmatrix}\begin{bmatrix}    a_0 \ a_1 \ \vdots \ a_n\end{bmatrix}=\begin{bmatrix}    y_0 \ y_1 \ \vdots \ y_n\end{bmatrix}\]</span> 实在是让人头秃（</p><h2 id="原因分析">原因分析</h2><p>一般而言，Hexo 是将公式块（被 <code>$</code> 或者 <code>$$</code> 包裹）渲染为一个元素，然后在页面中加载 <code>MathJax</code> 的 <code>JS</code> 文件。浏览器加载页面的时候运行 <code>MathJax</code> 读取这些元素中的公式并渲染完成替换的。但是 <code>marked</code> 会优先转义 Markdown 的语法，再考虑数学公式；因此当两者的语法冲突的时候，就会使得最终提供给 <code>MathJax</code> 的公式出现异常，导致渲染错误。</p><h2 id="解决方法">解决方法</h2><p>既然已经确定了渲染不正确的原因是 <code>hexo-renderer-marked</code> 的原因，那么就可以从这方面入手考虑解决方法了：</p><h3 id="修改-marked.js-源码"><del>修改 <code>Marked.js</code> 源码</del></h3><p>因为 <code>Marked.js</code> 会先将下划线 escape 成 <code>&lt;em&gt;</code>，将 <span class="math inline">\(LaTeX\)</span> 中用于换行的 <code>\\</code> 转移成 <code>\</code>，使得客户端的 <code>MathJax</code> 在渲染的时候无法正确读取公式导致渲染异常。因此，可以修改 <code>nodes_modules</code> 中的 <code>marked</code> 的源代码，或自行发布一个私有的 <code>marked</code> 作为依赖。</p><p>在 <code>marked/lib/marked.js</code> 中：</p><ul><li>去掉 <code>\</code> 的额外转义</li><li>将 <code>em</code> 标签对应的符号中，去掉 <code>_</code> ：因为 <code>markdown</code> 中有 <code>*</code> 可以表示斜体</li></ul><p>修改方式如下：</p><p>首先删除对于反斜杠的转义</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- escape: /^\\([\\`*&#123;&#125;\[\]()# +\-.!_&gt;])/,</span></span><br><span class="line"><span class="addition">+ escape: /^\\([`*&#123;&#125;\[\]()# +\-.!_&gt;])/,</span></span><br></pre></td></tr></table></figure><p>再删除对于 <code>em</code> 的多余的转义：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span></span><br><span class="line"><span class="addition">+ em:/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span></span><br></pre></td></tr></table></figure><p>遗憾地是上述做法并不适合目前较新版本的 <code>Marked.js</code>，所以现在无法使用。如果有新版本的 <code>Marked.js</code> 的修改方法也欢迎分享（</p><h3 id="强行适配渲染规则">强行适配渲染规则</h3><p>因为主要受到影响的是多行公式，所以在需要使用多行公式的时候，使用 <code>\\\\</code> 替换 <code>\\</code>，就可以保证页面的正常渲染。</p><p>但是这样并不能解决关于下划线的渲染问题<del>还是得看脸</del>，而且这样在 Typora 等可以正确渲染的本地环境下，看到的公式之间会有莫名的空行（并不优雅）。</p><h3 id="更换渲染引擎推荐">更换渲染引擎（推荐）</h3><p>既然是渲染引擎的锅，那么换一个渲染引擎就好了；下面列举作者尝试过的一些渲染引擎，并简单介绍一下它们的优缺点：</p><p>作者的博客在进行这些尝试的时候使用的主题是 <a href="https://github.com/volantis-x/hexo-theme-volantis">Volantis</a> 的 <code>4.3.1</code> 版本。</p><h4 id="hexo-renderer-markdown-it"><a href="https://github.com/hexojs/hexo-renderer-markdown-it">hexo-renderer-markdown-it</a></h4><p>和 Hexo 默认使用的 <code>hexo-renderer-marked</code> 不同，在博文的 <code>front-matter</code> 不开启 <code>mathjax</code> 的情况下，似乎会先使用 <code>Katex</code> 渲染公式。<code>Katex</code> 会在生成静态文件的过程中就完成数学公式的渲染，而不是在客户端的浏览器中。因此可以获得很棒的加载速度（毕竟在一些性能较差的设备上经常能看见公式半天加载不出来的情况）；但是问题在于 <code>katex</code> 支持的 <span class="math inline">\(\LaTeX\)</span> 实在是太少了，远远不够用。</p><p>一些 Hexo 主题的作者也会基于这个渲染器进行一些修改，作者就没有一一尝试了。</p><h4 id="hexo-renderer-kramed"><a href="https://github.com/hsfzxjy/hexo-renderer-kramed">hexo-renderer-kramed</a></h4><p>这是一个 <code>hexo-renderer-marked</code> 的分支，也会和 <code>hexo-renderer-marked</code> 产生冲突。本来应该是一个很不错的选项，但是作者在使用它作为渲染引擎后运行 <code>gulp</code> 来最小化 <code>HTML</code> 会报错…… 所以就没有继续尝试了。</p><h4 id="hexo-renderer-syzoj-renderer"><a href="https://github.com/Menci/hexo-renderer-syzoj-renderer">hexo-renderer-syzoj-renderer</a></h4><p>大佬 <a href="https://github.com/Menci">Menci</a> 出品，使用她为开源的 <code>SYZOJ</code> 写的 Markdown 渲染器来渲染文章的插件<del>其实使用的还是 <code>markdown-it</code></del>。优点是渲染行为和 <code>marked</code> 非常类似，且对于 <code>MathJax</code> 的支持和语法容忍度非常高：基本上是你在 <code>Typora</code> 里写的什么样，Hexo 渲染出来的就是什么样<del>特别是对于 SYZOJ 用户</del>，可以说是非常的舒服。</p><p>而且，虽然此渲染器使用 <code>MathJax</code> 渲染，但是这个过程也是在后端完成的。因此客户端浏览器的公式渲染速度很快，解决了 <code>MathJax</code> 公式渲染阻塞留白的问题。</p><p>但它的缺点就是在某些兼容性上可能有一些微妙的问题：博主使用的主题 <a href="https://github.com/volantis-x/hexo-theme-volantis">Volantis</a> 在开启 <code>Pjax</code> 后，包含数学公式的页面的 <code>Pjax</code> 跳转会失效（<a href="https://github.com/volantis-x/hexo-theme-volantis/issues/621">Issue #621 · volantis-x/hexo-theme-volantis</a>）；此外，很多主题会对于配置文件里写的字符串在布局的 <code>ejs</code> 文件中调用 <code>markdown()</code> 接口渲染成 Markdown，这个渲染器没有提供这个接口（也就是说，还得保留 <code>hexo-rederer-marked</code> 才可以使得这些部分正常渲染）。</p><p>如果你使用的博客主题没有 <code>Pjax</code>，或者和这个渲染器没有什么冲突的话，还是非常推荐使用的。</p><h4 id="hexo-renderer-pandoc"><a href="https://github.com/wzpan/hexo-renderer-pandoc">hexo-renderer-pandoc</a></h4><p>目前本博客采取的方案，在客户端使用 <code>mathjax</code> 渲染数学公式。相比于上面的 <code>hexo-renderer-syzoj-renderer</code> 容忍性较差：用来包裹行内公式的 <code>$</code> 和公式之间不能有空格，否则会渲染失败。此外，它对于一些其他的元素的渲染行为和 <code>hexo-renderer-marked</code> 的行为不同：比如对于 Markdown 图片 <code>![alt](url)</code>，它们的渲染结果分别如下：</p><p>使用 <code>hexo-renderer-marked</code> 的渲染结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span> <span class="attr">src</span>=<span class="string">&quot;url&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>使用 <code>hexo-renderer-pandoc</code> 的渲染结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span> <span class="attr">src</span>=<span class="string">&quot;url&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span></span><br><span class="line">    alt</span><br><span class="line">  <span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此外，另一个显著的问题是：直接写在文本中的链接（没有被 <code>&lt; &gt;</code> 和 <code>[]()</code> 包裹的链接）不会被自动加上超链接。</p><p>不过这对于 Volantis 而言倒也问题不大：上面这个问题实际上只要外挂一个 <code>CSS</code> 就没什么问题了；至少这样的渲染并不会影响到 <code>z-lazyload</code> 的脚本对于图片的标记。但是对于其他的，按照 <code>hexo-renderer-marked</code> 的渲染行为而设计主题，就可能会产生兼容性问题。</p><p>并且，使用 <code>hexo-renderer-pandoc</code> 可以正常渲染配置文件中那些使用 <code>markdown()</code> 渲染的字符串。因此真的可以卸载 <code>hexo-renderer-marked</code> 了！</p><p>另一个问题就是 <code>hexo-renderer-pandoc</code> 的渲染需要依赖本地的 <code>pandoc</code>：<a href="https://www.pandoc.org/installing.html">Pandoc - Installing pandoc</a>；如果只是本机生成静态文件再上传到服务器 / Github Page 倒也不算是什么问题了，但是如果我们使用自动部署，就需要对原来的部署脚本进行一些修改：</p><h5 id="github-action">Github Action</h5><p>在编译和部署的命令之前增加安装 Pandoc 的命令：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+ - name: Setup Pandoc</span></span><br><span class="line"><span class="addition">+   run: |</span></span><br><span class="line"><span class="addition">+     wget https://github.com/jgm/pandoc/releases/download/2.10.1/pandoc-2.10.1-1-amd64.deb</span></span><br><span class="line"><span class="addition">+     sudo dpkg -i pandoc-2.10.1-1-amd64.deb</span></span><br></pre></td></tr></table></figure><h5 id="vercel">Vercel</h5><p>目前无法在 Vercel 上安装 <code>Pandoc</code>，所以无法使用 Vercel 来构建博客的静态文件。</p><h2 id="总结">总结</h2><ul><li><code>hexo-renderer-syzoj-renderer</code>：如果对 <code>Pjax</code> 没有什么要求，且使用的主题没有兼容性的问题；</li><li><code>hexo-renderer-pandoc</code>：兼容性略好，但是无法使用 <code>Vercel</code> 自动构建静态页面；</li></ul><p>Volantis 的社区里也确实没有说这个相关的文章啊，还是写一篇好了（</p><p>虽然但是，还是希望能够解决这个兼容性问题能用上 <code>hexo-renderer-syzoj-renderer</code> 啊（）用 Pandoc 渲染在各种方面还是有点麻烦了==</p>]]></content>
    
    <summary type="html">
    
      得益于 mathjax，在静态博客里可以简单的插入数学公式；但是 Hexo 默认的渲染器 marked 并不能正确的渲染多行公式；本文简单考据了一些常见的替代渲染器
    
    </summary>
    
    
      <category term="折腾记录" scheme="https://shiraha.cn/categories/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="水" scheme="https://shiraha.cn/tags/%E6%B0%B4/"/>
    
      <category term="hexo" scheme="https://shiraha.cn/tags/hexo/"/>
    
      <category term="废话" scheme="https://shiraha.cn/tags/%E5%BA%9F%E8%AF%9D/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round#714 div.2 回顾</title>
    <link href="https://shiraha.cn/2021/codeforces-round-714-div2/"/>
    <id>https://shiraha.cn/2021/codeforces-round-714-div2/</id>
    <published>2021-04-12T04:58:33.000Z</published>
    <updated>2021-04-12T04:58:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>补题链接：<a href="https://codeforces.com/contest/1513" class="uri">https://codeforces.com/contest/1513</a></p></blockquote><h2 id="记录">记录</h2><p>总算是最后勉勉强强地成为了 ABCD 选手，，但是因为失明不长脑子以及没有手等众多因素，导致我这场比赛的罚时高的离谱，，四个题都会做甚至排名 500+（</p><p>当然，这场的题目比昨天发的<a href="https://shiraha.cn/2021/codeforces-round-712-div2/">那篇文章</a>的那套题还要水的多，，只能说…什么也说不出（</p><figure><img src="https://i.loli.net/2021/04/12/1MZkR637v5xn2zC.jpg" class="lazyload" data-srcset="https://i.loli.net/2021/04/12/1MZkR637v5xn2zC.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="S3DP4B0L_1J2VG8J0_7_W.jpg" /><figcaption aria-hidden="true">S3DP4B0L_1J2VG8J0_7_W.jpg</figcaption></figure><p>然后吃午饭的时候看一 20 级学弟在群里装杯，一查 CF 结果昨天这场他做了五个题，罚时也把我吊起来打……老年人的眼泪不争气地掉了下来（</p><h2 id="题解">题解</h2><h3 id="a---array-and-peaks">A - <a href="https://codeforces.com/contest/1513/problem/A">Array and Peaks</a></h3><p>没什么好说的，由手就行，没手也行（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = $.nextInt(), n, k;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        input, n, k;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; (n - <span class="number">1</span>) / <span class="number">2</span>)</span><br><span class="line">            output, <span class="number">-1</span>, <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++ i)</span><br><span class="line">                a[i * <span class="number">2</span> + <span class="number">2</span>] = n - i;</span><br><span class="line">            <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">                <span class="keyword">if</span> (!a[i]) a[i] = ++ cur;</span><br><span class="line">            $.putArray(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="b---and-sequences">B - <a href="https://codeforces.com/contest/1513/problem/B">AND Sequences</a></h3><p>显然，考虑极端情况 <span class="math inline">\(a_1 \&amp; a_2 \&amp; \cdots \&amp; a_{n - 1} = a_n\)</span> 是成立的，那么显然有 <span class="math inline">\(\&amp;_{i = 1}^n a_i = a_n\)</span>；同理也可以证明 <span class="math inline">\(\&amp;_{i = 1}^n a_i = a_1\)</span>；因此只需要先对数组求按位与的和，然后查找这个数字在数组里出现的次数；从中选择两个放在头尾，剩下的数字放在中间随便摆。</p><p>很简单的一个题，思路也很清晰……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], fact[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    fact[<span class="number">0</span>] = fact[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (longs i = <span class="number">2</span>; i &lt; N; ++ i)</span><br><span class="line">        fact[i] = <span class="keyword">int</span>(fact[i - <span class="number">1</span>] * i % mod);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = $.nextInt(), n;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        $(n).nextArray(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">        uint mask = ~<span class="number">0u</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            mask &amp;= (uint) a[i];</span><br><span class="line">        longs cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (mask == a[i]) ++ cnt;</span><br><span class="line">        cnt = cnt * (cnt - <span class="number">1</span>) % mod;</span><br><span class="line">        output, cnt * fact[n - <span class="number">2</span>] % mod, <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来应该是这样的，，但是因为我最开始预处理的时候没有赋值 <code>fact[0] = 1</code>，导致我 WA 的生活不能自理直接放弃，直到最后面才意识到这个问题的，，，我是傻逼嘛（</p><h3 id="c---add-one">C - <a href="https://codeforces.com/contest/1513/problem/C">Add One</a></h3><p>显然，对于一个具体的数字，我们进行 <span class="math inline">\(n\)</span> 次变换的结果时独立确定的，也可以表现为 10 个数字的个数。因为变换的上线也只有 <span class="math inline">\(2 \times 10^5\)</span> 级别，所以完全可以预处理后，对于具体的数字变形后查询得到答案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">10</span>][N], f[<span class="number">10</span>][<span class="number">10</span>], tmp[<span class="number">10</span>], cnt[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">transfer</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(tmp, <span class="number">0</span>, <span class="keyword">sizeof</span> tmp);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++ i)</span><br><span class="line">        tmp[i + <span class="number">1</span>] = f[id][i];</span><br><span class="line">    tmp[<span class="number">1</span>] += f[id][<span class="number">9</span>], tmp[<span class="number">0</span>] += f[id][<span class="number">9</span>];</span><br><span class="line">    tmp[<span class="number">1</span>] %= mod, tmp[<span class="number">0</span>] %= mod;</span><br><span class="line">    longs ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : tmp) ret += i;</span><br><span class="line">    <span class="built_in">memcpy</span>(f[id], tmp, <span class="keyword">sizeof</span> tmp);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(ret %= mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++ i)</span><br><span class="line">        f[i][i] = dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; ++ j)</span><br><span class="line">            dp[j][i] = transfer(j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = $.nextInt(), n, m;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        input, n, m;</span><br><span class="line">        longs ans = <span class="number">0</span>;</span><br><span class="line">        itoa(n, s, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">char</span> *st = s;</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="keyword">sizeof</span> cnt);</span><br><span class="line">        <span class="keyword">while</span> (*st) ++ cnt[*st - <span class="string">&#x27;0&#x27;</span>], st ++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++ i) &#123;</span><br><span class="line">            ans += <span class="number">1l</span>l * dp[i][m] * cnt[i];</span><br><span class="line">            ans %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">        output, ans, <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然，我这样写还是有点蠢的：实际上并不需要枚举每一个数字的变换，只需要枚举 0 的变换即可。</p><h3 id="d---gcd-and-mst">D - <a href="https://codeforces.com/contest/1513/problem/D">GCD and MST</a></h3><blockquote><p>一张图，有 <span class="math inline">\(n\)</span> 个节点，每个点都有权值 <span class="math inline">\(a_i\)</span>；相邻节点之间连接了权值为 <span class="math inline">\(p\)</span> 的边（共 <span class="math inline">\(n - 1\)</span> 条）；此外，对于下标 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(j\)</span> 即 <span class="math inline">\(1 \leq i &lt; j \leq n\)</span>，如果满足 <span class="math inline">\(\gcd_{k = i}^j a_k = \min_{k = i}^j a_k\)</span>，则 <span class="math inline">\(i \leftrightarrow j\)</span> 之间连接一条权重为 <span class="math inline">\(\min_{k = i}^j a_k\)</span> 的边；</p><p>现在要求求出这张图的最小生成树的边权值之和。</p></blockquote><p>看到最小值，就联想到要考虑最小值的区间；先对于 <span class="math inline">\(a[i]\)</span> 排序，然后对于每个最小值，向左向右尝试找到包含这个最小值的连续区间；显然，这个连续区间中的每一个节点都可以互相连接边权为这个最小值的边；对于长度为 <span class="math inline">\(l\)</span> 的这样的区间，我们只需要连接 <span class="math inline">\(l - 1\)</span> 条这样的边即可。</p><p>这样虽然解决了最小值区间内的问题，但是最小值区间之间也可能连边；所以最小值探边界的时候，如果遇到了已经被之前的（更小的）最小值占领的区间，仍需要额外考虑一次来判断是否可以连边来连接两个区间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = $.nextInt(), n, p;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">-1</span>, <span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;, greater&lt;&gt;&gt; heap;</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        $(n, p).nextArray(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (!heap.empty()) heap.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            heap.emplace(a[i], i);</span><br><span class="line">        <span class="keyword">int</span> res = n - <span class="number">1</span>;</span><br><span class="line">        longs ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!heap.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> [x, ii] = heap.top();</span><br><span class="line">            <span class="keyword">if</span> (x &gt;= p) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> heap.pop();</span><br><span class="line">            <span class="keyword">if</span> (vis[ii] == T) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span> vis[ii] = T;</span><br><span class="line">            <span class="keyword">int</span> g = x, l = ii - <span class="number">1</span>, r = ii + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">auto</span> gg = gcd(x, a[l]);</span><br><span class="line">                <span class="keyword">if</span> (gg == g) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (vis[l] == T) &#123;</span><br><span class="line">                        -- l; <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> vis[l --] = T;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (r &lt;= n) &#123;</span><br><span class="line">                <span class="keyword">auto</span> gg = gcd(x, a[r]);</span><br><span class="line">                <span class="keyword">if</span> (gg == g) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (vis[r] == T) &#123;</span><br><span class="line">                        ++ r; <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> vis[r ++] = T;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += longs(r - l - <span class="number">2</span>) * x;</span><br><span class="line">            res -= r - l - <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += <span class="number">1l</span>l * res * p;</span><br><span class="line">        output, ans, <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想通了实际上也就这么一回事，但是我却还是白给了两发…… 因为我认为我的手会敲出和我脑子想象中一样的代码，但是实际上手没有，，导致我一度以为我想错了开始胡思乱想，，还是菜的离谱了点（</p><h3 id="e---cost-equilibrium">E - <a href="https://codeforces.com/contest/1513/problem/E">Cost Equilibrium</a></h3><blockquote><p>有一个长度为 <span class="math inline">\(n\)</span> 的数组，每个位置都有值 <span class="math inline">\(a_i\)</span>；现在你可以花费 <span class="math inline">\(x \cdot |i - j|\)</span> 的成本，使得 <span class="math inline">\(a_i\)</span> 减少 <span class="math inline">\(x\)</span> 并使得 <span class="math inline">\(a_j\)</span> 增加 <span class="math inline">\(x\)</span>，操作中不能有任何值变为负数；每个点只能进行一类操作（减少操作和增加操作不能出现在同一个节点上）；将数组中的所有值全部变为相等而进行的操作带来的成本和定义为数组的成本。</p><p>现在要求你重新排列数组，使得数组的成本的最小值和最大值相等。求出这样重新排列后的数组的个数。</p></blockquote><p>题目一通花里胡哨完了之后实际上没啥内容；首先排除 <span class="math inline">\(\sum a_i \mod n \neq 0\)</span> 的情况。那么剩下来的情况就都满足 <span class="math inline">\(n \ | \sum a_i\)</span>；令 <span class="math inline">\(x = \sum a_i \div n\)</span>。</p><p>然后考虑：因为每个节点只能承担一种角色，所以</p><ul><li><span class="math inline">\(a_i &gt; x\)</span> 的节点只能是出点，<span class="math inline">\(a_i &lt; x\)</span> 的节点只能是入点</li><li><span class="math inline">\(a_i \neq x\)</span> 的节点不能参与任何操作</li></ul><p>失明的我一开始把这个限制条件看成了每个节点只能运入一次运出一次，然后鼓捣了个假做法，发现和题解完全不同<del>但是过了样例，要是比赛中这样那我大概也是个假人了</del>，不过似乎可以出个新题（？）</p><p>我们记小于平均值的节点的数量为 <span class="math inline">\(l\)</span>，大于平均值的节点数量为 <span class="math inline">\(g\)</span>；那么可以进行下面的猜想：</p><ul><li><span class="math inline">\(l = 0\)</span> 并且 <span class="math inline">\(g = 0\)</span>：显然，全数组已经相同，只有 <span class="math inline">\(1\)</span> 种排列满足要求</li><li><span class="math inline">\(l = 1\)</span> 或 <span class="math inline">\(g = 1\)</span>：出点/入点是确定的，所以运输方案只有一种；任何排列都满足要求</li><li>否则：出点们和入点们分布在数组的两侧且互不相交时才可以满足要求</li></ul><p>关于第三条，很显然如果出入点之间产生了交错，那么中间节点的运输方向的改变会影响到答案。</p><p>又因为输出的是重排后的序列的种类数，所以在直接求排列数之后需要特殊处理出现了相同数字的位置：将它们的排列数从总的排列数中除掉；而等于平均值插入到排序中可以使用组合数求出。</p><h4 id="补题代码">补题代码</h4><p>因为涉及到了排列组合，并且是模意义下运算，所以需要预处理阶乘和阶乘的逆元。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], n, fact[N], inv[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Inverse &#123;</span><br><span class="line">    <span class="function">longs <span class="title">fastPow</span><span class="params">(longs a, longs b, longs mod)</span> </span>&#123;</span><br><span class="line">        longs ans = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (b) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b &amp; <span class="number">1u</span>) ans = (ans * a) % mod;</span><br><span class="line">            a = (a * a) % mod;</span><br><span class="line">            b &gt;&gt;= <span class="number">1u</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">longs <span class="title">inverse</span><span class="params">(longs a, longs p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; p || a &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">1</span> &amp;&amp; p) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> fastPow(a, p - <span class="number">2</span>, p) % p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    fact[<span class="number">0</span>] = fact[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (longs i = <span class="number">2</span>; i &lt; N; ++i)</span><br><span class="line">        fact[i] = <span class="keyword">int</span>(fact[i - <span class="number">1</span>] * i % mod);</span><br><span class="line">    inv[N - <span class="number">1</span>] = (<span class="keyword">int</span>)Inverse::inverse(fact[N - <span class="number">1</span>], mod);</span><br><span class="line">    <span class="keyword">for</span> (longs i = N - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        inv[i] = (<span class="keyword">int</span>)(inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % mod);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> nCr = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &lt; <span class="number">0</span> || b &gt; a) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        longs ret = fact[a];</span><br><span class="line">        ret = (ret * inv[a - b]) % mod;</span><br><span class="line">        ret = (ret * inv[b]) % mod;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)ret;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    $(n).nextArray(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    lll sum = accumulate(a + <span class="number">1</span>, a + <span class="number">1</span> + n, (lll) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sum % n) &#123;</span><br><span class="line">        output, <span class="number">0</span>, <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> x = sum / n;</span><br><span class="line">    <span class="keyword">int</span> less = <span class="number">0</span>, greater = <span class="number">0</span>, equal = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line">    cnt.reserve(N * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        ++cnt[a[i]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; x) ++greater;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &lt; x) ++less;</span><br><span class="line">        <span class="keyword">else</span> ++equal;</span><br><span class="line">    <span class="keyword">if</span> (!less &amp;&amp; !greater) &#123;</span><br><span class="line">        output, <span class="number">1</span>, <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (less == <span class="number">1</span> || greater == <span class="number">1</span>) &#123;</span><br><span class="line">        lll ans = fact[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [k, v] : cnt)</span><br><span class="line">            ans = (ans * inv[v]) % mod;</span><br><span class="line">        output, ans, <span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> ans = (lll)fact[less] * fact[greater] % mod;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [k, v] : cnt)</span><br><span class="line">            <span class="keyword">if</span> (k != x)</span><br><span class="line">                ans = (ans * inv[v]) % mod;</span><br><span class="line">        ans *= <span class="number">2</span>, ans %= mod;</span><br><span class="line">        ans = (ans * nCr(n, equal)) % mod;</span><br><span class="line">        output, ans, <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为最开始没有特判全数组相等的情况，所以白给了一发（</p><h3 id="f---swapping-problem">F - <a href="https://codeforces.com/contest/1513/problem/F">Swapping Problem</a></h3><blockquote><p>现在你有两个长度为 <span class="math inline">\(n\)</span> 的数组 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span>；数组的权值之和是 <span class="math inline">\(\sum|a_i - b_i|\)</span>；你现在可以进行最多 1 次的交换：将 <span class="math inline">\(b\)</span> 中的两个数字交换位置；问可以求得的最小权值是多少。</p></blockquote><p>对于每个位置 <span class="math inline">\(i\)</span>，我们可以将它看作一个区间；那么权值和就是所有的区间大小的和。我们能做的是交换其中某两个区间的特定端点，从而使得总区间大小变小。要想实现这种交换，我们交换的两个端点在对应的区间中的角色必须不同（显然，如果角色相同，交换了没有任何意义）；</p><p>而进行简单的推导我们可以得出猜想：交换了两个在对应区间中角色不同的端点，带来的贡献是两个区间重复部分的 2 倍；如果两个区间没有重叠，那么就会造成两个区间间隔的两倍的负贡献。因此，我们只要找到来自两个部分的，且有最大覆盖的区间，就可以求出最小的权值。</p><p>我们将所有的区间分成两类：<span class="math inline">\(I\)</span> 类以 <span class="math inline">\(a_i\)</span> 为左端点，而 <span class="math inline">\(II\)</span> 类以 <span class="math inline">\(b_i\)</span> 为左端点；因此，交换的两个区间必须一个来自 <span class="math inline">\(I\)</span>，另一个来自 <span class="math inline">\(II\)</span>；在按照左边界排序之后，维护每组的前缀的最大右边界；这样我们就可以快速的查找对于某个区间而言，可能形成最大覆盖的来自另一组的区间；遍历一组，查找另一组，更新答案即可。</p><h4 id="补题代码-1">补题代码</h4><p>当然，这个经典的问题也可以使用双指针来解决，就像下面这样；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortVector</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">    sort(vec.begin(), vec.end());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    $(n).nextArray(a + <span class="number">1</span>, a + <span class="number">1</span> + n)</span><br><span class="line">        .nextArray(b + <span class="number">1</span>, b + <span class="number">1</span> + n);</span><br><span class="line">    lll ans = <span class="number">0</span>, origin = <span class="number">0</span>, pp = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; I, II;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; b[i]) &#123;</span><br><span class="line">            I.emplace_back(a[i], b[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            II.emplace_back(b[i], a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        origin += <span class="built_in">abs</span>(a[i] - b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> sizI = I.size(), sizII = II.size();</span><br><span class="line">    sortVector(I), sortVector(II);</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; heap;</span><br><span class="line">    ans = origin, pp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [L, R] : I) &#123;</span><br><span class="line">        <span class="keyword">while</span> (pp &lt; sizII &amp;&amp; II[pp].first &lt;= L) &#123;</span><br><span class="line">            heap.push(II[pp].second), ++ pp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!heap.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> lastR = heap.top();</span><br><span class="line">            minimize(ans, origin - <span class="number">2</span> * (min(lastR, R) - L));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!heap.empty()) heap.pop();</span><br><span class="line">    pp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> [L, R] : II) &#123;</span><br><span class="line">        <span class="keyword">while</span> (pp &lt; sizI &amp;&amp; I[pp].first &lt;= L) &#123;</span><br><span class="line">            heap.push(I[pp].second), ++ pp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!heap.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> lastR = heap.top();</span><br><span class="line">            minimize(ans, origin - <span class="number">2</span> * (min(R, lastR) - L));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    output, ans, <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老年人光是想着怎么维护这个区间的最大覆盖就想了半个上午，属实不行（</p><h2 id="后记">后记</h2><p>唉，感觉这一场也没什么难的啊，只可惜前面罚时实在是太多了，，写代码的时候竟然连 <span class="math inline">\(0!=1\)</span> 这种常识性的东西都能不注意，也算是重新认识了自己==</p><p>今晚还有 EDU 场，不废话了，好好打啊（</p>]]></content>
    
    <summary type="html">
    
      没什么好说的，虽然 ABCD 了，但是题目也是真的不难，我的罚时也是真的多的离谱，，，被 20 级学弟爆锤力呜呜呜（
    
    </summary>
    
    
      <category term="题解" scheme="https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="算法" scheme="https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM" scheme="https://shiraha.cn/tags/ACM/"/>
    
      <category term="Codeforces" scheme="https://shiraha.cn/tags/Codeforces/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round#712 div.2 回顾</title>
    <link href="https://shiraha.cn/2021/codeforces-round-712-div2/"/>
    <id>https://shiraha.cn/2021/codeforces-round-712-div2/</id>
    <published>2021-04-11T11:31:23.000Z</published>
    <updated>2021-04-11T11:31:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>补题链接：<a href="https://codeforces.com/contest/1504" class="uri">https://codeforces.com/contest/1504</a></p></blockquote><h2 id="记录">记录</h2><p>只能说进入四月一来一直颓的可以，，不仅没怎么训练没怎么准备考研，倒是莫名其妙地出去混了一天又一天，真的是愧对父母，，虽然出了各种各样的事情，但是再怎么说成年人还是应该对自己的行为负责…… 不废话了（</p><p>题目的话，A 白给一发，不过当时带人来 401 玩了，我还没有牛逼到一心二用还能好好写代码（）然后干脆直接 Div1 起步，从 C 开始做；然后做出了 C 和 D（当然，也花了相当的时间）之后就没怎么管了，，再之后（指一个星期之后的今天）补完了所有的题目。</p><p>但是听说这场 ABC 蓝名选手是要掉分的，做出了 ABCD 四个题的喜悦瞬间荡然无存，，</p><h2 id="题解">题解</h2><h3 id="a---déjà-vu">A - <a href="https://codeforces.com/contest/1504/problem/A">Déjà Vu</a></h3><p>反正就是破坏回文串：最简单的方法就是在前面加或者在后面加；都不行就输出 <code>NO</code> 就完事了（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> null = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[N], b[N], c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = $.nextInt();</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        input, a;</span><br><span class="line">        <span class="keyword">auto</span> n = <span class="built_in">strlen</span>(a);</span><br><span class="line">        <span class="built_in">strcpy</span>(b, a);</span><br><span class="line">        b[n] = <span class="string">&#x27;a&#x27;</span>, b[n + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(c, b);</span><br><span class="line">        reverse(c, c + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(b, c) != <span class="number">0</span>) &#123;</span><br><span class="line">            $.put(<span class="string">&quot;YES&quot;</span>).put(b);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcpy</span>(b + <span class="number">1</span>, a);</span><br><span class="line">        b[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>, b[n + <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(c, b);</span><br><span class="line">        reverse(c, c + <span class="number">1</span> + n);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(b, c) != <span class="number">0</span>) &#123;</span><br><span class="line">            $.put(<span class="string">&quot;YES&quot;</span>).put(b);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> $.put(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便，这是我第一次使用全新的<del>傻逼</del>快读板子 <code>cquery</code>，IO 交互和以往的代码可能有较大的差距（</p><h3 id="b---flip-the-bits">B - <a href="https://codeforces.com/contest/1504/problem/B">Flip the Bits</a></h3><p>和前缀和很想，可以很容易的想到如果要反转，反转的端点一定要出现在可以翻转的位置上；</p><p>本来想着先遍历维护端点，在遍历求区间，在验证区间是否合法的；但是实际上只需要双指针（甚至单个指针）就完事了；代码量远没有我想象的那么大……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> null = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T = $.nextInt();</span><br><span class="line">    <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = $.nextInt();</span><br><span class="line">        $(a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> cnt0 = <span class="number">0</span>, cnt1 = <span class="number">0</span>, ok = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] != b[i]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt1 != cnt0) &#123; ok = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="keyword">while</span> (a[j] != b[j]) &#123;</span><br><span class="line">                    ++ (a[j] == <span class="string">&#x27;1&#x27;</span> ? cnt1 : cnt0);</span><br><span class="line">                    ++ j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cnt1 != cnt0) &#123; ok = <span class="number">0</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">                <span class="keyword">else</span> i = j;</span><br><span class="line">            &#125;</span><br><span class="line">            ++ (a[i] == <span class="string">&#x27;1&#x27;</span> ? cnt1 : cnt0);</span><br><span class="line">        &#125;</span><br><span class="line">        $.put(ok ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能说写代码还是写少了，，惭愧惭愧（</p><h3 id="c---balance-the-bits">C - <a href="https://codeforces.com/contest/1504/problem/C">Balance the Bits</a></h3><blockquote><p>给一个 01 字符串：现在你要构造两个等长的括号序列，要求字符串为 0 的位置两个序列的括号不同，为 1 的位置相同；输出一种构造或者声明这是不可能的。</p></blockquote><p>显然，0 和 1 的位置必须都是偶数个，并且两端的数字都为 1；否则显然不行。</p><p>现在分开考虑 0 和 1；0 本身构成的序列一定是一个合理的序列，但是要求翻转之后也要成立；为了避免麻烦的括号嵌套，只能构造为 <code>()()()...</code> 的序列了；这样翻转之后的 <code>)()()(...</code> 也可以和两端为 1 的位置匹配。</p><p>同样还是为了解决麻烦的括号嵌套问题：因为 0 位置翻转之后可能会造成不必要的闭括号，所以考虑尽量提高嵌套层数；构造为 <code>...((()))...</code> 的形式可以达到这个目标；至此，我们得到了一种构造方法；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> s[N], ans[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt();</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        scanner(s);</span><br><span class="line">        <span class="keyword">int</span> cnt0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;0&#x27;</span>) ++ cnt0;</span><br><span class="line">        <span class="keyword">if</span> (cnt0 % <span class="number">2</span> || s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> || </span><br><span class="line">            s[n - <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span>) println(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            println(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> cnt1 = n - cnt0, half = cnt1 / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> flag0 = <span class="number">0</span>, flag1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&#x27;1&#x27;</span>) </span><br><span class="line">                    ans[i] = flag1 ++ &lt; half ? <span class="string">&#x27;(&#x27;</span> : <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span> ans[i] = flag0 ? <span class="string">&#x27;(&#x27;</span> : <span class="string">&#x27;)&#x27;</span>, flag0 = <span class="number">1</span> - flag0;</span><br><span class="line">            ans[n] = <span class="string">&#x27;\0&#x27;</span>, println(ans);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">                <span class="keyword">if</span> (s[i] == <span class="string">&#x27;0&#x27;</span>) ans[i] = ans[i] == <span class="string">&#x27;(&#x27;</span> ? <span class="string">&#x27;)&#x27;</span> : <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            println(ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我也不知道怎么证明，，<a href="https://codeforces.com/blog/entry/89319">题解</a>也什么都没有说清楚……只能说想到了就是想到了（</p><h3 id="d---3-coloring">D - <a href="https://codeforces.com/contest/1504/problem/D">3-Coloring</a></h3><blockquote><p>有 <span class="math inline">\(n \times n\)</span> 的棋盘和三种颜料；提供一个长度为 <span class="math inline">\(n^2\)</span> 操作序列，对于每个操作，你可以将任意一个没有染色的格子染色为提供的颜色之外的颜色；要求染色完成后没有任何四联通的两个位置同色，过程<strong>强制在线</strong>。</p></blockquote><p>没长眼睛的我一开始看成了必须染色为提供的颜色；然后白乎了半天证明了这个问题是无解的——还好我后来又重新读题了== 将两种指示归因为一种颜色，另一个指示归因为另一个颜色，然后交叉的填即可——如果有一种颜色先填满，那么这个指令就以另一种颜色填入另一组位置即可；显然，这样是合理的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n, b, x, y, a;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> t = n * n;</span><br><span class="line">    <span class="keyword">int</span> T = t;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; pos1, pos2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            ((i + j) % <span class="number">2</span> ? pos2 : pos1).emplace(i, j);</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">        <span class="keyword">switch</span> (a)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> (!pos2.empty()) </span><br><span class="line">                    x = pos2.front().first, </span><br><span class="line">                    y = pos2.front().second, </span><br><span class="line">                    b = <span class="number">2</span>, pos2.pop();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    x = pos1.front().first, </span><br><span class="line">                    y = pos1.front().second, </span><br><span class="line">                    b = <span class="number">3</span>, pos1.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> (!pos1.empty())</span><br><span class="line">                    x = pos1.front().first, </span><br><span class="line">                    y = pos1.front().second, </span><br><span class="line">                    b = <span class="number">1</span>, pos1.pop();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    x = pos2.front().first, </span><br><span class="line">                    y = pos2.front().second, </span><br><span class="line">                    b = <span class="number">3</span>, pos2.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">if</span> (!pos1.empty())</span><br><span class="line">                    x = pos1.front().first, </span><br><span class="line">                    y = pos1.front().second, </span><br><span class="line">                    b = <span class="number">1</span>, pos1.pop();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    x = pos2.front().first, </span><br><span class="line">                    y = pos2.front().second, </span><br><span class="line">                    b = <span class="number">2</span>, pos2.pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>愿天堂没有失明🙏</p><h3 id="e---travelling-salesman-problem">E - <a href="https://codeforces.com/contest/1504/problem/E">Travelling Salesman Problem</a></h3><blockquote><p>有 <span class="math inline">\(n\)</span> 个城市，每个城市有一个美丽值 <span class="math inline">\(a_i\)</span> 和起步价 <span class="math inline">\(c_i\)</span>，初始在 <span class="math inline">\(1\)</span> 号城市；现在我们要到达所有的 <span class="math inline">\(n\)</span> 个城市一次后返回 <span class="math inline">\(1\)</span> 号城市；路途 <span class="math inline">\(i \to j\)</span> 的花费是 <span class="math inline">\(\max(c_i, a_j - a_i)\)</span>，求出达成目标的最少花费。</p></blockquote><p>从哪个城市出发无所谓的，因为路程是一个环；考虑这个起步价是一条路途出边决定的，而我们确定要从每个城市出去一次，所以这笔钱省不了；问题就在如何最小化额外花费；考虑路途 <span class="math inline">\(i \to j\)</span> 的额外花费，我们不难得到： <span class="math display">\[\max(c_i, a_j - a_i) = c_i + \max(0, a_j - a_i - c_i)\]</span> 显然，我们可以把美丽值看作是海拔：这样下坡就是免费的，上坡的话根据起点有所减费。我们的旅途反正是一个环，此时就转变为从最高点俯冲而下，然后再借助某些位置作为减费跳板回到山顶；这样的话会重复访问节点？拜托，俯冲的时候跳过这些节点不就完了，反正又不要钱（</p><p>此时，我们已经可以将这个问题转化为一个最短路问题，建模求解；建图方式如下：</p><ul><li>下坡：相邻的位置之间连边，显然免费</li><li>上坡：在坡上二分查找，找到最高的可以被减至 0 费的位置<ul><li>对于这个位置，显然连免费边：定义里都已经这么说了</li><li>对于这个位置的更高位置，连边，并用公式计算费用</li></ul></li></ul><p>其实原问题就可以朴素建图解决，但是边数是 <span class="math inline">\(O(n^2)\)</span> 的只能作罢；但是为什么可以这么建图呢？现在对于这个建图方法的合理性进行简单的说明：</p><p>下坡的话已经没有什么好说的了，我直接连免费边和从一堆免费边过去有什么区别呢？上坡的话可这么理解：首先上坡肯定是尽量的最大化的利用减费的——但是并不是没有代价：如果你要采用某个点的减费政策，就要放弃看来自更低的位置的减费；而前者未必比后者优。因此这个抉择就可以转化为：对于每个节点的减费政策，我是直接采用还是放弃前面的减费政策。</p><p>在前面的减费非常诱人的情况下，可能包含了多个可以免费的上坡位置——但是我们只需要建最高的位置即可：因为其他的位置可以用下坡边回流；但是一定会有一个位置，它可以减费但是无法减至免费：这个位置是关键位置，不可以被其他的边表示，因此也要连边。</p><p>综上所述，上述建图就可以完成对原问题的描述；在建图上跑最短路就可以得到答案。</p><hr /><p>当然，题解还提供了一种更简单的做法，但是相应地也更加的抽象难懂：</p><p>就像上面说的那样，下坡已经无所畏惧了，问题就是怎么巧妙利用减费来上坡；因此我们可以对所有节点根据“海拔”排序之后，从底部出发，递推地维护上坡到每个位置之后的最小花费。转化的答案可以描述为下面： <span class="math display">\[\sum_{i = 2}^n \max(0, a_i - \max_{j&lt;i}(a_j + c_j))\]</span> 即维护在更低位置中的最大折扣，到达每个位置的费用都等于到达最大折扣的位置的最少费用加上利用这个折扣跳转到当前位置的费用之和。但是我们毕竟只关注到达顶点的费用，如对于每一个位置都严格的维护这个又显的太过于复杂；所以只需要维护到达每个位置使用可用的最大减费之后的费用和即可。</p><p>那么为什么这样是正确的呢？显然，在没有这个减费的情况下，上坡的费用完全就是势能的转化：那个<del>高中物理</del>名词叫啥我忘记了；减费政策就相当于在坡上放倒三角；我们维护的总是当前势能加上减费后能量最高的位置——也就是加上减费后最高的位置。我们爬斜坡需要能量，但是倒三角覆盖的部分不需要能量；因此，我们只需要尽量用倒三角覆盖斜坡，就可以统计得到最小的费用。</p><h4 id="补题代码">补题代码</h4><p>贪心也得取之有道啊，瞎**贪心是做不出题目的啊（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[N], c[N], id[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> a[l] &lt; a[r];&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">    longs ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        a[i] = scanner.nextInt(),</span><br><span class="line">        c[i] = scanner.nextInt(),</span><br><span class="line">        ans += c[i];</span><br><span class="line">    iota(id, id + <span class="number">1</span> + n, <span class="number">0</span>);</span><br><span class="line">    sort(id + <span class="number">1</span>, id + <span class="number">1</span> + n, compare);</span><br><span class="line">    longs discount = a[id[<span class="number">1</span>]] + c[id[<span class="number">1</span>]];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, p = id[i]; </span><br><span class="line">        i &lt;= n; p = id[++ i])</span><br><span class="line">    &#123;</span><br><span class="line">        ans += max(<span class="number">0l</span>l, a[p] - discount);</span><br><span class="line">        maximize(discount, (longs)a[p] + c[p]);</span><br><span class="line">    &#125;</span><br><span class="line">    println(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能说做题的时候还是瞎想多了，，</p><h3 id="f---flip-the-cards">F - <a href="https://codeforces.com/contest/1504/problem/F">Flip the Cards</a></h3><blockquote><p>有 <span class="math inline">\(n\)</span> 张牌，牌的两面写了互不相同的 <span class="math inline">\([1, 2n]\)</span> 的数字；现在你需要对牌进行排序，并翻转部分牌，得到一个新的牌的序列：满足正面的数字递增且反面的数字递减。求出最少的翻转次数或者证明这不可能。</p></blockquote><p>我距离做出这个题的距离还是挺遥远的…… 甚至当晚看题解都没有看懂……菜爆了（</p><p>首先需要意识到有解的套牌必须满足一张牌的两面必须一个属于 <span class="math inline">\([1, n]\)</span> 另一个属于 <span class="math inline">\([n+1, 2n]\)</span>，否则无解；这也很好理解，毕竟我问我的学弟队友，他也是一眼意识到这个<del>只有我这个老东西后知后觉了呜呜</del></p><p>满足了上述限制的套牌，我们先进行翻转，保证正面比反面的数字小，那么就可以桶排序；按照正面数字排序之后的套牌，第 <span class="math inline">\(i\)</span> 张的正面数字是 <span class="math inline">\(i\)</span>，反面的数字记为 <span class="math inline">\(f[i]\)</span>；</p><p>首先给出一种确定可以构造出满足题意的排序的构造方法：如果上述的 <span class="math inline">\(f[i]\)</span> 构成的序列，可以拆分成两个递减的子序列，那么可以将拆解得到的两个部分中的一部分翻转后倒序，拼装到另一个部分的后面组成一个满足题意的序列；如果考虑到最少翻转次数，只需要翻转其中翻转成本较低的一组即可。</p><p>翻转成本的计算也非常简单：分成的序列中可能包含了一些在桶排序的时候翻转的卡牌，翻转一个序列的成本就是另一个序列中的这些卡牌的数量加上待翻转序列中除此之外的卡牌的数量。</p><p>但是问题就是 <span class="math inline">\(f[i]\)</span> 可能有多种分割的方法；而上述翻转的成本中的冗余都是因为有些卡牌可以放到另一个序列中避免翻转或者翻转回来导致的。因此我们有必要进行唯一的最优分解，才能求出这个答案；最优的分解很显然就是每当出现逆序对的时候，考虑翻转的成本，并选择更优的一侧翻转；之后将这些逆序对合并成序列即可。</p><p>但是并不是所有的划分都是可以复原的，所以划分时需要加入条件；这里采用的是 <span class="math inline">\(f[i]\)</span> 的前缀最小值大于后缀最大值的时候可以划分；这至少是一个充分的条件，保证翻转之后的序列的两个部分可以嵌套着还原为原序列。</p><p>虽然有很多部分还是没有太清楚的明白，但是还是知道了一些事情：我只需要考虑可以构造出最小花费的序列的方法即可，至于有没有别的方法，Who care？当然，必要性还是需要证明的……这我就实在不太懂了（</p><h4 id="补题代码-1">补题代码</h4><p>经典对着标程猜测题解，，逊（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a[N];</span><br><span class="line"><span class="built_in">bitset</span>&lt;N&gt; rev;</span><br><span class="line"><span class="keyword">int</span> f[N], suf[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(null), <span class="built_in">cout</span>.tie(null);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = $.nextInt();</span><br><span class="line">    $.nextArray(a + <span class="number">1</span>, a + <span class="number">1</span> + n);</span><br><span class="line">    <span class="keyword">bool</span> legal = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i].first &gt; a[i].second) &#123;</span><br><span class="line">            swap(a[i].first, a[i].second);</span><br><span class="line">            rev.<span class="built_in">set</span>(a[i].first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[i].first &gt; n || a[i].second &lt;= n) &#123;</span><br><span class="line">            legal = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> f[a[i].first] = a[i].second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!legal) &#123;</span><br><span class="line">        output, <span class="number">-1</span>, <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        suf[n + <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; -- i)</span><br><span class="line">            suf[i] = max(f[i], suf[i + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> pref = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="keyword">int</span> cosA = <span class="number">0</span>, cosB = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; seqA, seqB;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i) &#123;</span><br><span class="line">            minimize(pref, f[i]);</span><br><span class="line">            <span class="keyword">if</span> (seqA.empty() || seqA.back() &gt; f[i])</span><br><span class="line">                seqA.push_back(f[i]), cosA += rev[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (seqB.empty() || seqB.back() &gt; f[i])</span><br><span class="line">                seqB.push_back(f[i]), cosB += rev[i];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                output, <span class="number">-1</span>, <span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pref &gt; suf[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> sizA = (<span class="keyword">int</span>)seqA.size(),</span><br><span class="line">                    sizB = (<span class="keyword">int</span>)seqB.size();</span><br><span class="line">                ans += min(cosA + sizB - cosB, cosB + sizA - cosA);</span><br><span class="line">                cosA = cosB = <span class="number">0</span>;</span><br><span class="line">                seqA.clear(), seqB.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        output, ans, <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这甚至还是个 2-SAT 问题，，可以见得乱搞的方法有很多，只是我都不会罢了（</p><h2 id="后记">后记</h2><p>想到了昨天 zcysky 说过的：Div2 本身已经足够白给了；突然就再次的感觉到——不管是为了什么的努力，重要的是看到成效，而不仅仅是自虐地自我满足。说教别人警惕这种繁荣的幻想的同时，我自己不也是这样吗？</p><p>对于我这种起步晚，学习慢的残疾 ICPCer 而言，更应该是脚踏实地地讲究训练方法效率，做有用的事情才行啊（</p><figure><img src="https://i.loli.net/2021/04/11/kupnAj6r93Io4yK.jpg" class="lazyload" data-srcset="https://i.loli.net/2021/04/11/kupnAj6r93Io4yK.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="YJ_JI1_O_AZV2_HWPA_YQ.jpg" /><figcaption aria-hidden="true">YJ_JI1_O_AZV2_HWPA_YQ.jpg</figcaption></figure><p>唉，还是且行且珍惜——</p>]]></content>
    
    <summary type="html">
    
      没有实际参加，也没有 VP 的一场——输给了自己薄弱的意志（）事后来看题目倒也不算太难，大概能做个四个题目吧；但是 ABC 选手甚至守不住 1750 分，，还是有点吓人的==
    
    </summary>
    
    
      <category term="题解" scheme="https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="算法" scheme="https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM" scheme="https://shiraha.cn/tags/ACM/"/>
    
      <category term="Codeforces" scheme="https://shiraha.cn/tags/Codeforces/"/>
    
  </entry>
  
  <entry>
    <title>基础知识：FFT - 简单入门</title>
    <link href="https://shiraha.cn/2021/The-concept-of-fft-introducing-edition/"/>
    <id>https://shiraha.cn/2021/The-concept-of-fft-introducing-edition/</id>
    <published>2021-03-29T11:34:35.000Z</published>
    <updated>2021-03-29T11:34:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>一句话简介：FFT 即<strong>快速傅里叶变换</strong>，是一种可以在 <span class="math inline">\(n\log n\)</span> 的时间内完成多项式乘法的算法——的一部分。</p><h2 id="前置知识">前置知识</h2><p>在了解 FFT 之前，你可能需要先知道的一些东西：</p><h3 id="多项式">多项式</h3><p>对于数域 <span class="math inline">\(\mathbb{F}\)</span>，若有 <span class="math inline">\(\forall i\in\{1,2,3,\cdots,n \}\)</span>，则： <span class="math display">\[f(x)=a_0+a_1x+a_2x^2+\cdots+a_nx=\sum_{i=0}^n a_ix^i \ (a_n \neq 0)\]</span> 为数域 <span class="math inline">\(\mathbb{F}\)</span> 上的一个多项式；该多项式的次数即为其中最高次项的次数为 <span class="math inline">\(n\)</span>，记作 <span class="math inline">\(\deg f(x) = n\)</span>；</p><h4 id="表示方法">表示方法</h4><p>通常有两种表示方法</p><h5 id="系数表示法">系数表示法</h5><p>即上文定义中的表示方法，是一个向量；可以映射为系数向量 <span class="math inline">\(\vec{a}\)</span>： <span class="math display">\[f(x) = \sum_{i = 0}^n a_ix^i ⇔ \vec{a} = (a_0, a_1, \cdots ,a_n) \ (a_n \neq 0)\]</span> 我们将向量 <span class="math inline">\(\vec{a}\)</span> 成为多项式 <span class="math inline">\(f(x)\)</span> 的系数表示。</p><h5 id="点值表示法">点值表示法</h5><p>设 <span class="math inline">\(\deg f(x) = n\)</span>；众所周知，确定一个 <span class="math inline">\(n\)</span> 次函数的解析式，需要 <span class="math inline">\(n + 1\)</span> 个点的坐标；同理，这样也可以确定一个有 <span class="math inline">\(n + 1\)</span> 个系数的 <span class="math inline">\(n\)</span> 次多项式。</p><p>因此，对于 <span class="math inline">\(\forall x_i \in \mathbb{F}, i \in [0, n]\)</span>，有 <span class="math inline">\(y_i = f(x_i)\)</span>；如果对于 <span class="math inline">\(\forall i \neq j\)</span> 总是满足 <span class="math inline">\(x_i \neq x_j\)</span>，那么我们可以在数域 <span class="math inline">\(\mathbb{F}\)</span> 中绘制 <span class="math inline">\(n+1\)</span> 个点，获得 <span class="math inline">\(n+1\)</span> 个不同的方程，从而确定这个多项式；</p><p>那么，这 <span class="math inline">\(n + 1\)</span> 个不同的点构成的<strong>点集</strong>，就是多项式的点值表示。</p><p>如果将这 <span class="math inline">\(n + 1\)</span> 个不同的点代入表达式中进行运算，可以得到下面的矩阵等式： <span class="math display">\[\begin{bmatrix}    1 &amp; x_0 &amp; x_0^2 &amp; \cdots &amp; x_0^n \\    1 &amp; x_1 &amp; x_1^2 &amp; \cdots &amp; x_1^n \\    \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\    1 &amp; x_n &amp; x_n^2 &amp; \cdots &amp; x_n^n  \end{bmatrix}\begin{bmatrix}    a_0 \\ a_1 \\ \vdots \\ a_n\end{bmatrix}=\begin{bmatrix}    y_0 \\ y_1 \\ \vdots \\ y_n\end{bmatrix}\]</span> 我们将最左侧的 <span class="math inline">\(n + 1\)</span> 阶矩阵称为范德蒙矩阵。</p><hr /><p>那么如何转换多项式的两种表达方式呢？</p><ul><li><p>系数表达式 <code>=&gt;</code> 点值表达式</p><p>这个还是非常的简单的；只需要选取 <span class="math inline">\(n + 1\)</span> 个不同的 <span class="math inline">\(x_i\)</span>，分别带入解析式中求出 <span class="math inline">\(y_i\)</span> 即可。我们假定使用快速幂计算乘方，那么这样做的复杂度就是 <span class="math inline">\(O(n^2\log n)\)</span> 的。</p></li><li><p>点值表达式 <code>=&gt;</code> 系数表达式</p><p>这个过程又被称为<strong>多项式插值</strong>；朴素地，我们可以将多项式看作一个 <span class="math inline">\(n\)</span> 次函数，将点值表达中的 <span class="math inline">\(n + 1\)</span> 个点代入其中得到等数目的方程，然后求解这个方程组得到每个系数，组成系数表达式。</p><p>形式化地说，我们可以利用范德蒙矩阵进行高斯消元，就可以在 <span class="math inline">\(O(n^3)\)</span> 的时间内求解；但是这样实在是太慢了，时间上无法接受；因此我们也可以用拉格朗日插值法求解： <span class="math display">\[f(x) = \sum_{i = 1}^n y_i \prod_{i = j} \frac{x-x_j}{x_i-x_j}\]</span> 这样，我们可以在 <span class="math inline">\(O(n^2)\)</span> 的时间复杂度内完成多项式插值。</p></li></ul><p>虽然但是，我们可以看到想要在这两种形式中转化，一般会消耗大量的时间。</p><h4 id="操作">操作</h4><p>令参与操作的两个多项式为 <span class="math inline">\(f(x)\)</span> 和 <span class="math inline">\(g(x)\)</span>；若 <span class="math inline">\(\deg f(x) \neq \deg g(x)\)</span>，我们可以为其中度数较小的一方增加系数为 <span class="math inline">\(0\)</span> 的高次项，从而使得两个多项式齐次；因此，下面的讨论都仅针对于两个多项式齐次的情况。</p><p>此外，如果两个多项式均仅提供点值表示，那么要求提供的点值的横坐标一一对应且相等。</p><p>现在假定 <span class="math inline">\(\deg f(x) = \deg g(x) = n\)</span>，系数表示分别为 <span class="math inline">\(\vec{a}、\vec{b}\)</span>；</p><h5 id="加减法">加减法</h5><p>对于系数表示，若 <span class="math inline">\(h(x) = f(x) ± g(x)\)</span>，则有： <span class="math display">\[h(x) = f(x) ± g(x) = \sum_{i = 0}^n (a_i ± b_i)x^i\]</span> 且 <span class="math inline">\(h(x)\)</span> 的系数表示记为 <span class="math inline">\(\vec{c}\)</span>，那么 <span class="math inline">\(c_i = a_i ± b_i\)</span>；</p><p>对于点值表示，只需要将对应的纵坐标相加/相减即可。</p><h5 id="乘法卷积">乘法（卷积）</h5><p>同上，对于系数表示，可以得到多项式乘法的定义如下： <span class="math display">\[h(x) = (f \cdot g)(x) = f(x) \times g(x) = \sum_{i = 0}^n \sum_{j = 0}^n a_ib_jx^{i + j}\]</span> 显然，两个 <span class="math inline">\(n\)</span> 次的多项式相乘会得到一个 <span class="math inline">\(2n\)</span> 次的多项式；若 <span class="math inline">\(h(x)\)</span> 的系数表示记为 <span class="math inline">\(\vec{c}\)</span>，那么也有： <span class="math display">\[c_i= \sum_{j+k=i}a_jb_k = \sum_{j = i}^{n} a_jb_{i - j}\]</span> 那么系数向量 <span class="math inline">\(\vec{c}\)</span> 为稀疏向量 <span class="math inline">\(\vec{a}、\vec{b}\)</span> 的卷积，记作：<span class="math inline">\(\vec{c} = \vec{a} ∗ \vec{b}\)</span>；</p><p>对于点值表示，依然只需要将对应的纵坐标相乘即可；但是因为新得到的多项式次数更高，所以每个因子多项式都需要提供 <span class="math inline">\(2n\)</span> 个点参与运算；</p><hr /><p>综上所述，我们可以看到：因为多项式运算本质上还是多项式的值进行运算，所以对于点值表示法而言，这些运算都是可以 <span class="math inline">\(O(n)\)</span> 完成的（即仅将对应点值的纵坐标进行运算即可）；唯一需要注意的就是多项式乘法，点值表示法需要提供更多组点值进行运算。</p><h3 id="复数">复数</h3><p><del>高 等 数 学 和 复 变 函 数 的 完 全 败 北</del></p><p>首先定义虚数单位 <span class="math inline">\(i^2 = -1\)</span>；则所有形如： <span class="math display">\[z = a + bi, \ \ a,b \in \mathbb{R}\]</span> 的数字为复数，它们构成的集合成为复数集，记为 <span class="math inline">\(\mathbb{C}\)</span>；上面的表达式中，<span class="math inline">\(a\)</span> 被称为实部，<span class="math inline">\(b\)</span> 被称为虚部。</p><h4 id="复平面">复平面</h4><p>复平面是一个笛卡尔平面，有两条坐标轴，纵轴为虚轴，横轴为实轴，两轴相互垂直；对于每一个复数 <span class="math inline">\(z = a + bi\)</span>，它都可以在复平面上被表示为一个从原点指向点 <span class="math inline">\((a, b)\)</span> 的<strong>向量</strong>；显然，复数和复平面上从原点出发的向量之间的映射关系是双射。</p><p>和一般向量一样，以实轴正方向为始，<span class="math inline">\(\vec{z}\)</span> 为终的角 <span class="math inline">\(\theta\)</span> 称为复数 <span class="math inline">\(z\)</span> 的<strong>幅角</strong>。</p><h4 id="基本操作">基本操作</h4><ul><li>模：即复数在复平面上所对应的向量的模，记作 <span class="math inline">\(|z|\)</span>；<span class="math inline">\(|z| = \sqrt {a^2 + b^2}\)</span></li><li>共轭复数：复数在复平面上所对应的向量关于实轴对称后对应的复数，记为 <span class="math inline">\(\bar{z}\)</span>；<ul><li><span class="math inline">\(z\)</span> 和 <span class="math inline">\(\bar{z}\)</span> 的实部相同，虚部互为相反数</li><li>两者的幅角满足：<span class="math inline">\(\theta_{z} + \theta_{\bar{z}} = \pi\)</span></li><li>两者的模满足：<span class="math inline">\(|z| = |\bar{z}|\)</span></li></ul></li></ul><h4 id="运算">运算</h4><p>令参与运算的两个复数为 <span class="math inline">\(z_1 = a_1 + b_1i\)</span> 和 <span class="math inline">\(z_2 = a_2 + b_2i\)</span>；</p><ul><li><p>加减法：<span class="math inline">\(z = z_1 ± z_2\)</span></p><ul><li><span class="math inline">\(z = (a_1 ± a_2) + (b_1 ± b_2)i\)</span></li><li>对于向量：按照平行四边形定则</li></ul></li><li><p>乘法：<span class="math inline">\(z = z_1 \times z_2\)</span></p><ul><li><p>$z = (a_1 + b_1i) (a_2 + b_2i) = $ <span class="math inline">\((a_1a_2 - b_1b_2) + (a_1b_2 + a_2b_1)i\)</span></p></li><li><p>对于向量：它们的幅角满足 <span class="math inline">\(\theta_z = \theta_{z_1} + \theta_{z_2}\)</span></p></li><li><p>对于向量：它们的模满足 <span class="math inline">\(|z| = |z_1| \times|z_2|\)</span></p></li><li><p>若 <span class="math inline">\(z_2 = \bar{z_1}\)</span>，那么 <span class="math inline">\(z = a_1^2 + b_1^2\)</span>，显然是一个实数</p></li></ul></li><li><p>除法：<span class="math inline">\(z = \frac{z_1}{z_2}\)</span></p><ul><li>通分 <span class="math inline">\(\bar{z_2}\)</span>，可以得到：<span class="math inline">\(z = \frac{z_1\bar{z_2}}{a_2^2 + b_2^2}\)</span></li><li>显然，分母是实数，所以可以直接除进分子的实部和虚部</li></ul></li><li><p>指数幂：首先，有<strong>欧拉公式</strong> <span class="math inline">\(e^{i\theta} = \cos\theta + i\sin\theta\)</span></p><ul><li><blockquote><p>在数学分析和复变函数中，欧拉公式是一个把复指数函数与三角函数联系起来的一个公式： <span class="math display">\[e^{i\theta} = \cos\theta + i\sin\theta\]</span> 这个恒等式就是欧拉公式，它是数学里最令人着迷的一个公式——它将数学里最重要的几个数字联系到了一起：</p><ul><li>两个超越数：自然对数的底 <span class="math inline">\(e\)</span>，圆周率 <span class="math inline">\(\pi\)</span>；</li><li>两个单位：虚数单位 <span class="math inline">\(i\)</span> 和自然数的单位 <span class="math inline">\(1\)</span> ；</li><li>以及被称为人类伟大发现之一的 <span class="math inline">\(0\)</span>。</li></ul><p>它将指数函数的定义域扩大到复数，建立了三角函数和指数函数的关系，被誉为“数学中的天桥”。因此数学家们评价它是“上帝创造的公式”。</p></blockquote></li><li><p>任何复数都可以表示为欧拉公式的形式，即： <span class="math display">\[z = |z|\cos\theta_z + i|z|\sin\theta_z = |z|e^{i\theta_z}\]</span></p></li><li><p>特殊值：当 <span class="math inline">\(\theta = \pi\)</span> 时，有 <span class="math inline">\(e^{i\pi} = -1\)</span></p></li><li><p>因此，复数的幂只需要将它转化为欧拉公式的形式，然后取幂即可</p></li></ul></li></ul><p>和多项式一样，复数的运算也需要根据不同的运算在不同的表示形式中反复切换。</p><h3 id="单位根">单位根</h3><p>在 <span class="math inline">\(\mathbb{C}\)</span> 中，满足 <span class="math inline">\(x^n = 1\)</span> 的 <span class="math inline">\(x\)</span> 被称为 <strong><span class="math inline">\(n\)</span> 次单位根</strong>；根据<a href="https://baike.baidu.com/item/%E4%BB%A3%E6%95%B0%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86/18104">代数基本定理</a>可知，<span class="math inline">\(n\)</span> 次单位根共有 <span class="math inline">\(n\)</span> 个，它们分别是： <span class="math display">\[x_k = e^{i\frac{2k\pi}{n}}, \ k \in [0, n)\]</span> 显然，<span class="math inline">\(x_k^n = 1\)</span>；可以用上一节讲到的欧拉公式来证明。</p><h4 id="性质">性质</h4><p>因为 <span class="math inline">\(\sin\theta + \cos\theta = 1\)</span>，所有的 <span class="math inline">\(n\)</span> 次单位根的模均为 <span class="math inline">\(1\)</span>.</p><p>在复平面上，<span class="math inline">\(n\)</span> 个 <span class="math inline">\(n\)</span> 次单位根平分了单位圆，且和单位圆的 <span class="math inline">\(n\)</span>-等分线重叠。</p><h4 id="本原单位根">本原单位根</h4><p>定义：<span class="math inline">\(0\)</span> 到 <span class="math inline">\((n - 1)\)</span> 次幂的值能生成全部 <span class="math inline">\(n\)</span> 个 <span class="math inline">\(n\)</span> 次单位根的 <span class="math inline">\(n\)</span> 次单位根称为为 <span class="math inline">\(n\)</span> 次本原单位根。</p><p>显然，对于任何 <span class="math inline">\(n &gt; 1\)</span>，<span class="math inline">\(x_1 = e^{i\frac{2\pi}{n}}\)</span> 是一个 <span class="math inline">\(n\)</span> 次本原单位根。</p><p>特别地，我们记 <span class="math inline">\(\omega_n = e^{i \frac{2\pi}{n}} = \cos \frac{2\pi}{n} + i \sin \frac{2\pi}{n}\)</span> 为 <span class="math inline">\(n\)</span> 次本原单位根；虽然它未必唯一，但是接下来的所有讨论中的“<span class="math inline">\(n\)</span> 次本原单位根”都特指 <span class="math inline">\(\omega_n\)</span>。</p><p><span class="math inline">\(n\)</span> 次本原单位根 <span class="math inline">\(\omega_n\)</span> 有一些特殊的运算性质：</p><ul><li><p>折半定理：<span class="math inline">\((\omega_n^k)^2 = \omega_{\frac{n}2}^k\)</span></p></li><li><p>令 <span class="math inline">\(n\)</span> 为偶数：<span class="math inline">\(\omega_n^{\frac{n}2 + k} = -\omega_n^k\)</span></p></li><li><p>相消定理：<span class="math inline">\(\omega_{dn}^{dk} = \omega_n^k\)</span></p></li><li><p>求和定理：可以描述为如下公式：</p><p><span class="math display">\[\sum_{i = 0}^{n - 1} (\omega_n^k)^i = \begin{cases}0, \ \ &amp; k \neq mn \ , \ m \in \mathbb{Z} \\n, \ \ &amp; k = mn \ , \ m \in \mathbb{Z}\end{cases}\]</span> 在 <span class="math inline">\(k \neq mn\)</span> 的场合下，由于公比不为 <span class="math inline">\(1\)</span>，我们可以用等比数列的求和公式推导： <span class="math display">\[\sum_{i = 0}^{n - 1} (\omega_n^k)^i = \frac{1 - (\omega_n^k)^n}{1 - \omega_n^k} = \frac{1 - 1}{1 - \omega_n^k} = 0\]</span> 否则，公比为 <span class="math inline">\(\omega_n^k = 1\)</span>，上述推导并不成立；但由于 <span class="math inline">\(\omega_n^n = \omega_n^0 = 1\)</span>，所以上计算结果为 <span class="math inline">\(n\)</span>；</p></li></ul><p>显然，第一个式子是成立的：每份角度扩大一倍，那么可以等分的份数就减为一半，这很合理；</p><p>显然，<span class="math inline">\(\omega_n^{\frac{n}2}\)</span> 的幅角是 <span class="math inline">\(\pi\)</span>；由和差角公式可以知道幅角加上 <span class="math inline">\(\pi\)</span> 意味着正弦和余弦值都变为原来的相反数，所以第二个式子也非常的正确；证毕（</p><p>相消定理也非常的好理解：两边的表达式转化为欧拉公式的形式是一样的。</p><p><del>不会有人真的连高中数学学的三角函数相关变换的忘记了吧？不会这人就是我吧？</del></p><hr /><p>到现在为止，我们已经把必要的前置知识<del>数学基础</del>给介绍完了。</p><h2 id="分析过程">分析过程</h2><p>根据上面的描述，我们已经知道了对于多项式的系数表示，计算其乘法需要 <span class="math inline">\(O(n^2)\)</span> 的时间；而对于点值表示法，这个运算只需要 <span class="math inline">\(O(n)\)</span> 的时间；但是如果我们想要通过两个多项式的系数表示得到它们乘积的系数表示，我们需要遵循以下的步骤：</p><ul><li><strong>求值</strong>：将待乘的多项式转化为点值表示，需要 <span class="math inline">\(O(n^2)\)</span></li><li><strong>运算</strong>：点值表示多项式乘法，需要 <span class="math inline">\(O(n)\)</span></li><li><strong>插值</strong>：将得到的结果转化为系数表示，朴素算法需要 <span class="math inline">\(O(n^3)\)</span>，不低于 <span class="math inline">\(O(n^2)\)</span></li></ul><p>可以看出，如果仅是将多项式转化为点值表示，并不能做到算法复杂度的降低——但是它为我们提供了思路：如果我们能将求值和插值步骤优化到低于 <span class="math inline">\(O(n^2)\)</span>，就可以降低多项式乘法的整体复杂度。</p><h3 id="离散傅里叶变换">离散傅里叶变换</h3><p>特别地，现在对上面的步骤进行一些定义：</p><ul><li><strong>离散傅里叶变换（DFT）</strong>：指求出一个 <span class="math inline">\(n - 1\)</span> 次多项式在每个 <span class="math inline">\(n\)</span> 次单位根下的点值的过程</li><li><strong>离散傅里叶逆变换（IDFT）</strong>：将上面求出的那些点值重新插值得到系数表示的过程</li></ul><p>对于多项式 <span class="math inline">\(f(x)\)</span>，若 <span class="math inline">\(\deg f(x) = n - 1\)</span>，那么对它进行的 DFT 被称为长度为 <span class="math inline">\(n\)</span> 的离散傅里叶变换，记作 <span class="math inline">\(\text{DFT}_n(f)\)</span>。</p><p>显然，这个操作就是朴素做法，具有 <span class="math inline">\(O(n^2)\)</span> 的时间复杂度；现在我们考虑使用 FFT 优化它。</p><h3 id="快速傅里叶变换">快速傅里叶变换</h3><p>现在，我们假设 <span class="math inline">\(n\)</span> 是偶数，且有 <span class="math inline">\(m = \frac{n}2\)</span>；有多项式 <span class="math inline">\(f(x) = \sum_{i = 0}^{n - 1} a_ix^i\)</span>，显然 <span class="math inline">\(\deg f(x) = n - 1\)</span>；</p><h4 id="分治">分治</h4><p>考虑分治：我们对 <span class="math inline">\(f(x)\)</span> 的系数角标按照奇偶性进行分类，可以得到： <span class="math display">\[\begin{align}f(x) &amp;= \sum_{i = 0}^{m - 1} a_{2i}x^{2i} + \sum_{i = 0}^{m - 1} a_{2i+1}x^{2i+1} \\     &amp;= \sum_{i = 0}^{m - 1} a_{2i}x^{2i} + x(\sum_{i = 0}^{m - 1} a_{2i+1}x^{2i}) \\     &amp;= \sum_{i = 0}^{m - 1} a_{2i}(x^2)^i + x(\sum_{i = 0}^{m - 1} a_{2i+1}(x^2)^i)\end{align}\]</span> 我们对于前半部分（偶数部分）记作 <span class="math inline">\(f_0(x)\)</span>，后半部分（奇数部分）记为 <span class="math inline">\(f_1(x)\)</span>： <span class="math display">\[\begin{align}    f_0(x) &amp;= \sum_{i = 0}^{m - 1} a_{2i}x^i \\    f_1(x) &amp;= \sum_{i = 0}^{m - 1} a_{2i + 1}x^i \\\end{align}\]</span> 那么，<span class="math inline">\(f(x)\)</span> 可以被表示为如下形式： <span class="math display">\[f(x) = f_0(x^2) + x \cdot f_1(x^2)\]</span> 如果知道了 <span class="math inline">\(f_0(x)\)</span> 和 <span class="math inline">\(f_1(x)\)</span> 在 <span class="math inline">\(n\)</span> 个不同的位置的值，那么我们只需要计算 <span class="math inline">\(O(n)\)</span> 次上式，就可以得到 <span class="math inline">\(f(x)\)</span> 的点值表示了；然后可以继续递归处理 <span class="math inline">\(f_{0/1}\)</span>；</p><p>但是仅仅是这压根是不够的；根据主定理，因为 <span class="math inline">\(f_{0/1}\)</span> 各需要递归一次，所以复杂度还是 <span class="math inline">\(O(n^2)\)</span> 的。</p><h4 id="使用单位根">使用单位根</h4><p>因此，我们考虑代入单位根求 <span class="math inline">\(\text{DFT}_n(f)\)</span>。根据单位根的性质，我们知道了 <span class="math inline">\(\omega_n^{m + k} = -\omega_n^k\)</span>：这提示我们需要考虑小于 <span class="math inline">\(m\)</span> 次的点值和大于等于 <span class="math inline">\(m\)</span> 次的点值之间存在的关系；因此我们以此进行分类讨论：</p><p>对于 <span class="math inline">\(k \in [0, m)\)</span>，我们可以利用单位根的折半定理进行简化，有： <span class="math display">\[\begin{align}f(\omega_n^k) &amp;= f_0((\omega_n^k)^2) + \omega_n^k \cdot f_1((\omega_n^k)^2) \\              &amp;= f_0(\omega_m^k) + \omega_n^k \cdot f_1(\omega_m^k)\end{align}\]</span> 在考虑 <span class="math inline">\(k + m \in [m, n)\)</span>，我们同样可以利用单位根的性质得到下面的化简： <span class="math display">\[\begin{align}f(\omega_n^{k + m}) &amp;= f_0((\omega_n^{k + m})^2) + \omega_n^{k + m} \cdot f_1((\omega_n^{k + m})^2) \\                    &amp;= f_0((-\omega_n^k)^2) - \omega_n^k \cdot f_1((-\omega_n^k)^2) \\                    &amp;= f_0((\omega_n^k)^2) - \omega_n^k \cdot f_1((\omega_n^k)^2) \\                    &amp;= f_0(\omega_m^k) - \omega_n^k \cdot f_1(\omega_m^k)\end{align}\]</span> 上面的两个式子又被称为<strong>蝴蝶操作</strong>，式子中的 <span class="math inline">\(\omega_n^k\)</span> 又被称为旋转因子；</p><p>至于叫“蝴蝶操作”这个名字的原因，现在我们可以考虑两层：一层是我们将要求的 <span class="math inline">\(f(x)\)</span>，它的 DFT 长度为 <span class="math inline">\(n\)</span>；另一层是我们已经求好的（或者将要递归去求的）<span class="math inline">\(f_{0/1}(x)\)</span>，它们的 DFT 长度均为 <span class="math inline">\(m\)</span>；对于 <span class="math inline">\(f_{0/1}(\omega_m^k)\)</span>，它们能影响到的位置只有 <span class="math inline">\(f(\omega_n^k)\)</span> 和 <span class="math inline">\(f(\omega_n^{k + m})\)</span>；所以可以画出下面的图：</p><figure><img src="https://i.loli.net/2021/03/30/7OEYgBQdZq4jeyR.jpg" class="lazyload" data-srcset="https://i.loli.net/2021/03/30/7OEYgBQdZq4jeyR.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="要不是不会画矢量图，谁愿意iPad手画呢？" /><figcaption aria-hidden="true">要不是不会画矢量图，谁愿意iPad手画呢？</figcaption></figure><p>图中实边贡献的权值为 +1，虚边的权值是 -1；结合推导的式子很容易理解，形状也许确实是蝴蝶（</p><p>综上所述，我们可以发现：<span class="math inline">\(k \geq m\)</span> 部分的值可以在求 <span class="math inline">\(k &lt; m\)</span> 部分的值时一并求出；因此，只要知道了<span class="math inline">\(f_0(x)\)</span> 和 <span class="math inline">\(f_1(x)\)</span> 在小于 <span class="math inline">\(m\)</span> 次位置的值（显然，这是 <span class="math inline">\(m = \frac{n}2\)</span> 次），就可以在 <span class="math inline">\(O(n)\)</span> 的时间内求出 <span class="math inline">\(f(x)\)</span> 在整全部 <span class="math inline">\(n\)</span> 个位置的值；显然，和朴素做法一样，这个过程也是递归的。</p><p>分析算法的时间复杂度：<span class="math inline">\(T(n) = T(\frac{n}2) + O(n)\)</span>，典型的 <span class="math inline">\(O(n\log n)\)</span>；</p><p>综上所述，得到的快速计算 <span class="math inline">\(\text{DFT}_n(f)\)</span> 的方法，就被称为 FFT。</p><h3 id="插值方法">插值方法</h3><p>在上一个部分，我们已经将朴素求值的过程用 FFT 取代，获得了更优的时间复杂度；但是朴素插值的过程仍然是 <span class="math inline">\(O(n^2)\)</span> 的；这个部分将说明朴素 IDFT 的过程，并尝试压缩它的时间复杂度。</p><h4 id="离散傅里叶逆变换">离散傅里叶逆变换</h4><blockquote><h5 id="问题">问题</h5><p>有 <span class="math inline">\(\deg f(x) = n - 1\)</span> 的多项式 <span class="math inline">\(f(x)\)</span> ；已知其点值表示 <span class="math inline">\(\{(x_k, \ y_k) \ | \ k \in [0, n)\}\)</span>；其中： <span class="math display">\[\text{DFT:} \ \ y_k = \sum_{i = 0}^{n - 1} a_ix_i \ , \ x_i = \omega_n^{ik}\]</span> 现在我们要从这个点集反向求出 <span class="math inline">\(f(x)\)</span> 的系数表示 <span class="math inline">\(\vec{a}\)</span>。</p></blockquote><p>至于这个问题的推导结果，<del>因为我不会推导</del>我们先给出它的结论： <span class="math display">\[\text{IDFT:} \ \ a_k = \frac1n \sum_{i = 0}^{n - 1}y_i\omega_n^{-ki}\]</span> 然后我们进行反向推导，来证明它确实是 <span class="math inline">\(\text{DFT}\)</span> 式子的逆变换：</p><ul><li><p>将 <span class="math inline">\(\text{IDFT}\)</span> 式子中的 <span class="math inline">\(y_i\)</span> 展开为 <span class="math inline">\(\text{DFT}\)</span> 式： <span class="math display">\[\begin{align}a_k = \frac1n \sum_{i = 0}^{n - 1}y_i\omega_n^{-ki} &amp;= \frac1n \sum_{i = 0}^{n - 1}\sum_{j = 0}^{n - 1} a_j\omega_n^{ji}\omega_n^{-ki} \\&amp;= \frac1n \sum_{i = 0}^{n - 1}\sum_{j = 0}^{n - 1} a_j\omega_n^{i(j - k)} \\&amp;= \frac1n \sum_{j = 0}^{n - 1} a_j\sum_{i = 0}^{n - 1}(\omega_n^{j - k})^i\end{align}\]</span></p></li><li><p>现在我们使用单位根的求和定理来考虑等式右侧的 <span class="math inline">\(\sum_{i = 0}^{n - 1}(\omega_n^{j - k})^i\)</span>：</p><ul><li><p><span class="math inline">\(j = k\)</span> 时，<span class="math inline">\(\omega_n^{i(j - k)} = \omega_n^0 = 1\)</span>，故： <span class="math display">\[\sum_{i = 0}^{n - 1}(\omega_n^{j - k})^i = 1 \times n = n\]</span></p></li><li><p><span class="math inline">\(j \neq k\)</span> 时，由求和定理可知： <span class="math display">\[\sum_{i = 0}^{n - 1}(\omega_n^{j - k})^i = 0\]</span> 既可以使用消去定理，也可以使用单位根的定义得到这个值为 0；</p></li><li><p>综上所述，仅当 <span class="math inline">\(j = k\)</span> 时，外侧的求和会对结果产生 <span class="math inline">\(n\)</span> 倍的贡献。</p></li></ul></li><li><p>因此，我们可以继续推导第一步我们得到的式子： <span class="math display">\[\begin{align}a_k = \frac1n \sum_{i = 0}^{n - 1}y_i\omega_n^{-ki} &amp;= \frac1n \sum_{j = 0}^{n - 1} a_j\sum_{i = 0}^{n - 1}(\omega_n^{j - k})^i \\&amp;= \frac1n a_k \times n\end{align}\]</span> 显然，等式的两侧是相等的。</p></li></ul><p>所以，我们证明了提供的结论确实是 <span class="math inline">\(\text{DFA}\)</span> 的逆变换。</p><p>如果愿意，也可以把式子写成矩阵的形式，然后对对应的矩阵求逆，也能得到这个结果。</p><p>分析这种做法的复杂度：对于每一个 <span class="math inline">\(k \in [0, n)\)</span> 我们都需要 <span class="math inline">\(O(n)\)</span> 的时间去求出等式右侧的求和；所以 <span class="math inline">\(\text{IDFT}\)</span> 公式的复杂度毫无疑问也是 <span class="math inline">\(O(n^2)\)</span> 的。</p><h4 id="快速傅里叶逆变换">快速傅里叶逆变换</h4><p>那么现在，我们就要考虑如何在更短的复杂度下求解 IDFT。显然 IDFT 公式也是一个多项式，我们定义： <span class="math display">\[a_k = F(x_k) = \frac1n \sum_{i = 0}^{n - 1}y_ix_k^i, \ \ x_k = \omega_n^{-k}\]</span> 在回忆一下我们前面刚推到完的 FFT： <span class="math display">\[y_k = f(x_k) = \sum_{i = 0}^{n - 1}a_ix_k^i, \ \ x_k = \omega_n^k\]</span> 我们就会发现它们出奇的相似！（好吧，我也是推到这一步才豁然开朗，，只能说我确实把复变函数的一些知识忘得精光，完全的不掌握了把）；<span class="math inline">\(\omega_n^k\)</span> 和 <span class="math inline">\(\omega_n^{-k}\)</span> 很显然是一对共轭复数——在复平面的角度来看它们只是幅角的旋转方向不同，实际上还是一一对应的；所以我们完全可以把 FFT 的方法拿到这里来，求出 <span class="math inline">\(F(x)\)</span> 在 <span class="math inline">\(\omega_n\)</span> 不同幂下的值之后，翻转结果就可以得到答案（<span class="math inline">\(\omega_n^{-k} = \omega_n^{n-k}\)</span>）。</p><p><del>是不是突然有些明白了在蝴蝶操作中 <span class="math inline">\(\omega_n^k\)</span> 被称为旋转因子的原因了（</del></p><p>综上所述，FFT + 事后翻转 = <span class="math inline">\(\text{IFFT}\)</span>；这就是快速傅里叶逆变换插值，时间复杂度显然是 <span class="math inline">\(O(n\log n)\)</span>。</p><hr /><p>综上所述，我们使用 <span class="math inline">\(\text{FFT}\)</span> 和 <span class="math inline">\(\text{IFFT}\)</span> 取代求值和插值步骤朴素的 <span class="math inline">\(\text{DFT}\)</span> 和 <span class="math inline">\(\text{IDFT}\)</span> 算法，就可以把多项式的点值表达和系数表达之间的互相转化的复杂度从 <span class="math inline">\(O(n^2)\)</span> 降为 <span class="math inline">\(O(n\log n)\)</span>，从而得到了一个总体复杂度为 <span class="math inline">\(O(n\log n)\)</span> 的多项式乘法的算法。</p><p>所以严格上来说，快速的多项式乘法算法并不是 FFT；FFT 只是其中非常重要的组成部分罢了。</p><h2 id="算法实现">算法实现</h2><p>好了，你已经学会了 FFT 了！快上！（指上机写代码</p><h3 id="朴素的递归实现">朴素的递归实现</h3><p>然后我们就写出了像上面说的那样的递归 FFT：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">complex</span> <span class="title">getW</span><span class="params">(uint n, uint k = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> angle = (k % n) * PI * <span class="number">2</span> / n;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(<span class="built_in">cos</span>(angle), <span class="built_in">sin</span>(angle));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">subprocess</span><span class="params">(addr f, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> m = n / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">complex</span>&gt; &amp;sub = _alloc(n);</span><br><span class="line">    <span class="keyword">auto</span> f0 = sub.begin(), f1 = f0 + m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i)</span><br><span class="line">        f0[i] = f[i * <span class="number">2</span>],</span><br><span class="line">        f1[i] = f[i * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    subprocess(f0, m);</span><br><span class="line">    subprocess(f1, m);</span><br><span class="line">    <span class="keyword">auto</span> unit = getW(n), w = getW(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++ i)</span><br><span class="line">        f[i] = f0[i] + w * f1[i],</span><br><span class="line">        f[i + m] = f0[i] - w * f1[i],</span><br><span class="line">        w *= unit;</span><br><span class="line">    _free_mem_stack_frame();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是最核心的递归过程；一些包装的函数在下面：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">complex</span>&gt; &amp;p, <span class="keyword">bool</span> inv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    subprocess(p.begin(), p.size());</span><br><span class="line">    <span class="keyword">if</span> (inv) reverse(++ p.begin(), p.end());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">complex</span>&gt; &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;start(p, <span class="literal">false</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ifft</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">complex</span>&gt; &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    start(p, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> n = p.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : p) _post_ifft(i, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是系数表达变点值表达，只需要开始递归即可；反之，在得到结果之后还需要进行后处理：首先将答案数组的 <span class="math inline">\([1, N - 1]\)</span> 位置翻转（因为 <span class="math inline">\(\omega_n^0 = \omega_n^n\)</span>，所以交换的是 <span class="math inline">\(1\)</span> 和 <span class="math inline">\(n - 1\)</span> 的位置），然后根据推导的表达式，我们还要对每个位置都除 <span class="math inline">\(N\)</span>；需要注意的是这一步也会引入误差，需要 <code>round</code>。</p><hr /><p>然后我们再为它添加一些头和尾的代码，用来去做模板题检验正确性：<a href="https://www.luogu.com.cn/problem/P3803">【模板】多项式乘法（FFT）</a>；增加的代码就像下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">int</span> n = scanner.nextInt(),</span><br><span class="line">        m = scanner.nextInt();</span><br><span class="line">    <span class="built_in">vector</span>&lt;FFT::<span class="built_in">complex</span>&gt; a, b;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> siz = FFT::stretch(n + m);</span><br><span class="line">    a.resize(siz), b.resize(siz);</span><br><span class="line">    FFT::init_mem_pool(siz);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">        a[i].real(scanner.nextInt());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i)</span><br><span class="line">        b[i].real(scanner.nextInt());</span><br><span class="line">    FFT::fft(a), FFT::fft(b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; siz; ++ i)</span><br><span class="line">        a[i] *= b[i];</span><br><span class="line">    FFT::ifft(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + m; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)a[i].real() &lt;&lt; <span class="string">&quot; \n&quot;</span>[n + m == i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后交上去就会发现…… A 了？和别人博客里说的不一样啊？</p><figure><img src="https://i.loli.net/2021/03/30/8GPRMhTuwJ24Cq6.png" class="lazyload" data-srcset="https://i.loli.net/2021/03/30/8GPRMhTuwJ24Cq6.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="_SPHGR0A___IYE3_WVFES_3.png" /><figcaption aria-hidden="true">_SPHGR0A___IYE3_WVFES_3.png</figcaption></figure><p>实际上是因为递归带来的较大的常数开销，很大一部分都来自于每层递归重复开辟内存空间用来做分治；因此，我写的时候就使用了一个内存池来处理递归中带来的内存分配和释放，就可以有效的降低它的常数。</p><p>当然，这种做法还是不够快的；所以我们还要对它继续优化。</p><h3 id="优化迭代实现">优化迭代实现</h3><p>因为递归是从上到下的过程，那么我们的迭代实现就是一个从下而上的一个过程。</p><p>我们把长度为 <span class="math inline">\(8\)</span> 的情况下，上述朴素的递归做法的调用树画出来，如下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Layer 1:   0 1 2 3 4 5 6 7</span><br><span class="line">  &#x2F;  \</span><br><span class="line">Layer 2:   0 2 4 6   1 3 5 7</span><br><span class="line">  &#x2F;  \  &#x2F;  \</span><br><span class="line">Layer 3: 0 4 2 6 1 5 3 7</span><br><span class="line"> &#x2F; \  &#x2F; \ &#x2F; \ &#x2F; \</span><br><span class="line">Layer 4:04261537</span><br></pre></td></tr></table></figure><p>当然，只看这个我们什么也看不出来；现在我们将焦点集中在最后一层上，并将它们的二进制和二进制反转以及二进制反转后得到的数字写出来，如下表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Layer 4:04261537</span><br><span class="line">Binary:000 100 010 110 001 101 011 111</span><br><span class="line">Reverse:000 001 010 011 100 101 110 111</span><br><span class="line">Decimal:01234567</span><br></pre></td></tr></table></figure><p>可以看出最后一层经过一番操作之后就变成了最开始的数组。因此，我们只需要在最开始的数组上进行这样的一番操作，就可以得到最后一层的这个新的数组，同时第一次合并也只是对相邻的位置进行合并。那么这样上面那几层就可以这样一直合并上去得到最终的数组了。</p><p>那么我们要怎么样快速的进行这一波神秘操作呢？现在我们考虑反转后的二进制表示（<span class="math inline">\(1, 2, \dots,2^k-1\)</span>），我们可以按照这样的顺序构造出这个序列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">round 1:(1)001(0)000</span><br><span class="line">round 2:(3)011(2)010(1)001(0)000</span><br><span class="line">round 3:...(6)110(5)101(4)100(3)011(2)010(1)001(0)000</span><br></pre></td></tr></table></figure><p>第一轮，所有的位都是 <code>0</code>；第一个位置是 <code>0</code> 已经满足了要求；我们选择最低位，放置 <code>1</code>，得到了序列 <code>0, 1</code>；第二轮，已经有满足要求的序列长度 2，我们选择次低位，将这一位置 <code>1</code>，那么又可以填两个数字，这两个数字的相对位置就和最开始满足要求的序列那样…… 最终，重复 <code>n</code> 次就可以构造出 <span class="math inline">\(0,\dots,2^k-1\)</span> 的序列。</p><p>那么我们现在构造的是二进制反向的序列，那么只需要从高位开始，重复这个过程就可以了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;uint&gt; &amp;<span class="title">reverse</span><span class="params">(uint length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">vector</span>&lt;uint&gt; <span class="title">rev</span><span class="params">(length)</span></span>;</span><br><span class="line">    uint msk = length &gt;&gt; <span class="number">1u</span>, i = <span class="number">0</span>;</span><br><span class="line">    rev[i ++] = <span class="number">0</span>, rev[i ++] = msk;</span><br><span class="line">    <span class="keyword">for</span> (uint w = <span class="number">2</span>; w &lt; length; w &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        msk &gt;&gt;= <span class="number">1u</span>;</span><br><span class="line">        <span class="keyword">for</span> (uint j = <span class="number">0</span>; j &lt; w; ++ j)</span><br><span class="line">            rev[i ++] = rev[j] | msk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的数组是关于原数组的一个排序。我们只需要利用这个排列进行<strong>位逆序置换</strong>——因为每一个 <code>i</code> 和 <code>rev[i]</code> 都是一一对应的，它们本是有序的，那么只要交换所有逆序的对，就可以得到适用迭代的数组。</p><p>计算在 <span class="math inline">\(n\)</span> 次单位根的各幂次点值的时候，令 <span class="math inline">\(m=\frac{n}2\)</span>，那么 <span class="math inline">\(f_0\)</span> 和 <span class="math inline">\(f_1\)</span> 已经由下层（迭代意义上的上层）计算并储存在 <span class="math inline">\(A[k]\)</span> 和 <span class="math inline">\(A[k+m]\)</span> 处，只需取出来计算后更新对应的值就完成了一层的迭代。到此，我们已经完成了对迭代优化的实现的过程描述，核心代码实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">complex</span>&gt; &amp;p, <span class="keyword">bool</span> inv)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> siz = p.size();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> rev = reverse(siz);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; siz; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (rev[i] &gt; i) swap(p[rev[i]], p[i]);</span><br><span class="line">        <span class="keyword">for</span> (uint n = <span class="number">2</span>, m = <span class="number">1</span>; n &lt;= siz; m = n, n &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> unit = get_w(n), w = get_w(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (uint l = <span class="number">0</span>, r = n - <span class="number">1</span>; r &lt;= siz; l += n, r += n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">complex</span> w0 = w, d, tmp0, tmp1;</span><br><span class="line">                <span class="keyword">for</span> (uint i = l, lim = l + m; i &lt; lim; ++ i)</span><br><span class="line">                    d = w0 * p[i + m], tmp0 = p[i] + d, tmp1 = p[i] - d,</span><br><span class="line">                    p[i] = tmp0, p[i + m] = tmp1, w0 *= unit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (inv) reverse(++ p.begin(), p.end());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样也可以通过上面的那个模板题：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ONLINE_JUDGE</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="comment">//  freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> n = scanner.nextInt(),</span><br><span class="line">        m = scanner.nextInt();</span><br><span class="line">    <span class="built_in">vector</span>&lt;FFT2::<span class="built_in">complex</span>&gt; a, b;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> siz = FFT2::stretch(n + m);</span><br><span class="line">    a.resize(siz), b.resize(siz);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">        a[i].real(scanner.nextInt());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; ++ i)</span><br><span class="line">        b[i].real(scanner.nextInt());</span><br><span class="line">    FFT2::fft(a), FFT2::fft(b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; siz; ++ i)</span><br><span class="line">        a[i] *= b[i];</span><br><span class="line">    FFT2::ifft(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n + m; ++ i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)a[i].real() &lt;&lt; <span class="string">&quot; \n&quot;</span>[n + m == i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，FFT 就简要的介绍完了。</p><h2 id="参考资料">参考资料</h2><ul><li><a href="https://blog.csdn.net/alpha202/article/details/90737497" class="uri">https://blog.csdn.net/alpha202/article/details/90737497</a></li><li><a href="https://www.luogu.com.cn/blog/fusu2333/solution-p3803" class="uri">https://www.luogu.com.cn/blog/fusu2333/solution-p3803</a></li><li><a href="https://blog.csdn.net/waduan2/article/details/79529900" class="uri">https://blog.csdn.net/waduan2/article/details/79529900</a></li><li><a href="https://blog.csdn.net/qq_38944163/article/details/81835205" class="uri">https://blog.csdn.net/qq_38944163/article/details/81835205</a></li></ul>]]></content>
    
    <summary type="html">
    
      年轻人的第一个高级算法（并不是）自学 FFT 的一些笔记……现在越来越多的题目都会出现 FFT 了，，再不会感觉就要去世了啊（
    
    </summary>
    
    
      <category term="算法" scheme="https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数学" scheme="https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="算法" scheme="https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM" scheme="https://shiraha.cn/tags/ACM/"/>
    
      <category term="数论" scheme="https://shiraha.cn/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces Round#710 div.3 回顾</title>
    <link href="https://shiraha.cn/2021/codeforces-round-710-div3/"/>
    <id>https://shiraha.cn/2021/codeforces-round-710-div3/</id>
    <published>2021-03-27T07:08:32.000Z</published>
    <updated>2021-03-27T07:08:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>比赛链接：<a href="https://codeforces.ml/contest/1506" class="uri">https://codeforces.ml/contest/1506</a></p></blockquote><h2 id="记录">记录</h2><p>比赛的时候可以说还是有点捞的，，竟然没有时间写完最后一题，属是不是很行（</p><p>但是精彩还是在比完之后：</p><figure><img src="https://i.loli.net/2021/03/27/2JZwcepftOClvbS.png" class="lazyload" data-srcset="https://i.loli.net/2021/03/27/2JZwcepftOClvbS.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="_XMUTFT_4YHFRV__35DML_Y.png" /><figcaption aria-hidden="true">_XMUTFT_4YHFRV__35DML_Y.png</figcaption></figure><p>直呼就这？</p><table><thead><tr class="header"><th style="text-align: center;">Penalty</th><th style="text-align: center;">A</th><th style="text-align: center;">B</th><th style="text-align: center;">C</th><th style="text-align: center;">D</th><th style="text-align: center;">E</th><th style="text-align: center;">F</th><th style="text-align: center;">G</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">168</td><td style="text-align: center;"><font color="#0a0">+</font></td><td style="text-align: center;"><font color="#0a0">+1</font></td><td style="text-align: center;"><font color="#0a0">+</font></td><td style="text-align: center;"><font color="red">-2</font></td><td style="text-align: center;"><font color="red"><strong>-1</strong></font></td><td style="text-align: center;"><font color="#0a0">+</font></td><td style="text-align: center;"><font color="#999">-1</font></td></tr></tbody></table><h2 id="题解">题解</h2><p>毕竟是 Div3，所以就只贴被 Hack 的题和没写出来的题好了：</p><h3 id="d---epic-transformation">D - <a href="https://codeforces.com/contest/1506/problem/D">Epic Transformation</a></h3><p>原来是 <code>unordered_map</code> 被卡了，，也不能这么说，也许遍历 <code>unordered_map</code> 就是意外的要慢（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt();</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        cnt.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            ++ cnt[scanner.nextInt()];</span><br><span class="line">        <span class="keyword">int</span> major = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [k, v] : cnt)</span><br><span class="line">            maximize(major, v);</span><br><span class="line">        println(max(n % <span class="number">2</span>, major - (n - major)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>哦，，破案了，，实际上是不断扩容消耗了大量的时间，，在使用之前预留空间就没有任何问题（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt();</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        cnt.clear(), cnt.reserve(n * <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            ++ cnt[scanner.nextInt()];</span><br><span class="line">        <span class="keyword">int</span> major = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> [k, v] : cnt)</span><br><span class="line">            maximize(major, v);</span><br><span class="line">        println(max(n % <span class="number">2</span>, major - (n - major)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就结果而言实际上跑的比 <code>map</code> 还要快：</p><figure><img src="https://i.loli.net/2021/03/27/plQCvT5VZODM9nk.png" class="lazyload" data-srcset="https://i.loli.net/2021/03/27/plQCvT5VZODM9nk.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" alt="M_H5_L__9533_L__SQT__EV.png" /><figcaption aria-hidden="true">M_H5_L__9533_L__SQT__EV.png</figcaption></figure><p>上面是 <code>unordered_map</code> + <code>reserve</code> 两倍空间，下面是 <code>map</code>；</p><h3 id="e---restoring-the-permutation">E - <a href="https://codeforces.com/contest/1506/problem/E">Restoring the Permutation</a></h3><p>没什么好说的，典型的复杂度估计错误，，这种数据范围 <code>1e5</code> 的，还要求在指定范围内寻找最大最小值的，拿个对数数据结构维护一下是再适合不过了；而且实际上也不难写，，只能说有些意识还是不够（</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> pmx[N], pmn[N], q[N];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; umx, umn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt();</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>, mn = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> update =</span><br><span class="line">    [&amp;](<span class="keyword">int</span> pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (++ mx &lt; pos) umx.insert(mx);</span><br><span class="line">        <span class="keyword">while</span> (++ mn &lt; pos) umn.insert(mn);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = scanner.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            q[i] = scanner.nextInt();</span><br><span class="line">        <span class="built_in">memset</span>(pmx, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">        <span class="built_in">memset</span>(pmn, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * (n + <span class="number">1</span>));</span><br><span class="line">        umx.clear(), umn.clear();</span><br><span class="line">        pmx[<span class="number">1</span>] = pmn[<span class="number">1</span>] = q[<span class="number">1</span>], mx = mn = <span class="number">0</span>;</span><br><span class="line">        update(q[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">            <span class="keyword">if</span> (q[i] &gt; q[i - <span class="number">1</span>])</span><br><span class="line">                pmx[i] = pmn[i] = q[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!pmx[i])</span><br><span class="line">            &#123;</span><br><span class="line">                pmx[i] = *umx.rbegin();</span><br><span class="line">                umx.erase(*umx.rbegin());</span><br><span class="line">            &#125; <span class="keyword">else</span> update(pmx[i]);</span><br><span class="line">            <span class="keyword">if</span> (!pmn[i])</span><br><span class="line">            &#123;</span><br><span class="line">                pmn[i] = *umn.begin();</span><br><span class="line">                umn.erase(umn.begin());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            print(pmn[i], <span class="string">&quot; \n&quot;</span>[i == n]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">            print(pmx[i], <span class="string">&quot; \n&quot;</span>[i == n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看来对 <code>bitset</code> 的无脑崇拜也得差不多得了（</p><h3 id="g---maximize-the-remaining-string">G - <a href="https://codeforces.com/contest/1506/problem/G">Maximize the Remaining String</a></h3><p>十分经典的问题，讲清楚了其实就没什么好说的；只能说思考题目的时候应该更加地理性，而不是总是对玄学抱有不切实际的幻想；比如这个题，如果看到就去考虑什么玄学构造方法，瞎几把贪，还欺骗自己的做法是正确的且很有道理，那就会贻笑大方，一辈子也做不出了（</p><p>首先，很显然待构造的 <span class="math inline">\(t\)</span> 是 <span class="math inline">\(s\)</span> 的子序列：这说明我们可能可以按照顺序遍历每个字符，来确定是否要把它加入到 <span class="math inline">\(t\)</span> 的末尾（当然 <span class="math inline">\(t\)</span> 最开始是一个空串）；对于一个构造到一半的 <span class="math inline">\(t\)</span>，在某个位置 <span class="math inline">\(i\)</span> 的字符 <span class="math inline">\(s[i]\)</span> 可以加入 <span class="math inline">\(t\)</span> 的末尾的必要条件是，<span class="math inline">\(s\)</span> 从 <span class="math inline">\(i\)</span> 开始的后缀（后面记作 <span class="math inline">\(s_i\)</span>）包含了所有 <span class="math inline">\(t\)</span> 不包含的字符。</p><p>显然，<span class="math inline">\(t\)</span> 的总长度也是确定的（并且极其有限），所以我们可以遍历字符串 <span class="math inline">\(t\)</span> 需要，但是目前的构造阶段还不包含的可能的字符，找到可以插入且尽可能大的字符插入即可。每次插入的字符都确保它的后缀中有足够的其他字符使得构造不会失败，因此我们总是可以找到合理的字符并插入其中。</p><p>当然，这里实际上也有一个小小的贪心：字符串前面的字符大的字符串字典序更大（可以说是显然了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">char</span> s[N], t[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    freopen(<span class="string">&quot;in.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, <span class="built_in">stdin</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">int</span> T = scanner.nextInt();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> suffix =</span><br><span class="line">    [&amp;](<span class="keyword">char</span> ch, <span class="keyword">int</span> st)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> &amp;p = pos[ch - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">auto</span> it = lower_bound(p.begin(), p.end(), st);</span><br><span class="line">        <span class="keyword">if</span> (it == p.end()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> *it;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> count =</span><br><span class="line">    [&amp;](<span class="keyword">int</span> st)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (st == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;ii : pos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = lower_bound(ii.begin(), ii.end(), st);</span><br><span class="line">            <span class="keyword">if</span> (it != ii.end()) ++ ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">while</span> (T --)</span><br><span class="line">    &#123;</span><br><span class="line">        scanner(s);</span><br><span class="line">        <span class="keyword">int</span> n = <span class="built_in">strlen</span>(s), len = <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; <span class="title">ss</span><span class="params">(s, s + n)</span></span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> siz = ss.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">            pos[s[i] - <span class="string">&#x27;a&#x27;</span>].push_back(i);</span><br><span class="line">        <span class="keyword">int</span> st = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (len &lt; siz)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> add = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> ch : ss)</span><br><span class="line">                <span class="keyword">if</span> (count(suffix(ch, st)) + len == siz)</span><br><span class="line">                    maximize(add, ch);</span><br><span class="line">            t[len ++] = add;</span><br><span class="line">            st = suffix(add, st) + <span class="number">1</span>;</span><br><span class="line">            pos[add - <span class="string">&#x27;a&#x27;</span>].clear();</span><br><span class="line">            ss.erase(add);</span><br><span class="line">        &#125; t[len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        println(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次检查一个字符是否合法的复杂度是 <span class="math inline">\(O(26\text{log}n)\)</span> 的，因为只有小写拉丁字母，所以检查次数是 <span class="math inline">\(O(26\cdot26)\)</span> 的；上面的代码去重用了 <code>set</code>（其实完全没必要），复杂度是 <span class="math inline">\(O(n\text{log}n)\)</span> 的；综上所述，总时间复杂度是 <span class="math inline">\(O((26^3 + n)\cdot\text{log}n)\)</span> 的；如果不用 <code>set</code> 去重，时间复杂度可以做到 <span class="math inline">\(O(\text{log}n)\)</span> 的。</p><h2 id="后记">后记</h2><p>不要盲目崇拜 <code>bitset</code> 和 <code>unordered_map</code>；至少要明白使用它们意味着什么：</p><p><code>unordered_map</code> 本质是哈希表，它的访问是将键值经过哈希计算映射到本地的连续空间，从而可以快速的“随机访问”的；如果这段连续空间不足以存储数据，就必须要开辟更大的空间，并且 <code>rehash</code>，从而将键值映射到更大的连续空间中；这个过程很显然是极其耗时的，但是在做题的时候我们大概知道元素的数量，所以可以使用它提供的 <code>reserve</code> 方法，预留足够的空间，就可以减少这个过程的发生，从而达到提速的目的。</p><p>当然，<code>pb_ds</code> 里的哈希表又是另一回事，得找个时间去了解才行。</p><p>至于这个 G，确实是和我还颇有渊源，，，这个就不提了（）但是确实在做题的时候应当舍弃不切实际的无聊幻想，用做题的思维去考虑才行==</p>]]></content>
    
    <summary type="html">
    
      本来作为一个 div3 是没有必要大动干戈还写（水）一篇文章的，但是这场确实被干翻了，，，可以说表现是非常的差，所以还是挂在耻辱柱上，用来时刻警醒自己（
    
    </summary>
    
    
      <category term="题解" scheme="https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="算法" scheme="https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="ACM" scheme="https://shiraha.cn/tags/ACM/"/>
    
      <category term="Codeforces" scheme="https://shiraha.cn/tags/Codeforces/"/>
    
  </entry>
  
</feed>

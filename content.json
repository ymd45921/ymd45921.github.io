{"meta":{"title":"七海の参考書","subtitle":"恋はとこからきて、どこに行くだろう","description":"这里是魔法少女☆七海的个人主页；七海会不定期更新一些文章和随笔，来记录她的学习和日常，欢迎浏览！","author":"七海","url":"https://shiraha.cn","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-02-08T16:00:00.000Z","updated":"2021-03-26T16:00:00.000Z","comments":true,"path":"404.html","permalink":"https://shiraha.cn/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除 回到首页 Our first promise and your words I wanted to express that day."},{"title":"关于「七海の参考書」","date":"2021-02-11T14:22:00.000Z","updated":"2021-03-26T16:00:00.000Z","comments":true,"path":"about/index.html","permalink":"https://shiraha.cn/about/","excerpt":"","text":"这是世界第一可爱的白羽七海的个人博客。 关于本站 本站是一个静态网站，技术参数如下： 键 值 静态生成器 Hexo 5.3.0 主题 hexo-theme-volantis 4.3.1 （已修改） 部署于 Github Pages 代码字体 Fira Code 5.2 评论 Valine 1.4.14 Serverless 服务提供商 LeanCloud CN *：又拍云为我的其他 Web 应用提供了云存储/CDN 加速。 **：本站绝大多数的图片存储在 SM.MS 图床 和 去不图床 上。 关于我 永远的17岁，是学生，是中华人民共和国公民。 化学什么的曾经有学，现在在学计算机。 还有什么要说的吗？ Galgame 玩家、二次元、肥宅、变态 因为很菜找不到工作，大概是考研人 很喜欢图形学，但逐渐变成了 Web 的形状 算法爱好者爱好者，菜鸡 ACMer 联系方式：发邮件给我 欢迎一起交流，一起学习进步！ 也欢迎一起讨论黄油，交换 XP（不是 关于内容 包括但不限于以下内容： 学习笔记：ACM 补题记录，知识点总结或者是考研笔记 折腾和花里胡哨：瞎玩的一些心得，或者是作为一个过程的记录 随笔 &amp; 哔哔：有感而发无端联想 心血来潮：一些转载，或者是我自己都说不清的东西 若文章的内容有错误或是不合适的地方，请及时发邮件联系我 评论的话因为没有搞邮件提醒所以大概是个摆设，可能不能及时收到，敬请谅解（ 评论系统邮件提醒现在已经有了，所以现在大概不是个摆设了？ 声明 本网站的所有原创内容均受CC BY-NC-SA许可协议的保护，不得用作商业用途；若转载请保留出处。 请在评论区和谐交流，禁止发布违法国家法律法规的内同或者人身攻击。 请您自觉遵守以上声明；否则，因浏览本站导致的任何问题，本站概不负责。 感谢 感谢Hexo工程以及Volantis主题，以及作为 Dependencies 的形形色色的开源项目的贡献者。 感谢免费提供各种优质云服务的运营商们（在关于本站的栏目中已经提及）。"},{"title":"说说","date":"2021-02-13T16:50:00.000Z","updated":"2021-02-13T16:50:00.000Z","comments":true,"path":"artitalk/index.html","permalink":"https://shiraha.cn/artitalk/","excerpt":"","text":".c2 { padding: 20px; opacity: 1; background: var(--color-card) !important; } #operare_artitalk p { margin: 24px; font-size: 1em; } .at_button { color: var(--color-text) !important; background: transparent; border-radius: 108px !important;; margin: 0 16px; transition: all 0.3s ease; font-size: 1em !important; padding: 4px 20px !important; border: 1.5px solid var(--color-text) !important; } #operare_artitalk .shuoshuo_input_log { border-radius: 32px; transition: all 0.3s ease; padding: 6px 12px; width: 80%; } .at_button:hover { background: rgba(230, 60, 94, 0.2) !important; border: 1.5px solid #E63C5E !important; box-shadow: none !important; } #operare_artitalk .shuoshuo_input_log:hover { border: 1.5px dashed #E63C5E; background: rgba(127, 127, 127, 0.2); } #operare_artitalk .shuoshuo_input_log:focus { border: 1.5px solid #E63C5E; background: rgba(230, 60, 94, 0.2); } #operare_artitalk .c1 { -webkit-backdrop-filter: saturate(200%) blur(20px); backdrop-filter: saturate(200%) blur(20px); transition: all 0.3s ease; } #pubShuo, #switchUser, #uploadSource { margin: 1.5px; color: var(--color-text); } #artitalk_main .shuoshuo_emoji_part { opacity: 0.8; font-weight: normal; transition: all 0.3s ease; font-size: 0.9em; } #artitalk_main .zuiliangdezai { opacity: 1; font-weight: bold; background: transparent; font-size: 1em; color: var(--color-text); } #ccontent p { font-size: 1.1em; color: var(--color-text); } #logw code { font-family: \"PingFang SC\", \"Microsoft YaHei\"; font-size: 1em; }"},{"title":"所有分类","date":"2022-03-11T08:12:45.453Z","updated":"2022-03-11T08:12:45.453Z","comments":true,"path":"categories/index.html","permalink":"https://shiraha.cn/categories/","excerpt":"","text":""},{"title":"","date":"2022-03-11T08:12:45.453Z","updated":"2022-03-11T08:12:45.453Z","comments":true,"path":"css/artitalk.dev.css","permalink":"https://shiraha.cn/css/artitalk.dev.css","excerpt":"","text":".c2 { padding: 20px; opacity: 1; background: var(--color-card) !important; } #operare_artitalk p { margin: 24px; font-size: 1em; } .at_button { color: var(--color-text) !important; background: transparent; border-radius: 108px !important;; margin: 0 16px; transition: all 0.3s ease; font-size: 1em !important; padding: 4px 20px !important; border: 1.5px solid var(--color-text) !important; } #operare_artitalk .shuoshuo_input_log { border-radius: 32px; transition: all 0.3s ease; padding: 6px 12px; width: 80%; } .at_button:hover { background: rgba(230, 60, 94, 0.2) !important; border: 1.5px solid #E63C5E !important; box-shadow: none !important; } #operare_artitalk .shuoshuo_input_log:hover { border: 1.5px dashed #E63C5E; background: rgba(127, 127, 127, 0.2); } #operare_artitalk .shuoshuo_input_log:focus { border: 1.5px solid #E63C5E; background: rgba(230, 60, 94, 0.2); } #operare_artitalk .c1 { -webkit-backdrop-filter: saturate(200%) blur(20px); backdrop-filter: saturate(200%) blur(20px); transition: all 0.3s ease; } #pubShuo, #switchUser, #uploadSource { margin: 1.5px; color: var(--color-text); } #artitalk_main .shuoshuo_emoji_part { opacity: 0.8; font-weight: normal; transition: all 0.3s ease; font-size: 0.9em; } #artitalk_main .zuiliangdezai { opacity: 1; font-weight: bold; background: transparent; font-size: 1em; color: var(--color-text); } #ccontent p { font-size: 1.1em; color: var(--color-text); } #logw code { font-family: \"PingFang SC\", \"Microsoft YaHei\"; font-size: 1em; }"},{"title":"","date":"2022-03-11T08:12:45.453Z","updated":"2022-03-11T08:12:45.453Z","comments":true,"path":"css/cmsg.dev.css","permalink":"https://shiraha.cn/css/cmsg.dev.css","excerpt":"","text":":root { --cmsg-main: #fff; --cmsg-bg: rgba(255, 255, 255, 0.75); --cmsg-bg-border: #ebeef5; --cmsg-text-title: #1f2d3d; --cmsg-text-content: #8391a5; --cmsg-el-button: #999; --cmsg-el-button-hover: #666; --cmsg-el-a: rgba(131,145,165,.8); --cmsg-el-a-hover: #5c6775; --cmsg-bg-blur: saturate(200%) blur(20px); } .c-message { background-color: var(--cmsg-bg) !important; -webkit-backdrop-filter: var(--cmsg-bg-blur) !important; backdrop-filter: var(--cmsg-bg-blur) !important; border:1px solid var(--cmsg-bg-border) !important; } .c-message__title { color: var(--cmsg-text-title) !important; } .c-message--icon { color: var(--cmsg-main) !important; } .el-notification__content { color: var(--cmsg-text-content) !important; } .c-message--close { color: var(--cmsg-el-button) !important; } .c-message--close:hover { color: var(--cmsg-el-button-hover) !important; } .c-message a { border-bottom:1px solid var(--cmsg-el-a) !important; } .c-message a:hover { border-bottom:1px solid var(--cmsg-el-a-hover) !important; } @media (prefers-color-scheme: dark) { :root:not([data-user-color-scheme]) { --cmsg-main: #000; --cmsg-bg: rgba(0, 0, 0, 0.75); --cmsg-bg-border: #010; --cmsg-text-title: #def; --cmsg-text-content: #678; --cmsg-el-button: #777; --cmsg-el-button-hover: #aaa; --cmsg-el-a: rgba(98,108,128,.8); --cmsg-el-a-hover: #9ab; } } [data-user-color-scheme='dark'] { --cmsg-main: #000; --cmsg-bg: rgba(0, 0, 0, 0.75); --cmsg-bg-border: #010; --cmsg-text-title: #def; --cmsg-text-content: #678; --cmsg-el-button: #777; --cmsg-el-button-hover: #aaa; --cmsg-el-a: rgba(98,108,128,.8); --cmsg-el-a-hover: #9ab; }"},{"title":"","date":"2022-03-11T08:12:45.453Z","updated":"2022-03-11T08:12:45.453Z","comments":true,"path":"css/main.dev.css","permalink":"https://shiraha.cn/css/main.dev.css","excerpt":"","text":":root { --font-cn: 'PingFang SC', \"Open Sans\", 'Microsoft YaHei', sans-serif; --font-art: 'Noto Serif SC', var(--font-cn); --font-code: UbuntuMono, Consolas, Monaco, var(--font-cn), monospace; --font-jp: 'UDDigiKyokashoNP-R', var(--font-art); } .blogger .content { font-family: var(--font-jp); text-align: center !important; } body { background: var(--color-site-bg) url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACFJREFUeNpiZGBg4GegAsBlCD8TqSYNQg2Mo6FEBAAIMACdPABtrSW/IQAAAABJRU5ErkJggg==); } .menuitem, .vlts-menu { font-weight: 400 !important; } .cover-wrapper.dock .list-h a { font-weight: 500 !important; } .cover-wrapper.dock .list-h a.active { font-weight: 600 !important; } .l_header.auto.show { transform: translateY(0) scale(1) !important; } .l_header.auto { transition: all .35s ease !important; transform: translateY(-100%) !important; visibility: hidden; } ul.list-v.rightmenu { -webkit-backdrop-filter: saturate(200%) blur(20px) !important; backdrop-filter: saturate(200%) blur(20px) !important; } #rightmenu-wrapper { opacity: 1 !important; transition: opacity 0.5s ease; } .cover-wrapper .cover-body .title { text-shadow: 0 1px 2px rgb(0 0 0 / 85%) !important; } .article code { font-family: 'Fira Code', var(--font-code) !important; font-size: 0.95em; } p.friend-name { font-family: var(--font-art);; font-size: 1em !important; } .cover-wrapper .cover-body .subtitle { font-family: var(--font-jp); text-shadow: 0 1px 2px rgb(0 0 0 / 75%) !important; /* font-size: 18px !important; */ } .article mjx-container { padding: 2px 1px !important; font-size: 120% !important; } .article ul.has-jax { padding: 0 0 0 18px !important; } span.mjpage { font-size: 85%; } .blogger .content p { font-weight: normal !important; } span.mjpage__block { display: block; overflow: auto hidden; } /* blockquote h1:before, blockquote h2:before, blockquote h3:before, blockquote h4:before, blockquote h5:before, blockquote h6:before { display: none !important; } */ blockquote h1:before, blockquote h2:before { height: 2rem !important; } blockquote h3:before, blockquote h4:before, blockquote h5:before, blockquote h6:before { height: 4rem !important; } @media screen and (max-width: 768px) { .widget.blogger { color: var(--color-text) !important; } } .widget.blogger .content .social-wrapper { -ms-flex-pack: distribute !important; justify-content: space-around !important; } .article figure:not([class]) { margin: 0; margin-block: 0; margin-inline: 0; line-height: 0; text-align: center; } .article figure figcaption { /* font-size: 14px; opacity: 75%; line-height: normal; */ display: none; }"},{"title":"","date":"2021-02-15T10:56:20.000Z","updated":"2021-02-15T10:56:20.000Z","comments":true,"path":"favorite/index.html","permalink":"https://shiraha.cn/favorite/","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-02-08T16:50:00.000Z","updated":"2020-02-08T16:50:00.000Z","comments":true,"path":"friends/index.html","permalink":"https://shiraha.cn/friends/","excerpt":"欢迎我的朋友们和我互加友链！ 我的友链信息见文章末尾（","text":"欢迎我的朋友们和我互加友链！ 我的友链信息见文章末尾（ 我的友链信息： 1234567891011121314151617&#123; &quot;title&quot;: &quot;七海の参考書&quot;, &quot;author&quot;: &quot;七海&quot;, &quot;avatar&quot;: &#123; &quot;jsdelivr&quot;: &quot;https://cdn.jsdelivr.net/gh/45921/cdn-images@main/me/avatar.jpg&quot;, &quot;gitee&quot;: &quot;https://shiroha.gitee.io/cdn-images/me/avatar.jpg&quot;, &quot;github&quot;: &quot;https://gh.shiraha.cn/cdn-images/me/avatar.jpg&quot;, &quot;sm-ms&quot;: &quot;https://i.loli.net/2021/03/13/kFa9li52DyNxJGB.jpg&quot; &#125;, &quot;url&quot;: &quot;https://shiraha.cn/&quot;, &quot;keywords&quot;: [], &quot;description&quot;: &#123; &quot;ja&quot;: &quot;ハッピーエンドを約束しよう——&quot;, &quot;zh&quot;: &quot;许下一个美好的结局吧——&quot;, &quot;en&quot;: &quot;Promise a happy ending...&quot; &#125;&#125; 另提供简略版 YAML 格式： 12345678- title: 七海の参考書 author: 七海 avatar: https://cdn.jsdelivr.net/gh/45921/cdn-images@main/me/avatar.jpg url: https://shiraha.cn/ keywords: - ACGN - Web description: 许下一个美好的结局吧—— 别的信息就随便写点什么就可以啦♥"},{"title":"","date":"2021-02-15T10:50:00.000Z","updated":"2021-02-15T10:50:00.000Z","comments":true,"path":"memo/index.html","permalink":"https://shiraha.cn/memo/","excerpt":"","text":""},{"title":"收藏夹 & 导航","date":"2021-02-15T09:31:00.000Z","updated":"2021-02-15T09:31:00.000Z","comments":true,"path":"navigation/index.html","permalink":"https://shiraha.cn/navigation/","excerpt":"","text":"刷题上分！ 上分网站，多刷题才能变强！ AtCoder Codeforces 网站维护 建站/网站维护用的各种服务 DNSPod namesilo TinyPNG TinyPNG CN LeanCloud CN Volantis.js SM.MS Font-Awesome 这个标签按钮好像不是很好用啊，那就先不写简介好了 == 会更新日用网页的链接（"},{"title":"项目 & 链接","date":"2020-07-30T16:50:00.000Z","updated":"2020-07-30T16:50:00.000Z","comments":true,"path":"projects/index.html","permalink":"https://shiraha.cn/projects/","excerpt":"","text":"说是 Projects 实际上也就是一些乱搞的玩意； 我的第二个域名 shiraha.top 正式投入使用辣！ 说是一个新的页面，但是和友链一样果然还是有点捞== 听说 volantis 主题有一些全新的组件，有时间的话尝试给它搬过来好了（ 虽然不知道未来我是不是还在用这个主题就是了）"},{"title":"所有标签","date":"2022-03-11T08:12:45.457Z","updated":"2022-03-11T08:12:45.457Z","comments":true,"path":"tags/index.html","permalink":"https://shiraha.cn/tags/","excerpt":"","text":""},{"title":"小工具","date":"2021-02-15T09:43:00.000Z","updated":"2021-09-13T18:05:00.000Z","comments":true,"path":"toys/index.html","permalink":"https://shiraha.cn/toys/","excerpt":"","text":"如果开发了小工具什么的，它们就会出现在这里吧 ：） UPD（2021.9.14）：更换地址为 toolbox/ -&gt; toys；nicknack 更多还是装饰品的意思；omocha 虽然不错，但是 about/me 页面也没有用 watashi 所以还是算了（）现在定义 spa/ 用来存放这些小应用，其他的整理性质的文件夹之后再想办法；——之所以搞得这么复杂是因为 Pjax 重载有点问题，也没有什么好办法来解决所以先这样，看起来好看一些（"},{"title":"2021 秋季上半学期总结","date":"2021-10-30T15:56:23.000Z","updated":"2021-10-30T15:56:23.000Z","comments":true,"path":"memo/2021/2021-autumn-first-half-summary.html","permalink":"https://shiraha.cn/memo/2021/2021-autumn-first-half-summary.html","excerpt":"","text":"只能说为了应付考试的学习是真的可以令生活充实起来，之前和队友朋友谈笑的“有时间的话就写写代码作为娱乐放松吧！”似乎也成为了一纸空谈—— 似乎也就是弹指一挥间，距离开学已经过去了半个学期；和朋友进食后回家的路上，看到了熟悉又陌生的机器人的邮件，才意识到确实还有个博客（乐了） 作为除草，简单的总结一下过去的半个学期的快乐的事情吧！ 娱乐活动 虽然确实说出来挺奇妙的，但是确实进行了相当多有趣的娱乐活动： 双人成行 作为今年上半年最能打的游戏之一，我很庆幸还有可以一起玩的朋友可惜没有对象；如果要让我用词语来形容，就像两个人一起遁入了某个童话故事之中；作为游戏中夫妻缓解矛盾的方法可以说是再合适不过—— 有什么可以比得上来一次说走就走的旅行，甚至还是前往不可思议国度的冒险呢？ 不由得让我联想起小的时候，曾经也对着各种小物件产生奇妙的幻想—— 想象文具盒中的世界，又或者是电视柜中居住的一家人，也许某根灯管就等同于浩瀚无边的宇宙；当这个游戏用现代图形技术，将脑中的幻想再现在我的眼前的时候，只能说大受感动。也许可以在雪景球中玩上一天雪仗，也可以以身体为笔，沾上颜料在画布上描绘古老的图腾—— 只是简单的快乐，却不由的让人流连其中。 虽然游戏因为中途易辙使得某些地方稍显奇怪，但是整部作品的氛围相当的温馨，也许是我目前为止今年玩过的最好游戏。如果可以的话回家想让老爸老妈来一起玩玩。 虽然确实有点贵就是了…… 但是作为一张梦幻世界的车票也确实算不上什么了（ アインシュタインより愛を込めて APOLLOCRISIS 作为去年新岛夕跌落神坛的最大败笔的《アインシュタインより愛を込めて》的续作，不如说是补充说明；我认为加上这份续篇才算构成了一个完整的游戏。作为新岛夕的粉丝，在第一时间读完了之后也算是松了一口气—— 老师水平尚在，只是去年真的没有写完就拿出来卖了（ 简单的说，这是一个很有老师风格的爱情故事；但是老师确实不会写 SF，建议向隔壁すかぢ学学，多看看三体学学人家是怎么写科幻的。续篇为了提高整个故事的质量，否定/忽视了大量本篇中的设定，虽然填了一部分没有回收的伏线但是本篇就显得更加尴尬—— 跑火车程度快赶上雪人了。 说到角色，我认为续篇做的最好的事情就是把Σ写活了—— 毕竟是整个故事里唯一的白毛女主角。作为 Pure AI，Σ只能机械的决定最优的做法：如果你有疑问，我就提供答案；如果你需要温暖，我就成为温暖你的人；但是程序又怎么能计算出人类复杂的感情？也许感情就是这样不讲理的东西吧：即使有唾手可得的答案，那也无法比拟自己去寻找的过程—— 毕竟旅行本身就存在意义。 回到主线剧情：「俺はお前がどこから来てどこに行くとしても....... お前を愛しているという結論に、何も変わりは無い」 ——这能否也可以看作是男主经历了被女主保护，以及各种各样的艰难的抉择之后最后得到的答案呢？又想到在游戏内反复提及的观点：自己的难题要自己去寻找答案；而这一定是男主经过了漫长的岁月而找到的答案吧：比起唾手可得的知识与智慧，甚至都不是绝对之恶；而选择用自己平凡的思考，用尽一生来解读，去品味她所给予的一切，拼尽全力伸出手守护挚爱——也许就是新岛夕笔下爱情的样子吧。 比起寻找精神寄托的叔父，本就没有心的机械的 Sigma，从最开始不知道人心为何物，无知狂妄，只是被一味的保护着的少年，成长为了可以支撑起ロミ，可以伸出手去追求幸福的男人—— 这也最终回到了新岛夕笔下男主的一大特质：成长；就像 H2O 里的浪漫是两人并肩而行，只留下沙滩上的一排脚印；只有在这样的新世界里，他们的恋爱才能再一次启程吧。就算没有知道那新世界的去向，现在的他和她也一定能这样走下去—— 最后以一句话总结一下吧：最烂的 SF，最棒的恋爱故事。 弹丸论破 因为之前被各种各样神秘剧透了，所以玩的很快。虽然案件在推理作品里应该并不是很能排得上名号，但是值得称道的是和它最开始各种“超高校级”的设定很好的融合了，一旦接受了它的设定只会感受到无比的畅快。从最开始最为引人注目的沙耶香去世之后，整个游戏就紧张感拉满：荒诞的学校，不知所云的黑白熊，一切常识都歪向奇怪的方向；有人揣揣不安，有人心怀鬼胎—— ……算了不说废话了；黑白熊可以说是这个故事的点睛之笔灵魂人物，角色本身的荒诞性也将一切奇怪的行为合理化，是故事得以进行；虽然身处绝望的环境，但是不同人的反应也构成了一部扭曲但又闪耀着个性的群像剧；言弹和发言值等设定也确实有趣；不愧是经典作品。 此外，在草稿纸上画各种各样的黑白熊非常的解压，亲测。 偶像大师星耀季节 我都花钱买了为什么还要玩？ 过去了这么多年了，她们还是一如既往的可爱；不过游戏也就是普通的 JRPG，各种讨人厌的要素也确实都还在，不是很能处。MV 放映的效果应该是很好的，但是我的电脑不是很能带的动，所以搁了== 真要刷刷刷完也太慢了吧，你们 JRPG 能不能整点有趣的机制啊？（暴论 杂七杂八 一些折腾的记录，大概算是这段时间里为数不多的技术相关吧（笑 Windows 11 体验 Windows 11 似乎默认开启了仅允许 Windows Hello 登录，这使得 IIS 提供的 FTP、远程桌面什么的都不能正常的工作；虽然微软说的头头是道（也确实是这样）但是为了方便也只能关掉这一条。搭建 smb 服务比想象中要简单很多，而且应该也是目前我发现的局域网共享文件的最优雅的方案。从此之后向黄油板里复制游戏再也不需要拔出存储卡，带上大卡套这么麻烦了；而且 smb 挂载为虚拟硬盘后甚至可以直接启动其中的程序，突然理解了那些在家中搭建 smb 的人什么电子设备都买最低配了—— 挂载虚拟硬盘几乎可以获得一致于机械硬盘的体验，只要你的交换机和硬件够给劲（） 这段时间里 Windows 11 在我的电脑上出的最大最恶的问题就是某天突然发现关机只能注销回登陆页面。在网上找了半天也只发现关闭快速启动的方法—— 但是这样会让我开机时间翻一倍== 最后直接重做了（）唉 STL 堆的疑问 因为复习考研数据结构的原因，顺便读了一下 STL 里关于堆的函数的实现，意外地发现 __adjust_heap 函数再执行下滤的过程中，会先将待处理节点一直下沉到最低位置，再调用上滤函数 __push_heap 将节点上移到正确的位置，意义不明；目前推测是为了减少分支预测方便处理器/编译器的神秘的优化，也没在参考书上找到什么合理的答案，只好先作罢。希望之后可以搞懂。 原来那个线性建堆的方法叫 Floyd 建堆法啊，邓书还是很扎实的。 密码生成器 出于娱乐心理，某次复习累了我决定直接在博客内嵌入一个密码生成器。也确实不难写，但是也算是我第一次尝试在这个博客主题的框架下插入可交互元素，属于是标志性了—— 可惜关于对 Pjax 的适配我还没有什么思路…… 之后考完了再研究研究吧。 看了看 Volantis 的最新代码和示例博客，他们似乎已经对于这个问题有了相当完备的解决方案，甚至可以在 Pjax 页面里放入一个简单的 Linux 终端，只能说真的是玄之又玄。可惜没有时间也没有什么心情去认真研究了。毕竟还有事情要做…… 之后有缘再看吧，躺了。 退役 OIer 轰趴 虽然我也不是什么 OIer，但是还是姑且参加了这次活动—— 可惜本校的鸽子最后都没来；本来以为要坐牢了，但是最后大家熟悉起来了还是可以一起玩很开心的，也见到了偶像 Menci—— 确实是个很可爱的男孩子，而且性格也很好很会照顾人，也确实很会打音游（） 狼人杀确实是线下聚会破冰的利器！一直自诩高冷的我也在两把之后直接上头（）可惜最后第三把表现的拉了—— 最后还是靠 Menci 力挽狂澜才赢得了胜利；还是很愉快的== 网安基地一日游 受云研友安安的邀请，我可以第一次踏上国家网安基地的校园；首先在高中同学的带领下绕了校区逛了一圈。虽然面积并不大（相比主校区）但是相当的现代化—— 到处都是玻璃墙。住宿区的寝室也是围成一个环状，很有设计感的楼虽然就居住者的反应来看确实也有相当不合理的地方。 之后安安醒了，就直接开始主要活动—— 一起去网安图书馆自习。基地的图书馆的内部设计和老家前几年建起来的图书馆很相似，当然是要更豪华许多毕竟老家的图书馆似乎都不怎么维护了，没办法毕竟穷啊；顶层的自习区域中间甚至围成了一个空中花园，其中甚至还配备了秋千这种我已经很多年没有见过的高级情调物品…… 只能说有钱真好啊，我也想每天都在这种宽敞明亮干净的图书馆自习（ 学完了就去低楼层看每天都被公众号宣传的图书馆高级电脑和高级座椅，但是就结果而言确实有些鸡肋…… 四个屏幕并起来还可以认为在 cosplay Windows 网络和共享中心的图标，六个屏幕并起来是为了什么我是真的没太理解了…… 但是毕竟可以正常使用，倒也问题不大。至于配置了 4k 曲面屏的电脑，我随便开了两台都是蓝屏，只能说带我参观的安安不觉得尴尬我都觉得尴尬了） 然后去体验高级电竞椅，配备的电脑上甚至还有原神，甚至还有它的上一个用户登录的账号（？）只能感慨同学的网络安全意识有待提高== 之后发现这一排电竞椅背后就是玻璃墙，你摸鱼可以被外面的路人看的清清楚楚，也难怪没有什么人来用了（） 最后想要吐槽的一点就是整个网安基地的所有的消费都要使用手机支付—— 校园卡完全成为了摆设，只能用来进出校门图书馆；不过考虑到武大华科合用基地，统一校园卡可能确实有些难度，也就释然了（ 打工人的中秋节 中秋节之际，受已经工作的学长的邀请，我前往了距离学校几公里的学长的公寓—— 让我切身的体会到了在外漂泊打工人的辛酸…… 虽然没有大豪斯，房间也因为忙于工作而疏于打理，但是学长也能笑呵呵的乐在其中，不由得让人肃然起敬。终有一天我也要变成这样啊…… 虽然空间并不宽敞，但是并不影响一起过中秋节的气氛。我们就像一家那样出去买菜，材料备妥后学长下厨，很快就摆出了一桌子家常菜。尽管中秋是一个与家人团圆的节日，但是如果是无法还乡的同僚一起度过想必也不会十分偏移它的原意—— 打工人，四海为家啊！ Galgame 兴趣小组 目前我唯一的社团活动（） 约歌吃饭 吸取了上学期约歌房间不够的教训，这次我提前打电话订了最大的房间—— 然后发现最大的房间也太大太贵了== 还好在同行学长的陪同下去找了工作人员换成了稍微小一点的，之后组织活动的时候可得注意了才行。虽然很多群友都已经在上学期的“毕业歌会”真的毕业了，但是还是有几位群友返回武汉一起玩，真不错。 之后吃饭发现似乎被坑了：征集大家意见的时候群友全票通过了湖锦酒楼，到最后却有些群友觉得价格太高没有参加，属于是给我差点整不会了…… 还好最后还是有差不多那么多人来参加，也不至于搞得太尴尬（）作为活动组织者我还差的远了！ 招新宣讲 动漫社要开社员大会，作为第一（？）大的兴趣小组当然是不可能放过这个拉人的机会的；虽然确实是时间比较紧张，而且没有什么头绪做准备工作，本来都准备交给学弟摸了（）之后一想到之前口嗨然后准备的一堆樱之诗樱之刻素材，就突然“灵机一动”，做了完全以樱之刻风格的 PPT—— 之前学院送我去的培训倒也没白搭上； 就结果而言，我大概做出了全场最华丽的 PPT—— 可惜核心部门给兴趣小组的时间是在是太少了，我没能完全按照 2k 字的稿子说完甚至还被给我限制时间的家伙锐评“社恐”，只能说多少有些不愉快。令人欣慰的是确实捞了很多新人，用来做群网站的 .ml 域名在那几天也没有被污染，可以算是大成功吧） 就算不是也是为数不多的记忆了—— 如此投入社团活动也是自有乐趣的（） 最后 FAQ：说了这么多开心的事情，那么你学习了吗？ 那当然是学了，但是有什么写出来装裱的必要吗？懒得写啦！ 最后 50 天，冲啊！ 复习 虽然这是个很无聊的话题，但是作为这段时期的主题，也确实不能一句话都不提：简单来说就是因此过上了作息规律的、充实的生活—— 抛开别的来说，能够如此高集中力地去做这样一件事情，也算是苦中作乐，乐在其中； 尽管进度确实有些紧张了。 虽然确实摸了点，但是也算是稳步推进进度吧—— 嗯，是这样。 最后在母上的帮助下决定了报名院校—— 接下来要做的只是努力了。"},{"title":"2021 暑假总结","date":"2021-09-06T09:17:59.000Z","updated":"2021-09-13T19:53:35.000Z","comments":true,"path":"memo/2021/2021-summer-vacation-summary.html","permalink":"https://shiraha.cn/memo/2021/2021-summer-vacation-summary.html","excerpt":"","text":"其实这篇文章的各种片段早就零零散散地写了一些了，但是实在是难以整理成一片文章的样子所以才拖到了现在；不过为了一篇只是算作是记录的文章花费大量的功夫本就不是明智之举，所以就这样随便拼凑起来发出来了（ 于是这就是你从八月底就开始企划，决定九月二三号发布然后推迟到生日又推迟到教师节又推迟到 12 号最后想要 13 号写最终 14 号才写的原因🐎 ENDER LILIES 这是一个类银河战士恶魔城的游戏，具有“白发少女”、“触手”、“替身”、“空洞骑士”等多重诱人上钩的 Tag，然后我就上钩了；因为难度还算是比较友好，所以在沈阳站结束了的那几天打着打着就全收集了，属于是靠自己力量全收集的第一个游戏了（毕竟有人是空洞科学家，是谁我不说）。 虽然这游戏氛围不错，音乐很好（毕竟是那个 Mili），画面精美，小女孩跑跑跳跳也很可爱，比较简单所以正反馈也很强，但是还是无法掩盖关于一些游戏性设计上的问题；最需要吐槽的大概就是最终 boss 过于白给了吧——虽然网易云评论区里一堆解读，但是没有空洞骑士的 boss 效果震撼也确实是事实，虽然拿这两个游戏进行对比也属于有点为难胖虎了（笑） 另一个我比较在意的就是结局设定了；本就不是很完善的世界塞入了大量的要素导致的结果就是每一个部分都不甚完整；当然这种欲言又止的体验本就是碎片化叙事的特色，但是如果玩家用游戏中的碎片无法拼出一个比较公认的故事线路的话，那么也只能说是有点问题了。而且结局其实也显得非常的无力，比起空洞骑士最后化身虚空爆扇辐光大嘴巴子，这游戏明显差了点意思。 当然，这些缺点虽然客观存在，但是花个 70 块钱在一个精美的中世纪世界里作为一个攻击是替身的小女孩到处玩玩也是十分值得的；有兴趣可以去 Steam 上买： 之后还有和群友进行的关于这个游戏吸引力的所在的讨论，只能说非常图一乐。毕竟没有人愿意承认自己是赛博色批，但是事实上近几年的类银河战士恶魔城或多或少都要站点，难道只能说是这届玩家不行？没有数据，不知道它在商业上成功程度，就不多评价了。 关于结局还有一个值得一提的就是，在我和朋友都觉得这个结局虎头蛇尾的时候，网易云评论区却是一副大受感动的样子——关于这点我们进行了一些讨论，结果就是大概每个（男性）玩家都想当护花使者吧，所以女主角回眸一笑就够了，乐（ 小米新品发布会 8 月 10 日，雷军举办了小米新品发布会：发布的是 MIX 4 和小米平板 5 ——当然，我关注的只有后者就是了实际上只有 Pro 版（）基本上和预料的差不多——2500左右的价格买一个小米平板 4 用户到死也没有等来的 MIUI for Pad，一个 870 和带高刷的比较顶级的 2.5k 屏幕，以及不怎么期待的手写笔。 发布会上雷军亲口说出“可以连续玩原神 6 小时”的时候确实有点绷不住了，但是想到小米现在和米哈游搞合作，小米之家摆的 K40 上跑着的全部都是原神的时候觉得又合理了许多。虽然如果我买它的话一定不是因为这个原因就是了！ 虽然发布的第一时间确实有点蠢蠢欲动，但是在出了小米平板 4 之后我有突然觉得安卓平板似乎也就是那么一回事了——毕竟真要玩黄油或者干活比不上 Surface，娱乐起来又不如 iPad 乐；虽然有些只有安卓能做的，但是真的也不算很有必要，所以还是暂且作罢（ 密室逃脱 做梦也没有想到只有同龄人的第一次密室逃脱竟然是和平时不怎么交往的亲戚家小孩一起；虽然家里的亲缘并没有那么的近，平时的交流也十分有限（甚至其中还包含一位 2022 届高考考生）但是经过了短暂的装模做样之后很快就放开了—— 只能说我确实是没有玩这种游戏的能力就是了毕竟在学校也是只老鼠根本没有什么社交；在游戏的最开始我们甚至直接暴力拆迁，Game Holder 甚至忍不住直接用对讲机制止我们（）然后一位刚高考和两位算是通过高考的人不能凑出一个排列组合复杂度也能接受的对子，实在是有点绑不住了== 玩了一会之后就逐渐上道了，也就没有太多值得一提了；只能说这种类型还是有点意思，只是在学校一群鼠人去玩也未免有些尴尬就是了（ 玩的黄油 这个暑假好想玩了好几个黄油，每一个都作为一个 h2 显得有些愚蠢，所以就和在一起了；短时间也不会写正式的评论文章，所以以下内容也就是随口扯扯外加控制篇幅的原因，若是没有逻辑想必也是预料之中的吧） 以下讲述的顺序并没有按照实际游玩顺序进行。 加奈 ~欢迎回来~ 一个很老的作品；玩完之后第一感想就是：完整的故事需要的只是登场人物和必要的环境；虽然十五巨细的作品可以展现更加完整的世界，但是这并不是将感情和思考传达给读者的必要作品；就长度和叙事的完整性来看，本作绝对算是“麻雀虽小，但五脏俱全”。 一个家，一位病弱但是又依赖男主的妹妹，一个从小就被男主误会但是一直喜欢男主的青梅竹马，被妹妹所吸引的同班同学；只是这样的四位登场人物，想必玩家已经可以把故事编的有模有样——无非就是男主选择了谁，妹妹是否得救——仅仅是 2×2 的可能性。 但是若是这个游戏仅仅止步于此的话，那也不会颇具盛名；事实上本作除了前面所说的“可以被料想”的三条线路之外，还有三条其实是一条“知性”线路——确能展现口三才与一般人的想法的不同之处；让将死之人认识到生命的意义，这话说的轻巧，但是若是真的又有谁能承担的起呢？到头来，嘴上说着为病人好，实际上也只是自私罢了——玩家和那个肤浅地喜欢着妹妹的懵懂无知的同班同学到头来又有什么区别呢？属实有被愉悦到。 ……场面话就不说了；听说之后有根据这个改变的韩剧《蓝色生死恋》以及国内翻拍的电影；之后如果有时间的话还是可以去看一看。 冥契的牧神节 扭曲的桐叶和扭曲的ルクル的最新力作；之前也玩过了《纸上的魔法使》和《水葬银货》，对他的作品本就有着极高的期待，所以汉化一出就打算玩了； 看完最大的感想还是自己书读的太少了啊，就算想在日记本里随便闲谈都难以成篇；对于花式用典我们先暂且不谈毕竟一问三不知的我不配，这也是叙诡的完美实践——在推的过程中可以让我在每一个阶段都对剧情有不同的预期，也许确实是我太过于底力不足了吧（） 唯一有些不满的是最后作者也没有明说实际的世界具体怎么样了；就类似是 ENDER LILIES 那样的结局一样，玩家并不好判断是 GE 还是 BE；虽然这并不重要就是了，但是不知道实际上发生了什么确实是有些一头雾水== 但就算虎头蛇尾，也不影响这部作品讲述了优秀的故事这一事实。 这游戏大概还会再打一遍吧，当然是在了解了所有的典故之后== 此外这游戏的文本质量极高（金句频出），虽然这些句子中的一些也许看起来十分中二，但是却也确实能重击读者的心灵——宛如戏剧本身；整部作品或许就是 rkr 妹控本人的狂想曲罢！ Parquet 一段时间没有联系过的老柚子厨学长突然转发了柚子新作发表的直播，属实让我吓了一跳；虽然看了直播发现就这，但是毕竟柚子的子品牌的第一作，还请了最近还参加 D.C.4 的东山奈央来配女主，所以自然还是要去玩一下的； ……只能说不愧是柚子社，可以说是意料之中的催眠；七月底出的生肉我就下载了开始，但是在那一晚上爆玩之后，故事进入稳定阶段之后就完全没有让人玩下去的爆点——最后官方中文版八月底出来之后的一天我才打完（）也算是了却一桩事情了吧；下面是官中购买链接↓ 看翻译 API 的调用报告，大概游戏在 10w 文本量级别，时长在 10h 以内；明明这样的篇幅已经足够说明一个具有一定冲突的故事了，为什么要弄得这么白开水呢…… 但是又意外地觉得不意外，大概也确实不对柚子有什么期望了吧（笑 Loopers Key 社的小短篇，虽然群友对它的评价是一致的不行，但是因为简介也还算是比较具有吸引力而且汉化出的很快，所以就顺便玩了一下；虽然群友说的问题确实客观存在，但是对一个长度大约在 7h 左右的作品追求一些过多的描写是不是有些过于苛刻？ 故事上则是一股浓浓的 Angel Beats 味还有永远轮回的暑假 mini，也很具有龙骑士先生个人的风格——当然，也仅限故事的开头；虽然我对于 Key 传统的热血并不是很感冒，但是放在这样的一个短小的篇幅里却又恰好地不那么的令人反感。我们并不需要太多地了解解决问题的具体方法毕竟他们也写不出来，只需要知道大家通力合作完成了这样的壮举就好了；最后男女主幸福地生活在了一起，可喜可贺（虽然打完冷静下来之后还是觉得这或许还是多少沾点 就逻辑性而言，故事虽然短小，但是为数不多的伏笔都有认真回收，就总体的结构而言可以说是合情合理的至少没崩；虽然因此没有足够的篇幅渲染男女主感情的进展，但是并不妨碍一个平面的可爱女主角的养成；就这点来看我觉得本作或许比去年的 ATRI 更适合成为年轻人的第 x 部 ADV== 而且除了女主角之外的声优虽然名字不熟，但是表现的都可圈可点，把龙骑士笔下女主角的“内味儿”展现的淋漓尽致就像祝姬的声优们那样；如果有了官中，我还是很推荐周围的人去玩一玩的（ 虽然，这也许更加适合做成动漫的吧——不过这样的话似乎有会有一些其他的问题比如剧情上没有什么新意等等所以也只是想想== 不过，肯定比成神之日强吧！（暴论 再见 Edge 8 月 24 日，我像往常一样打开笔记本打开浏览器准备上网冲浪，然后发现 Edge 的启动栏下出现了一个丑陋的导航条——为什么一眼就看到了呢？那当然是因为它实在是丑的显眼；本来为了让首页看起来更加清爽已经使用了内容关闭选项，但是似乎广告还是弹出来了。经过几番确认，我确信这是无法关闭的“流氓”广告条。 联想到之前 Edge 国行版的新标签页面下的蜜汁浮起，现在终于也能说得通了——因为要引入广告；包括申请增值业务许可证也都是为了这个的准备，只能说国内用户就低人一等了是吧？越想越气，把默认浏览器换成了 Firefox 还是没能解气，于是上微软社区发帖骂人== 在当天晚上就得到了如下的回复： 「突发 &amp; 紧急」关于 “Microsoft Edge 浏览器新标签页底部出现无法关闭的广告” 问题的说明 - Microsoft Community 没什么好说的，只能说垄断真的会带来差的用户体验。国内广告投放本来就是劣币驱逐良币的过程；现在手机系统软件内置广告已经不再是小米的专利，甚至“国之栋梁”的华为也不吝惜在自己的各种系统软件中增加广告（来自同学的描述听说鸿蒙目前没有）；如果 Firefox 被干碎了，不知道未来会怎么样== 所以，哪怕不管 Edge 多香，性能多么好功能多么全面，我还是继续 Firefox 吧。加油啊，永远站在用户一边捍卫互联网的浏览器！ 其他的娱乐活动 虽然但是，这也确实是这段时间里相当重要的组成部分，所以随便提一嘴好了（ 你画我猜 这也太乐了；群友是不是什么动漫都能猜成 JOJO 啊（笑），建议把这个从题库中移除== 总之这游戏像橙汁一样有希望成为你群为数不多可以众乐乐的游戏之一（ 炉石 前前后后开了 100 个包也没有无敌的恶魔之种，之前那套黑眼术又被彻底砍废了，干脆弃坑 备战考研 因为算是逐渐调节自己的状态以面向考研，所以暑假基本就是调整作息，然后尝试集中精力学习，晚上出去散步的节奏再辅以一些娱乐措施（？；看完了线代 9 讲之后发现 18 讲原来是二轮复习资料怪不得看起来寸步难行；不管啦，调整作息就算成功！ 最后 应该做些什么样的总结呢，好想暑假也就是半摸鱼地考研准备一边打打黄油就过去了；整理后的箱子和回来时的箱子别无二致，看过的书比起带回家的部分那也真的是九牛一毛——虽然不相信，但是也确实是一如之前的每一个暑假。每一本原样带回去的书似乎都在嘲笑对自己抱有过高期待的自己，诉说着摸鱼的罪恶，惭愧！ 算了，不说这些有的没的了；要开学啦，该做正规考研人该做的事情啦！希望下个月或者是下两个月或者是下季度（学期）的总结可以不辜负自己吧！"},{"title":"2021 寒假总结","date":"2021-02-26T10:45:20.000Z","updated":"2021-02-26T10:45:20.000Z","comments":true,"path":"memo/2021/2021-winter-vacation-summary.html","permalink":"https://shiraha.cn/memo/2021/2021-winter-vacation-summary.html","excerpt":"","text":"2020 年的年终总结，由于各种原因一拖再拖，最终还是没有在一个差不多的时间里写出来，只好作罢（）但是让时间这么白白过去也确实不太好，于是就打算以寒假的结束作为契机，也是作为我博客“随笔”板块的第一篇文章，对已经过去的寒假的总结： 记流水账 今年的寒假虽然时间上是相当的长（当然，也没有必要和去年的八个月超长寒假进行对比），但是比起要做的事情来说还是远远不够的；总体来看，寒假可以以春节为界限划分为前后差不多相等的两个部分： 前三周 前三周我还算是比较勤奋的：大概是因为去年年底那场区域赛打铁搞了点心态，再加上早就已经确定下来的第二年的日程——冲刺考研；所以一放寒假满脑子都是想着怎么样才能在这个寒假提升自己的做题能力和知识水平……也确实挺好的，这段时间还算是做了一些事情。 首先最开始的一个星期：大概是因为刚刚放假吧，所以我总体还是处于放松的状态；首先是把已经搁置了一年但是回家之前一直有在玩的经典游戏 CHAOS;CHILD 推完了；怎么说呢，虽然网上对于大多数的个人线的评价并不高，但是我觉得还是基本都很有意思的：就比如 Real Sky End 和 Dream Sky End，都有非常的有我很喜欢的那种虚幻的幸福的味道——毕竟我一向的观点就是不管多老的套路，只要你玩的好，我还是很喜欢的（ 打完之后就是 hls 宣布了新的任务：我个人而言不是太希望把队友逼的很紧，所以就没有严格的要求他们完成这些任务——采用合作的方式完成；但是现在看起来就非常的尴尬——一位队友几乎没声音没图像，另一位队友经常有各种奇妙的安排导致没有办法贯彻训练…… 这确实有点令人不快，但是我又能做什么呢：谁又能知道正确的做法在何处呢？只能向似懂非懂的父母倒倒苦水，半夜里独自哀叹罢了（ 我到底应该怎样握住你的手，才能够不伤害到你呢？ 虽然这确实不是好事，但是一个人的训练倒也确实地做下来了：除了这阶段的各种大小 CF 比赛，以及 hls 安排的专题（前两个）还是有好好的完成了。不得不说很有收获：没有知识的情况下做题目就是盲人摸象，而当掌握了一些知识之后，思考就明显地更加地 rational——且不论最后有没有做出一道题目，这种思考方式、或者说感觉给人带来的体验还是很棒的。 当然，最为瞩目的成就还是我的一个 Codeforces 账号上紫了：这要放在之前我自己也不敢想的； 在做题之外还得提一嘴就是水葬银货——一个挺不错的游戏；在打完了 CC 之后我就在群友的推荐下带着玩了：只能说不愧是纸上的魔法使的精神续作；整部作品都弥漫着悲伤的感觉…… 但是带给玩家的也不仅仅是扣人心弦的剧情—— 虽然大概和剧情关系不大，但是还是感觉受到了提醒：奇迹不是免费的——如果说 TE 男主最后从恶人父亲的阴影中走了出来，和傲慢的“导演”正式地站到牌桌前，是男主自己努力抗争而得到的“奇迹”的话，那么就不得不提为他流过眼泪的四位人鱼公主—— 不论在接下来的生活中到达了怎样的场所，都不能忘记垫在脚下的，他人对自己的奉献和付出——给我带来最大的感受莫大于此吧。关于这一点，如果日后有时间，还是拿出来好好地回味一下的好；我已经很久没有玩过这样的作品了（ 此外，由此而衍生的感想就是经典的“人生游戏”——和一句德州扑克又有什么区别呢？究其所有，我们只不过是在不断地做出更高期望值的选择罢了；到底是在占据优势的时候洋洋得意地更进，甚至是 ALL-IN 呢？还是见好就收的 FOLD 呢？在失败的时候又是否会因为失去筹码的恐惧而丧失清晰的判断呢？虽然并不能看到自己在这赌桌上的神态，但从高中的竞赛生涯到现在，我一定不是一个理智的玩家吧（ 过春节 不得不说的就是：比起之前的过年来说，今年的过年有很多“惯例”都没有执行——比如春节当天给特定的朋友发送具体的春节留言（yysy，这方面三上线虫陈永康做的都比我好），又比如说和储文睿他们一起出去爬山甚至是走路锻炼身体；但是也又很多的保留：比如说一如既往没有一点完成的意思的看书计划之类的； 虽然也不说是恋旧吧，但是在过年的时候回忆一年之内不同的朋友的各种交集，确实是一件很有意思的事情。今年春节期间的时间基本都在写一些娱乐代码（改造 icarus 主题给七海 Galgame使用以及黄油画廊），所以基本也就没有什么时间去写评论了；之后明年过年还是得重启这个才行== 春节做的一大事情就是把已经弃坑半年的博客（没错，就是本博客）一阵翻新之后又重新投入使用了：使用原主题 Material-X 的作者们翻新且换代好多版本的 Volantis 作为基础，重新折腾了一些新的小玩意，最后博客得以重新开张；虽然形式化的写博文并不可取，但是不做任何记录同样是不可取的。 后三周 春节之后，没折腾够的无心学习的我对朋友曾经使用过的 hexo-theme-icarus 进行了一些改造和尝试；它现在已经使用了一种类似于 React 的，使用 JSX 的框架 inferno 作为布局文件的模板，恰好是我略懂一二的东西——所以进行的倒也还算顺利：经过东拼西凑以及四处借鉴（实际上，有相当一部分的代码都来自于本站使用的主题 volantis），倒是也做出了个像模像样的东西，还是挺有成就感的吧（）最后将一个阶段性的版本作为七海 Galgame 的主题投入使用的时候，还是挺兴奋的。 将大量的时间用在前端相关的开发上带来的问题也是非常的显然的：我的 ACM 相关的投入相对于前半个寒假而言是极大地减少——基本也就是水水牛客的比赛，混混 CF（实际上，寒假最后两场 CF 我也没有打：因为各种各样的原因，就这样被我翘掉了，甚至现在还没有补） 感觉自己在疯狂上分的路上丧失了最开始打 CF 的时候初心——只是为了锻炼自己的临场解题的能力——我变得患得患失，害怕掉分——是因为小号打上紫名之后就变成这样了吗？理论上说紫名其实也算不上什么啊？在上橙名之前应该什么都不是啊？感觉很像当时刷洛谷的时候也是这样：当时也是刷上了橙之后逐渐就丧失了动力，最后就也没有多少实质性的水平提升。 当然，我对于前端开发的理解在这三周的反复摸索中确实有了和之前不一样的感觉：在临走的最后一天，我发现了主题上的一些纰漏，也能有条不紊的分析错误并且解决，release 了寒假最后一个稳定版本，我还是觉得很可以的。虽然只是小东西，但是我真的能做点什么想做的东西了。 特别的 不得不提的就是这个寒假的运动量：完成了两轮敬亭山后山五峰楼梯，这当然是好的；最后一次差点因为父亲加班没有时间就告吹了，但是还是想了点办法进行了补救措施，于是也就爬了；爬山是真的可以放松心情：即使是现在，大半夜的，回想起爬山的时候的阳光和风，以及从高处向下看的景色，心情依然会变得舒畅起来——这大概就是运动对于心情的调节作用吧== 回想起这个暑假运动的契机：虽然起因是 tmc 的高中同学在大学被人捅了，但是华科拿刀捅我的人大概没有——就算有，以我的运动量也大概不能躲过；但是在考研期间，简单的学习，放轻松的运动，也许正是我现在需要的：如果可能的话，真想在学校也想保持这样的运动量啊（ 这个寒假还和高中同学——其实也只有五个人一起出去玩了两次：年前一次，年后一次；唱歌——还是那家经典的小 KTV，还是一样的没有什么日文歌：倒是经典的几首歌我因为不熟悉而唱不了，有一点遗憾；之后的那一次是去一位同学家玩各种游戏机——这好像还真是我第一次见这么多品类的游戏机出现在同一个屋里：不过人家是靠奖学金买的，倒也无可厚非——大概这就是所谓的劳逸结合吧？ 然后就是七海 Galgame 使用了我新买的萌萌域名和主题重建了：尽管现在我玩各种黄油也是会自己做一些记录，也有朋友和我交谈，但是还是觉得应该有一个这样的站点——去记录一些成文的东西；唯一的希望就是在接下来日渐紧张的生活中，自己还是可以抽出一些时间去玩一些游戏，写一些东西——不要让这个网站再次荒废就行了。 ……时间已经不早了，但是还有很多的东西没有说——关于读书的一些体会，又或者思想上的一些变化；生活中总是有很多精妙的篇章，只恨自己不能将它们的美好悉数定格在字里行间—— 23:59——已经快要到明天了——想要说的话已经说的差不多了；虽然万般不想开学，但是还是得向前看才是。该睡个好觉了；新的学期，将之前学期的一些历史遗留问题处理一下，然后就静下心来比赛——尽力做到最后就行，当是体验生活了；静下心来考研——高三的生活虽然并不多彩，但是也开拓了新的可能性；静下心来读故事——观众只是观客，只求心中美好留存； 新学期，新阶段，可得好好的加油了——"},{"title":"4 月的简单总结","date":"2021-05-03T19:00:00.000Z","updated":"2021-05-04T19:03:00.000Z","comments":true,"path":"memo/2021/A-simple-summary-of-April-2021.html","permalink":"https://shiraha.cn/memo/2021/A-simple-summary-of-April-2021.html","excerpt":"","text":"When you saw only one set of footprints, it was then that I carried you. ——Footprints in the Sand 虽然但是，四月已经过去了；对于大多数的不像我这样的考研同党而言，这是不容虚度的一个月，当然，对于我更是如此。然而，就像截止于这篇文章写完之前也没有写完的三月总结一样，四月度过的也相当的懒散…… 但是本着就算懒散也要留下可考的记录的想法，最后还是决定去写这样一篇文章聊以慰籍： 初春：ICPC 昆明 其实我的队伍并没有参加昆明站；毕竟只剩下最后一次参赛机会，无论如何还是想参加一次线下的比赛的，但是昆明站变成了线上比赛，属实也有点扰乱大家原本的安排。既因为参加这次比赛的有关系不错的朋友，也因为想以此作为进入状态的”激活“因子，我作为志愿者参加了这次线上比赛的流程—— 虽说是比赛但是还是一如既往地在训练室进行，所以第一天晚上的热身赛和往常并没有什么不同；第二天的正式赛，由于主办方的经验不足，经过了混乱的赛前安排，最后才勉强地在比赛正式开始之前完成了赛前准备工作；发布题面之后（甚至习题册都没有封面），训练室的打印机出现了故障使得打印的题集缺页，着实让我们手忙脚乱了好一会；还好另一个志愿者及时去了打印店，打印了全部的题面，才回避了参赛队伍没有题面的尴尬情景； 虽然每一支队伍都拼尽了全力，但是最后的结果并不理想——因为一些各种各样的问题，我的朋友没有拿金；尽管封榜之后它们连开三个题，尽管赛后五分钟他们就真的通过了一道题，尽管他们没过的题还包括一个非常难写的暴搜…… 但也无力回天。 之后有参赛队伍的队长向我倾诉，队员分散在华科的三个校区，训练非常困难、队友摸鱼、自己也被加权和各种各样的垃圾事搅得脱不开身…… 只能说在 ACM 放养的学校中，大家都是背负着沉重的十字架而前行的；我能说出口的也只是一些无力的安慰罢了。 欢快的 OIers 某天晚上，我因为一些意外的原因和 wjh、zcysky 以及一些现在在武汉就读的 OIers 一起去纯 k 唱歌。其中甚至还包含了一些常年潜伏在风蓝 Galgame 交流群的来自武汉各所高校的朋友们；OIer 对于我这种半路转行的计算机学生，特别是还参加了相关竞赛的人来说一直都是神秘而又高端的存在，但是实际深入交流就会发现他们并不难以交流（无冒犯），也和我们一样是充满了热情的，对自己的喜好可以疯狂的大学生不过本来就是大学生嘛。 一直认为是高冷男神的 KS 实际上也是二次元歌曲的爱好者，甚至我们的品味也十分类似；一直只闻其名的 mgm 实际上和我一样，也为备赛而烦恼着…… 我似乎产生了回到了高中，和这样的那样的各色各样的小伙伴们一起为梦想而奋斗，一起笑而一起疯的错觉—— 真的是一段美好的回忆。 回到寝室后打开手机，竟然还是有两位数的未读消息——嗯，还是有很多温柔的大家在关心我的，要继续奋斗了！ 考研相关 三月进攻势头非常凶猛的三位室友已经有一位确定找工作了—— 我甚至还以为是愚人节玩笑，但是也非常的合理：不是像我这样混到大三还不知道到底要做什么的人，哪里还会现在考研呢（sigh）更不用说现在因为备赛几乎考研复习都没什么进展；也许就像队友说的那样吧：你这样是肯定上不了岸的——最清楚知道这件事情的人是我自己。 一直阴翳面孔的一鸿学长近日才和我透露他的战况——北京大学软件学院录取：实在是有些恐怖。三月一直埋头不做声，让我一度不敢开口问这件事情，直到现在才知道那是人家的低调；不过这也算是情理之中的事情了，如果像他那样的努力都不能抵达 Happy Ending，我想我以后都不会再相信努力能改变命运了；当然，可喜可贺，可喜可贺。 吸取了三月考研没有一点进度的教训，我和一些朋友也进行了努力尝试：比如约自习啊等等，但是效果一直不理想不过实际上也没有几次就是了；除了两年半以来的懒散生活使得难以集中注意力之外，本就孱弱不堪的数学基础则让我的考研复习举步维艰。虽说现在可以托辞比赛之后再专心备战考研，但是我真的能做到吗？ 备赛&amp;麻烦事 除了周周练之外，我个人的训练就主要集中在 codeforces 上；这个月 codeforces 题解更新的还算是比较勤快的但是相应地，周周练的套题的补题情况则不容乐观，考虑其背后的原因，可能是 cf 一次可以补完一整套，比较完整，带来的成就感更大；而任何一个区域赛的套题，都一定是我的能力难以顾及全部的。当然，这不好：努力不是为了取悦自己。 这之外，赛站分配也出了一些糟心的事情；我实在不忍心看到我的朋友因为这种事情而泪流满面的样子，也不想因为一些不该有的矛盾而和队内的其他成员反目成仇。但是，为了守护自己的参赛资格，我采用了最糟糕的做法——成为自己最讨厌的样子，居高临下地对别人说出”你不配“…… 但是事实上完全没有必要，冲动只会使人变得盲目和极端。 You should destroy them, not join them! 于是，像是清算又像是定罪，我在绝对不可能掉分的场上掉分了——真是可喜可贺，不配的从来都只是我自己罢了。 娱乐活动 当然，要说过得比较摸鱼，很大一部分的原因就是因为各种娱乐活动了。 来自风平浪静的明天 一部比较有年代的动漫；我第一次了解它还是在高中的时候——但是那个时候我因为承受不了女主喜欢上了男主之外的男主而一直都没有看下去；直到后来 bilibili 买回了它的版权，我才回想起来还有这样一部番没有看过；于是作为每周打完 CF 的休闲，我就这样慢慢地把它看完了。这大概是一部描述了关于孩子们对恋爱认识的成长的动漫吧——事实上除了主人公们，观众的我在不同的年龄段看它的感受也不尽相同：从最开始觉得”贵圈真乱“到对于女主角们表示理解，我或许也发生了一些变化吧。 简单地说，这是一部画风干净，剧情还可以的动漫；如果没有看过还是值得一看的。 吹泡泡中毒助手 在武汉大学 zz 同学的帮助下，修好了 vnr 之后玩的一部作品；是なかひろ老师去年发布的作品，作品风格上也继承了他一贯的特色——如童话传说故事一般温柔的，不包含一点恶意的世界。详评传送门&gt;&gt; 不善言辞的我一直难以描绘出这样的故事对于我的吸引之处，只能引用本文开头的那句诗来糊弄过去了。 练歌 &amp; 唱歌 因为决定了参加下个月初风蓝动漫社的表演，我和几位朋友决定唱一首歌，但是最后去纯 k 练歌的只有我和 Wegifan；确实就如同我讨厌的各种团队合作作业一样，不成熟的团队合作就会变成某些人的单方面付出——而获益者不仅不会自以为耻，反而会洋洋自得地夸耀自己的智慧，并且对努力付出的分子施以冷嘲热讽：你们这些老好人就是一辈子的劳碌命；只能说十分滑稽而荒诞了。 但是这件事最后的结果并不坏；因为设备的原因（或者是我的认知的原因？），工作人员为我们免费升级了包房，还连接了自己的设备：这意味着我可以放它曲库里没有的歌了；而一首歌本就没啥要特殊排练的，所以就变成了我在 KTV 连续唱四个小时——还都是我的收藏中的，曲库里面没有的歌，实在是非常尽兴——付出也不全都是坏事啊。 最后 没什么好说的了，就用想要对自己说的几句话作为结尾吧： 逃避从来不是解决问题的办法；既然决定了要做的事情，就要面对它，想办法创造条件解决它 遇到麻烦的时候要更加的理智、冷静；不要再因为不必要的事情而徒增自己的烦恼，这样毫无意义 始终明白自己要做的事情；要极力避免被周围的环境带偏了生活的节奏 展望未来的五月，希望可以在沈阳站取得一个还可以的成绩吧；作为考研人，也应当要少说废话多做事了"},{"title":"","date":"2022-03-11T08:12:45.453Z","updated":"2022-03-11T08:12:45.453Z","comments":true,"path":"css/bak/cmessage.css","permalink":"https://shiraha.cn/css/bak/cmessage.css","excerpt":"","text":".animated { animation-duration:1s; animation-fill-mode:none } .animated.infinite { animation-iteration-count:infinite } .animated.hinge { animation-duration:2s } .animated.bounceIn,.animated.bounceOut,.animated.flipOutX,.animated.flipOutY { animation-duration:.75s } .slideInDown { animation-name:slideInDown } .slideInLeft { animation-name:slideInLeft } .slideInRight { animation-name:slideInRight } .slideInUp { animation-name:slideInUp } .slideOutDown { animation-name:slideOutDown } .slideOutLeft { animation-name:slideOutLeft } .slideOutRight { animation-name:slideOutRight } .slideOutUp { animation-name:slideOutUp } .c-message { top:16px; z-index:2000; width:300px; padding:14px 26px 14px 13px; box-sizing:border-box; position:fixed; right:16px; background-color:#fff; transition:opacity .3s,transform .3s,right .3s,top .4s; overflow:hidden; box-shadow:0 2px 12px 0 rgba(0,0,0,.1); border-radius:8px; border:1px solid #ebeef5 } .c-message a { border-bottom:1px solid rgba(131,145,165,.8); color:inherit; text-decoration:none; word-break:break-all } .c-message a:hover { border-bottom:1px solid #5c6775 } .c-message.messageFadeInDown { animation-duration:.6s; animation-fill-mode:both; animation-name:messageFadeInDown } .c-message.messageFadeOutUp { animation-duration:.6s; animation-fill-mode:both; animation-name:messageFadeOutUp } .c-message__title { font-weight:400; font-size:15px; color:#1f2d3d; margin:0 } .c-message--icon { position:absolute; color:#fff; height:25px; width:25px; font-size:25px } .el-notification__content { font-size:13px; line-height:21px; margin:10px 0 0; color:#8391a5; text-align:justify } .el-notification__group { margin-left:35px } .c-message--close { position:absolute; right:10px; color:#999; text-decoration:none; cursor:pointer; font-size:25px; top:0; line-height:34px; display:block; height:20px; font-weight:100 } .c-message--close:hover { color:#666 } .c-message--success { background:url(data:image/svg+xml; base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTE2NDE5MDE4MjQ0IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjUgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjE3OTAiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjQuMDIzNDM3NSIgaGVpZ2h0PSIyNCI+PGRlZnM+PHN0eWxlIHR5cGU9InRleHQvY3NzIj48L3N0eWxlPjwvZGVmcz48cGF0aCBkPSJNODEwLjAxNTg1Nzc4IDMzMy40MzYwMTc3OEw0ODAuMzkyNTMzMzMgNzI0LjkwNjY2NjY3Yy0xNC42NjkzNjg4OSAxNi41MDQ2MDQ0NS0zOS42ODIyNzU1NSAxOC42MzU2NjIyMi01Ni45MzQ0IDQuODA3MTExMTFMMjI0LjE5OTExMTExIDU0MS4wNTU0MzExMWMtMi4xNTM4MTMzMy0yLjA1MzY4ODg5LTMuOTE5NjQ0NDUtNC4zMjY5Njg4OS01LjQ2NzAyMjIyLTYuNzA0OTI0NDQtNC4xMTUzNDIyMi01Ljc1NjAxNzc4LTYuNjExNjI2NjctMTIuNzU1NjI2NjctNi42MTE2MjY2Ny0yMC4zOTM1Mjg4OSAwLTE5LjM5MDAwODg5IDE1LjcxMDQzNTU1LTM1LjExNjM3MzMzIDM1LjEyMzItMzUuMTE2MzczMzMgNi4wOTczNTExMSAwIDExLjc1MjEwNjY3IDEuNjg3MzI0NDUgMTYuNzQ1ODEzMzMgNC40MTc5OTExIDAuNDgyNDE3NzggMC4yNzE5Mjg4OSAxLjAzNDI0IDAuNDc1NTkxMTEgMS40ODU5Mzc3OCAwLjc1NDM0NjY3bDAuNzIzNjI2NjcgMC40NTA1NmMwLjM1NzI2MjIyIDAuMjMzMjQ0NDUgMC43MzE1OTExMSAwLjQ3NTU5MTExIDEuMDk3OTU1NTUgMC43MjQ3NjQ0NWwxNzUuNjM3NjE3NzggMTE0LjMyNjE4NjY2YzIuMzE3NjUzMzMgMS41MjQ2MjIyMiA1LjM1ODkzMzMzIDEuMjEyODcxMTEgNy4zMjUwMTMzNC0wLjcxNTY2MjIybDMxMy41NzA0MTc3OC0zMDguMTQyMDhjMTIuMjQyNDg4ODktMTIuMDI0MDM1NTUgMzEuODU3Nzc3NzgtMTIuMDMyIDQ0LjExMjc4MjIyLTAuMDMwNzJDODE5LjczODE2ODg5IDMwMi4xNTI4MTc3OCA4MjAuNjQwNDI2NjcgMzIwLjgyMDMzNzc4IDgxMC4wMTU4NTc3OCAzMzMuNDM2MDE3NzhNNTE0LjIxMDcwMjIyLTIuMTI5OTJjLTI4MS41MDg5Nzc3OCAwLTUwOS43MjQ0NDQ0NSAyMjguMjE1NDY2NjctNTA5LjcyNDQ0NDQ0IDUwOS43MjQ0NDQ0NXMyMjguMjE1NDY2NjcgNTA5LjcyNDQ0NDQ1IDUwOS43MjQ0NDQ0NCA1MDkuNzI0NDQ0NDRjMjgxLjUyNDkwNjY3IDAgNTA5LjcyNDQ0NDQ1LTIyOC4yMTU0NjY2NyA1MDkuNzI0NDQ0NDUtNTA5LjcyNDQ0NDQ0Uzc5NS43MzU2MDg4OS0yLjEyOTkyIDUxNC4yMTA3MDIyMi0yLjEyOTkyeiIgZmlsbD0iIzY3YzIzYSIgcC1pZD0iMTc5MSI+PC9wYXRoPjwvc3ZnPg==) 0 50% no-repeat } .c-message--error { background:url(data:image/svg+xml; base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTE2NDE3MjY0NzM4IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjQ0NzMiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTk4My44IDMxMi43Qzk1OCAyNTEuNyA5MjEgMTk3IDg3NCAxNTBjLTQ3LTQ3LTEwMS43LTg0LTE2Mi43LTEwOS43QzY0OC4yIDEzLjUgNTgxLjEgMCA1MTIgMFMzNzUuOCAxMy41IDMxMi43IDQwLjNDMjUxLjcgNjYgMTk3IDEwMyAxNTAgMTUwYy00NyA0Ny04NCAxMDEuNy0xMDkuNyAxNjIuN0MxMy41IDM3NS44IDAgNDQyLjkgMCA1MTJzMTMuNSAxMzYuMiA0MC4zIDE5OS4zQzY2IDc3Mi4zIDEwMyA4MjcgMTUwIDg3NGM0NyA0NyAxMDEuOCA4My45IDE2Mi43IDEwOS43IDYzLjEgMjYuNyAxMzAuMiA0MC4zIDE5OS4zIDQwLjNzMTM2LjItMTMuNSAxOTkuMy00MC4zQzc3Mi4zIDk1OCA4MjcgOTIxIDg3NCA4NzRjNDctNDcgODMuOS0xMDEuOCAxMDkuNy0xNjIuNyAyNi43LTYzLjEgNDAuMy0xMzAuMiA0MC4zLTE5OS4zcy0xMy41LTEzNi4yLTQwLjItMTk5LjN6TTY2NC43IDYxMy44YzE0LjEgMTQuMSAxNC4xIDM2LjkgMCA1MC45LTcgNy0xNi4yIDEwLjUtMjUuNSAxMC41cy0xOC40LTMuNS0yNS41LTEwLjVMNTEyIDU2Mi45IDQxMC4yIDY2NC43Yy03IDctMTYuMiAxMC41LTI1LjUgMTAuNXMtMTguNC0zLjUtMjUuNS0xMC41Yy0xNC4xLTE0LjEtMTQuMS0zNi45IDAtNTAuOUw0NjEuMSA1MTIgMzU5LjMgNDEwLjJjLTE0LjEtMTQuMS0xNC4xLTM2LjkgMC01MC45IDE0LjEtMTQuMSAzNi45LTE0LjEgNTAuOSAwTDUxMiA0NjEuMWwxMDEuOC0xMDEuOGMxNC4xLTE0LjEgMzYuOS0xNC4xIDUwLjkgMCAxNC4xIDE0LjEgMTQuMSAzNi45IDAgNTAuOUw1NjIuOSA1MTJsMTAxLjggMTAxLjh6IiBwLWlkPSI0NDc0IiBmaWxsPSIjZjY2YzZiIiBkYXRhLXNwbS1hbmNob3ItaWQ9ImEzMTN4Ljc3ODEwNjkuMC5pMiIgY2xhc3M9IiI+PC9wYXRoPjwvc3ZnPg==) 0 50% no-repeat } .c-message--info { background:url(data:image/svg+xml; base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTE2NDE5MTk2ODQ3IiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjExMzciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjUiIGhlaWdodD0iMjUiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxMiA3LjEzMDA3NDA4Yy0yNzguODQzNTQzNyAwLTUwNC44Njk5MjU5MiAyMjYuMDI2MzgyMjItNTA0Ljg2OTkyNTkyIDUwNC44Njk5MjU5MnMyMjYuMDI2MzgyMjIgNTA0Ljg2OTkyNTkyIDUwNC44Njk5MjU5MiA1MDQuODY5OTI1OTIgNTA0Ljg2OTkyNTkyLTIyNi4wMjYzODIyMiA1MDQuODY5OTI1OTItNTA0Ljg2OTkyNTkyLTIyNi4wMjYzODIyMi01MDQuODY5OTI1OTItNTA0Ljg2OTkyNTkyLTUwNC44Njk5MjU5MnpNNTkxLjE4NjkwNjA4IDY5Ny43NTMyOTY1OWMtMzguMDk4MjYxMzMgNTcuMjA1NjQ2MjItNzYuODU2NzM3MTggMTAxLjI4NDY3NDM3LTE0Mi4wNjI2Mjk5MyAxMDEuMjg0Njc0MzgtNDQuNTA2MjI1NzgtNy4yNjIzNTk3LTYyLjc5ODA1MTU1LTM5LjE0NjgzNzMzLTUzLjE2NjY4NjgyLTcxLjY1MjY5MzM0bDgzLjg4NjA4LTI3Ny44MzM4MDM4NWMyLjA1ODMxNTg1LTYuNzk2MzI1OTItMS4zNTkyNjUxOC0xNC4wNTg2ODU2My03LjU3MzA0ODg4LTE2LjI3MjM0NjA4LTYuMTc0OTQ3NTUtMi4xNzQ4MjQzLTE4LjI5MTgyNTc4IDUuODY0MjU4MzctMjguNzc3NTg1NzggMTcuMzU5NzU4MjJsLTUwLjcyMDAwOTQ5IDYxLjAxMTU4ODc1Yy0xLjM1OTI2NTE4LTEwLjI1Mjc0MzExLTAuMTU1MzQ0NTktMjcuMTg1MzAzNy0wLjE1NTM0NDU5LTM0LjAyMDQ2NTc4IDM4LjA5ODI2MTMzLTU3LjIwNTY0NjIyIDEwMC43MDIxMzIxNS0xMDIuMzMzMjUwMzcgMTQzLjE1MDA0MjA4LTEwMi4zMzMyNTAzNyA0MC4zNTA3NTc5MiA0LjExNjYzMTcgNTkuNDU4MTQyODIgMzYuMzg5NDcwODIgNTIuNDI4OCA3MS44NDY4NzQwN2wtODQuNDY4NjIyMjIgMjc5LjE5MzA2OTA0Yy0xLjEyNjI0ODMgNi4yOTE0NTYgMi4yMTM2NjA0NSAxMi42OTk0MjA0NSA3LjkyMjU3NDIyIDE0LjcxODkwMDE1IDYuMjEzNzgzNyAyLjE3NDgyNDMgMTkuMjYyNzI5NDgtNS44NjQyNTgzNyAyOS43ODczMjU2My0xNy4zNTk3NTgyM2w1MC42ODExNzMzMy02MC45NzI3NTI1OGMxLjM1OTI2NTE4IDEwLjI1Mjc0MzExLTAuOTMyMDY3NTUgMjguMTk1MDQzNTUtMC45MzIwNjc1NSAzNS4wMzAyMDU2MnpNNTc5Ljg4NTU4Njk3IDMzNC44NjgzMjgzYy0zMi4wNzg2NTgzNyAwLTU4LjA5ODg3NzYzLTIzLjM3OTM2MTE4LTU4LjA5ODg3NzY0LTU3Ljc4ODE4ODQ1czI2LjAyMDIxOTI1LTU3Ljc0OTM1MjMgNTguMDk4ODc3NjQtNTcuNzQ5MzUyMyA1OC4wOTg4Nzc2MyAyMy4zNzkzNjExOCA1OC4wOTg4Nzc2MiA1Ny43NDkzNTIzYzAgMzQuNDQ3NjYzNDEtMjYuMDIwMjE5MjUgNTcuNzg4MTg4NDUtNTguMDk4ODc3NjIgNTcuNzg4MTg4NDV6IiBmaWxsPSIjMjE5NmYzIiBwLWlkPSIxMTM4Ij48L3BhdGg+PC9zdmc+) 0 50% no-repeat } .c-message--warning { background:url(data:image/svg+xml; base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNTE2NDE4MzA1NDMxIiBjbGFzcz0iaWNvbiIgc3R5bGU9IiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjcxOTciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiPjxkZWZzPjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+PC9zdHlsZT48L2RlZnM+PHBhdGggZD0iTTUxMiAxMDI0QzIyOS4yMzIgMTAyNCAwIDc5NC43NjggMCA1MTIgMCAyMjkuMjMyIDIyOS4yMzIgMCA1MTIgMGMyODIuNzY4IDAgNTEyIDIyOS4yMzIgNTEyIDUxMkMxMDI0IDc5NC43NjggNzk0Ljc2OCAxMDI0IDUxMiAxMDI0ek01NjAgMjQwYzAtMjYuNTEyLTIxLjQ4OC00OC00OC00OHMtNDggMjEuNDg4LTQ4IDQ4bDAgMzUyYzAgMjYuNTEyIDIxLjQ4OCA0OCA0OCA0OHM0OC0yMS40ODggNDgtNDhMNTYwIDI0MHpNNTEyIDczNmMtMjYuNTEyIDAtNDggMjEuNDg4LTQ4IDQ4czIxLjQ4OCA0OCA0OCA0OCA0OC0yMS40ODggNDgtNDhTNTM4LjUxMiA3MzYgNTEyIDczNnoiIHAtaWQ9IjcxOTgiIGZpbGw9IiNlNmEyM2MiPjwvcGF0aD48L3N2Zz4=) 0 50% no-repeat } @keyframes slideInDown { 0% { transform:translate3d(0,-100%,0); visibility:visible } 100% { transform:translate3d(0,0,0) } } @keyframes slideInLeft { 0% { transform:translate3d(-100%,0,0); visibility:visible } 100% { transform:translate3d(0,0,0) } } @keyframes slideInRight { 0% { transform:translate3d(100%,0,0); visibility:visible } 100% { transform:translate3d(0,0,0) } } @keyframes slideInUp { 0% { transform:translate3d(0,100%,0); visibility:visible } 100% { transform:translate3d(0,0,0) } } @keyframes slideOutDown { 0% { transform:translate3d(0,0,0) } 100% { visibility:hidden; transform:translate3d(0,100%,0) } } @keyframes slideOutLeft { 0% { transform:translate3d(0,0,0) } 100% { visibility:hidden; transform:translate3d(-100%,0,0) } } @keyframes slideOutRight { 0% { transform:translate3d(0,0,0) } 100% { visibility:hidden; transform:translate3d(120%,0,0) } } @keyframes slideOutUp { 0% { transform:translate3d(0,0,0) } 100% { visibility:hidden; transform:translate3d(0,-100%,0) } } @keyframes messageFadeInDown { 0% { transform:translate3d(0,-100%,0) } 100% { transform:none } } @keyframes messageFadeOutUp { 0% { opacity:1 } 100% { opacity:0; transform:translateY(-100%) } }"},{"title":"密码生成器","date":"2021-09-09T16:41:00.000Z","updated":"2021-09-13T18:10:00.000Z","comments":true,"path":"toys/spa/passwd-gen.html","permalink":"https://shiraha.cn/toys/spa/passwd-gen.html","excerpt":"","text":"点击复制 已复制 点击生成 生成密码的长度 包含大写 包含小写 包括数字 包括符号 生成密码 console.clear(); const notPasswd = [\"CLICK GENERATE\", \"点击生成\", \"请至少选择一类字符！\"]; const isPasswd = (passwd) => passwd && !notPasswd.includes(passwd); // const pageroot = document.getElementById(\"passwd-gen\"); // 选择相关元素 const slider = document.querySelector(\".range__slider\"); const sliderValue = document.querySelector(\".length__title\"); // 为滑条元素绑定时间并初始化状态 slider.querySelector(\"input\").addEventListener(\"input\", event => { // sliderValue.setAttribute(\"data-length\", event.target.value); sliderValue.innerText = event.target.value; applyFill(event.target); }); applyFill(slider.querySelector(\"input\")); sliderValue.innerText = sliderValue.getAttribute(\"data-length\"); // 滑条元素的属性更新函数 function applyFill(slider) { const percentage = (100 * (slider.value - slider.min)) / (slider.max - slider.min); const bg = `linear-gradient(90deg, var(--slider-filled) ${percentage}%, var(--slider-unfill) ${percentage + 0.1}%)`; slider.style.background = bg; sliderValue.setAttribute(\"data-length\", slider.value); } // 显示生成结果的文本框 const resultEl = document.getElementById(\"result\"); // 用来设置生成长度的滑动条 const lengthEl = document.getElementById(\"slider\"); // 生成选项的复选框 const uppercaseEl = document.getElementById(\"passwd-gen-uppercase\"); const lowercaseEl = document.getElementById(\"passwd-gen-lowercase\"); const numberEl = document.getElementById(\"passwd-gen-number\"); const symbolEl = document.getElementById(\"passwd-gen-symbol\"); // 其他元素 const generateBtn = document.getElementById(\"generate\"); const copyBtn = resultEl; const copyInfo = document.querySelector(\".result__info.right\"); const copiedInfo = document.querySelector(\".result__info.left\"); // 元素工具 const hideInfo = el => { el.style.transform = \"translateY(200%)\"; el.style.opacity = \"0\"; } const showInfo = el => { el.style.transform = \"translateY(0%)\"; el.style.opacity = \"0.75\"; } // 将生成的密码复制到剪贴板 copyBtn.addEventListener(\"click\", () => { const textarea = document.createElement(\"textarea\"); const password = resultEl.innerText; if (!isPasswd(password)) { callGenerator(); return; } textarea.value = password; document.body.appendChild(textarea); textarea.select(); document.execCommand(\"copy\"); textarea.remove(); hideInfo(copyInfo); showInfo(copiedInfo); }); // 点击生成密码按钮逻辑 const callGenerator = () => { const length = +lengthEl.value; const hasLower = lowercaseEl.checked; const hasUpper = uppercaseEl.checked; const hasNumber = numberEl.checked; const hasSymbol = symbolEl.checked; resultEl.innerText = generatePassword(length, hasLower, hasUpper, hasNumber, hasSymbol); if (isPasswd(resultEl.innerText)) showInfo(copyInfo); else hideInfo(copyInfo); hideInfo(copiedInfo); console.log(resultEl.innerText) }; generateBtn.addEventListener(\"click\", callGenerator); // 随机密码生成函数 function generatePassword(length, lower, upper, number, symbol) { let generatedPassword = \"\"; const typesCount = lower + upper + number + symbol; const typesArr = [{ lower }, { upper }, { number }, { symbol }].filter(item => Object.values(item)[0]); if (typesCount === 0) return notPasswd[2]; for (let i = 0; i < length; i++) { typesArr.forEach(type => { const funcName = Object.keys(type)[0]; generatedPassword += randomFunc[funcName](); }); } return generatedPassword.slice(0, length); } // 生成字符工具函数 const randomFunc = { lower: getRandomLower, upper: getRandomUpper, number: getRandomNumber, symbol: getRandomSymbol, }; function getRandomLower() { return String.fromCharCode(Math.floor(Math.random() * 26) + 97); } function getRandomUpper() { return String.fromCharCode(Math.floor(Math.random() * 26) + 65); } function getRandomNumber() { return String.fromCharCode(Math.floor(Math.random() * 10) + 48); } function getRandomSymbol() { const symbols = '~!@#$%^&*()_+{}\":?>"},{"title":"","date":"2022-03-11T08:12:45.453Z","updated":"2022-03-11T08:12:45.453Z","comments":true,"path":"css/dark.dev.css","permalink":"https://shiraha.cn/css/dark.dev.css","excerpt":"","text":":root { --dark-mode-bg: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABIgAAAcICAMAAABgqgq0AAADAFBMVEUAAADY2uXX2eTY2OPY2eXY2OXX2OTY2OjX2eXZ2uO8w/X////b2+3Y2eXW1O3pw8/Y2eTG0+rX2uTcyvz////Y2eTY2eTX2eTY2eP/yByUJjX/xxz/whr/xx7/yB3/xhz/xxz1xinR7A3T7w7V8Qz/xRvW6wrV8A/V7xDb/wD/xx7/yR3/qCbeyOjT7RLU7g3V8Q7T7xCxxf+wxP+xxv+xx/+wwv/V2ubT7hHV8Q7T7xDU8A/U8RCyxv+yxf+xxf+yx/+xw//z1Dv/jEX8riL/i0f/jUP/i0b/ikf/ikX/jEb/ikb/i0fY2eTV2ObX2eTX2eTX1+XX2uXKzu3Y2eTX1+H+qDL/yB3/xx3/xxz/xxv/yB3/xR/X2eT/yB7/xxz/yR712iv/xx7/wxn/qCzctf/dtv//xx7Ytv/dtf/ctv/ctf//yB3X2eT/xxz/xx3/xhz/xx3/yB7/yB3/yB7dtf//yB3ctf//yB7X2+Xctv/etP/ctf/dtf/X2eTctv/dtv/dtf/ctf/ctf/ctf/ctv/dtf/dtf/Z2ebX2eTX2eXV2ebZ2ePY2uTX2+XY2uXY2OPT3unR1ujW2ub/m8L/oK3/n6v/nqv/m63/n6z/oKv/n6vY2eTX2ea98fSt8Nyt8N2s7tms8N2t79zX2eSs8d2s8Nz/ikX/i0b/jEb/ikX/jEf/jEX/iUb/i0b/i0b/i0b/i0X/i0b/i0b/jkf/e3v/i0b/k3L/jEX/jESyx/+yxv+uw/+xx/+xxf+u8Nyu8d6s8Nyt8Nus8N2s8Nys8Nys8d2t8N2s8dys8Nyq5t2s8dys8Nys8Nys8dyn8t+s8N3X2eTW2OTX2uSxx/+xxv+yyP+yxv/h+T3i+T7i+j/h9z/i+T7i+D7i+T7j+j7i/D/j+T7i+T7j+T7j+ELh+T3i+T7h+D7i+T/h+j/j+j7k+z7i+D7g+D//n6v/n6v/n6v/n6v/n63/n6v/n6z/n6v/oKz/oKr/n6v/oKv/oa3/nav/n6z/nqnF0PC3yvsH8rZWAAABAHRSTlMAhvsum07hIX4jAwIOKhQHbRG/BQFAooKcLQFtHYA7SEAFJjYoJRlncwN3PgQJHTtIQCVASTsdHS5tgHc+PneAbS4GPwJ3JYBIOx1tLuPGaPkmlAvQGQdzcE8SXhjfRGQhDzIUDCg2Zxlpc2ZUdzZpG3JLYigkWSspTBYecm/3X1kvTklUQmw8PHNXPTZTOGJbF7lEBSU2KBhoc2axMgUnNRloc3E5KyFSYVpzahhnMzhxb0QrAiwSKCo2KBhncyIVZWIecV1ZME5JCVNAbUQNPf99SmBVITIeKSAUbHNvMRtbZiQLRlI/cTtCN0tJX249WQ1EMFFrIVZLLHNxG/aJJC3F7wAAONRJREFUeAHs3AOSs2kUgNH721Z32vbYbnOM/S9lKioO2q/OCW59LIZPKnEduHHzVnfc7o3b/7Jw+nWnP+jKzwoU487de91xvzfu/8vCqded/qCrP+uDKAUAAAAAAA+j69Hj/v2/LJx63WkOSnDWvAGPnlSa77V8KMjTgvP96Q96Fv8OAAAAgPqrmXgGJai/mg3G8xeRK6D+ajZY9/JVJAUAAAAAgHw/WHgdQIbetJHvhwtvPRVBhh69bCPfDxeeBgAAAAAAmWol3/cGkKdW8v1gvPN8BBlqJt8PxkgAANdkdDQAkuqMjXUCIKXxiYnxKEaV1cz/WMPkxMRkFONhQ9WsN9oAUxMTU1GWZqpZb7wKqN/0xMR0NApmZufmZ4LkFiYmFqJNsLi0vLy8tBipsbK6uhLQpJml5a6lmUiNtbWANs0v981HaqyvR2k2Wsr3Iv4Vmlvum4s06Lz3/gcfzq7EwMOPPv7k0886pUT8zxvK9yL+FZr1jiitL778quvrb3pPRQ+//e77rh82oxyt5PvBAldhy3dEnoiSA9XMR7P0YGbe74h8WQ3Qs70dSQHs7O7uRJnk+1rA3v7+XhRKvq8EbO/vb0fBWsn3j6NicLC/fxApARzu7x9GSgBH+/tHkRJA5/i4E+Wrvpo92oiKwclJVKD6anb7xwAy9+SnmqtZb2xEQQAAAAAAqC/f90ZJgJ9/qS7f90ZJgF+fVpjvewMAAACAc1DN0gN+U81SA35/p5rlAwAAAAAA+T49QL5PD7gj36cHAAAAAIB8nwfgxR/yfWrA4z/l+8wAAADQ+WslEgBUs6Gt6bG/2bmD3bSVKA7j/6u7unfrFRCFZJEFok9RZd1FK3FsSI2JIYChoXbatH37BgaTtFJ2YYw0328z5wmskT7PsTgZCoB3H6lmzvuRbXVu5BuA/z5TzXZSc8bXAoBGXHdsLxMANGJitVs1AgByq7XkFQBkaZKeSZpa7UY7AKLZ3SySHyHn+17XtpKB1DFn3tYWgMWyKIrVQn4EnO/75ownWpvTl9Qe5j0BgYtWxdYyki9fwsz3g9j25pN72+lMNUk3T+f5tYIGzApnpqNCZgfjr+48v+yXtlMpaMBd4dzpqHBlz9Yj9z16sNo3hQz4zo3Ij6G9MDezshvbQaKQAdGy2FpF8iy4avZof4rthQcFDVisiqJYLuRbcNVsuLHXjRQ88B/Rj0jehffodVLF9ppzeQEAg+w+7SbVg/1tM5A3ADDpb8zprOtpnMsXABikpR1srvLWRZWkP9/JFwDIDrchd1y09SoA5PtPenut0vbW5iQ9AWjOrxPP9//ozQ1Lq7VsrxKA5vz/4bTz/b96c6nVyummiSWNADCy2vp57lwKABr4EGWqmnjvCgBd23uUbq12L28AIC9tJ86l4eks0Adwivn+SOp8H1/pydqceCoADTvJfH80N8l8XuVujOu91QCadpL53ouzuZnF/bYAoDG97LY1FYDf7NzRatpgFMDxA7sYRLttmNfIu2z4DAZzQi9DwSb9okbduvWdR0xi22VSktUvfvr/3RwOeH1A//gBF8CfJwtfAGA4Sayq8b0AvfnuVzMMK0m1lM2l4k0E6Gj8cHbV7LvAIV6kFSOleZ5qHPoCdPLl7KpZIHBIoo2FiCxTLa3EHgBYaiMUuU+1shRrAGCmjbVMYq3lYg0ABJnWCgm1EYk9ALDRmplstWGkM+CM8j1c4xmtmKUebKQz4IzyPZwzjnUvz7URTaUz4PZ88j3cMzZaMtqI5mIHAEx3eRznm9m40JdWU7EDAOZbraSF0Ua2XoglABBE+resuAvEGgAI9V+yuNjdj6Q3YNh8D8es9Kg4kdMZyZ4vuFDD5ns4ptAXUn3tTt6R31ygq4Bh8z0cs9Nnq62qZvps+1lODgDGmdbiJC+HifXZTE4PAJJMS1Ho7bSUJqkehHIiPx5+tsZheZQrA+Drxpj1zJNPqe7Ndv/9I9H09vHImWnGr2+t8Xr5eCNwmz9MNQsETiu0spO11rJAennjzJRG0h7tBS4bDVHNHn2ByxZaW4m37v/NzH/7zFwP2K9mcNzm5buMy30/C8UmADCvnkML7kL+52EbgEhrhQwDAPIj7zLaz/ftRW5+yxUAEGolXUgfx69Ir3zf+sCTwE228r0vuARe3rOUfXhqn5T3y/eHAVdZyve4EJNNphrPpKs3T8of9u6rq407DeDwu30XTircWLbStrqk954cbETb4sMxd7nz7X6F3KZ3uSAS94IZOukYPtt6VlipxE3iz4ye52ZA0vV7RvMbzSvf81bn8z2l0XO7Z7kALQCkr2abf6AF4P3WdOh8Nfv+a3cEBdX+agat6bAV1awMz5flnd+3uZodDOhVzbgxD97Vzmr2798FAAAA0KX5vvXPv8ajOwHj3xsIafJ9658Posjof/Bm8v14QNz2QWsSJMv3rX8Kjv4bz/dPRwuKfZvyPdz14UfXl+8/vj0AAAAA+X7Tfz6JLgH0f9KaAYny/eb/dAngV5sPhHT5vnUA6keOHqtHyfXK99sZHJ9sNBpTxyMVgPpUIzdZj0QAjjWajkUKqlnz8P5t0c3gaKPpaJRZ2yZGh6rZO6+NRxeDI2U/Ixpv78ToQDVzDRzqk43cVF01SzYxgONT+bXq45EOQP1Y0vuIAACQ71uHgwGYGInyfeu1twMo517pAuX73gDKyA0/AAAAroHf+AeA0rjt9beKVc1a/wBl6mWqWWJAb1GrGQAAAADy/ZufBlAObxY03+eHQwEU3aGC5/veSAuQ7wEAAACQ7/MDUIIhUex8/1ZACfjZvXyfFNAr3wMAALSFavZ0JAaoZp9FeoBqBhSWagYAAACcOHnq5ImAguf7/PB2UFCnz5w9e/bM6aAr3f1WafJ9fjgXFNOJM2dzZ04EXajn9bfKlO97g4I6ebbpZOAx1YnyPZw623Q+AJwRAa4RAahm3Cr5/q2gqE6cPH/hRGDLdAny/VsBBeV39/I9IN8DAADQtdWMHTsiKVDNqOzcWYmUQDVjV7W6K1IC1Yx7qtV7IiWAe6vVeyMlgPuq1fsiJYC/Vqt/DWg/+f4PwfXat2fP7oD2k+8PBtdt795IC+R79u2LFEC+p/LQw488+sDu2NDz2ONPPPlUJQC2zDPPPpd7/oXdcUXPiy+9nHvl1QAwiCgN1ez9SMxXM1DN3g9crKY4VDMGBiIpUM3Yf+DA/kgJYLBWG4yUAAZqtYFICWCoVhuKlEC+Z7hWG46UQL5npFYbiZRAvqcyOlqJpEC+Z2wsAAAAADyzGugA+f7pAApFvgfkewAAgBJSzdIDVLP0ANUMaBfVDAAAAC5OX5oZOBzJAPL9QJabnQugo+T7zQ1mTfP3R+7wwsDC4QDaT77f3Ey2YSyuWFzKsmx5MQD5fgvNZhtmImIha1oMgK0zmm1Y2hdzS1nT8kQAbJnp7Kq57/09GMAvU83ORduMZFddnMtaxgJot56SVbO3o31Wsg2fD2UtIwG03d2q2Wa+mMmaFpazq+b3B9B2/arZpiY2JtF0dtXSxQDYInNfLnw5MrFvKMstZxtmLwbA1jg8k+WWZhZXlrOW5ZWJANgaE/NZy3e3NS5MBHBN8v1n0RaL2U/MDy0uDH5VCaBjypLvn462mMk2MTs0EkCHlCbft8d8trmVSgCdId9/33T2ndnl7IeGA6DzxrKW6ZXsiktZzs9egQSnRPNfN392f2k6+85gQHnt2BHbBPtW8vkzM/bFF5ey/5ubz1q+CSitys6dlbgF8n1bTVy8ePh7z0P7Zm40u2ouoLR2Vau74lbI9+33xWzWtBIjy1nTpYDyuqdavSdSOSjf/6yvsw0zERvfzkbnAsrr3mr1Xvl+mxnKvncaNDEwny1PfxVQYvdVq/cF28tMtmE+Inf/FwGl9tdq9a/B9jKdddeFIdi3Z8/uuGmq2aHogMVsw0pAd9i7NxI6VPBq9mlHnwey/FVAd9i3L1IrcDXrkK/msyuWBwNKrfLQw488+sDu2NDz2ONPPPlUJZJQzX5qYmF6evFwQKk98+xzuedf2B1X9Lz40su5V14NAIMI8NWsQAAXq+X7FKDvsW9X+6J0BgYitYLm+wTg8tr6+vra5SiZ/QcO7I/EbpPvrw/0ra3n1vqiXAZrtcFoke9hW1tdb1qNchmo1QaiGIBv15u+jXIZqtWGohiAx0p6RjRcqw1HMQAnSnqNaKRWG4kbJd8fjPYB1awyOlqJ9IqW73sC0uzE6Vst5X1EY2MR6RUq30N5d+JgYmAnDkD6nTgAxdiJg2r22nhAeXfiMF6Eavb+bQFl3olDAarZ5mB3GXbioJphJw7Adn/MIIAHLwNWUSDffxLQJYOI/k9udmLkhw7m+18F+GrWXW5wYrQOncn30J0Xq7mRieG+H+zEAWjtxAEo604cVLMPArpyJw63fbBtqtm/xgO6cycO49uimoGdOKhm2IkDUKSdOABjYwEApcv3d0QOIGG+bwF4P1W+bwHol+8BAAAA2LJ8f9u78UsAOpzvrwNAR/P99QLoL1m+BwAAUM3+cFsA3IJbq2avvx0At2r8v2/fQjVrC4DOVjMAAAAAAKgfOXqsHukAHJ9sNBpTxyMVgPpUIzdZj0QAjjWajkUiAEcbTUcjEYAjqc+IAOqTjdxUPVIBOD6VX6s+HukA1I+1+z4i+h77drUv0gG4vLa+vr52OVIB6Ftbz631RSIAq+tNq5EIwLfrTd9GIgCPpT4jAjjhGlEAqhlA36r7iAAAAAAAAADYXv7H3r3stJVlYQBeY/eg1VImGA5gEirclHui3C9l4HCbM8k8s2SSQT2NDd6C1wASm2sI9Ugdx1BJl7olinS8VeL7HmLprH8d7X9gILICqA4OViMngKGiGIqcAIaLYjhyAhgpipHICWC0KEYDIKfxohgPgJxmpqYmAyCr6ekAyGtmJgByqN64eev22GScqty5e+/+g2r0DcDDR4+7njydjC8qz56/6Hr5KgAMIsBqBiCsBi6jej2yApidm5uNnADmy3I+cgKol2U9cgJYKMuFAMhpsSwXAyCnpbJcCoCcqsvL1QAu4sr61vaV4P9gZSWAi9jaSSl9+BgAuWy1U1d7PXoqjQDoq0or9XSia323nXbWrgRA/2ylM9sRsddOXfsB0D976cxaxMd26tkLgL5ppjMH0dhJp3YD+AG1savXasF5HbbTqaPYSGdaAVzcL9cnJiau/xLnxad0qtM4Tmc+BHBhtesTXddrwTlVOqmns5f+8DmAC7s20XMtOK+TD+mrzm460zoJ4MKuTvRcDf7qJPqQzrTWA7i4MV9Ef8HJ752dnd3PzZOj9L39kwB+wK8yovNbP0497aNOOtM+2A6gT1czDlvpz46PNg8D+GG1a/4jOp+19N8c7xx9+viPAOiH/fQ/7WwFQB8cpe+003/aDICf7/f0zf7xn4bR8T8D4Kc7Of62ie2mLzo76ZtmAPTtbcbWWmMjdbWb7fSHtQDog3997nQOmpXYbqevmhuZQyJAbP0pDtKp9mEA9M92OrUflYPUsxE5AF4k2o2Iva/3s7UA6KdO+r7I43BzY/Mw+gqglU4dBUAeu95lBHJbSz3t7QDIo7LrUgbk1vh8nNLOZgBkVNk+CQAAAAAAAAAAAAAAAAAAAACA3AYGAiCr6uBgNQByGiqKoQDIabgohgMgp5GiGAmAnEaLYjQAchovivEAyGlmamoyALKang6AvGZmAiCH6o2bt26PTcapyp279+4/qEbfADx89LjrydPJ+KLy7PmLrpevAsAgAqxmAJcxrAao1wMgq9m5udkAyGm+LOcDIKd6WdYDIKeFslwIgJwWy3IxAHJaKsulAMipurxcDYCsVlbi7wQAAAAAAACg0VxrNgIgn/VWSqm1HgC5NFqpq9UIgEyaqacZAJmspZ6NAPBFBMiILi/A1Qyg0dzYbEQ/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBt/O37WgDk8/rd6urqm9cBkEvtzWrXu1oAZPJ+tee3AMjk7WrP2wDIZHy1530AZPLru9WuN7UAyOX1m25W/ToA8qm9f/tbLS4jAAAAAAAAAAAAAAAAAAAAAAAAAND3Cej7hIGBAH2fZFUdHKwG6Pskp6GiGArQ90lOw0UxHKDvk5xGimIkQN8nOY0WxWiAvk9yGi+K8QB9n+Q0MzU1GQBZTU8HQF4zMwGQQ/XGzVu3xybjVOXO3Xv3H1SjbwAePnrc9eTpZHxRefb8RdfLVwFgEAFWM4DLGFYD1OsBkNXs3NxsAOQ0X5bzAZBTvSzrAZDTQlkuBEBOi2W5GAA5LZXlUgDkVF1ergZAViv/Zs8urhuJoiCAvmHmSWPWCmLIuFQqDsAMW1ks5WMnZPxm+mK6d/HqqBJQd9ef6BcAAAAAAIAve59OY7+4fRovSmun3c8YCoDFdxHx6uAwbserle0YBoCdn+mmuNO9DwAAAAAA6LePpe2IWC9uR4p0MzqA3qV1Pt2bPzK6+V8BMIDFPt2s7nMAAAAAMMEeHsXSze+WA6ArD49i6eZ3L38GQBceGsXS7aIDYLKVK9VKOQBGp1ZvNBr1WgCMSrneOFUvx4gAVBrnKjEzsNv3db5P8WInuka1ca4VMwO7fX/n+xR/P0cmPBHBzs++z/cp8I2oe4DVDKBcabXLMf0AAIB3GUt8uj11+RbXChFRaL44ZucOdtrYzgCOf11cVTWpiTWuuuYBsjFO7upKZnOXlW7d9g2MjK0ur67yBlVF1Zt2G/ICKCRLQuzzAF02HnidxvEArQgqkNgzY/9+C3+ekQ7s0NH8hxMfNT80Y50Bdy3xxecX3mvH//HHPz+/5Qf95uU/Yz0Bdy3xxeeX3nsUt3lyx9/ejyUAAAAA4HDJ1Wxpi45+0Yy7A1Sz5S26O0A1W9Yi6gwAAAAA4PHP9c33N+/940XUD/CHf9c+398YtQS6fe3z/fWoFQAAAAAAVlHdi1HColoAVlHdi1HGom8DKId872xrAPqNKBFA47tpSrNOlAXgVZ4+2QtQzYrBqu2mQitANbsaWbA67V4qfBegml2PdrBk/d1pmj3djohmutQNgNWZ9NLcrBVxXsYfIoDGNC1M+9FJlzoBsDKddClvX32ftQNgZZ6mK2eTVDgPkO9V/NU5S1d6k7SwG9dAvi9GP1iWSbrW7aW5fKvR2c1n+UUjQL4vBkvVTdem6aO8tdtLn8z6wdrKBvuDLKAasjz9j2k3XcmDdTU8GI1G42FARZzn6TaTYD1l49HcQRZQFa2L7ix9zkWwngajhYFq5vjY6mg8O+tO0017wXraHy3sq2b3u7c8nBe57KZmsJ5+vOeOSDXTzpasmaf/Ns09rN4A2cFobpwFleGfXgufvubPLjdI+ZNgXQ3H82fVw4Aq2JqlK7PF97yRdXbzvPt+K1jr94h+ygIq4Vm61injEBCAvXQl76fC+4B7+P1G5fvDH2J5HAPSazVTYZrF3cFfNyrff/My+Nr+1UuFi5h4kZEHaW9Wvn8RfHVn1+flt8rp9gAX8z1Rby8ittOlWawSwHbnovMq5mZl74gAzsrOZgCNmQ0RD7Ix+b4YS8Wrbkqp97QRcG8bke+LsWRsTyaNgPvbnHxfDAAAAABuOtqoanb4bVQP8MuNqmbf/DYqCGhtVDVrRlUBAAAAALAp+b64qCLg+Ybk++KikoBNyffFBQAAAAC3Us2A0qlmQKlUsyoBAAAAAODX8j1QtvbfH693vt+KL7Hz/ZvTnQBWQL6/xeuT4+Pjk9cBUJadk+O5k50AKMnp8cK7ACjJm+OFtwFQku+PF04DWKH22uX7w9+146H+5BkRlKX/+Oe1yffz8YNqBvW1Jvm+GA+zc/r2nf0QAAAAQN2rWTGAOvtLzatZMYBaa9W/mgEAAAAAUH/1z/fFAGrtqOb5vhiPAqixZs3zfTEaUV0AAABANtgfZAFQnuHBaDQaD6PaqH++F/G5XTYezR1kUWnUP98XF/AZg9HCIKqN+uf74gJu2h8t7AdASX60IwLKlh2M5sZZAJRlOJ4/qx4GK6Ga/Srg8+8R/ZRF5fFhParZ80cBlEw1exIAAAAAANTYYf3z/XwcBVBfL+qf7+fjbwHUW/3zfTEAAAAAeKj6V7Ni/Id9u0ZyIwjjKP6vcmRmzJyZLrGQmiHXMXwF4/WGvkGx5DOYpsfsjdQ921XvJ2jIBTOvGkC84q9mbgAQMaoZAAAAAAAA8JcHSZq90iDP8lvyC8CVR7Hn+5faqbQws7LSd3XzddF28gvAx9jz/XPtUme9Sl/l5c+FTwAiz/fntEuHrfXKiXTYDIupACCU2gYz9++Iv0QAAutsUD7Q3AYLAUAouf3Q7S/5RwRgDI0NFp0NlhN5ByDefH9eu5UX5jQrG6zkH4DXceZ7H+rCesXcnLUAhBBnvvdi0ljPlfyyEgAEdnpT2k/zXAAQ0iStNlXazUrrNWmedFl+VwAQRt2YU7jBjeU2F4AwYqtmO5Ys7b+KWt4BoJrdau0I7W0BCCKqaublnNn/pfINAFL7RePeflrINwDI7Kd1Y1+1K/tpJd8A4G5rg03Sj1W1tEEi7wCgc986baa5m6lurTcXgDBOvY0k3/uRtd9C/WJf06X1au2vv8/n+wIQyKko8v1VeXJYp/UDSdWvd6in1WJVC0BAEeT78/Jta04jABhHY04rABj5i6gQAIxjxqUZMLoLx7OanX1/WmHky9HPdQA4cSyrWTi3XDb7JADjGbOaXfx774xCS+blskn1hb37KGgAhgIA+hFAb9WCkCKGrYGRHVkIYp/Ye/W9WxQk+RMAAAAAgB/3Ten7zbN4AsC3pO9fBLD4+vQ9AAAAAAB3Ui41xZP41PT91kkAD7Q+xpgtnsPuF26KBtIc13qK57D6rPQ98FAdt2oA/JAybpUA+CHZiwj4aamPazMFr7XYOH9d1mx7GcBrtHkdq27xViyPXsiarQJ4pVTfW0fEg1HTd4dLdu3isI0oCADonHXdi2ghzMwcMdaYPkTbWsiuwWN4r4PPf6ATAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMClU7zeH4oAyHM8tW17OgZAluLU/nMqAiDJoT1zCIAk+/bMPgCSvPYjArL9kiMCVM0AojjoI0pGrxepAPqDQT8AMg3LchiZAKqyrCITQF2WdWQCaMqyCSAT98ryXmQCePr48aNIBfDkSeQCePo0MgD0n794+er2ozjXef3m7bv3/QC4MB8/ff7ny9dH8Vfn2/cf//wcBYCLCBCaAUhWAzfRZBIAqaaz2TQAMs0Xi3kAZJosFpMAyLRcLJYBkGm1WKwCINN6sVgHQKb+ZtMPgFTbrTkAAAAAAAAAgCsHAAAA+MO+XZvLrYVhFP7uNTOpAVNmxc7dgCM/B/OJzNiFafBXG4Y+XIh48LBmJJmdzT4w6xU3sER7N9thFMaXtF8AoJlYIUw15bWyLL8kAHAotpm+vkryE9szGModABhYSbF0LrGp6KtcAYDUKhpJbSuNBQD7EKKB/MhKAzkDAIGVZM3YanIGACZWkqU9qwRyBwCSOkS51WK5AwBpUIWob5XwktwDQIlkkZVGvhwBgO5k0ul+TpNZiEq93JMbAJAmVoj6+bgO0UYyuSNHAMAPrBJFZYjCeNLqNuUGAGT2E1llM8mbcgAAgt9DVAu6mj8A2PxHiGyQyikAPBENNkxmgX2Xae4AILZaf2Qms3FktUDuAOCvWa/TsWmIwo7VNuUKAMYRBe2mP5iFyPzM8RMRAGy1864nZVaGaOj1rRTLHQBIN6sQtXV2bFNhU+4AQNsKKn+VdQKzzbEvhwAgqUM01h6vu+XLKQCI6hDFAoB9MahDNNGRA+D67UcvruugG1UhGjR11ABYf7y0tNRY1wE3tIIsGuqoAXC9sVR4fP1QTPbQ+KuOHAAvlmbe6KBrjaKejiIAj5ZmHmmRnPjvnKRvx4v9z4efLu6/8zR/AG4vzbzQYjh3VntO/n++3v98+NOFp7kCcO/xUqFxXQvh4gUVTh2r9z8f/nhx94HmCsB6o/hWvS7gX3bZuavtNrYzgONfOBEckg6fYJnbQ2FmBjuXfYT0pozXZTTbKw9iWfMQfp+S1hSUkjxdivfsye9nEO3bT/Tfa8PzdfRb3/je0XhuAAAAoP36f6nzYzcqLOj2A6Ci1ybV+b3VFsy2ogqAyXW++oI8AAAAAFA9ilVfMAFA5ShWfcF/B9CqHsWqL5gAAAAAAADhfnvyfXkBMKb1panV+QkLxi/6AfAPx6dX5ycsGL94KQAAAACoUy5LUc3K/wB/i1gpqln5H6CMWEmqWfkfAAAAAADdPn2+V/FBt0+e71V80O0T5XvnWAMAAAAA0N3drle+33wYwAvm3s5OvfL93tkAXshwX5t8L+IDAAAAJLCZupo5wBrYm7qaOcAaUM0AAAAAAEjofrvO+f53ATTfwwedOuf7JwE030u7ap3vjwcAAAAAAM23ubvG+X500Q+g6fburHG+H118KZoO2FfjfF9ejAMAgN7764NepAOwMSyKYrgRTQEzj9oZVLPyokRvWIwMe9EQ8ObOTgbVrLwoMShKg2gU9DLVLCfrRWk9EgF4P/U7IoCnviMCVDOA6A0atY8INnfL94kBe+X7hAD5HgAAAIC2apYUsGd3dFSzxEC2V83SAcw2AAAAAPJ9asCr5WzL98kAndmOfJ8W8NhsAwAAACDfpwMceFTOtnyfDPD1sdmW7xMAzHZCAAAAqll6wJPxcc6zms0EkLGxcVbNkgHMNgAAAAD55/tuAPlpfX98nHPP97O9APJzb3ycs8/3LwWQlwZuzQEAAABAvgey0emPz3GT8j2Qi1d+Mj7Hjcr3QAZenJM1AHj77UgK4J13330nANUspfcOHnwvYDJHUjeqmr0ctXLo4MFDAZM5krpJ1awb9XL44MHD8SzAefTb68jBg0diS4De++uDXkwdnzp48FOxFcDGsCiK4UZMG1/8/Oc/F1sA9IbFyLAX08YXvhBbAQyK0iD7fF8/X/xijAH+6xyvF8Xv7xVFsZ59vq+Ld778la9+7djn4m9a73/w4Ucf29kI/f8xx+8XxZ/+dK4oBtnn+5o4cfLUyOkzn4u/ap09d37kwsUAu6L/6xw/HRZ//vPoOyL5PtkTEaCapf9oBvQG9hFl8GU1UO9q9ptW1NLly1ECqs92btXsd1FLV65evRJAVJ/tHKtZTV27fv1aANN7xqiOy9evX46UAG5cv34jUgK4ef36zUgJ4Nb167ei8UC+/1nU2Du3b9vHCD/b3W54vl+biTq7cydgRLdvdL7vRwZAt5fvMwcAc/MLi3ORDsDS8srKyupSpAIwt7oysjwX/wb5/kDAdlhcKS1GdfyiHN3m5nvYHgsrpYWojC/t7TQ838P2mP//3xHx6i75fhpgbnllZHUuUgFYWh19V70U6QDMLdpH9AzVLCPA5u5mVrOMAHt3NrCadSMnwD7VrFEAAAAA5PuZyAvQb1i+zxDwpWbl+wwBffl+WgAAAFSzXAGv7m43opq91o5cAb/d2WlCNetEvoDf7VLNMgcAAAAg3+cP2Mw93+cP2Jt7vs8fsE++BwAAACDTfJ8YIN/PRFqAfP8w0gPkewAAANJVs+QA1Sw1QDVLC1DNAAAAAJDvfxWJAfL940gMkO8B+V6+BwAA/sLeXWw3boZhHH/KrYYZA2V0mXl4V8o12Cd+tQ7bxxzv23XI35lcRsjMc0kd2ZIcnPiY4pGe38pX8MH7tyS32Mqvpi/jxBARLRfUU9kLOIj5nogGo6AaUhM4iPl+EIgorUw1DATzPREdUFGmFPM9EZ2QmrIso9fo8uTU/GUQ0TFWlaUEYD2bqRbW0Bs0pYuIvgAierYtZdHMgKYyK6xm+A/dmwqIITiJJu0SDkVEOXtGtGz9rNZZzS6ga5pfmkIwTIYDovsug4gO2lRNZRSUZRV99O/wV7PemBLLPIBIQAxREFGLls9tZytrsNafyqqyFdBHZ91SzSJi8QELAWmKgIgs1j0sly6llGE1o2xlUPe8Yonhki6mMIjoYLYvrBtLUCarWlZB3fMExRSHTyx+EJGplFG2albtlTqHHqCEmEKXFsUSAhGZ1tTRqmnm+57QQtIUiogtAaJjcSFKVeror++GPd970COndWkIh8XinwARmZar6oBcoVjJr11G3004Pd/bTofEEBKLfxI2InqiDtp5vIVBcEG+n0iGdT2c8J6Oy27RCbgC3bgBaodWbh2EqsqW2wR1b3JRmgLxkFiCsXm4A928desmqC3r5e3tbDFfX1WGjDKVS6AuefyyXzA+44Fb0O2RkdvoAF9IlFOW7TpcXc3eQNd8cpigHk8unIIL0OjIyCg6wFnR6qD/Vz2c1aw3onIkfQrOR2MjI2Og9q0oUzqrbBcwAENZzXokLrsEZK8ZOB6Nj4yMg9pWqipTel3ZNlnNupOUlqgxtw5Ky+I5OB29OzLyLtpGj5Vl7dROrxYiOh1s3cTC8lRIlxYvnI4++eijD9E2yilLHWllypTQHZoKisHv05JiCEwFxOaD49HHH6N9tKNM1V1z6xq6RRcSoVDMq+FsQBq8SVcNieiTT9A+KihTsfVqkPKyi/N9r8WlKYmYmIIeOBTd/PSzz79460OYtC+/+vqbb2/iOLSydyyUrpWLKxiMPx2c723zYopCizn9Zkbf//Cj4aefG0uR9suvvxl+v4Nj0OWyaihg4F5xcL63JXa/lzHS6Gc+7ENciEirZJSqPtEweH+74EuvoT2vQ/PM+GY8OIh4NaPltfQy+oP8YorjZBCH1URhl76Xke7dw7Ag8klTYB5uQvcfPLiPLpFL8/0l9JwWdmUpo4ePHj3Ec4KGKt/3x6VEUET3gtzl3qNH9/D8oKHJ932jnT0Ncpv/2bkLmwqCMACDPyGOu/RwbeBOVzSNP9dzmynhZO1L9ub6+iZoh67me7i9vr4NgDrdXV/fBUCdLu/vL4OUVLP9gCI9PAStctyAanZ44D0ANVezowBQzQAAAADqI98fB8Cfj5ry/WkADCS15Pvd4wAYke8BAAAAqiXfnwXAfFXl+/PtAFio/HwPsIR83wMAAIBqluI2RoAyqlkKAKVUs3QAkteCqhkAAAAA8n0BsQwgc75/TKIgAJsb7xnyvWEIKJ58DwAAAAAAAAAAAAAAAAAAAEB+XHyxYx+oCYVBFEaHDu4gT3+VgICF9IT0wlPHsv/9BANkCRkg5yziwnfPAqBUNxx2AVBp1NooACqNWxsHQKVJa5MAqDRtbRoAlWatzQKg0nyxmEcpgOUyagGsVlEBoLu4vLo+/42ywc3t3f1DF38G4PHp+eTl9WeKBm/vHyefXwFgiABp9h8BzmqAvg+AUuvNZh0AlbaZ2wCo1GdqM6DWLnMXAJX2mfsAqHTIPARApe547L7Zu2PkVmEgjONb8wqaXCM3yfEwhuUguRUQLExwxMwLgBReZl67ykz+v8q1i51Pu1ohvwamsW37QX4Y4OVFfg30urpXAgCJXHTXFLIaXO9s0xEAvOnhIZ9K//nLl2IIAO56eFvrkO6oRACSFCJfSOV11+UCAGZGDSp51+AiAGBm+dDDtGjkBADs3GK3etZoEgCwk4W5mes0qDMBAEP50Rr66hZ5AhEAM9XDPZa82M9kMRDdqUMArAz7ocy35c1r1N2Y3QOwkjcafMTbRG35LAAsse36TT2X7vL6JACMsWX23X1eBAAsNPp/N1IRAAvv5xDU6b96/h8ABh4ajdv16hiRWHsFYOQpRKLmuvhtYjbqirVXAHaK7fpQ67Ks1U3VaHQVALDwPE3D6T20a9VpsAgA2MnqMCuTJVSiVgDA0PX0WmzV8FEPAAnMeopBeV9rN74KACS5Yl0fTew/YgsAxq9ElAYAlBqb1WkB4D0Qn6gzBABhVNZdJBkAKNw8lsNf9u7st6q63QP4c91zcXLCe9Pdrg4mvShtHHCI89TS1em6G9QgCElvDBzRvPEPQYaSUGAHRZYdxONrAamgBQdE3j/psLu7d6vnGKPE9Svt55M0e+1erosn3+f5DTv+CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALS3R1IAlY6OSqQE0JllnZESQFeWdUVKAN1Z1h0pAfRkWU+kBNCXZX2REsDgzp39kRTAwECkBTA4GCkAVB597PEnHmk1ZW27nnzq6WcqURqAZ597vu6FF1dLUdtLL79S9+pr8WcAvX2HP+iNdBQi4K0j1Wp1+q0gVWsG9E5X644ky0SG1cAH1YYP4wExNBR/CXC42nA4HgzDu3cPx18B9FUbPogHw0iej8RfAbx+pFo33RsPhqE8/4u9GfDWdH1W/cCrZozm+Wj8NUDvB4c/fPA8xFiej0VKAON5Ph4pAVQmJiqRFMDkZDzcAAAAAAAAPrn46aWhQ5EMwFBR99lcJAIwUjTM90bdoYWhhXLTEcClYs1k3Lf4+f2ny4tRIoDPijWX7n9ZKBrKrEQAE8Wazwdj7vOi4fJUlAbgYtE0t+F5JEoDMF40fTJXtExGeQC+KNb8z2jRMh7lAfiyuW62cLlomh+OEgFMrVWii0XT559ESQDm/rXwr/GpwdGirhWIPiurDgEcutTIP5cWv7hctFz+YirKATA1X7Ssb2tcKK8MAYwV/8f86OLCyFeVKBnglNlvfTY6HmUAmC9+3xdlpCKAixtD0OXi18a8H0oAk0XLxdXt1Z8WdQmOvQIi0fxS49j9p/V/lHnsFWDwi3r9uTT55ZdrWWhuvmi5EmUAmPrkk0Mb7kO7Mjex4VKQ8gB8+VlzrSzGm0PrT6NEAEsbbotd684mSg1EAKPFhhg0NTRfXL74VSQB2GI9H6t6v4xyAVxcT0RpACwWrWF1WoD7QC6bDCUDfDW/WodGIhmA1xcuXlw8FAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAn3dm9uzsmUgH4Nz5Wq12/lykAnDmfK3ufLJMBDBba5iNRADO1houBIBEBJgRbWeAVTPAPqILH8tDAA/k2EfHTxyLdABOnpqZmTl9MlIBOHZ6pu5UskwEcGKm4UQkAnB8puF4JALwUepEBHDs1EzdaTOidICT9Wn1qZORDsCxE/YRbUsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA7e2RFEClo6MSKQF0ZllnpATQlWVdkRJAd5Z1R0oAPVnWEykB9GVZX6QE0L9zZ38kBTAwEGkBDA5GCgCVRx97/IlHWk1Z264nn3r6mUqUBuDZ556ve+HF1VLU9tLLr9S9+loAKESA1mw7AgyrAYaGIimA4d27h+Nh0juysNQbWwkwkucj8RCZmy+KYn4uthBgKM+HHqY8NF/UzW+lTASM5vloPDyWioYrsXUAY3k+Fg+PhaJhMbYOYDzPx+PhMVI0LMXWAVQmJirx8JgyI9qKYHIyrJoB/Bm9S4tX5CEAAAAAAAAAAAAAAAAAAAAAAIA/VJnqj4QAXu/pqO7Z+0akAvD6m9W6jrciEYB91Ya3hyMJgOGO6pr9kQTAgWrTO5EEwMFqU3uUCmD/vr37Ou9/Hqo2lTqtBujvrtbtnYroqDZMV6JEAAPNpbID8W61YaC+s/GNg/1RBoCpPdU10wcOV1d1HIoD+47c/+wqYxkfYH+15e3/rq7q6h14r7rqqPdDCaCvuu7dNxv16P1q0wcB8Ld7o7rB9P2/97r3VFv2ekGUAP5Z/bU91Q3e934oAbxxpPr73owSABw4uqf6e7qiFABT+w/v69579P3qbx2ZitIAHBhotmgd7zaf3j4YZQGY2vdeteVI38H2nqN79304GGUB2N9KQ9VVPZUoFUB7Kw41T5vt7Y8SAbyx3pa1V9ccjRIB7Ks2vXfoSIpLGgHerDa9u/7c0RsJAArR/jia4rwrQHd1zT8j3qk2HY7SABxcG1bvObjxMH57lA2wfL+nr/7cXMDfcyhKBPDW3unpowcbj3ta91YnAtA5Xc9DA5VIBqB//zvt26kvAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgH+e+ufGPAEjnm5u1Wu3b7wIglW9WanUr56Kh7UwAlKrtfK3hVtSdu71Su3m2zEYN4Jta0437375vxKMfAqA839eazkZ8t1Jr+D4ASjNba/oxztysrbkdAKX5aaW25k5cqDWdD4Dy/Fxbc+vM3VrTtwFQnrZbzUL0fa3llwAo0b1v1wrR7fXO7F4AJKhE367XoXMBUI57/7518+btX2bv3alt9ENZeQjgXHM4vXLnVq1p5ccbAVCSn87XfuvunY9/CoDSnK39f+7evPPzd/8RAGX4ofa7bn4TACW4U9tgpfZrH3s/QAn+XVv3w916V7axQ/vP+NsB3Lu73omt7mW8dbO2bjYASrub8fzZMxdqdSuzK7WWswFQgv/65datH2fb4sZaAZq9YEgEJB5b/xw/tobXZe4nArjRGllHW7MSXQiAEv288V7G7+/W85AJEVCub2sbf8jjp48vOOcBlO38+mWxAGnc3iz3MgJOv67cCIA02m5bKQNSO/PL3Vrt5scBkFDbjXvxcAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA2LHr6rUdAZDO19eXl5evfx0Aqey4vlx3PVkmAri23HAtABK5utxwNQAS2ZU6EQGcMSMCrJoBxI5rf8M+IgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgvT02r96RhaXeALa4SkdHJTarufmiKObnAtjaOrOsc9Pmofmibn6LZyKgK8u6YpNaKhquBLCldWdZd2xSC0XDYgBbWk+W9cQmNVI0LAWwpfVlWV9sUlNmRLA9DO7c2W/VDEhrYCA2r96lxStbPw8Bg4MBkELl0ccef+KRVlPWtuvJp55+phIApXn2uefrXnhxtRS1vfTyK3WvvhYAChGgNQMwrAa2o6GhAEhqePfu4QBIaSTPRwIgpaE8T9ubAYzm+WgApDSW52MBkNJ4no8HQEqViYlKACQ1ORkAAAAAAAAAf6S9PQCSqnR0VAIgpc4s6wyAlLqyrCsAUurOsu7Ybo59dPzEsdgsgJ4s64lt5uSpmZmZ0ydjkwD6sqxvu+Wh0zN1pzZLJgIGd+7sj+3lxEzDidgkgIGB2GaOzzQcD8CPvyXyUepEBPg53GOnZupOmxFBWs8+93zdCy+ulqK2l15+pe7V12JbOFmfVp86GYBClM6xE/YRgdZsUwEMqwGGhgIgqeHdu4cDIKWRPB8JgJSG8jxtbwYwmuejAZDSWJ6PBUBK43k+HgApVSYmKgGQ1ORkPBAAAAAAAAAAAAAAAAAAAAB27Lp6bUcApPP19eXl5etfB0AqO64v111PlokAri03XAuARK4uN1z1Kv6XfXtHUhsIwjjeuUNnkNghVUQ+goozLH6VbXwwX8QX0euTNBIIAes7GEsas8luxlBa/r9guvsCU1090wBu5cOddkQAlnGSPpiXpdnMbuXXfc6IACS5pKK0XuUk1Q2vZgBCajQo7SwrfHErb3/f3T8iAKtag2JzLpwvtgYAoVTydmaNvNJCAYBGXrG0Vt7eQgGATP81UUdHdAsAnLx9I6/bWDAAkOUauYO8gwUEAFWuQd5qdLSgAGDjNKjVK0oLDADenApdtJmFBACbpDyVSbMrNHBJFjdptrAwAKByGuVjGGPxmFkAABB3elZe2dUBwKzWC+r3dm0AUOlFiV0bACR6wvkj4L4ZAKS6ODqd1QddHOzaAGBRyzvF6pVlJy+2qwOAplOvTq0dM6tqDVoLAADSWlK+j2zbaVBZdOzzNrIQAGBVJdXSzMqnE+ptuT9UBgBhPWrkDHgNZg8Lw9Q4jWoDpi96N19//PTZMNGLKDdg8qIv63/mXw2TstPIGTB539aD7yvDlGQdex14NVbz9eiHYUpmpXp/DJi8zdr7aZiWuC06Rz+Ev+zcBbIiVxTG8S/uOooTDxK3DWQBUQ4yhTs8aV5sCymJlEv2OtY0MopeusL/hxyp6nL03nv+D1oWiMgpAKhXS9W4pLYFbsghAMik7I5SQYqZrxeVQwCQM1+tobH5cpKi5VZGAOBCoWhTvcapn8TaalTPbsfkt9o/AKjbzMW5H5Nv5Tw/m2j/AOA9mxtX7Lba+YUFftHeAUDZFvTMzEsVbaak/QOA32xZ0RZcaP8AoHxmD1cRADjQmBTtYZJyAgAK9dNqqjS5sHudFeQMADRyZ+aLjYOs1pIrAFCoejZz9l4rkp6Uqn/k5QoA1GffhvyQjsopAIh4NjU2XykjhwCg7FkgYlMTOQQAVQt47TOGNAI4hIoFxvM89pYA4ABvRHVNOO8K4BBSNvWb1LTAqZwBgJZndxVbUtkCEbkGgOX74nu6bWy+YlsA4NCNUq83aflp0e7K6VAAIN4zMy8X1cEAQKbejLS1KgAAAAAAAODyR7rtpZc1C0vFrPej9gQAnn7yqdnzcvGg3iuXtDMA8O/JN7rt+Wefmz0vFw/s/fSqtgYAAAAAAAAAwINW5x9QrNB7TWsCgO9/eszq/LxYrfeKVgcAq63Oz4pVe8cJAIBLnW7nkg4HAPqD4XA46itcIhEdDQCXRsM7BpcUJtFYLKpVsFC221WzWQE41Rn6OgqTeCIR18Nh9UWxWbF270UBrnSHvq7CJJlIJPUYLJftZ9VsFv7+V4Ajv4byG1EqkUjpWAC4NBjeMbqkMEknEmkdDQD9O/9WD/oKlfcSifd0VAD2Ef1+SeGSyWYzOigAyOWEh6/bu1i+ZxEfyOf1ANhkJX7Li/78UUcFiH78yaefvZ3R1Iuff/HlV19HBd/lVzdaid/2ov8u69jd0ogCo8DC0goErG00wcWQrZ09CDgA2rlv5KiCKAyjF2/kTaQ9EJPKj8XDrvBsmPDWpKKH23p9TvLXMx3KflVzEQC+EQH+NAOq+Wc1jQLYXQ8NCq6uYgN3CGDtDg0Jrm9uroPUKID9w6EXMRq4nc1uA6DS1Wx2FQCV5rPZPAAqLWazRVQCWM5my0i6fXG+z4GBnK1WZ5F0++J8nwMjWa+DjW5fmu9zAAAAAAAYz8vifO9zrIHTz21LfINDewGMZW8LJb7Bof8IAAAAgJ1d1QwotIUA1uwQMJDnnVazTwEAAAAAQCH5PmfqgC/d5vucaQNOX3eb73MmDQAAAACA0917kO93dmLCgJ+ZyfvN94+PY8KAd5nJ+8v3ebEbWwMAAADATtfVLC8mDHjcdzXLi+kCnndfzfICAAAAAIBa8n0OUES+zwGKyPc5AAAAAKhmO5+iBqCa5XyIIoBqllMJAAAAAAD5Pu9VAeT7vFcHkO/z4tuXqAUAAAAAgHyfUwKQ7zemBiDfb8yfowAAAABg6GqWF6+iEfgLXQGrXPIHZhAAAAAASUVORK5CYII=); /* --dark-mode-bg: url(https://cdn.jsdelivr.net/gh/45921/cdn-images@main/texture/background/1.png); */ } @media (prefers-color-scheme: dark) { :root:not([data-user-color-scheme]) { --color-site-mask: #111; --color-list-hover: #eee; } :root:not([data-user-color-scheme]) body { background: var(--color-site-mask) var(--dark-mode-bg) !important; } } [data-user-color-scheme='dark'] { --color-site-mask: #111; --color-list-hover: #eee; } [data-user-color-scheme='dark'] body { background: var(--color-site-mask) var(--dark-mode-bg) !important; }"},{"title":"十年学会编程 | Teach Yourself Programming in Ten Years","date":"2020-06-10T09:30:00.000Z","updated":"2020-06-10T09:30:00.000Z","comments":true,"path":"favorite/bookmarks/Teach-Yourself-Programming-in-ten-years.html","permalink":"https://shiraha.cn/favorite/bookmarks/Teach-Yourself-Programming-in-ten-years.html","excerpt":"","text":"Chinese translation of Peter Norvigs's essay Teach Yourself Programming in 10 Years. 关于Peter Novig Peter Norvig任职于Google，其职位是研究主管（Director of Research). Peter Norvig是享誉世界的计算机科学家和人工智能专家。他是 AAAI 和 ACM 的会员，是业界内经典书籍《Artificial Intelligence: A Modern Approach 人工智能：一种现代方法》的作者之一。在加入Google之前，他曾经是NASA计算科学部门的主要负责人，并在南加州大学以及伯克利大学任教。 为什么大家都急于求成 每当走进各大书店总能看到一些诸如《24小时自学Java开发》之类的书籍，类似的还有几小时内学会C,Ruby,SQL,Algorthms等等。如果使用亚马逊的高级索索功能title: teach, yourself, hours, since: 2000 可以找到512种这类书籍，在搜索结果的前十名中有九本是编程类书籍（其它的是关于记账类书籍）。如果把搜索词\"yourself\"换成\"learn\"，或者把\"days\"换成\"hours\"，搜索结果也是类似的。 从上面的案例中我们能出的结论是，要么大家都非常着急的想学编程，要么学习编程和其它事情相比是一件很容易的完成的事。Felleisen et al.在它的《How to Design Programs》一书中也提到了这个问题，当然他也是不认同这种思路的，他们的原话是：\"编写糟糕的程序很简单，傻瓜也可以在21天内学会，哪怕他们傻到家\"。风靡网络的漫画公司Abtruse Goose也对此冷嘲热讽了一把，漫画如下 ars_longa_vita_brevis.png 让我们来一起分析一下《24小时学会C++》意味着什么 自学：在24小时内你甚至没有时间写几段有难度的程序，更不用说从中学习什么了。你也没有时间和有经验的C++程序员工作，不会了解真正的C++项目是怎样的。简而言之就是你没有时间学到很多东西，因此书中只能浅显的让你熟悉下语法，没法做更深入的讲解。就像 Alexander Pope 曾经说过的，浅尝辄止的学习是一件非常危险的事情。 C++: 在24小时内只够你学习一些基本的C++语法（假设你已经有过其它编程语言的经验），但是无法学到该如何使用这门语言。简单的说，如果你曾经是一名BASIC程序员，你可能会学会如何将原来的BASIC代码按照C++的语法重写一遍，但却不清楚为什么要用C++，也不清楚这门语言的优点（或者缺点）在哪里。Alan Perlis曾经说过，\"如果一种语言不能改变你对编程的理解，那么这门语言就不值得学习\"。现实生活中，一种可能的情况是，为了完成某种任务你需要快速学一点C++来对接某个三方库，但是这种并不是真正的学习某种语言，只是为了完成某种任务。 24小时内: 不幸的是，24小时时间实在是太短了，下一小节会讨论这个问题 给自己十年的时间来学习编程 很多学者已经证明了如果某个人想要成为某个领域的专家，需要差不多10年的时间，这些领域包括象棋，作曲，电报通信，绘画，弹钢琴，游泳，网球 等等。在这10年中，最重要的是保持刻意练习: 不仅仅是不断重复，还要不断挑战自己去完成超出目前能力的任务，然后总结自己的表现，改正错误后继续重复。这件事貌似没有捷径，即使像莫扎特这种4岁就成为音乐奇才的人也花了13年才创作出世界级的音乐。另一个例子是Beatles，貌似他们在1964年就凭借一系列热门单曲以及在The Ed Sullivan show上的演出而一炮而红，但是你也许不知道，他们早在1957年就在利物浦和汉堡两地进行小规模演出了，而在此之前的非正式演出更是不计其数，即便是在他们走红之后，他们的第一部最具影响力的唱片《Sgt. Peppers》也是在1967年才发布。 Malcolm Gladwell 曾经提出过一个很流行的理论，即一万小时的刻意练习。Henri Cartier-Bresson (1908-2004) 曾经说过，\"你的前一万张照片是最糟糕的\"（他并没有预料到数码相机的出现，人们能在1周内完成一万张的拍摄）。真正的专家们可能会在某个领域投入自己一生的时间，Samuel Johnson (1709-1784) 曾经说，\"想要在某个领域做到卓越的唯一办法就是终身投入\"。Hippocrates (c. 400BC) 有一段著名的引用\"ars longa, vita brevis\"，这句话出自\"Ars longa, vita brevis, occasio praeceps, experimentum periculosum, iudicium difficile\"，翻译过来是说，\"生命很短暂，但是技艺却很高深，机遇转瞬即逝，探索难以捉摸，抉择困难重重\"。当然，没有任何一个精确的数字能够回答这个问题，而且对于不同领域(比如，编程，象棋，作曲等)所需要的时间也不同。就像 K. Anders Ericsson 教授所说的，\"在绝大多数的领域内，即使是那些极具天赋的人，也需要非常大量的时间才能达到卓越的高度。所谓一万小时只是给你一种感觉，即使是那些非常有天分的人也需要年复一年的保持每周10到20个小时的练习才能达到最高境界\" 你想成为一名程序员吗 下面是我列举的程序员成功的必备要素 对编程产生兴趣，因为有趣才去编程。一定要确保你能在编程中找到乐趣，这样你才会有动力去完成10年，每年一万小时的练习 写代码，实践出真知，如果从学术的角度讲:\"某个个体在某个领域内能达到的最高水平并不会随着时间的增长而自动增长，而必须要通过可以练习来不断提高\"。并且\"最有效的学习还需要一系列针对某个个体专门设计的，难度适中的任务以及不断重复的正向反馈机制\"，对于这个观点，可以参考《 Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life》这本书 和其它程序员保持交流，阅读其它人的代码。这个比阅读任何书籍或者参加任何培训都要重要。 如果可能的话，在大学里读四年书，一方面文凭对就业找工作有帮助，另一方面你能对这个领域都更深层次的理解。如果你不喜欢去学校，也可以自学或者在工作中积累经验。不管怎么说，仅靠书本上的知识是远不够的。Eric Raymond曾说：\"仅接受计算机科学的教育是不可能让人成为编程专家的，就像学习画笔和颜料不可能让你成为画家一样\"。他是我雇佣过的最优秀的程序员，他开发很多优秀的软件，创立了属于自己的社区，并且通过股票期权赚足了钱买下了一家自己的夜店 和其他的程序员一起合作项目积累经验。在有些项目中你可能是最好的程序员，在另一些项目中你可能是最差的，当你是项目中最好的程序员时，尝试培养自己的领导力，用你的视野鼓励大家。当是最差的时候，向项目中的高手学习，学习他们不做什么（因为他们让你帮他们做）。 维护已有的项目。了解其他人的编程思路，尝试在作者不在的时候修复bug。换位思考，想象如果你是作者，怎么可以让别人轻松的维护你的代码 至少学习一半的编程语言。包括一门强调类型抽象的语言（比如Java或者C++），一门强调函数抽象的语言（比如Lisp或者ML或者Haskell）,一门声明式的语言（比如Prolog，C++模板）还有一门强调并行计算的语言（比如Clojure或者Go） 记住\"计算机科学\"中包含着\"计算机\"这个词，要了解你的计算机需要花费多长时间执行一条指令，从内存取一个WORD（考虑命中或者没命中缓存的情况）的时间，以及从磁盘上连续读取多个WORD时定位文件指针的时间（答案见附录）。 参加语言的标准化制定工作，这些工作种类多样，可以是加入标准C++委员会，也可以是制定编码风格（每行缩进是2个还是4个空格）等等。不论哪种工作，你能通过反馈收集到其他人是否喜欢这门语言，如果喜欢，他们喜欢哪些东西，倾听他们的感受，了解他们的想法 有良好的意识，能尽快适应语言标准化的成果。 考虑到上面所说的一切，你会发现只靠看书学习是很难成功的。当我的第一个孩子出生的时候，我几乎阅读了市面上所有的《如何…》指南书籍，但是我读完了以后还是觉得自己是个没有头绪的新手。30个月以后，我的第二个孩子快出生时，我还要回去读书将所有的知识复习一遍吗？不，相反，我此时更依赖我的个人经验，这些经验相比于那些专家写的上千页的书更加有效和让我放心。 Fred Brooks 在他的散文No Silver Bullet中给出了一个寻找软件设计师的三步走计划： 尽早开始系统性的寻找找顶尖的软件设计师 给有潜力的工程师指派一名职业规划导师，并仔细规划并记录他们的职业档案 为处在职业上升期中的软件设计师提供和互动交流的机会 上面的讨论是假设某个人已经具备足够的能力成为一名软件设计师，那么他只需要一份工作去督促他。Alan Perlis更简洁地指出，“每个人都可以被教会如何雕刻，但是对于米开朗基罗来说，则不应该被'教会'，伟大程序员也是如此”。Perli认为所有伟大的人其内心都有一种内在的特质(自我驱动的能力)，这种特质往往可以超越训练，达到更高的高度。但是这些特质是从哪里来的呢？是天生的吗？还是他们通过后天的勤奋习得的？就像Auguste Gusteau（动画片《料理鼠王》里的大厨）所说的，“每个人都能成为厨师，但只有那些内心“无所畏惧”的人才能成为伟大的厨师。\" 我认为伟大更多的是来自与愿意将自己全身心的投入到某项事业中，并保不断持刻意练习。也许“无所畏惧”可以概括这种精神。或者像 Gusteau's critic, Anton Ego所说的，“不是每个人都能成为伟大的艺术家，但是伟大的艺术家可以来自任何地方。” 所以尽管去买 Java/Ruby/Javascript/PHP 这类的书吧；你可能会从中学到点儿东西。但作为一个程序员，你并不会在21天内或24小时内改变自己的人生，或你的综合水平。你是否想过努力不间断的学习超过24个月？如果是的话，那么恭喜你，你已经在路上了... 参考文献 Bloom, Benjamin (ed.) Developing Talent in Young People, Ballantine, 1985. Brooks, Fred, No Silver Bullets, IEEE Computer, vol. 20, no. 4, 1987, p. 10-19. Bryan, W.L. &amp; Harter, N. \"Studies on the telegraphic language: The acquisition of a hierarchy of habits. Psychology Review, 1899, 8, 345-375 Hayes, John R., Complete Problem Solver Lawrence Erlbaum, 1989. Chase, William G. &amp; Simon, Herbert A. \"Perception in Chess\" Cognitive Psychology, 1973, 4, 55-81. Lave, Jean, Cognition in Practice: Mind, Mathematics, and Culture in Everyday Life, Cambridge University Press, 1988. 答案 PC上一些常用操作的大概耗时 操作 耗时 execute typical instruction 1/1,000,000,000 sec = 1 nanosec fetch from L1 cache memory 0.5 nanosec branch misprediction 5 nanosec fetch from L2 cache memory 7 nanosec Mutex lock/unlock 25 nanosec fetch from main memory 100 nanosec send 2K bytes over 1Gbps network 20,000 nanosec read 1MB sequentially from memory 250,000 nanosec fetch from new disk location (seek) 8,000,000 nanosec read 1MB sequentially from disk 20,000,000 nanosec send packet US to Europe and back 150 milliseconds = 150,000,000 nanosec 附录：语言的选择 很多人询问如果要入门编程，应选择哪一门语言作为第一门编程语言。这个问题没有统一的答案，下面三点可供参考 看看你的朋友们用什么。当被问起“我该用哪种操作系统，Windows，Unix， 还是 Mac？”，我总是回答：“你朋友用什么，你就用什么。“ 你从朋友那学习得到的好处可以抵销不同操作系统或语言之间本质的差异。同样，你也要考虑你将来的朋友们：程序员社区，因为在未来如果你继续前行，你将会是他们中的一部分。你选择的语言是否有一个快速增长的社区？ 有没有书籍、网站或者论坛能解答你的问题？你喜欢论坛里的那些人吗？ 保持简单。像 C++ 和 Java 这样的语言是为具有丰富编程经验的开发团队设计的，他们更关注代码的执行效率。因此，这些语言为了优化性能，有些部分设计的非常复杂。 而你关注的是如何学会编程，不需要那些复杂的设计。你需要的是一些设计简单的，易于上手的语言。 及时反馈。你偏爱哪种学弹钢琴的方式：是简单的互动的方式，你一按下琴键就能听到音符；还是完整的批量的模式，你只有弹完整首曲子才能听到音符？ 显然，用基于互动的学习更容易些，对编程也一样。坚持用支持交互模式的语言进行学习，这样可以得到快速反馈。 参考上面几点，我推荐的第一个编程语言是Python 或Scheme。另一个选择是 Javascript，并不是因为它的设计对初学者很友好，而是因为有大量的在线教程，比如Khan Academy’s tutorial。但是这些选择视个人情况而定，除了这几门语言之外也还有更好的选择。如果你的年纪是10岁以下，你可以尝试Alice 或 Squeak 或 Blockly （大人们也可能会喜欢）关键是你下定决心后要快速行动。 附录：编程书籍和其它资源 很多人问我该看那些编程类的书籍或者学习哪些编程类的网站。我的回答是“书本上的知识是远远不够的”，但是我可以推荐下面一些书籍 Scheme: Structure and Interpretation of Computer Programs (Abelson &amp; Sussman)（译者注：中文名称为《计算机的构造与解释》），这本书可能是对于计算机科学入门来说最好的一本书了，它从理解计算机工作原理的角度来教你编程。你可在这里找到在线视频和配套的文本教材。但是这本书有一定的挑战性，会淘汰一些之前学习过其它语言的老手。 Scheme: How to Design Programs (Felleisen et al.)，这本书可能是在所有介绍使用函数型语言设计程序的书中最好的一本 Python: Python Programming: An Intro to CS (Zelle)这本书是比较不错的一本入门Python的书籍 Python: Python.org上提供一系列在线的教程 Oz: Concepts, Techniques, and Models of Computer Programming (Van Roy &amp; Haridi)这本书被某些人认为是对Abelson＆Sussman观点的传承。它对重要的编程理念进行了回顾，覆盖的内容比Abelson＆Sussman更广泛，也很容易读懂。它使用Oz语言，一门不常用但是适合学习编程的语言。 备注 T. Capey指出，在Amazon的Complete Problem Solver的商品页面中，查看浏览“购买此书的用户还购买过这些产品”区域，会发现\"Teach Yourself Bengali in 21 days\"和\"Teach Yourself Grammar and Style\"这两本书。我估计浏览这两本书的大部分人是从这篇文章的链接过去的。感谢Ross Cohen的帮助。"},{"title":"2021 秋季下半学期总结","date":"2022-01-11T11:03:37.000Z","updated":"2022-02-21T17:14:56.000Z","comments":true,"path":"memo/2021/2021-autumn-second-half-summary.html","permalink":"https://shiraha.cn/memo/2021/2021-autumn-second-half-summary.html","excerpt":"","text":"2022 考研的最后两个月。这下想不读书都不行啦！ 考前 每天基本就是重复着去教室自习，吃饭，回寝室躺的循环。 拆卸键盘 因为之前 Surface 的黑色键盘开包，本着能用就不换的原则，我决定挑一个好日子用我新买的 502 胶水把破掉的皮给粘回键盘的基板上—— 然后我就把 502 胶水挤按键里了== 虽然还能用吧，但是总感觉有些膈应：毕竟坏掉的是个 Shift 键，算是个蛮常用的键吧，于是准备去整个新的。 咸鱼买了个当时买新机都没舍得买的灰色键盘—— 虽然也有点脏，但是脏算什么问题！货到了用了一会觉得没啥问题就爽快收获了—— 大概是我咸鱼购物经验不足吧，晚上就发现这货的空格键有点软，回弹甚至需要半秒钟：这可问题大了，结果我已经确认收货了，自然是找不到卖家人了== 这下尬住了啊。 折磨了几个星期，大概也是有考研焦虑症作祟的因素吧，终于某一天受不了了，拿了个大剪刀喀的给它那官方宣称不可拆卸的把空格键撬起来拆了—— 是两个剪刀脚支架支撑着一个金属的框，中间是感应点，在那旁边有两个白色的 LED 灯。这卖家也不知道之前到底一边用电脑一边再做些什么，金属框和支架上沾了一些不可名状的凝结成固体的焦油色异物—— 难怪迫不及待地要出掉它== 于是喷了点酒精做了清洁，支架看起来没有什么奇奇怪怪的阻碍了，于是原样给它装回去，键帽用力怼上去—— 您猜怎么着：嘿，直接恢复正常了；只能说自己动手丰衣足食好吧== 精神洗礼 距离考研还有一天。 要说这最后一天该干什么，那当然是本着贪心原则去抱佛脚最先要考的科目了；最先考的是作为通识课的政治，因为寝室里恰好有一位跨考马院的室友，于是就一起背书了—— 大声地。已经有多久没有上过早读课了呢，虽然早起确实有点难，但是将什么大声的读出来是真的令人感到心情舒畅。 虽然考研政治并没有比高中政治历史多太多的内容，背诵的东西也大概都是知道的东西；但是当把它们确实地从嘴中读出来的时候确实别样的感觉。也许这就是国家普及教育的成果吧—— 使用马克思主义，借由辩证的方法去唯物地认识这个世界，已经和呼吸一样自然的融入了我们的思考回路；就像徐涛老师在他的网课里说过的那样（大概？），其实这门课并没有教我们什么新的东西，只是把我们一直都是用的思考模式用学术的语言表达出来。 再回首，马克思等先贤早在那遥远的过去就能高瞻远瞩的”预测“了如此简单但却朴实的规律—— 每当发生了什么事情，使用它所赋予的方法去分析之后，都会惊叹于这份武器的伟大。也许无关考试，每个人都应该去了解一些这人类的精神财富；似乎很多的烦恼在当我拿起这沉甸甸的法宝时都迎刃而解—— 也许因为应试而没能进一步的去了解他的思想和理论，会成为我今年的一大遗憾吧。 于是我们就这样一直大声朗诵到室友睡觉，希望能做个共产主义的好梦。 考中 四门课，分两天考；考的这天恰好是圣诞节，不合时宜的雪却没有飘落下来。 政治 虽然去年肖老爷子的神迹依然还在耳畔回响，但是看到眼中的题目却略显陌生，以至于甚至会感到诧异的程度：为什么会有这么多没有在肖老爷子的卷子上见过的东西？但是毕竟是考前那样地背过语料，所以就使劲挤出红之力（不是）最后倒是也把卷子给印满了—— 我已经多久没有一笔一划写过这么多字了？ 事后听说今年肖老爷子的书确实歪了，希望人没事。 英语 完全裸考，应该不会有第二个人小作文写的是异世界食堂吧（笑）。 缺乏作文训练导致的结果就是写作文宛如便秘，希望明年不要再这样了。 数学 大寄特寄。 我虽然！确实没做几套模拟卷！只做了李林的卷子！但是也罪不至此吧！之前和研友打趣大概不会考的几个东西真的就都考了，大题目每个都长得和李林卷子很像，但是做起来都麻烦许多！甚至还有张宇书上的证明题！可是这些东西都没有再看第二遍！只是对于为数不多的事件进行优化而已，至于被卡嘛！！ 下午都不是很想去了，从来没交过这么干净的答题卡== 但是毕竟五十块一张的卷子，还是去吧（） 408 考的很散漫；大概没有什么是应该不会做的题目，有的话那也是记不清了；虽然我也没做几套真题，但是这张卷子大概是我做过的真题里体验最好的一张吧…… 虽然以这样的心态考大概是考不了多少分的了，但是至少让我觉得专业课没有那么恐怖—— 如果明年再考的话还是很有考头的（） 考完之后发现小算法题写错了，算导上有一模一样的== 行吧，我确实只会写快排，理解还是差得远了；虽然还是有点疑问，但是还是之后再说吧—— 就这样吧，我要回去吃饭了。 考后 ”事实上，诸君未来都会成功。读研与否，并不影响你们未来的高度，只是会影响人生的方向。“ 难受 考研本来就寄了，因而没有很好的心情去回应社交，导致了朋友的尴尬；之后准备偶像大师，然后就发现一直坚持到考研结束的笔记本风扇突然发出很大的声音…… 尽管我是唯物主义坚定的拥护者，也不免因为这一连串的变故而感到有些悲伤。 好兄弟 zcysky 听闻我的窘境之后就把他的 PS4 借我完了，大概算是这段时间为数不多让我感到温暖的事情吧；这真是太感谢了！ 不过紧张的时间安排也没有给我留多少玩它的时间；很快我就被导师抓去商量毕设的事情了。又要忙起来了！忙起来的话大概就不会去想这些有的没的的事情，自然也就不会难受了吧。希望接下来可以过上相对充实的生活，做什么都没有精神的日子，真的不想再体验一次了！ 考研歌会 风蓝 Galgame 群这几年开始的惯例活动，不过并没有几位后辈来就是了，所以还是自助== 和三上吃完饭之后坐他车到了地儿，见到了武大群友之后就开房唱了。说是 Galgame 群的歌会但是来的人却也相当随便，我还叫上了本院的稀客和哥哥一起来唱歌，总之是人越多越开心啊。 六个小时还是不算短的，我们几乎唱完了纯 K 有的偶像大师曲和东方曲，太舒服了—— 大声的做些什么实在是减压利器，而唱歌又在其中数一数二。唱到后来实在没什么二次元歌唱了纯K能不能更新的再频繁一点甚至还唱了首反方向的钟，乐（）来的人还有几位关系不错但之前失利二战的先辈，大概是这次活动之后就回老家了—— 之后大概就真的各奔东西了吧，哈哈。希望大家都能有个美好的结局（） 唱累了之后玩了一把节奏贼，差点被龟壳圣骑士带走== 不过最后还是被我用重拳先生一脚踢死了。这次吃饭的地点定在简朴菜；因为确实是好多次了，所以倒也没有出现什么大问题，这次歌会就圆满落幕了。这里应该播放难忘今宵吗（ 至少现在，让我忘记现实吧（不） 网安基地 本想着心碎之前再去见见我的云研友安安的，但是他却直接去准备找工作了—— 这份行动力是我所没有的，只能说一句断舍离，佩服！认识了洛佳—— 虽然他比绝大多数的同龄人都要优秀，但是仍然非常乐于和我们交流分享各种各样我所不知道的事情…… 只能说的烂的人各有烂法，而优秀的人却总是都那么相似== 见识了网安传说中的 CTF 寝室，真好啊！ 和 sac 说了最近的各种各样的事情，本来想当成段子说的，但是说着说着自己也没了这份从容了啊== 我到底在惧怕什么呢？惧怕的还是自己不能贯彻口中的自己吧。明明是先辈，却完全没有先辈的样子啊…… 难道我只能许”希望明天能够成为更好的自己“这种虚无缥缈的愿吗？ 虽然确实很不成样子，但还是希望这次我能够真正记住自己说过的话并且付诸于具有直接现实性的实践；也许我就应该在说的时候给直接录下来，好在之后放给摆烂的自己听== ？？？ 考的不太行，不想多说了. 1ZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmVudGVydGFpbm1lbnQnKS5zdHlsZS5kaXNwbGF5ID0gJyc&#x3D; 就算是考研已经进入了绝对紧张的时候，也不可能没有娱乐活动的。但是毕竟考的不是很好，所以直接就这么明晃晃地摆在这里也确实有点不太合适。但是既然确实是那段时间的构成部分，那么也理应记录下来。 有一些条目可能是上半个学期就已经搞过的东西了，但是因为各种原因之前没写，在这里一并写了。 弹丸论破2 弹丸论破的续作，个人认为是集成了上一部作品的优点并进一步发扬的集大成作。本作对于角色的塑造下了较大的功夫，每一个被处刑的同学的动机，感情都更加立体而细腻，比起第一部很多开玩笑一般的动机要高出许多。不管是孝子还是护主女仆，还是求食困境，还是究极的殉道，虽然做出了残忍的行为但是他们的身上却散发着人的光芒。狛枝则更是成为整个弹丸论破系列中最为丰满的角色。 当然，盾子信徒狗粉丝我还是理解不能。 故事的主题最终还是归于系列一直不变的希望和绝望。也许江之岛的大人气不是没有原因，“希望”这一存在不管是在本作和前作都显得过于单薄：上一作还有诚哥大吼大叫的话，本作希望则更显的空虚—— 也许是玩到后面有点懵了，我没能理解吧。 本推理白痴完全根据攻略进行游戏，对游戏系统和推理的设计不做评价。 七海我的七海呜呜呜 偶像大师星耀季节 傻逼游戏，但是确实不错。打歌系统虽然简单，但是特殊构筑的技能还是可以有爽点的：甚至我还会去试炼之门刷刷刷；此外本遭诟病的刷刷刷的养成系统，在一周目却确实的将我和虚拟的制作人联系在了一起。虽然还是相对比较耗时间但是却并没有最开始想象的那么糟糕，大概这就是上班魂吧== 整个游戏的高潮当然要数最后在星耀巨蛋举办的水晶之冬；实在是让我回想起了最开始入宅时看二次元偶像番时的激动；大概这也是偶像的魅力所在吧。从整个团上台前的鼓劲儿到上台表演之后安可，万代全新的建模以及现代计算机图形技术也将登上舞台的临场感传达给了屏幕前的我。而当登上星耀满天迎接朝阳的那幅画面又是如此的梦幻而又充满希望，只能让我感叹：这就是偶像！ 就游戏本身来考虑的话，虽然细节上感觉有点不如之前的星光舞台，比如开始演出和结束演出的问候啊、特殊节日的 event 啊…… 此外我觉得列表的行动菜单也太蠢了点== 但是毕竟也没有必要去和两作积淀的星光舞台比就是了；此外歌少也是一大遗憾，希望之后 DLC 能多加些歌，加了我必买== 就我个人而言，这游戏算是从我考研后期的一些心理问题中拯救了我；说句她们是我的天使一点都不过分吧我当时就一边看着偶像大师一边哭啊（）虽然梦幻故事经不起现实的推敲，但是又有谁会做这样不解风情的事情呢？需要做的大概只是将她们的这份光辉铭刻心中，记录下这份属于自己的美好回忆吧。 肉眼可见将要陷入 DLC 地狱，但是只买本体我觉得血赚，更甚至元旦本体还优惠 25%，只能说买了血赚== 无尽的平安夜 minori 的作品；听说有父女恋我就来了；然后就是典型的女儿穿越时空想要纠正父亲路线的错误最后不了了之的剧情—— 虽然看起来很了不起但是其实写的也就是白开水；虽然描写还算是细腻但是角色的行动却时常让人难以理解：大概就是看起来这个地方我应该哭，所以我就哭了，可是这又是为什么呢？的感觉。 虽然可爱的女儿终于回溯跳出了缺少父爱的世界线，这确实很感动—— 但是事情是怎么样一步一步的发展到这里的却经不起推敲；毕竟我必须要先和谁谁谁生下女儿才能有女儿穿越时空搁这搁这—— 不过当然也没有必要去纠结这些东西，毕竟也没啥必要，还破坏观感你说是吧？ ……之所以理解不了 minori 的女主，大概还是我玩的太少了吧；下次再去玩点别的中二社作看看 不过似乎也不用考虑的特别多；似乎自从中二社转型为巨乳社之后剧情就一直在摆烂所谓的各种花里胡哨的设定只是为了各种各样的 H 罢了（暴论）；而且中二社任由脚本跑火车犯病也不是一天两天了不然为什么叫中二社呢，只能说要是理解不了也没什么不对的，没必要折磨自己是吧 猫神大人的七颗星星 画风可爱，声优也是我喜欢的几位，但是剧情可以说是诈骗。整部游戏我只知道我开幕雷击但是捡回一条狗命和可爱妹妹搁这搁这，最终却发现一切都是阴谋，然后我们的牛逼主角和黑幕和谐共存了…… 我也不知道这和游戏的主标题猫神大人的七颗星星，还有副标题”姐姐与妹妹“之间到底有什么联系—— 唯一的联系就是数字 7 了吧== 其实抛开这莫名其妙的黑幕，在设定一个更和谐的标题，我想这应该还是一部 能到及格线的萌作—— 所以我完全难以理解这么写的目的到底是什么，难道真的就是为了让企划和写手自嗨吗？可是写出这种东西真的能嗨的起来吗？我不好说…… 大概 SWEET TEA 确凿是要死了吧 星恋*Twinkle 这其实是上半个学期就一直在打的作品。可以说非常的出乎意料，我是真的没有想到这样的一个超自然的充满了幻想的设定能给他写成重返地球== 但是不管是写什么，如果你没有说的让读者心服口服的话，那只能啊对对对== 大概是经费不允许但是确凿是要做成一个萌拔吧，所以整个 GRAND END 发发糖就结束了，不是很行 似乎なかひろ是真的很喜欢来自星星的你这种题材—— 不管是星空的记忆还是星辰恋曲的白色永恒；但是本作的体验应该是比前两作要差了许多：一方面卷心菜似乎并没有像 F 社一样为他提供充足的篇幅预算；另一方面，虽然本作也使用了星辰作为线索，但在个人线路中引起矛盾的却主要是主角们的神技，而并没有强调它和星辰之间的联系；而在最后的结局中，将它们联系在一起的也不过是一句陈述设定性质的说辞，使得氛围的提供者和矛盾的提供者之间割裂开来，不明所以的玩家只能啊对对对== 所以なかひろ能不能不要再惦记着你那逼宇宙幻想了== 能不能先多提升点对剧情的把控水平 不过卷心菜大概确凿的是经费不足吧；我还挺喜欢新田惠海唱的 ED 主题曲的，但是似乎这作的 ED 都没有发售光盘…… 所以这游戏打完了之后我还留了好长一会就为了听这首歌，只能说多少有点遗憾 异想魅惑 光是看封面只会以为这是一个以魅魔女主角作为卖点的萌拔，但是质量却意外的高；在玩家扮演的阴阳师进入到公寓中之后，并没有穿着暴露的色情魅魔搁这搁这，而是充满房间的”恶意“—— 于是玩家看是探求隐藏在这份恶意之后的真相；最终解决了一个惊天大案子，从邪教团伙和毒品的折磨下拯救了几位同住的”天使“，并制裁了恶意的源头—— 只能说如果只是看封面的话，完全想不到这游戏还能整这样的活，但是好活！ 虽然游戏本身还是有点恐怖要素的，但是抛开恶意成分来看，这游戏真的是贞子姐姐爱上我级别的纯爱故事啊！本应当被大师除掉的恶灵请求最后的宽限，于是在最后的宽限期内爱上了主角，虽然内心有千百种欲望但是最后还是克制下来让主角劈了她；最后主角还牺牲了自己的胳膊给她赋予了新的生命然后二人幸终…… 真好啊真好啊真好啊。真的打完了结局之后，便再也不想玩主角杀她的梗了—— 玩纯爱故事的梗还是告辞。 邪教必须死，毒品必须死，愿所有人都能生活在阳光下 之后 希望可以度过一个相对充实的寒假…… 这个寒假要做的事情可太多了啊！ ——然后，安静地接受审判吧！"},{"title":"2020 ICPC 沈阳区域赛 - 游记","date":"2021-07-20T02:58:47.000Z","updated":"2021-08-08T06:37:25.000Z","comments":true,"path":"memo/2021/shenyang-2021-travel-notes.html","permalink":"https://shiraha.cn/memo/2021/shenyang-2021-travel-notes.html","excerpt":"","text":"咕了又咕的沈阳区域赛最后是安排在 7/17-7/18 的，所以行程安排就是 16 号到东百（）说句实在话，只有实际经历了之后才意识到一直延期并不是什么好事…… 虽然理论上准备时间变的更多，但是变数也变的更多—— 比如我的队友因为研究生的问题开始摆烂…… 明明我也要考研，嘴上说着这次出来旅游但是实际上真出来旅游的只有他一个== (这里省略一万句脏话)；这场比赛硬要说只有一点好，我终于和这个内心极度自私的扭曲卷怪说再见了，真是可喜可贺！哈哈哈 …… 因为是出来旅游的成绩也不那么好看，所以就不贴图了（）免得被认出来== 7 - 16 今天中午的飞机，虽然昨天晚上因为傻逼（指在 Surface 上临时配置 LaTaX 而配置这个的原因是在比赛的前一天我的板子还没有生出来）最后搞到四点睡觉（然后上床了甚至还看奶头乐视频直到晚上五点多才睡觉）……但是不愧是外出 buff 最后还是在八点半准时醒来收拾出门，只能说这不愧是我== 乡下人坐飞机 上午去了启明拿了队友的《杂七杂八重制版.pdf》之后就去了地铁——然后活活坐了两个小时之后才做到了机场，大家在机场集合之后去候机区随便等了一会就上了飞机。我真的好久没有做过飞机了：飞机内部的空间真的比我想象中要小了好多啊——以至于从过道中间走过和空姐擦身而过看起来都那么像性骚扰——啊当然不是我，我指的是在我前面登机的秃头油腻大叔（ 飞机起飞时最开始就像是防滑没有做好的汽车，然后两边的引擎猛然传出一阵轰鸣后机身就会腾空而起，就不再有还在跑道上的颠簸的感觉了；虽然上升的过程中靠窗什么也看不见，但是很快飞机就会穿越云层，然后就能看到白云之上的蓝天——飞机上应该有的景色：就像在一望无垠的大海上航行的孤舟，所见之处只有没有尽头的蓝色和白色，就仿佛停在原地，真是奇妙的体验；但是这种宛如梦中的体验并没有持续很久，我的队友就因为承受不了强烈的光照关掉了窗户，真是遗憾（ 到沈阳后才发现沈阳其实和武汉没什么区别——毕竟一个是温带半湿润大陆性气候，一个是亚热带季风性气候啊；如果不看冬天和降水，在夏天都是一样的热啊（）出了机场就已经可以感受到东北人的热情了：守在机场门口拉客的师傅即使拉客不成也为我们指明了上车点——虽然最后还是不忘拉客就是了（ 南北经济差距 晚上出去找吃的，当然来了东北就自然会想着要吃东北菜了。于是何佬打开带众点评，随手翻了家附近评价第二的东北菜馆，距离 1.7km 于是就走着过去了。在经过了 RPG（银河战士恶魔城）式的探图，甚至还在找到了让我们自愧输在起跑线上的数量的早教中心和远超过我认知的奢侈品店之后才看到了这家饭馆。 在餐馆外百无聊赖的等了半个小时我直接睡着了之后终于才排到了我们；进入餐馆打开菜单，翻了一遍后又翻了一遍，才真正确实的意识到了南北经济发展的差距——带众上人均消费 114 真不是盖的，一起去吃饭的五个人面面相觑不知如何是好，最后碍于面子只好随便点了四个菜——当然每个的分量都很少，以至于同行下完单之后赶忙去了旁边的KFC，笑稀了——就算是这样之后结账也是人均 70………… 我想我大概再也不会觉得校门口那家东北菜贵了，这着实远远超出了我的预料； 大概是没吃饱，又或是被价格所震惊到了，大家回宾馆的步伐都显出了一丝疲惫和沉重。事后才了解到那个位置大概可以说是沈阳的比较靠前的高消费地区了——这样倒也合理——但是这样的话那些成群出现的早教中心就又显得……一言难尽啊！ 睡觉前 回了宾馆之后看校队的个人训练 3 的题，一道被称为是签到题的题目我在看了答案之后才搞懂，有点难受；突然觉得自己好弱小，准备寻求队友的帮助，但是队友张旭一副什么也不想看的样子……算了算了，不看就不看吧，只希望这能成为一次开心的旅行我亦已心满意足（）洗洗睡了。 啊，睡觉前还要把板子的 pdf 造出来。 7 - 17 大概是因为昨天太累昨天晚上睡得太少今天早上一觉给睡到了十二点，甚至差点超过了签到的时间。因为昨天完全没有踩点，我们在地图的指引下勉强找到地儿，然后发现大家都和我们别无二致地选择了在这个时候踩点排队，以至于队伍长的令人恐惧的程度——反复折叠了五次；所以最后还是吃了饭才签上到。 热身赛 开幕式就是在比赛现场的体育馆进行的，我们队的机位在体育场中间的边上；坐下之后还是感觉桌子比想象中要小了不少；电脑也没有上次湘潭的给劲儿：一副饱经风霜的样子只有 4GB 内存以及 4 代酷睿；就算是这样，打开电脑，在没有了我的一大堆自定义设置的 Ubuntu 上登陆 DOM Judge 之后；当中央的大屏幕亮起来显示倒计时和评测队列之后，一切仿佛就变得不一样了起来：大概这就是所谓的临场感吧——明明自己还是那个弱小的自己，却仿佛披上了从未存在过的荣誉感，连敲代码这种日常不知道重复了多少次的行为都变的具有了神圣感；再次认识到这就是选手们投入了大量努力的赛场啊，就算是我这种努力不足的人也仿佛变得“高贵”了起来。 做题情况就那样吧，C 与我们无关似乎是个 Google 的题，最后好像只有逆十字过了；B 是个 sb 题真的排个序就完事了，但是我们推式子推魔怔了，没有足够的敏锐来察觉致命的边界条件，残念残念（）不过因为队之间的距离比较近，所以能听到其他队伍的谈笑声还是颇有趣味——算是一大乐子吧，只希望明天不要受到他们的影响。 另一个有趣的事情就是在比赛快要结束的时候，在我旁边的一个看起来像是志愿者小队长一样的老师（无贬义，只是举止神态真的很有那种感觉罢了）用对讲机和下级通话：“注意，注意，等他们从体育馆出来之后，让他们全部从东门（进来的门）出去，严禁这些人在校园内溜达”——到底是出于什么原因呢？不过我想多半还是因为怕麻烦吧，毕竟我们进校园的手续那么简单呢（ 校园内溜达 颇为讽刺的是，再我听完小队长老师的命令之后……郑佬就联系了他的同学，我们收起狗牌，骑上和学校里不太一样需要定点还车的哈罗单车，直接和保安说我们是东带人，就愉快的进去了== 中间虽然也有人将信将疑尝试阻拦，但是最终还是没能拦住…… 这种做坏事的感觉，还挺令人心旷神怡（ 不过我们倒也不是受虐狂，要在和武汉不相上下的大热天下逛没有特别的景观的校园的——这一切都只是为了找个打印店去打印昨天晚上只加了一个版本号的板子；在内鬼的带领下，我们找到打印店，打印完了各自的板子后就速度离开了东北大学校园。 晚饭和逛街 晚上就在郑佬的美少女同学的带领下吃了一顿正经指价格正常的东北菜；虽然大体上和昨天以及平时在学校附近吃的没有什么区别就是了，但是有鸡架——这玩意刚端上来我只觉得是一堆没有被吃的很干净的鸡骨头，但是吃起来还是有点……逐渐上头虽然我因为体质原因没有吃很多就是了；事后才知道这属于是沈阳的土特产，只有在沈阳才能吃的到的食物，甚至常年盘踞沈阳热搜榜首== 然后去了商业中心——然后就变成了盲目目的的散步毕竟商业中心基本大同小异——不过我也觉得这样挺好的就是啦（）虽然沈阳白天的天气真的非常不适合任何的户外活动，但是晚上其实还行——如果没有背着那么多东西以及没有那么多的人；和本地和武汉的商业中心不同，这里的街头舞台和各种摊子数量比较多：这大概也算是东北城市的特色吧？ 摊子中的一些是小动物展示——虽然我对小动物不怎么感兴趣，但是这样的摊子在我常在的地方倒也确实不多见；在众多小动物中看到了一只雪白的兔子，和与它同笼的另一只花兔子不同，总是待在笼子的角落不多动弹（）这种反常的行为让我联想到了超级糖果开头的那只兔子——人为什么要合群呢？是因为这样更开心？还是因为这样更容易办事？还是因为……不这样就会（）？在这个文明但又野蛮的世界，只有足够强大才能活下去啊== 之后去了某个神秘的名字里有“动漫”两个字商店，看到了一些玩偶手办；本来因为这家店看起来一点也不二次元，我还以为摆在货架上的只会有洋娃娃，或者是那些经典老番以及“国产二次元”的周边，直到我看到了一些偶像大师手办——不过倒也正常吧，并没有什么人规定只有 Animate 可以卖这些东西（）是我见识少了== 不过这倒也然后我觉得逛这里也还行了——竟然还真的能见到认识的东西（ 在一边吹牛一边乱逛走了一万多步（就这？）之后，我们六人都绷不住了（）告别了郑佬的女同学之后，甚至还因为打不到车，最后只能坐地铁回宾馆，尬住 睡觉前 晚上睡得很迟；虽然今天有牛客多校的第一场，理论上要说还是有事情做的：但是实在是走路走 yue 了…… 队友张旭满嘴混过明天就安心考研了所以摆烂了也不怎么想干事了，我也实在是没有什么心情了，于是干脆就不看了。原本打算写完日记就睡觉，但是写完之后有谜之有精神了起来，所以还是看了一个题——万幸的是还凭一己之力看出来了，没有对明天的心情造成什么影响…… 善哉善哉（ 7 - 18 虽然之前在群里打过招呼，说要尽量早点起来（毕竟还要开发票什么的）但是最后大家还是起的不是很早，开完发票之后随便找了家店吃点东西之后就直接进场了——此时还有十分钟开考，不过意外的也不算晚（）拿出板子放完包，发密码纸条和试题册后，比赛紧接着就开始了。 丢人记录 签到应该挺快的——虽然榜上什么也看不出来——因为东百大学给我们提供的傻逼电脑因为承受不了 CLion 的内存占用频繁卡死，最后只好换上了 Code::Blocks…… 好不舒服，明明昨天热身赛的时候还能用的。签完到之后看 I 过的人很多我的队友就去大力日 I 了，我则看了构造的 D——因为就平时训练来看这种题说不定就可做：然后就发现我不会，于是开始漫无目的地开题：基本上是看什么题有人做就去读什么题——还好没有变成平时大量英语阅读读昏的样子，大概是因为题目的名字全是炉石大版本，所以倒也自有乐趣——可惜就是不会做（） 队友想出了暴力求解 I 的办法的样子，又想着昨天热身赛测试了评测机，好像大概也可以跑过去，就想着去莽了一发，未果…… 然后就不会怎么处理那个古怪的求和式子了，此时已经过去了两个半小时的样子；刷榜发现 K 过的已经比 I 多了，阿潘觉得不能再这样尬住了就去看 K：可是 K 是个人工智能的背景，我一看到就烦（虽然这些概念还真学过毕竟这学期学的人工智能导论），于是只能继续漫无目的的开题——过了会阿潘想出了这个题，就讨论了一下写法，但是没写对，于是阿潘就回去调试了（ 接下来就是一段极其难熬的时光：阿旭开始瞎看新题，我看 I 看 D 反复横跳，阿潘自闭改题。总感觉这样一段时光有些似曾相识——去年的现场赛上我们好像也是一副这样的样子，真是……没什么长劲啊（ 最后封榜前一分钟阿潘改了出来，过了 K；但是这也说明时间只剩下了一个小时：阿潘觉得凭我们几个大概是做不出 I 了，所以我们临时决定去做 D：我敲了个暴力妄图找规律——这也是我们做这种构造题的常见做法——然而可惜的是没有什么效果；找了，但没完全找——暴力枚举到 20 之后我觉得电脑跑不动了，然后就开始对着打出来的表哔哔赖赖——虽然确实总结出了一些特征，但是还是不足以支撑得到一个结论…… 时间还剩下最后二十分钟，真的感觉猪脑过载：但是和黑眼术上分不同的是，我的大脑一片空白——这张表里到底有什么决定性的要素我没有察觉？我要怎么样优化才能卡过 I 题？——即使那不是正解，但是毕竟过了那么多人，说不定找到点什么优化就卡过去了…… 然而却无法进行思考，被大屏幕上的倒计时和周围队伍的焦急情绪所裹挟，陷入了深不见底的情感中，绝望开始蔓延：真是丢人啊，就算平时自诩心态良好，真尬住了还是手足无措（ 颁奖 结束了，我承认内心深处是期待着这一刻的到来——压抑的感觉真的受不了；阿潘默默掏出 Switch，阿旭只是叹了口气回去考研（？）有点想宣泄自己的感情，但是却发现自己的内心空无一物，真是让人火大！ 赛后看群，I 确实可以加点什么优化卡过去，突然觉得有什么圆满了：这场还是我熟悉的沈阳站——不过算了，毕竟这也不算是正解吧！毕竟承认了就等于承认找不到这个优化的我是傻逼了（）之后就是滚榜拿奖拍照——唉虽然挺有灵魂拷问内味儿的，但是……总得去吧！ 然后就是看戏时间；滚榜滚到一半电脑卡死了还行，笑死（）然后…… 郑佬他们好像没金了，残念…… 宁夏理工学院的 TS1 队也做了四个题——上台领奖的时候整个体育场都为之喝彩……嘛，可喜可贺可喜可贺？虽然这次没有金但是毕竟成绩上下浮动也是可以理解的是吧（）看起来洗白了呢，是好事一件 诸如颁奖过程的队名笑话还是有许多的——比如银牌强队拿了银首（其实是第三还是第二），比如拿到银牌就算胜利拿了铜牌…… 算了我也没仔细听，无所谓啦！ 赛后 虽然我不太关心周围的队伍，但是还是想在最后提一下在我们后排的一个大概是出线（？）队的一些状态；最后一个小时可以说他们总是在惊爆全场大呼小叫，虽然也不会有人指责他们就是了——过题的兴奋懂得都懂。但是比完了之后，某队员反复矿泉水砸头以及以物抢地，他的队友在旁边拼命安慰——似乎是功亏一篑，出线变金牌了（）虽然就结果而言这还是有些可惜，但是果然这就是竞赛，这就是青春啊！现在的我大概再也难因为所热爱的事物（或者说，真的存在这样的东西吗？）有这样的剧烈的情感波动了（）嗯，年轻真好，各种意义上。 好啦，奖快要颁完了，我也要走啦！楽しいかった？ 归途 飞机上何佬和一位 04 级的华科毕业生谈笑风生，然后说到了什么政治联姻…… 属实有点给我听傻了，很难想象二十年前不到竟然就还有这样的卵事——真是太狂野了！算了也就图一乐（ 首都航空真的比去的时候的海南航空差得远了，，，不仅机票贵，各种磨叽以及飞机上放了一路的广告以及介绍他们公司的贵物吉祥物属是有点教我绷不住了——下飞机后发现阿旭的室友正等他，为他接风洗尘，于是我们剩下了的四个人（因为还有一个没买到票留在了沈阳）便和他们一起去吃了海底捞——这还是我第一次吃海底捞，味道且不论，服务属实到位（ 意外地发现阿潘喝了酒之后变得狂野了许多，又见到了队友群友不为人知的一面，颇有趣味。 在那之后 总体来说还是很愉快的——除了垃圾的首都航空和东北大学的垃圾电脑以及我的垃圾队友（有一个人不想赢，是谁我不说）之外都很享受；玩的尽兴了吗？不管怎么样，总之接下来要做的事就是静下心来考研啦！ 后记 听说某大学在比赛前几个星期去找东北大学出题组要题了，出题组为了大家紧急换题，但是 H 最后没有被换掉，然后宁理过了这个 H 题…… 太那啥了（以上内容来自知乎）"},{"title":"2022 寒假总结","date":"2022-02-20T02:55:27.000Z","updated":"2022-02-21T10:59:20.000Z","comments":true,"path":"memo/2022/2022-winter-vacation-summary.html","permalink":"https://shiraha.cn/memo/2022/2022-winter-vacation-summary.html","excerpt":"","text":"这个寒假属实过的有点糟心——从各种方面而言都是：首先整个寒假都没有能称得上是好天气的天气，似乎全国上下不管是哪里，都是除了雨就是下雪。完全没有给各种活动提供有力外部条件且不论，整日阴沉的天气还会对身体和精神套上各种各样的 debuff…… 算了 事件回顾 也就是记流水账 毕设 老实说，我是真的不太想写 C++ 工程，但是既然分到这个题目也没有什么办法；只能不断地踩坑折磨。但是毕设就做一个 Qt 项目实在是实非吾愿，于是就一直嗯拖…… 倒是学会了不少 CMake 脚本，虽然感觉也没有什么意义就是了。总之也就是不用 Visual Studio 最后的倔强…… 不过 CMake 确实一言难尽就是了。 但是比起踩坑之外，去面对一个相当具体但是资料较少的领域的研习才是更加的折磨—— 我要参考的库可以说是相当的，完善，我也觉得它是一个完善的库，但是我却难以研读它的代码：一是自身水平不行，二是文档实在有些简单：并不能从它的文档中理解它的设计；当然做出这个项目肯定是够用了，但是这又有什么意义呢？毕竟要我为了一个毕设去了解一个这辈子大概都不会接触的领域实在是有些强人所难，当然它的文档也是一样晦涩就是了。 再回想到和导师商量毕设的时候，我所做的工作甚至都不能反馈到我的论文中—— 我开始怀疑做这份工作的意义，进一步也不能退一步又显得浪费的感觉真是太糟糕了我玉玉了我真的玉玉了。 大病 大概是病由心生？没过多久我就腹泻发烧浑身发炎三连击（当然，我是阴性的）去医院躺了，一躺就到了过年，前半个寒假说没就没了，只能说不管发生了什么身心健康都是要摆在第一位了，没了革命的本钱生产力根本就无从谈起…… GAMES-103 因为毕设一筹莫展，所以决定找点别的事情做；恰好看到了 GAMES-103 的作业可以补交，于是就报名补课；这一章节还是相当的有意思的，而且对于前置的编程知识没有什么要求，想要混完作业的基础部分即使是连我独角猫的 Unity 水平也能勉勉强强达到要求，于是就做完了它的四个作业。 这一章节的主题是基于物理的动画，个人感觉如果想要学的更好的话还是需要计算方法（数据分析？）和必要的物理知识作为前置；然而哪怕是计算方法我也是水过去的所以感觉到最后也只是学会了一些方法的名词并且写了一个 demo 而已，并没有真正的理解它—— 这在我做作业的过程中也有体现：后面的作业反复地用到了前面作业介绍的 Impulse 方法，而我用的都非常的僵硬…… 大概还是学习方法上有点问题吧。 因为时间真的不多了，最后一个流体作业还是边听着春晚直播边做的，大概算是度过了一个相对充实的除夕吧（笑）可是为什么没有人改我写的作业呢（哭） 春节 毕竟刚考完研，我大概算是比较有时间的吧？所以就尝试捡回之前的老传统，给这一年重要的朋友们写新年祝福：大概写了个五六十份吧，回应寥寥—— 大家都变忙了啊；虽然确实少了许多成就感，但是表达感谢还是个人的态度问题，肯定是没有什么问题的吧== 熊出没：重返地球 本来只是看各个论坛老哥尬吹，图一乐的电影；但是出乎意料的带制作；虽然剧情是典中典的几个主题的集合，但是主要故事讲得好就是好电影！作为一个国产的子供向电影，它已经极力地在给孩子们塑造正确的价值观：不管是如同小丑一般的不理智彩民，还是因为破坏地球而遭到报复的猫人—— 虽然可以说是正能量要素过多吧，但是给孩子看的或许真的应该这样。 大概这就是国漫之光的含金量吧。虽然不想承认，但是我确实觉得真好。当从最开始被他的乐子吸引体现自己内心的成熟啊对对对到一个沉默的观众去欣赏它的时候，它就已经赢了，没什么好否认的。 前端娱乐 说是说前端娱乐，可是我感觉差不多也该到一个极限了：要是再想要娱乐得去潜下心来学点东西了。老实说今年我几乎一整年都没有在这方面做过什么，折腾的水平甚至还有所退步（？）随便上网冲浪发现全都是我没听过的新玩意，只能说再不学就要成为时代的累赘了== 去年寒假搞的黄油记录本因为域名被墙了一会导致我疑神疑鬼找了个好借口偷懒直接就没有更新了，不过后来来看境外无法备案的域名，挂在 Vercel 这种公交车上的网站偶尔抽风似乎也合情合理没处说理，也难怪 *.moe 域名确实都不建议买…… 但是除开域名问题，就我个人而言还是很希望有这样一个网站的，所以从写代码开始（？）打算重建： ……但是显然我没有去年的定力其实去年也没有了，最后也是做的半半拉拉不了了之；不过毕竟今年有很多外部因素扰乱心智，倒也情有可原就是了（？）回学校之后还是尽量开起来吧，毕竟做什么事情都是一个坚持嘛—— Galgame 群的你画我猜 拿了第三，感觉还行。虽然这游戏总感觉已经过去好久了，但是似乎确实每次都能给整出点新活来== 二次元记录 虽然没有能足够称得上是二次元总结的东西，但是寒假确实也有不算少的相关娱乐： 女仆咖啡巧克拉 丸户女仆咖啡系列三部曲中的第一部；这个时候的丸户虽然已经展现出他的才华，但是对故事整体上的塑造仍然稍显青涩；当然，整个游戏除了三位密切相关的女主，其他的女主的线路可以说是充话费送的，但一旦回到主要的线路上，丸户就可以塑造出细腻的，让人感到“很有味道”的女主角。 发生在咖啡馆的故事，市面上可多的去了；但是能把日常写的这样欢乐而不失趣味的却并不多。愉快的日常可以让人会心一笑，家人团结一心度过各种困难也恰好可以反应 famile 的主题，再加上神秘但是又理所应当的精灵巧克尔，如梦似幻的温馨故事大概就这么构成了。 大概丸户的白二构思从这个时候就开始初现端倪了；翠和香奈子都倾心于男主，但是却因为各种原因维持着并不妙的关系直到最后无法维稳；香奈子和男主明明互相倾慕，但是却因为意外和误会，最终变成了这样互相伤害；游戏对于每一个角色都设定先 BE 才给 TE，体会到了没有人幸福的苦闷后，才更加发自内心的喜欢上了这样一往情深，坚强但是又弱小的女孩子，给予 TE 中的他们衷心的祝福：可喜可贺，可喜可贺。 但是我好心疼翠啊…… 因为内疚而一直止步不前的翠为男主奉献了太多太多，但是人真的不能背叛自己的感情：每个人都值得去依靠他人…… 说不清了，希望在恋爱中每一个默默付出的人都能收获美好的爱情。 我肯定会再玩的。 弹丸论破V3 我算是入了弹丸论破的大坑了，即使 V3 的评价是如此的两极分化我还是忍不住地去玩了。 听说这次小高叫了专业的写手来设计案件，所以本作的案件比起之前的案件要更加倾向于机关精巧的设计，而不再是对于角色特点的依赖。个人觉得第四个和第五个案子有些拉跨—— 第五个案子其实本就设定来看还是相当精彩的，也出色地塑造了王马这个角色，但是在当前玩家和幸存者所掌握的信息来看，这就是理想化的冒险—— 毕竟当时还没有人能保证黑白熊不撕票，本质都是口嗨所以少了点说服力。 那么到了万众瞩目的第六章，这样的展开确实也早有预料，所以个人觉得还行；上网随便冲浪，大家对这部作品的差评大多数是被第六章激怒—— 但是作为以“谎言”为主题的本作，我觉得这样倒也恰得其所：玩家可以使用谎言引导审判回归正轨，游戏主持可以用谎言去欺骗幸存者，小高也可以用弹丸论破作为谎言散播绝望（不是） 但是从另一个方面来看，这游戏还有其他令我感到疑惑的地方：看到了真结局之后，我不由得想知道玩家和幸存者做的一切的意义是什么？答案其实也很显而易见：一切都毫无意义—— 单薄无力，但是又能够震撼玩家的内心；为了解决这一形而上的问题，玩家只能质问自己的内心：但是这并不同于质疑活着的意义，玩家直面自己的内心所需要付出的代价只是思考玩这个游戏的原因—— 这大概也算是恶评的一个来源吧。上网冲浪看到了有的玩家戏称本作为小高的辞职信，如果是真的还挺有意思的。 我并不喜欢通过作品的结局来给作品评个三六九等；作品并不是说只有取悦玩家和创作者自嗨两种—— 它们之间也并不对立。至于本作的结局，虽然确实并没有许以玩家希望，但是也并不妨碍它作为一个整体的组成部分而言十分优秀，也给了玩家相当的冲击；以至于我并不能讨厌的起来虽然确实有点不太舒服。 扯了些有的没的，我个人还是推荐去玩一玩这作的。虽然本作确实充满了欺诈，但是我觉得这也是作为 IP 的续作权衡各种要素所得到的一个优解，毕竟我想骂玩家的游戏如果骂的有理有据，玩家还是会干了这杯拍手叫好：“好骂！”的。但是后几个案件拉也是真的不太行，只能说没什么评价了。 主播女孩重度依赖 某日上网冲浪，看到一个游戏的宣传视频中出现了“我看到了海，所以我不再害怕”的字样，我 DNA 直接动了，再一看是说主播的游戏，于是就插了个眼准备图一乐，却没想到真的有点东西： 本来只是想着截图玩梗来着，结果越玩越觉得真实；真实感不仅体现在游戏的各种文本中，还表现在糖糖这一形象的塑造上：大概每个人都有阴湿的一面吧，很多时候我甚至能与她共情—— 但是我们不会成为メンヘラ。此外这个作者也玩的一手好毒电波：大概我也是互联网重度依赖患者吧，但是过量就是剧毒呢（笑） 另外值得一提的就是本作的本地化做的堪称一绝，一度让我产生了一种我在国产游戏，在中国互联网上冲浪的错觉。虽然在游戏中的聊天对于糖糖的回复被限制在了 8 个表情里，但是将它们发给各路网友也毫无违和。大概这也是这个当代网络的真实写照的一部分吧。 明明是个乐子游戏，却最后还是打了全结局；到底是谁依赖谁呢？还是远离互联网糖块，自己去抓住未来吧！ 互联网我cnm！你他妈把多少人的生活都给毁了！ ペトリコール Mellow 的纯爱小拔作。感觉不如少女 Minority，至少我到最后都没有对女主产生多少喜爱之情。当然，作为钦定女苦主的鈴谷まや配的女主还是那么的熟悉—— 不过毕竟是拔作，所以也就不多做要求了。 故事还是典型的失足少女用从男主身上寻求慰籍这种过分但是又不那么过分的手段从钦定原配身边逐渐合法地夺走男主作为展开，本不该出现的她再次进入了他的生活—— 然后和他和他那可怜的女苦主拉扯。终于男主得以走进失足少女的内心，对此表示理解并用实际行动填补了她心中的空白，可喜可贺：终于，我不再讨厌雨后的味道—— 这一环境要素作为线索，也使得故事也沾上了如同初雨渐停的忧伤的味道。 不过不得不说这种展开实在是太好用了；毕竟寻求慰籍多半是遇到什么事儿了，这样的背景设定本就可以恰到好处的吸引玩家的注意，唤起男性玩家的保护欲；随着进一步的了解再娓娓道来，最后他们互相理解并幸福的在一起，这实在是过于正义—— 原配的撕心裂肺似乎也难以唤回男主的心；而且在这个过程中，还可以尽情的体现原配的可怜，对于男主的依赖—— 就算一不小心原配比外卖更受欢迎也方便玩家下台阶不是？ 梦乃唱歌还是行啊。但是反过来思考，这群人除了梦乃的歌之外还剩下什么呢？ 混蛋必须死，扫黑除恶不能停 〇〇病栋 没什么好说的，听说它游戏化上了 steam 所以立即前往图一乐；没想到它们真的能请的到风音；听说还有下半部，只能说到时候又能拿来图一乐== 创作彼女的恋爱公式 发售之前就有群友说这作怎么怎么，发售以来也与我颇有渊源（大雾）的，看起来制作十分精良的游戏；但是真的玩还是因为有人对比本作的女主逢樱和星奏，所以我也决定一看究竟—— 我的评价是平庸—— 工藤搁着创业就这？男主可以说是除了有点才华之外啥都没有的超级样板后宫王，基本没有起到除了和女主卿卿我我之外的任何作用，甚至某些地方为了呼应这一主题而偏执的令人感到有些反感；诚然，杜鹃啼血并不是什么没有高度的主题，想要为了创作奉献自己可以，但是能不能让玩家心服口服？我突然病了，我想逃避，我迷茫，你男主开光嘴搁着嘴炮几句，我就得搭上老命了？你寄吧谁啊？ …… 嗯，现在进行简单的理性分析。我不否认游戏最开始的几章还是颇有恋彼女感觉的：男主也是极具洸太郎的风范，同样是青春伤痛，擦肩而过的恋爱。但是我没有想到的是，作为对于真女主这样一个相对重要的伏笔，却在共同线进行了一半的时候就以对过去的自己和解草草收尾。当然，除了这样的片段，本作的很多片段单独拎出来似乎都是相当浪漫的桥段，但是桥段和角色，和作者的目的之间却似乎是割裂的—— 导致的结果是虽然故事情节很美，但是却言之无物：男主还是那个有些偏执的花花公子，逢樱还是那个写作青梅竹马读作对手的过客。 另一个想要吐槽的地方就是本作工藤并没有忘记点题，但是点的题却不是创作，而是公式；恋爱当然没有公式，我想如果随便写一个校园青春恋爱故事，多来几条线路这么说也并不冲突；作为作家自称的“写给创作者的故事”，作为主线的创作要素却几乎难以寻觅，但是却要借以这个名义献祭逢樱：工藤，你好过分！但是即使是献祭逢樱，作者的“春秋笔法”也极大地冲淡了这个事件的冲击力，难道是为了雰囲気いい这个 Tag 吗？但是这样的后果只能说要感情没感情，要深度没深度…… 到底是图个啥呢？ 和群友吐槽的时候群友一边破口大骂一边给我看了他打完了体验版后 YY 的大纲；说句实话，我觉得比现在好。 当然，值得一提的是作为非真女主的桐叶线写的颇有真实感—— 虽然创作的要素依然单薄，但是好歹算是情节跌宕起伏，男主也终于为把他奶起来的后宫成员做点什么实在的事情—— 然后光速 ED，行吧== 此外，有叶超超超超超进化的 CG 和志水相当清新的 BG 也使得这一作赏心悦目：其实本作除了剧本之外的硬件条件都相当优秀，明明是小品作的文本，但是卖 9800 也并不让我觉得过分…… 只能说可惜了带制作。 水夏 其实并没有打完。马戏团的早期作品系统实在有点叫人好受…… 由四个略带神秘的乡下温馨的小故事组成。虽然名义上四个小故事互不相干，但是却被若有若无的线微妙的联系在一起—— 清凉的夏天，清爽可口的恋情以及漂浮在小镇的疯狂—— 这样说的话，这些小故事大概就可以归于怪谈一类了。似乎这个时段怪谈作品还挺多的（笑） 夏日的清凉可能并不只有清风，还有埋藏在小镇的疯狂。其实除了最后一个故事的无名氏之外，本作并没有太多的超自然要素，但是却有着嫉妒着双胞胎但却相信着死人重生的幼驯染，以及和外科医生一样了解人体结构的孤僻的画家…… 我并不是很会欣赏悬疑作品，但是也可以感受到《九相图》逆转的讽刺和荒诞。 此外，本作背景音乐虽然不多，但是可以说首首精品；能将这样的清凉夏色的氛围展现在玩家面前，这些 BGM 都功不可没—— 比起从共用素材库下载可高太多了。 最后再回过头想想水夏的含义，似乎又与刚才产生了细微的区别：水不再是清凉的别称，反倒是给了我一种水雾凝于眼前，让人捉摸不透的神秘。而这水究竟是谁的泪水或是别的什么，那就不得而知了。 最后再来点图一乐：当时的御影的笔法还是青涩啊，我还是第一次看到把害怕太阳的学姐比喻成很耐热但是弱明火的泡沫聚苯乙烯这种说法，只能说学到许多ww 冥婚交友中心 情趣寿衣.jpg 同样是作为图一乐的游戏，实际体验却比想象中好完整不少；很多国 G 似乎真的忘记了国人之间是怎么插科打诨讲段子的，建议在写剧本之前先默念文化自信好吧（）本作对于这方面处理的还算成功克制了翻译腔就算成功，至少作为玩家来看并不感到感到尴尬。 不多评价剧情。黄毛可爱，达到了日本那边单线作品的及格线了毕竟玩起来真的不觉得无聊；黑毛线虽然作者似乎想要整活，但是感觉没有写完；但是毕竟是图一乐游戏，所以就这样吧。 作为包含小游戏的Galgame，小游戏其实还算是个相当有讲究的部分—— 无聊则拖剧情后退，而平庸则又显得鸡肋，打扰剧情破坏气氛则更是大忌；本作的几个小游戏设计还算有点意思，结合文本中的各种怪话作为阅读对话的调节而言大概算是完成任务可惜并不好玩不过也没差了。 本作虽然质量一般，但是作为国G而言表现可以。希望某武汉制作组能多看多学 十三机兵防卫圈 本来应该在这里写游戏感想的，但是寒假过的乱七八糟，我几乎没怎么玩这个…… 所以还没有打完。 再次感谢借我游戏机的 zcysky，好兄弟！ 最后 当然，每一个糟糕的寒假的最后肯定都是后悔，明明没有什么意义…… 希望新的阶段可以保证身体健康的情况下提高行动力，多做点事情。"},{"title":"提问的智慧 | How To Ask Questions The Smart Way","date":"2021-04-17T20:27:58.000Z","updated":"2021-04-17T20:27:58.000Z","comments":true,"path":"favorite/bookmarks/How-to-ask-questions-the-smart-way.html","permalink":"https://shiraha.cn/favorite/bookmarks/How-to-ask-questions-the-smart-way.html","excerpt":"","text":"How To Ask Questions The Smart Way Copyright © 2001,2006,2014 Eric S. Raymond, Rick Moen 本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。 原文网址：http://www.catb.org/~esr/faqs/smart-questions.html Copyleft 2001 by D.H.Grand(nOBODY/Ginux), 2010 by Gasolin, 2015 by Ryan Wu 本中文指南是基于原文 3.10 版以及 2010 年由 Gasolin 所翻译版本的最新翻译； 目录 声明 简介 在提问之前 当你提问时 慎选提问的论坛 Stack Overflow 网站和 IRC 论坛 第二步，使用项目邮件列表 使用有意义且描述明确的标题 使问题容易回复 用清晰、正确、精准且语法正确的语句 使用易于读取且标准的文件格式发送问题 精确地描述问题并言之有物 话不在多而在精 别动辄声称找到 Bug 低声下气不能代替你的功课 描述问题症状而非你的猜测 按发生时间先后列出问题症状 描述目标而不是过程 别要求使用私人电邮回复 清楚明确的表达你的问题以及需求 询问有关代码的问题时 别把自己家庭作业的问题贴上来 去掉无意义的提问句 即使你很急也不要在标题写紧急 礼多人不怪，而且有时还很有帮助 问题解决后，加个简短的补充说明 如何解读答案 RTFM 和 STFW：如何知道你已完全搞砸了 如果还是搞不懂 处理无礼的回应 如何避免扮演失败者 不该问的问题 好问题与蠢问题 如果得不到回答 如何更好地回答问题 相关资源 鸣谢 声明 许多项目在他们的使用协助/说明网页中链接了本指南，这么做很好，我们也鼓励大家都这么做。但如果你是负责管理这个项目网页的人，请在超链接附近的显著位置上注明： 本指南不提供此项目的实际支持服务！ 我们已经深刻领教到少了上述声明所带来的痛苦。因为少了这点声明，我们不停地被一些白痴纠缠。这些白痴认为既然我们发布了这本指南，那么我们就有责任解决世上所有的技术问题。 如果你因寻求某些帮助而阅读本指南，并在离开时还觉得可以从本文作者这里得到直接帮助，那你就是我们之前说的那些白痴之一。别问我们问题，我们只会忽略你。我们在这本指南中是教你如何从那些真正懂得你所遇到软件或硬件问题的人取得协助，而 99% 的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。 简介 在黑客的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确的提问以获得你满意的答案。 不只是黑客，现在开源（Open Source）软件已经相当盛行，你常常也可以由其他有经验的使用者身上得到好答案，这是件好事；使用者比起黑客来，往往对那些新手常遇到的问题更宽容一些。然而，将有经验的使用者视为黑客，并采用本指南所提的方法与他们沟通，同样也是能从他们身上得到满意回答的最有效方式。 首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发他们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，\"好问题！\"是诚挚的大力称赞。 尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。 我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 —— 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 失败者（撸瑟） （由于历史原因，我们有时把它拼作 lusers）。 我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们了解这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们回答问题的风格是指向那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就是在降低做自己最擅长的事情上的效率。 我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答赢家（winner）的问题。 如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 —— 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。 所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 —— 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。 如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 —— 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。 （欢迎对本指南提出改进意见。你可以 email 你的建议至 esr@thyrsus.com 或 respond-auto@linuxmafia.com。然而请注意，本文并非网络礼节的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议）。 在提问之前 在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情： 尝试在你准备提问的论坛的旧文章中搜索答案。 尝试上网搜索以找到答案。 尝试阅读手册以找到答案。 尝试阅读常见问题文件（FAQ）以找到答案。 尝试自己检查或试验以找到答案。 向你身边的强者朋友打听以找到答案。 如果你是程序开发者，请尝试阅读源代码以找到答案。 当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所学到的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。 运用某些策略，比如先用 Google 搜索你所遇到的各种错误信息（搜索 Google 论坛和网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 我在 Google 中搜过下列句子但没有找到什么有用的东西 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。 别着急，不要指望几秒钟的 Google 搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。 准备好你的问题，再将问题仔细的思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。 小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着蠢问题…， 一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。 绝不要自以为够格得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去挣到一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 —— 一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。 另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。谁能给点提示？、我的这个例子里缺了什么？以及我应该检查什么地方比请把我需要的确切的过程贴出来更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。 当你提问时 慎选提问的论坛 小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者： 在与主题不合的论坛上贴出你的问题。 在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然。 在太多的不同新闻群组上重复转贴同样的问题（cross-post）。 向既非熟人也没有义务解决你问题的人发送私人电邮。 黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。 因此，第一步是找到对的论坛。再说一次，Google 和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括阅读 FAQ）都没有结果，网站上也许还有报告 Bug（Bug-reporting）的流程或链接，如果是这样，链过去看看。 向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 —— 如果你不确定，那就向别处发送，或者压根别发。 在选择论坛、新闻群组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。 别像机关枪似的一次\"扫射\"所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。 搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于 Unix 或 Windows 操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。 一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。 可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 —— 已经好几次了，一些热门软件的作者从自己软件的支持中抽身出来，因为伴随而来涌入其私人邮箱的无用邮件变得无法忍受。 Stack Overflow 搜索，然后 在 Stack Exchange 问。 近年来，Stack Exchange 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。 因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的机率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。 Stack Exchange 已经成长到超过一百个网站，以下是最常用的几个站： Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。 Stack Overflow 是问写程序有关的问题。 Server Fault 是问服务器和网管相关的问题。 网站和 IRC 论坛 本地的使用者群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表）， 这些地方是开始提问的好首选，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。有广告赞助的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。 事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复 \"用我们的版本\"。 在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。 通过论坛或 IRC 频道来提供使用者支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。 在使用 IRC 的时候，首先最好不要发布很长的问题描述，有些人称之为频道洪水。最好通过一句话的问题描述来开始聊天。 第二步，使用项目邮件列表 当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法： 任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。 向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。 大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。 如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。 如果一个项目既有\"使用者\" 也有\"开发者\"（或\"黑客\"）邮件列表或论坛，而你又不会动到那些源代码，那么就向\"使用者\"列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。 然而，如果你确信你的问题很特别，而且在\"使用者\" 列表或论坛中几天都没有回复，可以试试前往\"开发者\"列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意） 如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。 使用有意义且描述明确的标题 在邮件列表、新闻群组或论坛中，大约 50 字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的帮帮忙、跪求、急（更别说救命啊！！！！这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而应该是在这点空间中使用极简单扼要的描述方式来提出问题。 一个好标题范例是目标 —— 差异式的描述，许多技术支持组织就是这样做的。在目标部分指出是哪一个或哪一组东西有问题，在差异部分则描述与期望的行为不一致的地方。 蠢问题：救命啊！我的笔记本电脑不能正常显示了！ 聪明问题：X.org 6.8.1 的鼠标光标会变形，某牌显卡 MV1005 芯片组。 更聪明问题：X.org 6.8.1 的鼠标光标，在某牌显卡 MV1005 芯片组环境下 - 会变形。 编写目标 —— 差异 式描述的过程有助于你组织对问题的细致思考。是什么被影响了？ 仅仅是鼠标光标或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在 6.8.1 版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境和你遇到的问题。 总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。 如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 Re: 测试 或者 Re: 新 bug 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。 对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许使用者按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。 仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。 在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你只想在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。 使问题容易回复 以请将你的回复发送到……来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，换个好点的；如果是操作系统不支持这种邮件程序，也换个好点的。 在论坛，要求通过电子邮件回复是非常无礼的，除非你认为回复的信息可能比较敏感（有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如追踪此讨论串、有回复时发送邮件提醒等功能。 用清晰、正确、精准且语法正确的语句 我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。 正确的拼写、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 —— 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它必须很准确，而且有迹象表明你是在思考和关注问题。 正确地拼写、使用标点和大小写，不要将its混淆为it's，loose搞成lose或者将discrete弄成discreet。不要全部用大写，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。Alan Cox 也许可以这样做，但你不行）。 更白话的说，如果你写得像是个半文盲[译注：小白]，那多半得不到理睬。也不要使用即时通信中的简写或火星文，如将的简化为d会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。 如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。 如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的： [译注：以下附上原文以供使用] English is not my native language; please excuse typing errors. 英文不是我的母语，请原谅我的错字或语法。 If you speak $LANGUAGE, please email/PM me; I may need assistance translating my question. 如果你说某语言，请寄信/私讯给我；我需要有人协助我翻译我的问题。 I am familiar with the technical terms, but some slang expressions and idioms are difficult for me. 我对技术名词很熟悉，但对于俗语或是特别用法比较不甚了解。 I've posted my question in $LANGUAGE and English. I'll be glad to translate responses, if you only use one or the other. 我把我的问题用某语言和英文写出来，如果你只用一种语言回答，我会乐意将其翻译成另一种。 使用易于读取且标准的文件格式发送问题 如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以： 使用纯文字而不是 HTML (关闭 HTML 并不难）。 使用 MIME 附件通常是可以的，前提是真正有内容（譬如附带的源代码或 patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。 不要发送一段文字只是一行句子但自动换行后会变成多行的邮件（这使得回复部分内容非常困难）。设想你的读者是在 80 个字符宽的终端机上阅读邮件，最好设置你的换行分割点小于 80 字。 但是，对一些特殊的文件不要设置固定宽度（譬如日志档案拷贝或会话记录）。数据应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。 在英语论坛中，不要使用Quoted-Printable MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持这种编码。当它们处理换行时，那些文本中四处散布的=20符号既难看也分散注意力，甚至有可能破坏内容的语意。 绝对，永远不要指望黑客们阅读使用封闭格式编写的文档，像微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你家门口时你的反应一样。即便他们能够处理，他们也很厌恶这么做。 如果你从使用 Windows 的电脑发送电子邮件，关闭微软愚蠢的智能引号功能 （从[选项] &gt; [校订] &gt; [自动校正选项]，勾选掉智能引号单选框），以免在你的邮件中到处散布垃圾字符。 在论坛，勿滥用表情符号和HTML功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是对答案感兴趣。 如果你使用图形用户界面的邮件程序（如微软公司的 Outlook 或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的查看源代码命令，用它来检查发送文件夹中的邮件，以确保发送的是纯文本文件同时没有一些奇怪的字符。 精确地描述问题并言之有物 仔细、清楚地描述你的问题或 Bug 的症状。 描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：Fedora Core 4、Slackware 9.1等）。 描述在提问前你是怎样去研究和理解这个问题的。 描述在提问前为确定问题而采取的诊断步骤。 描述最近做过什么可能相关的硬件或软件变更。 尽可能的提供一个可以重现这个问题的可控环境的方法。 尽量去揣测一个黑客会怎样反问你，在你提问之前预先将黑客们可能遇到的问题回答一遍。 以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。 Simon Tatham 写过一篇名为《如何有效的报告 Bug》的出色文章。强力推荐你也读一读。 话不在多而在精 你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。 这样做的用处至少有三点。 第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加； 第二，简化问题使你更有可能得到有用的答案； 第三，在精炼你的 bug 报告的过程中，你很可能就自己找到了解决方法或权宜之计。 别动辄声称找到 Bug 当你在使用软件中遇到问题，除非你非常、非常的有根据，不要动辄声称找到了 Bug。提示：除非你能提供解决问题的源代码补丁，或者提供回归测试来表明前一版本中行为不正确，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的Bug，你应该能提供相应位置的修正或替代文件。 请记得，还有许多其它使用者没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前已经做了这些，是吧？）。这也意味着很有可能是你弄错了而不是软件本身有问题。 编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了 Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。当你在标题中嚷嚷着有Bug时，这尤其严重。 提问时，即使你私下非常确信已经发现一个真正的 Bug，最好写得像是你做错了什么。如果真的有 Bug，你会在回复中看到这点。这样做的话，如果真有 Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。 低声下气不能代替你的功课 有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 —— 低声下气：我知道我只是个可悲的新手，一个撸瑟，但...。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。 别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。 有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。 描述问题症状而非你的猜测 告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。 蠢问题 我在编译内核时接连遇到 SIG11 错误， 我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？ 聪明问题 &gt; 我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6/233 CPU（威盛 Apollo VP2 芯片组）， &gt; 256MB Corsair PC133 SDRAM 内存，在编译内核时，从开机 20 分钟以后就频频产生 SIG11 错误， &gt; 但是在头 20 分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作 20 分钟。 &gt; 所有内存都换过了，没有效果。相关部分的标准编译记录如下…。 由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：所有的诊断专家都来自密苏里州。 美国国务院的官方座右铭则是：让我看看（出自国会议员 Willard D. Vandiver 在 1899 年时的讲话：我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方的展示给我们看吧！ 按发生时间先后列出问题症状 问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如 20 行）记录会非常有帮助。 如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，多不等于好。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。 如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。 描述目标而不是过程 如果你想弄清楚如何做某事（而不是报告一个 Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。 经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。 蠢问题 &gt; 我怎样才能从某绘图程序的颜色选择器中取得十六进制的的 RGB 值？ 聪明问题 &gt; 我正试着用替换一幅图片的色码（color table）成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块（table slot）， &gt; 但却无法从某绘图程序的颜色选择器取得十六进制的的 RGB 值。 第二种提问法比较聪明，你可能得到像是建议采用另一个更合适的工具的回复。 别要求使用私人电邮回复 黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者可以得到一些奖励，奖励就是他的能力和学识被其他同行看到。 当你要求私下回复时，这个过程和奖励都被中止。别这样做，让回复者来决定是否私下回答 —— 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人没有兴趣。 这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是向我发电邮，我将为论坛归纳这些回复。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 —— 但你必须信守诺言。 清楚明确的表达你的问题以及需求 漫无边际的提问是近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。 如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。 要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。 所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你有用答案相当有帮助 —— 但这技巧通常和简化问题有所区别。因此，问我想更好的理解 X，可否指点一下哪有好一点说明？通常比问你能解释一下 X 吗？更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。 询问有关代码的问题时 别要求他人帮你调试有问题的代码，不提示一下应该从何入手。张贴几百行的代码，然后说一声：它不能工作会让你完全被忽略。只贴几十行代码，然后说一句：在第七行以后，我期待它显示 &lt;x&gt;，但实际出现的是 &lt;y&gt;比较有可能让你得到回应。 最有效描述程序问题的方法是提供最精简的 Bug 展示测试用例（bug-demonstrating test case）。什么是最精简的测试用例？那是问题的缩影；一小个程序片段能刚好展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试用例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译/直译/被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试用例越小越好（查看话不在多而在精一节）。 一般而言，要得到一段相当精简的测试用例并不太容易，但永远先尝试这样做的是种好习惯。这种方式可以帮助你了解如何自行解决这个问题 —— 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。 如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。 别把自己家庭作业的问题贴上来 黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由你来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。 如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在使用者群组，论坛或（最后一招）在项目的使用者邮件列表或论坛中提问。尽管黑客们会看出来，但一些有经验的使用者也许仍会给你一些提示。 去掉无意义的提问句 避免用无意义的话结束提问，例如有人能帮我吗？或者这有答案吗？。 首先：如果你对问题的描述不是很好，这样问更是画蛇添足。 其次：由于这样问是画蛇添足，黑客们会很厌烦你 —— 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：没错，有人能帮你或者不，没答案。 一般来说，避免用 是或否、对或错、有或没有类型的问句，除非你想得到是或否类型的回答。 即使你很急也不要在标题写紧急 这是你的问题，不是我们的。宣称紧急极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，紧急这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 —— 你希望能看到你问题的人可能永远也看不到。 有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。 当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如紧急：帮我救救这个毛绒绒的小海豹！肯定让你被黑客忽略或惹恼他们，即使他们认为毛绒绒的小海豹很重要。 如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。 礼多人不怪，而且有时还很有帮助 彬彬有礼，多用请和谢谢您的关注，或谢谢你的关照。让大家都知道你对他们花时间免费提供帮助心存感激。 坦白说，这一点并没有比清晰、正确、精准并合法语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的 Bug 报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教给我们什么来评价问题的价值的） 然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。 （我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得先谢了意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说先谢了，然后事后再对回复者表示感谢，或者换种方式表达感激，譬如用谢谢你的关注或谢谢你的关照。） 问题解决后，加个简短的补充说明 问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。 最理想的方式是向最初提问的话题回复此消息，并在标题中包含已修正，已解决或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串问题 X和问题 X - 已解决的潜在回复者就明白不用再浪费时间了（除非他个人觉得问题 X的有趣），因此可以利用此时间去解决其它问题。 补充说明不必很长或是很深入；简单的一句你好，原来是网线出了问题！谢谢大家 – Bill比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。 对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此之后才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。 除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表/新闻群组/论坛中搜索到真正解决你问题的方案，让他们也从中受益。 至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。 思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。 在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。 如何解读答案 ### RTFM 和 STFW：如何知道你已完全搞砸了 有一个古老而神圣的传统：如果你收到RTFM （Read The Fucking Manual）的回应，回答者认为你应该去读他妈的手册。当然，基本上他是对的，你应该去读一读。 RTFM 有一个年轻的亲戚。如果你收到STFW（Search The Fucking Web）的回应，回答者认为你应该到他妈的网上搜索。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 Google 是你的朋友！） 在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。 通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为 你需要的信息非常容易获得； 你自己去搜索这些信息比灌给你，能让你学到更多。 你不应该因此不爽；依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见。你应该对他祖母般的慈祥表示感谢。 如果还是搞不懂 如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。 比方说，如果我回答你：看来似乎是 zentry 卡住了；你应该先清除它。，然后，这是一个很糟的后续问题回应：zentry 是什么？ 好的问法应该是这样：哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？ 处理无礼的回应 很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。 如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这没有发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而你将被视为有错的一方，这将伤害到你获取信息或帮助的机会。 另一方面，你偶尔真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。 （有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会正常交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们喜欢我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑）。 Jeff Bigler 的观察总结和这个相关也值得一读 (tact filters)。 在下一节，我们会谈到另一个问题，当你行为不当时所会受到的冒犯。 如何避免扮演失败者 在黑客社区的论坛中有那么几次你可能会搞砸 —— 以本指南所描述到的或类似的方式。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。 这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反地，你该这么做： 熬过去，这很正常。事实上，它是有益健康且合理的。 社区的标准不会自行维持，它们是通过参与者积极而公开地执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。 也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称如果你不想帮助用户就闭嘴。 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的唠叨与无用的技术论坛。 夸张的讲法是：你要的是“友善”（以上述方式）还是有用？两个里面挑一个。 记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心你和他的社区而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现得有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。 有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是真的会把问题搞砸。 这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。 也别让自己卷入口水战，最好不要理睬大多数的口水战 —— 当然，这是在你检验它们只是口水战，并且未指出你有搞砸的地方，同时也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。 不该问的问题 以下是几个经典蠢问题，以及黑客没回答时心中所想的： 问题：我能在哪找到 X 程序或 X 资源？ 问题：我怎样用 X 做 Y？ 问题：如何设定我的 shell 提示？ 问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？ 问题：我的程序/设定/SQL 语句没有用 问题：我的 Windows 电脑有问题，你能帮我吗？ 问题：我的程序不会动了，我认为系统工具 X 有问题 问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？ 问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？ &gt; 问题：我能在哪找到 X 程序或 X 资源？ 回答：就在我找到它的地方啊，白痴 —— 搜索引擎的那一头。天哪！难道还有人不会用 Google 吗？ &gt; 问题：我怎样用 X 做 Y？ 回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。 &gt;问题：如何设定我的 shell 提示？？ 回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 RTFM，然后自己去找出来。 &gt; 问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？ 回答：试试看就知道了。如果你试过，你既知道了答案，就不用浪费我的时间了。 &gt; 问题：我的{程序/设定/SQL 语句}不工作 回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 —— 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种 你还有什么要补充的吗？ 真糟糕，希望你能搞定。 这关我屁事？ &gt; 问题：我的 Windows 电脑有问题，你能帮我吗？ 回答：能啊，扔掉微软的垃圾，换个像 Linux 或 BSD 的开源操作系统吧。 注意：如果程序有官方版 Windows 或者与 Windows 有互动（如 Samba），你可以问与 Windows 相关的问题， 只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。 &gt; 问题：我的程序不会动了，我认为系统工具 X 有问题 回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库档案有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。 &gt; 问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？ 回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在这儿找到使用者群组的清单）。 注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地使用者群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 Linux 和所有被怀疑的硬件作关键词仔细搜索。 &gt; 问题：我怎么才能破解 root 帐号/窃取 OP 特权/读别人的邮件呢？ 回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！ 好问题与蠢问题 最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。 蠢问题： 我可以在哪儿找到关于 Foonly Flurbamatic 的资料？ 这种问法无非想得到 STFW 这样的回答。 聪明问题： 我用 Google 搜索过 \"Foonly Flurbamatic 2600\"，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？ 这个问题已经 STFW 过了，看起来他真的遇到了麻烦。 蠢问题： 我从 foo 项目找来的源码没法编译。它怎么这么烂？ 他觉得都是别人的错，这个傲慢自大的提问者。 聪明问题： foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？ 提问者已经指明了环境，也读过了 FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。 蠢问题： 我的主机板有问题了，谁来帮我？ 某黑客对这类问题的回答通常是：好的，还要帮你拍拍背和换尿布吗？，然后按下删除键。 聪明问题： 我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？ 这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。 在最后一个问题中，注意告诉我答案和给我启示，指出我还应该做什么诊断工作之间微妙而又重要的区别。 事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。 通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。 事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候， 一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的名人，而是因为我用了正确的方式来提问。 黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我像个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。 如果得不到回答 如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。 总的来说，简单的重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。 你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。 有许多网上的以及本地的使用者群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。 另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了 —— 完全可能如此 —— 你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。 对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名使用者。根本不可能由一个人来处理来自上万名使用者的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开源软件的要高得多，且内容也没那么丰富）。 如何更好地回答问题 态度和善一点。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。 对初犯者私下回复。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。 如果你不确定，一定要说出来！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。 如果帮不了忙，也别妨碍他。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 —— 有些可怜的呆瓜会把它当成真的指令。 试探性的反问以引出更多的细节。如果你做得好，提问者可以学到点东西 —— 你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。 尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。 如果你决定回答，就请给出好的答案。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（workaround），应推荐更好的工具，重新界定问题。 正面的回答问题！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 试试看 A 或是 B 或者 试试 X 、 Y 、 Z 、 A 、 B 、 C 并附上一个链接一点用都没有。 帮助你的社区从问题中学习。当回复一个好问题时，问问自己如何修改相关文件或常见问题文件以免再次解答同样的问题？，接着再向文件维护者发一份补丁。 如果你是在研究一番后才做出的回答，展现你的技巧而不是直接端出结果。毕竟授人以鱼不如授人以渔。 相关资源 如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅 Unix 系统和网络基本原理。 当你发布软件或补丁时，试着按软件发布实践操作。 鸣谢 Evelyn Mitchel 贡献了一些愚蠢问题例子并启发了编写如何更好地回答问题这一节， Mikhail Ramendik 贡献了一些特别有价值的建议和改进。"}],"posts":[{"title":"对于 npm 中 Dependencies 以及一些杂项的小结","slug":"simple-summary-of-dependencies-and-misc-in-npm","date":"2022-03-11T06:54:54.000Z","updated":"2022-03-11T06:54:54.000Z","comments":true,"path":"2022/simple-summary-of-dependencies-and-misc-in-npm/","link":"","permalink":"https://shiraha.cn/2022/simple-summary-of-dependencies-and-misc-in-npm/","excerpt":"","text":"一些关于 npm 中依赖和版本号的小结。知识盲区实在是太多了！ npm 中的依赖 npm 中的依赖主要有 dependencies、devDependencies 和 peerDependencies。 dependencies vs. devDependencies 顾名思义，前者是在生产环境和开发环境中都使用的包，而后者是仅在开发环境中使用的包。 比如 gulp、webpack 就是典型的只在开发环境中使用的包，无需打包到产品中。 开发环境和生产环境，可以通过 NODE_ENV=production|development 来指定。 对于 npm 而言，安装两种不同的依赖需要指定的完整标志分别是 --save 和 --save-dev。 peerDependencies 对于一般的 dependencies 的场合：如果我们有包 A 引用包 B 作为依赖，而我们在我们的项目中安装了包 A 作为依赖，那么实际上只有包 A 被安装到了我们的项目的 node_modules 中，包 B 实际上被安装到了包 A 安装目录下的 node_modules 中。这带来的结果是，虽然包 A 和包 B 都安装过了，我们可以使用 require 引用包 A，但是却不可以直接在我们的项目中引用包 B。 但是如果在包 A 中，包 B 是作为 peerDependencies 引入的，那么安装包 A 时，包 B 会被同样安装到我们项目的 node_modules 目录下；此时就可以直接在我们的项目中引用包 B。 综上所述，peerDepenedencies 的含义可以理解为对包管理器的要求：如果你安装了某个包，那么我建议你也安装我的 peerDependencies。 npm2 在安装包时会强制安装包的 peerDependencies，不需要再宿主环境中指定对于这些包的依赖；而 npm3 不再强制安装这些依赖，而是在安装结束后检查本次安装是否正确；如果发现安装不正确则打印 WARN。不正确包括未安装和版本不匹配两种情况。 而如果出现了这种不正确的问题，只能手动解决：比如手动将这些依赖增加到 package.json 或者修改它们的版本使得这些依赖可以符合要求，然后 npm install --force…… 太蠢了！ 1 WARN using --force I sure hope you know what you are doing npm 版本号规则 整体来说，npm 的版本号的格式是 &lt;major&gt;.&lt;minor&gt;.&lt;patch&gt; 的形式。 版本号匹配规则 出现在 package.json 中的各种依赖包的版本实际上是匹配规则，又被称为 npm 语义化版本。一般来说有以下常用的匹配规则： 写法 含义 version 精确匹配某个特定版本 &gt;version&lt;version&gt;=version &lt;=version 大于、小于、大于等于、小于等于某个特定版本；表示了一个范围将两个规则连写也可以表示一个范围；如：&gt;=version1 &lt;version2 ~version 大致匹配某个版本。具体来说规则如下：1）指定到 &lt;patch&gt;：形如 ~a.b.c；指大于当前指定的版本，但是小于下一个次版本号的所有版本2）指定到 &lt;minor&gt;：形如 ~a.b；指固定主版本号和次版本号，补丁版本号任意3）指定到 &lt;major&gt;：形如 ~a；指固定主版本号，次版本号和补丁任意 ^version 兼容某个版本，其含义是版本号中最左的非 0 版本号的右侧版本可以任意；如 ^a.b.c 实际上等价于 &gt;=a.b.c 和 &lt;a+1.0.0 同时成立；而 ^0.a.b 则等价于 &gt;=0.a.b 和 &lt;0.a+1.0 同时成立；如果缺省了某个低权重的版本号，那么缺失的位置可以任意（此时类似 ~version） 标识符 x 标识符 x 的位置可以填入任何数字 标识符 * 表示任意版本；等价于留空规则；严格的来说等价于 &gt;=0.0.0 version1 - version2 匹配了 [version1, version2] 双闭区间的版本 range1 || range2 操作符 || 可以连接多个范围，表示匹配多个范围内的版本 由此可以看出 npm 语义化版本中有各种各样的模糊和范围，这为前端的工程化引入了一些问题：当某些包升级过程中没有遵循语义化版本，可能会导致每次打包生成代码都不同；所以我们需要特定项目依赖的包的版本号，为此各大包管理器都引入了 lockfile 的机制来锁定项目依赖的版本号。 开源的包一般都不包含 lockfile，其原因可能是为了避免特定过多具体的包导致引用较多开源包重复打包某个包的不同版本使得工程体积膨胀，故只能信任其依赖的包遵循语义化版本的要求，某个小版本/大版本的功能不发生过大变化而可以兼容。 包管理器的 install 和 update 以 npm 为例，安装有 install 和 update 两种命令；它们之间的区别主要体现在两个方面： 对于已安装的模糊版本 install 会忽略模糊版本，而 update 会更新模糊版本至最新版。 对于未安装的包，两者都会直接安装 对于 devDependencies install 会安装/更新 devDependencies，除非指定 --production 标志。 而 update 会忽略 devDependencies，除非指定 --dev 标志。 参考 探讨npm依赖管理之peerDependencies NPM版本号规则以及更新策略 npm install vs. update - what's the difference? Dealing with the deprecation of peerDependencies in NPM 3","categories":[{"name":"Web","slug":"Web","permalink":"https://shiraha.cn/categories/Web/"},{"name":"前端","slug":"Web/前端","permalink":"https://shiraha.cn/categories/Web/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://shiraha.cn/tags/npm/"},{"name":"Web","slug":"Web","permalink":"https://shiraha.cn/tags/Web/"}]},{"title":"考研中的伽马函数","slug":"gamma-function-in-kaoyan","date":"2021-11-03T05:04:25.000Z","updated":"2021-11-09T06:29:30.000Z","comments":true,"path":"2021/gamma-function-in-kaoyan/","link":"","permalink":"https://shiraha.cn/2021/gamma-function-in-kaoyan/","excerpt":"","text":"首先，在概率论里我们经常能遇到一个神秘的不可积的积分： \\[ I = \\int_0^{+\\infty} e^{-t^2} \\text dt \\] 这个积分既不能直接凑出来，也不能使用分部积分法消掉什么；一般，我们会使用升维的方法转化到极坐标来解决这个积分，就大概是下面这样： \\[ I^2 = \\int_0^{+\\infty} e^{-x^2} \\text dx \\cdot \\int_0^{+\\infty} e^{-y^2} \\text dy = \\iint_D e^{-(x^2+y^2)}\\text dx\\text dy \\] 这样，使用极坐标变换可以得到： \\[ I^2 = \\int_0^\\frac\\pi2\\text d\\theta\\int_0^{+\\infty}re^{-r^2}\\text dr = \\frac\\pi2\\left(-\\frac12e^{-r^2}\\Bigg|_0^{+\\infty}\\right) = \\frac\\pi4 \\] 显然被积函数恒大于 0，故 \\(I &gt; 0\\)，综上所述可得：\\(I = \\int_0^{+\\infty} e^{-t^2} \\text dt = \\frac{\\sqrt{\\pi}}2\\)。 每次遇到这种积分都要这样搞一遍实在是有些麻烦，有没有更系统化的方法呢？经过查阅 Wolfram Alpha，得知这种形式的积分可以使用 Gamma 函数表示。 定义 伽马函数也叫欧拉第二积分，是阶乘函数在实数与复数上扩展的一类函数，是阶乘函数在复数域上的延拓。怎么理解这句话呢？首先我们知道阶乘函数定义在正整数离散点上，若对于任何一个非整数，无法使用其定义式求出它的值，因此我们需要对其进行延拓—— 最后得到了如下的定义式： \\[ \\Gamma(x) = \\int_0^{+\\infty}t^{x-1}e^{-t}\\text dt \\] 现在我们只考虑其在实数域且 \\(x &gt; 0\\) 上的情况，毕竟考研只需要这个。 Gamma 函数作为阶乘函数在更广的数域上的延拓，首先它当然满足阶乘函数本来的定义；它具有如下的性质： 阶乘函数：\\(\\Gamma(x) = (x - 1)!\\) 递推关系：\\(\\Gamma(x) = (x-1)\\Gamma(x-1)\\) 那么如何证明这两个性质呢？一般有两种常见的做法： 分部积分法 对于 \\(\\Gamma(k)\\) 的定义式使用分部积分法： \\[ \\int_0^{+\\infty}t^{k-1}e^{-t}\\text dt = \\frac1{k}\\int_0^{+\\infty}e^{-t}\\text dt^{k} = \\frac1{k}\\left(e^{-t}t^{k}\\Bigg|_0^{+\\infty} + \\int_0^{+\\infty}e^{-t}t^{k}\\text dt\\right) \\] 显然，第一项为 0，第二项又是 \\(\\Gamma(k+1)\\) 的定义式，故： \\[ \\Gamma(k) = \\frac1{k}\\int_0^{+\\infty}e^{-t}t^{k} = \\frac{\\Gamma(k + 1)}{k} \\] 就得到了上面性质中说到的递推关系；但是我们现在还缺乏一个初值；对于 \\(\\Gamma(1)\\)： \\[ \\Gamma(1) = \\int_0^{+\\infty}e^{-t}\\text dt = -e^{-t}\\Bigg|_0^{+\\infty} = 1 \\] 结合上面的到的递推公式，就可以得到它和阶乘函数的对应关系。 展开法 这种做法需要一定的技巧性；首先我们可以进行如下的展开： \\[ \\begin{align} &amp;\\frac1{1-x} = \\sum_{k=0}^\\infty x^k &amp;,\\ |x| &lt; 1\\\\ &amp;e^x = \\sum_{k=0}^\\infty \\frac{x^k}{k!} &amp;,\\ x \\in \\R \\end{align} \\] 对于第一个展开式，又有： \\[ \\frac1{1-x} = \\frac1{1-x}\\int_0^{+\\infty}e^{-t} \\text dt = -\\frac1{1-x}\\int_0^{+\\infty}e^{-(1-x)t} \\text d[-(1-x)t] \\] 综上所述，可得： \\[ \\frac1{1-x} = \\int_0^{+\\infty}e^{-t}\\cdot e^{xt} \\text dt \\] 上式右侧的 \\(e^{xt}\\) 也可以利用第二个展开式展开为无穷级数： \\[ \\frac1{1-x} = \\sum_{k=0}^\\infty x^k = \\int_0^{+\\infty}e^{-t}\\cdot \\sum_{k=0}^\\infty \\frac{(xt)^k}{k!} \\text dt = \\sum_{k=0}^\\infty \\frac{\\int_0^{+\\infty}e^{-t}\\cdot t^k \\text dt}{k!} x^k \\] 简单地说，就是在一致收敛域 \\(|x|&lt;1\\) 上，有： \\[ \\sum_{k=0}^\\infty x^k = \\sum_{k=0}^\\infty \\frac{\\int_0^{+\\infty}e^{-t}\\cdot t^k \\text dt}{k!} x^k \\] 对比系数可得 Gamma 函数的定义式： \\[ \\Gamma(k+1) = \\int_0^{+\\infty}e^{-t}\\cdot t^k \\text dt = k! \\] 虽然上述等式需要在一致收敛域上才成立，但是 \\(k\\) 才是函数的参数，因此 \\(k\\in\\R\\) 不受限制。 应用 那么，已经知道了 Gamma 函数，我们应该怎么运用到上述的情况中呢？对于积分 \\(I\\)，我们令 \\(x = \\sqrt t\\)： \\[ I = \\frac12\\int_0^{+\\infty} t^{-\\frac12}e^{-t} \\text dt = \\frac12\\Gamma(\\frac12) = \\Gamma(\\frac32) \\] 因此，我们得到了关键值 \\(\\Gamma(\\frac12) = \\sqrt\\pi\\)。其他的值都可以从这个关键值出发求出； 举例 下面对于几种常见的变换进行示范： \\(\\int_0^{+\\infty} e^{-\\frac12x^2}\\text dx\\) 令 \\(x = \\sqrt{2t}\\)，那么有： \\[ \\int_0^{+\\infty} e^{-\\frac12x^2}\\text dx = \\frac1{\\sqrt2}\\int_0^{+\\infty} t^{-\\frac12}e^{-t}\\text dt = \\frac1{\\sqrt2}\\Gamma(\\frac12) \\] 我们就可以使用关键值快速求出这个积分值 \\(\\int_0^{+\\infty} x^2e^{-\\frac12x^2}\\text dx\\) 同理，令 \\(x = \\sqrt{2t}\\)，那么有： \\[ \\int_0^{+\\infty} x^2e^{-\\frac12x^2}\\text dx = \\frac2{\\sqrt2}\\int_0^{+\\infty} t^\\frac12e^{-t}\\text dt = \\sqrt2\\Gamma(\\frac32) \\] 关键在于使用换元法将原积分转化成 Gamma 函数定义式的形式。 查表 常用的类似积分的查表。 被积函数 \\(\\Gamma\\) 函数 在 \\(\\R^+\\) 上积分值 在 \\(\\R\\) 上的积分值 说明 \\(x^{-\\frac12}e^{-x}\\) \\(\\Gamma(\\frac12)\\) \\(\\sqrt\\pi\\) 不存在 关键值 \\(e^{-x}\\) \\(\\Gamma(1)\\) \\(1\\) 不存在 反常积分 \\(x^{\\frac12}e^{-x}\\) \\(\\Gamma(\\frac32)\\) \\(\\frac{\\sqrt\\pi}2\\) 不存在 \\(xe^{-x}\\) \\(\\Gamma(2)\\) \\(1\\) 不存在 可分部积分 \\(e^{-x^2}\\) \\(\\frac12\\Gamma(\\frac12)\\) \\(\\frac{\\sqrt{\\pi}}2\\) \\(\\sqrt\\pi\\) 关键值 \\(xe^{-x^2}\\) \\(\\frac12\\Gamma(1)\\) \\(\\frac12\\) 不存在 可直接积分 \\(x^2e^{-x^2}\\) \\(\\frac12\\Gamma(\\frac32)\\) \\(\\frac{\\sqrt{\\pi}}4\\) \\(\\frac{\\sqrt{\\pi}}2\\) \\(e^{-\\frac12x^2}\\) \\(\\frac1{\\sqrt2}\\Gamma(\\frac12)\\) \\(\\frac{\\sqrt{2\\pi}}2\\) \\(\\sqrt{2\\pi}\\) \\(xe^{-\\frac12x^2}\\) \\(\\Gamma(1)\\) \\(1\\) 不存在 可直接积分 \\(x^2e^{-\\frac12x^2}\\) \\(\\sqrt2\\Gamma(\\frac32)\\) \\(\\frac{\\sqrt{2\\pi}}2\\) \\(\\sqrt{2\\pi}\\) 部分积分在上面已经进行了推导。 速记 说是速记，其实涉及到了 Gamma 函数的另一种形式；令 \\(t = u^2\\)： \\[ \\Gamma(x) = \\int_0^{+\\infty}t^{x-1}e^{-t}\\text dt = 2\\int_0^{+\\infty}u^{2x-1}e^{-u^2}\\text du \\] 也就得到了 Gamma 函数的另一种表现形式： \\[ \\frac12\\Gamma(x) = \\int_0^{+\\infty}u^{2x-1}e^{-u^2}\\text du \\] 这种情况下和原定义不同；当 \\(u\\) 的次数增加 2，对应的 Gamma 函数的参数增加 1. 虽然看起来很显然，但是在对于考研中各种类似这个的积分，使用这种形式可以快速建立积分和 Gamma 函数之间的关系，从而使用我们记忆的关键值和定义对积分求解。 后记 原来这玩意不管是在汤家凤的高数讲义上还是在张宇概率论9讲上都有提到啊…… 我学的是个寄吧（） 参考资料 伽马函数 - 959 - CSDN博客 - 伽马函数 伽玛函数_百度百科 (baidu.com) 世界上最美丽的函数——γ函数，一颗数学皇冠上的明珠，可以回答分数阶乘的问题 - 知乎 (zhihu.com)","categories":[{"name":"课业","slug":"课业","permalink":"https://shiraha.cn/categories/%E8%AF%BE%E4%B8%9A/"}],"tags":[{"name":"推导","slug":"推导","permalink":"https://shiraha.cn/tags/%E6%8E%A8%E5%AF%BC/"},{"name":"考研数学","slug":"考研数学","permalink":"https://shiraha.cn/tags/%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6/"}]},{"title":"简单数学：从约数个数和到莫比乌斯反演","slug":"sdoi-2015-the-summation-of-divisors","date":"2021-08-05T14:32:56.000Z","updated":"2021-08-08T07:26:40.000Z","comments":true,"path":"2021/sdoi-2015-the-summation-of-divisors/","link":"","permalink":"https://shiraha.cn/2021/sdoi-2015-the-summation-of-divisors/","excerpt":"","text":"差不多算是基础的程度的知识的数论能力，就算已经不参加弹幕神乐的巫女想必也是应该要掌握的吧。 首先来点题目链接：P3327【SDOI2015】约数个数和 - 洛谷 | 2185. 「SDOI2015」约数个数和 - LibreOJ \\(\\text d(x)\\) 是 \\(x\\) 的约数个数，给定 \\(N, M \\le 50000\\)，求： \\[ \\sum_{i=1}^N\\sum_{j=1}^M \\text{d}(ij) \\] 莫比乌斯反演 这个题要用到它，但是我还不会。所以先随便学学吧！ 前置名词 数论函数 定义域为正整数的函数称为数论函数。 积性函数 若 \\(f(x)\\) 是数论函数，且对于 \\(\\forall a,b \\and (a,b)=1\\) 有 \\(f(ab)=f(a)f(b)\\)，那么这样的数论函数称为积性函数。 常见的积性函数有欧拉函数（\\(\\varphi\\)）、莫比乌斯函数（\\(\\mu\\)）和除数函数（\\(\\sigma_k\\)） 完全积性函数 若积性函数不需要 \\((a,b)=1\\) 也能有 \\(f(ab)=f(a)f(b)\\)，那样的 \\(f\\) 就是完全积性函数。 常见的完全积性函数：\\(f(x)=x\\)、\\(1(x)=1\\) Dirichlet 卷积 两个数论函数 \\(f,g\\) 的 Dirichlet 卷积的定义如下： \\[ (f*g)(n)=\\sum_{d\\mid n}f(d)g(\\frac nd) \\] 卷积运算符 \\(*\\) 满足运算的交换律结合律以及对于 \\(+\\) 的分配律；此外，对于满足 \\(h(1)\\ne0\\) 的数论函数 \\(h\\)，卷积运算符还满足了等式的性质，即：\\(f = g \\Leftrightarrow f*h=g*h\\)。 Dirichlet 卷积具有单位元，其单位元 \\(e\\) 定义如下： \\[ \\varepsilon:e(n)=\\left\\{\\begin{matrix} 1\\; (n=1)\\\\ 0\\; (n\\neq 1) \\end{matrix}\\right.=[n=1] \\] 这个单位元也被称为单位函数，它是一个完全积性函数。 结论 1：若 \\(f, g\\) 是积性函数，那么 \\(f*g\\) 也是积性函数。 结论 2：积性函数的逆元（对于单位元）也是积性函数。 莫比乌斯函数 莫比乌斯函数是积性函数。 定义 记作 \\(\\mu\\)；对于一个整数 \\(n\\)，令其标准分解形式为 \\(\\prod p_i^{a_i},\\ i\\in[1, k]\\)，则莫比乌斯函数可以如下定义： \\[ \\mu(n)=\\begin{cases} 0 &amp;,\\ \\exists i: a_i &gt; 1 \\\\ (-1)^k &amp;,\\ \\text{else} \\end{cases} \\] 简单地说：如果 \\(n\\) 有平方因子，那么 \\(\\mu(n)=0\\)；否则是 \\((-1)^k\\)，\\(k\\) 是 \\(n\\) 互不相同的质因子个数。 性质 莫比乌斯函数最重要的性质是： \\[ \\sum_{d\\mid n}\\mu(d) = \\begin{cases} 1 &amp;,\\ n=1 \\\\ 0 &amp;,\\ n\\ne1 \\end{cases} = e(n) \\] 用 Dirichlet 卷积的形式表示，就是 \\(\\mu * 1 = e\\). 这个性质的证明 令 \\(n\\) 有标准分解形式为 \\(\\prod p_i^{a_i},\\ i\\in[1, k]\\)，定义 \\(n&#39; = \\prod p_i\\)；那么显然有： \\[ \\sum_{d\\mid n}\\mu(d) = 0 + \\sum_{d\\mid n&#39;}\\mu(d) \\] 而 \\(n&#39;\\) 中是没有重复的因子的，所以 \\(d\\) 只需要在这 \\(k\\) 个本质不同的因子中随意选取组合即可： \\[ \\sum_{d\\mid n&#39;}\\mu(d) = \\sum_{i=0}^k \\mathbf C_k^i\\cdot(-1)^i \\] 为每一项增加一个 \\(1^{k-i}\\)，由二项式定理可得： \\[ \\sum_{i=0}^k \\mathbf C_k^i\\cdot(-1)^i\\cdot1^{k-i} = (-1 + 1)^k = 0^k \\] 显然，当且仅当 \\(k=0\\) 时上式取值 \\(1\\)；其他情况下均为 \\(0\\)。而 \\(k=0\\) 时，\\(n\\) 没有任何素因子，故 \\(n=1\\). 除此之外，我们还有一个结论可以帮助我们将莫比乌斯函数和欧拉函数联系起来： \\[ \\sum_{d\\mid n}\\frac{\\mu(d)}d = \\frac{\\varphi(n)}n \\] 这个待会再想办法证（ 线性筛求解 根据定义，稍微修改一下线性筛，我们可以写出下面的代码： 12345678910111213141516171819template &lt;int n&gt; auto &amp;mobius_sieve() &#123; vector&lt;int&gt; prime; static array&lt;int, n + 1&gt; mu; bitset&lt;n + 1&gt; vis; mu[1] = 1; for (int i = 2; i &lt;= n; ++ i) &#123; if (!vis[i]) prime.push_back(i), mu[i] = -1; for (auto &amp; pp : prime) &#123; auto ipp = (llong)i * pp; if (ipp &gt; n) break; vis[ipp] = true; if (i % pp == 0) &#123; mu[ipp] = 0; break; &#125; else mu[ipp] = -mu[i]; &#125; &#125; return mu;&#125; 事实上，线性筛基本可以求所有的积性函数。 莫比乌斯反演 对于一些函数 \\(f(n)\\)，若它本身难求但其倍数/约数和好求，那么就可以用莫比乌斯反演来简化其运算。 公式 设有数论函数 \\(f,g\\)，那么有如下公式： \\[ \\begin{align} f(n)=\\sum_{d\\mid n}g(d) &amp;\\iff g(n) = \\sum_{d\\mid n}\\mu(d)f(\\frac nd) \\\\ f(n)=\\sum_{n\\mid d}g(d) &amp;\\iff g(n) = \\sum_{n\\mid d}\\mu(\\frac dn)f(d) \\end{align} \\] 形式一是标准形式。 证明 我们先利用卷积知识简易证明上述的形式一： 首先，将上式左边看作 \\(f = g*1\\)；然后，有 Dirichlet 卷积的运算性质，我们在等式两侧卷积 \\(\\mu\\)，有： \\[ f * \\mu = g * 1 * \\mu \\] 又因为莫比乌斯函数的性质有 \\(e = 1 * \\mu\\)，所以上式的右侧消去单位元，得：\\(g = f * \\mu\\)，即上式右侧。 或者通过数论变换的方式证明形式一： 数论变换就是反着推导的过程；对于上述关系右侧等式的右侧，代入关系左侧的条件可得： \\[ \\sum_{d\\mid n}\\mu(d)f(\\frac nd) = \\sum_{d\\mid n}\\mu(d)\\sum_{k\\mid \\frac nd}g(k) = \\sum_{k\\mid n}g(k)\\sum_{d\\mid \\frac nk}\\mu(d) \\] 因为 \\(dk\\) 是 \\(n\\) 的因数，\\(d\\) 和 \\(k\\) 是对于 \\(dk\\) 的进一步划分，这里交换求和顺序可以得到上式最右侧的形态；观察这个式子的右侧，利用莫比乌斯函数的主要性质，可以将其转化为单位函数的形式： \\[ \\sum_{k\\mid n}g(k)\\sum_{d\\mid \\frac nk}\\mu(d) = \\sum_{k\\mid n}g(k)[\\frac nk = 1] = g(n) \\] 也就是左侧的求和只有在 \\(k = n\\) 时取值 \\(g(n)\\)，结果也是 \\(g(n)\\)，和形式一右侧等式的左侧一致。 我们也可以如法炮制的证明形式二： 将可被 \\(n\\) 整除的 \\(d\\) 表示成 \\(kn\\)，将形式二的前提代入关系右侧的等式的右侧可得： \\[ \\begin{align} g(n) &amp;= \\sum_{n\\mid d}\\mu(\\frac dn)f(d) = \\sum_{k=1}^{+\\infty}\\mu(k)f(kn)\\\\ &amp;= \\sum_{k=1}^{+\\infty}\\mu(k)\\sum_{kn\\mid q}g(q) = \\sum_{n\\mid q}g(q)\\sum_{k\\mid \\frac qn}\\mu(k) \\end{align} \\] 然后再进行如法炮制的交换求和顺序：\\(kn\\) 是无穷的 \\(q\\) 的因数，再进一步划分 \\(kn\\)；再次观察最右侧的式子，并转化为单位函数： \\[ \\sum_{n\\mid q}g(q)\\sum_{k\\mid \\frac qn}\\mu(k) = \\sum_{n\\mid q}g(q)[\\frac qn=1] = g(n) \\] 显然，整个求和式子只有在 \\(q = n\\) 时才能取到值，且此时的值是 \\(g(n)\\)，和形式二右侧等式的左侧一致。 不知道看到这里，是否对于”莫比乌斯函数是一个和容斥系数相关的函数“这句话有了什么新的理解。 应用 但是一般来说构造一个 \\(f(n) = \\sum_{d\\mid n}g(d)\\) 颇有难度，那个公式很多时候都意义不明。所以通常的做法都是想办法整出一个 \\([\\gcd(i, j)=1]\\) 也就是 \\(e(\\gcd(i,j))\\)，然后通过 \\(\\sum_{d\\mid \\gcd(i,j)}\\mu(d)\\) 来计算它；而这实际上就是莫比乌斯函数的性质——这样说也是十分意义不明，所以我们说一类相对比较常见的问题作为例子： 给定 \\(n\\le m\\)，求解： \\[ \\sum_{i=1}^n\\sum_{j=1}^m f(\\gcd(i, j)) \\] 我们考虑枚举 \\(d = \\gcd(i, j)\\) 的取值，于是有了： \\[ \\sum_{i=1}^n\\sum_{j=1}^m f(\\gcd(i, j)) = \\sum_{d=1}^n \\sum_{i=1}^{\\lfloor\\frac nd\\rfloor}\\sum_{j=1}^{\\lfloor\\frac md\\rfloor} f(d)e(\\gcd(i,j)) \\] 那么我们可以对于单位函数的部分代入莫比乌斯函数的性质——有： \\[ \\sum_{d=1}^{\\min(n,m)} \\sum_{i=1}^{\\lfloor\\frac nd\\rfloor}\\sum_{j=1}^{\\lfloor\\frac md\\rfloor} f(d)[\\gcd(i,j)=1] = \\sum_{d=1}^n \\sum_{i=1}^{\\lfloor\\frac nd\\rfloor}\\sum_{j=1}^{\\lfloor\\frac md\\rfloor} f(d)\\sum_{r\\mid\\gcd(i,j)}\\mu(r) \\] 对右侧式子进行反演——或者说调换求和顺序，去枚举 \\(r\\) 的值并将其挪到外层，有： \\[ \\sum_{d=1}^n \\sum_{i=1}^{\\lfloor\\frac nd\\rfloor}\\sum_{j=1}^{\\lfloor\\frac md\\rfloor}f(d)\\sum_{r\\mid\\gcd(i,j)}\\mu(r) = \\sum_{d=1}^n \\sum_{r=1}^{\\min(\\lfloor\\frac nd\\rfloor,\\lfloor\\frac md\\rfloor)}\\mu(r)\\sum_{i=1}^{\\lfloor\\frac n{dr}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac m{dr}\\rfloor}f(d) \\] 可以注意到这个时候右侧式子中的 \\(i,j\\) 已经不会影响到所需要求和的东西了，相当于对 1 求和： \\[ \\sum_{d=1}^n \\sum_{r=1}^{\\lfloor\\frac nd\\rfloor}\\mu(r)f(d)\\sum_{i=1}^{\\lfloor\\frac n{dr}\\rfloor}\\sum_{j=1}^{\\lfloor\\frac m{dr}\\rfloor}1 = \\sum_{d=1}^n \\sum_{r=1}^{\\lfloor\\frac nd\\rfloor}\\mu(r)f(d)\\lfloor\\frac n{dr}\\rfloor\\lfloor\\frac m{dr}\\rfloor \\] 此时，我们假设一个 \\(g(t)\\)： \\[ g(t) = \\sum_{d\\mid t}f(d)\\mu(\\frac td) = f * \\mu \\] 观察题设的公式和我们的推到结果： \\[ \\sum_{i=1}^n\\sum_{j=1}^m f(\\gcd(i, j)) = \\sum_{d=1}^n \\sum_{r=1}^{\\lfloor\\frac nd\\rfloor}\\mu(r)f(d)\\lfloor\\frac n{dr}\\rfloor\\lfloor\\frac m{dr}\\rfloor \\] 我们把 \\(dr\\) 看作一个整体，它是 \\(n\\) 的因数，\\(d,r\\) 是对其进一步的划分；那么令 \\(t=dr\\)： \\[ \\sum_{i=1}^n\\sum_{j=1}^m f(\\gcd(i, j)) = \\sum_{t=1}^ng(t)\\lfloor\\frac nt\\rfloor\\lfloor\\frac mt\\rfloor \\] 至此，我们完成了题设公式的转换，即反演；但是这样做的意义，是什么呢？当然是推出来的这个式子相对比较好算了！一重求和不比二重求和容易？ 钢筋（bushi 上面的部分主要说的是对于含有 \\(\\gcd\\) 的式子的处理方法：弄出一个 \\([\\gcd(i,j)=1]\\) 然后再利用它的等价式子 \\(\\sum_{d\\mid \\gcd(i,j)}\\mu(d)\\) 代换它，并求出了一个比较通用的“公式”；那么对于这种出现了 \\(\\gcd\\) 的式子，我就是想要使用反演公式设函数套怎么办呢？套路在此： 首先，我们再写一遍莫比乌斯反演公式的某种形态： \\[ f(n)=\\sum_{n\\mid d}g(d) \\iff g(n) = \\sum_{n\\mid d}\\mu(\\frac dn)f(d) \\] 一般来说，我们设 \\(g(d)\\) 为范围内满足 \\(\\gcd(i, j) = d\\) 的数对个数，\\(f(n)\\) 为满足 \\(n \\mid \\gcd(i, j)\\) 的数对个数，那么它们就满足了： \\[ \\begin{align} g(d)&amp;=\\sum_{i=1}^N\\sum_{j=1}^M[\\gcd(i, j)=d]\\\\ f(n)&amp;=\\sum_{n\\mid d}g(d)=\\lfloor\\frac Nn\\rfloor\\lfloor\\frac Mn\\rfloor \\end{align} \\] 关于 \\(f(n)\\) 的两种表达式：第一个表达式是利用我们定义的 \\(g(d)\\) 来定义；第二个表达式是根据我们的定义直接得到的——当 \\(i,j\\) 都有确定范围的时候，满足 \\(\\gcd(i, j) = kn\\) 的数对数量当然是这个。 这样，我们就可以利用前面写的那个莫比乌斯反演公式，得到： \\[ g(n) = \\sum_{n\\mid d}\\mu(\\lfloor\\frac dn\\rfloor)f(d) \\] 当然，裸求 \\(g(d)\\) 是不好求的；但是 \\(\\mu\\) 可以线性筛加维护前缀和，\\(f(n)\\) 可以数论分块；于是我们就利用反演公式将不太好求的 \\(g(d)\\) 简化的好求了一些。 例题 上面的简介仍然是比较抽象，所以还是看几个题： 【HAOI2011】Problem b 求 \\(\\sum_{i=a}^b \\sum_{j=c}^d [\\gcd(i,j)=k]\\) 首先原式的求和有区间，所以很显然地将他转化为一个二维差分的形式： \\[ \\begin{align} &amp;记\\ A_{n,m}=\\sum_{i=1}^n \\sum_{j=1}^m [\\gcd(i,j)=k]\\\\ &amp;则\\ 原式 = A_{b,d} - A_{b,c-1} - A_{a-1,d} + A_{a-1,c-1} \\end{align} \\] 那么原来的问题转化成求 \\(A_{n,m}\\)： 参考上面运用小节推的那个比较具有代表性的”公式“——这里 \\(f(x)=[x=k]\\)；那么我们可以根据”公式“来套路的得到： \\[ g(t) = \\sum_{d\\mid t}f(d)\\mu(\\frac td) \\] 然后，将它代回那个公式里，可以得到： \\[ \\begin{align} &amp;\\sum_{i=1}^n \\sum_{j=1}^m [\\gcd(i,j)=k]\\\\ =&amp;\\sum_{t=1}^{\\min(n,m)}\\sum_{d\\mid t}[d=k]\\mu(\\frac td)\\lfloor\\frac nt\\rfloor\\lfloor\\frac mt\\rfloor\\\\ =&amp;\\sum_{t=1,k\\mid t}^{\\min(n,m)}\\mu(\\frac tk)\\lfloor\\frac nt\\rfloor\\lfloor\\frac mt\\rfloor\\\\ =&amp;\\sum_{d=1}^{\\lfloor\\frac {\\min(n,m)}k\\rfloor}\\mu(d)\\lfloor\\frac n{dk}\\rfloor\\lfloor\\frac m{dk}\\rfloor \\end{align} \\] 现在这个公式已经可以通过 \\(\\mathcal O(n)\\) 来计算了；但是注意到这里待求和的式子还可以使用数论分块计算，所以实际上上式的时间复杂度是 \\(\\mathcal O(\\sqrt n)\\) 的。如果不会数论分块可以看这个：数论分块入门 - 七海の参考書 (shiraha.cn) 然后，我们就能写出代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253constexpr int N = 5e4 + 50;int mu_sum[N + 1], a, b, c, d, k;int mu_seq(int l, int r) &#123; return mu_sum[r] - mu_sum[l - 1];&#125;template &lt;int n&gt; auto &amp;mobius_sieve() &#123; vector&lt;int&gt; prime; static array&lt;int, n + 1&gt; mu; bitset&lt;n + 1&gt; vis; mu[1] = 1; for (int i = 2; i &lt;= n; ++ i) &#123; if (!vis[i]) prime.push_back(i), mu[i] = -1; for (auto &amp; pp : prime) &#123; auto ipp = (llong)i * pp; if (ipp &gt; n) break; vis[ipp] = true; if (i % pp == 0) &#123; mu[ipp] = 0; break; &#125; else mu[ipp] = -mu[i]; &#125; &#125; return mu;&#125;int ybb(int n, int m) &#123; if (n &gt; m) swap(n, m); int ret = 0, nk = n / k; for (int l = 1, r; l &lt;= nk; l = r + 1) &#123; int nlk = n / l / k, mlk = m / l / k; r = min(&#123;nk, n / (n / l), m / (m / l)&#125;); ret += mu_seq(l, r) * nlk * mlk; &#125; return ret;&#125;signed main() &#123;#ifndef ONLINE_JUDGE freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif const auto mu = mobius_sieve&lt;N&gt;(); for (int i = 1; i &lt;= N; ++ i) mu_sum[i] = mu_sum[i - 1] + mu[i]; for (auto T = read(); T --;) &#123; a = read(), b = read(), c = read(); d = read(), k = read(); auto ans = ybb(b, d) - ybb(b, c - 1) - ybb(a - 1, d) + ybb(a - 1, c - 1); cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 遇事不决开 long long 是吧？long long 不是你的电子宠物（ YY的GCD 求 \\(\\sum_{i=1}^n \\sum_{j=1}^m [\\gcd(i,j)\\ \\text{is}\\ \\text{prime}]\\) 令 \\(n\\le m\\)，还是很套路地把上面的式子变成枚举 \\(\\gcd\\) 的值： \\[ 原式 = \\sum_{k=1}^{\\min(n,m)}\\sum_{i=1}^n \\sum_{j=1}^m [\\gcd(i, j)=k] = \\sum_{k=1}^{n}\\sum_{i=1}^{\\lfloor\\frac nk\\rfloor} \\sum_{j=1}^{\\lfloor\\frac mk\\rfloor} [\\gcd(i, j)=1],\\ k\\ \\text{is}\\ \\text{prime} \\] 还是运用“应用”部分得到的公式；我们轻而易举地发现 \\(f=e\\)，那么套路地设 \\(g\\)： \\[ g(t) = f * \\mu = \\sum_{d\\mid t}e(d)\\mu(\\frac td) \\] 然后还是代回原来的那个包含 \\(f\\) 的表达式中，可以得到： \\[ \\begin{align} &amp;\\sum_{k=1}^n\\sum_{i=1}^{\\lfloor\\frac nk\\rfloor} \\sum_{j=1}^{\\lfloor\\frac mk\\rfloor} e(\\gcd(i, j)),\\ \\ k\\ \\text{is}\\ \\text{prime}.\\\\ =&amp;\\sum_{k=1}^n\\sum_{t=1}^{\\lfloor\\frac nk\\rfloor}\\sum_{d\\mid t}e(d)\\mu(\\frac td)\\lfloor\\frac n{tk}\\rfloor\\lfloor\\frac m{tk}\\rfloor\\\\ =&amp;\\sum_{k=1}^n\\sum_{t=1}^{\\lfloor\\frac nk\\rfloor}\\mu(t)\\lfloor\\frac n{tk}\\rfloor\\lfloor\\frac m{tk}\\rfloor \\end{align} \\] 令 \\(x = tk\\)，那么： \\[ 上式 = \\sum_{x=1}^n\\sum_{k\\mid x}\\mu(\\frac xk)\\lfloor\\frac nx\\rfloor\\lfloor\\frac mx\\rfloor = \\sum_{x=1}^n\\lfloor\\frac nx\\rfloor\\lfloor\\frac mx\\rfloor\\sum_{k\\mid x}\\mu(\\frac xk),\\ \\ k\\ \\text{is}\\ \\text{prime}. \\] 那么式子就推到这里；上面的式子左边可以数论分块，右边那个东西虽然看起来玄乎但是总归还是可以预处理的：只需要对于所有的质数在范围内的倍数“对数筛”即可，复杂度不明不会素数定理。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556constexpr int N = 1e7 + 50;int f[N + 1], f_sum[N + 1];int f_sec(llong l, llong r) &#123; return f_sum[r] - f_sum[l - 1];&#125;template &lt;int n&gt; auto mobius_sieve() &#123; static vector&lt;int&gt; prime; static array&lt;int, n + 1&gt; mu; bitset&lt;n + 1&gt; vis; mu[1] = 1; for (int i = 2; i &lt;= n; ++ i) &#123; if (!vis[i]) prime.push_back(i), mu[i] = -1; for (auto &amp; pp : prime) &#123; auto ipp = (llong)i * pp; if (ipp &gt; n) break; vis[ipp] = true; if (i % pp == 0) &#123; mu[ipp] = 0; break; &#125; else mu[ipp] = -mu[i]; &#125; &#125; return make_pair(ref(prime), ref(mu));&#125;llong fuck(int n, int m) &#123; if (n &gt; m) swap(n, m); llong ret = 0; for (llong l = 1, r; l &lt;= n; l = r + 1) &#123; r = min(&#123;n / (n / l), m / (m / l), (llong) n&#125;); ret += (llong) f_sec(l, r) * (n / l) * (m / l); &#125; return ret;&#125;signed main() &#123;#ifndef ONLINE_JUDGE freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif const auto [prime, mu] = mobius_sieve&lt;N&gt;(); for (auto pp : prime) for (int i = 1;; ++ i) &#123; auto ipp = (llong)i * pp; if (ipp &gt; N) break; else f[ipp] += mu[i]; &#125; for (int i = 1; i &lt;= N; ++ i) f_sum[i] = f_sum[i - 1] + f[i]; for (auto T = read(); T --;) &#123; auto n = read(), m = read(); cout &lt;&lt; fuck(n, m) &lt;&lt; endl; &#125; return 0;&#125; 所谓条条大路通罗马（罗马！），直接用莫比乌斯反演公式也能推出一样的式子，看各自喜好了（ 思路 那么，你已经学会了莫比乌斯反演了，快上！（指做开篇的那个题 关于 d(x) 首先关于这个都不太熟的 \\(\\text d(x)\\)，我们有一个结论： \\[ \\text d(NM) = \\sum_{i\\mid N}\\sum_{j\\mid M}[\\gcd(i, j)=1] \\] 这个式子为什么是正确的？首先考虑对于一个整数 \\(X\\) 的标准分解，即 \\(X = \\prod p_i^{a_i}\\)，约数的个数为 \\(\\text d(X) = \\prod (a_i + 1)\\)；这非常的好理解，它的约数必定由它的质因子构成，每个质因子 \\(p_i\\) 有 \\(a_i + 1\\) 种不同的选法。合数因子本身就是对于这个数字所有的质因子进行这样的选择组合而成；对于 \\(NM\\)，我们也可以从这个角度入手考虑： 对于一个素数 \\(p\\)，有 \\(N = n\\times p^x\\) 和 \\(M=m\\times p^y\\)；那么显然 \\(p\\) 在 \\(NM\\) 中出现的次数是 \\(x + y\\) 次，关于这个质因子有 \\(x + y + 1\\) 种选法。那么怎么枚举选法呢？显然，若枚举 \\(i\\mid N\\) 和 \\(j\\mid M\\)，得到的 \\(ij \\mid NM\\)。那么问题就在于两次不同的枚举得到的 \\(ij\\) 的乘积可能实际上是一样的；为了避免重复，我们定义下面的取法： 令对于 \\(NM\\) 和素因子 \\(p\\)，我们要选取其中的 \\(k\\) 次，那么这 \\(k\\) 个 \\(p\\) 就要由 \\(N\\) 和 \\(M\\) 来提供。 当 \\(k \\le x\\) 时，我们要求 \\(p\\) 完全由 \\(N\\) 提供；此时可以选出 \\(k = x + 1\\) 种不同的有序数对 \\((p^k, 1)\\) 当 \\(k &gt; x\\) 时，我们要求超过 \\(x\\) 的部分由 \\(M\\) 提供，但不再在 \\(N\\) 中选择；此时有 \\(y\\) 种有序数对 \\((1,p^{k-x})\\) 因此对于每一个因子，在上述规则的限制下，在 \\(NM\\) 中只会选出 \\(x + y + 1\\) 种不同的选法，符合我们的要求；而实现这样的限制条件很显然可以通过 \\(\\gcd(i, j)=1\\) 来达成目的，因为我们从来没有在 \\(i\\) 和 \\(j\\) 中同时选择 \\(p\\). 变换 综上所述，我们要求的式子可以写成下面的形式： \\[ \\sum_{n=1}^N\\sum_{m=1}^M\\text d(nm) = \\sum_{n=1}^N\\sum_{m=1}^M\\sum_{i\\mid n}\\sum_{j\\mid m}[\\gcd(i, j)=1] \\] 改变四层求和的枚举顺序，先枚举 \\(i\\) 和 \\(j\\)，那么可以得到下面的形式： \\[ \\sum_{n=1}^N\\sum_{m=1}^M\\text d(nm) = \\sum_{i=1}^N\\sum_{j=1}^M\\lfloor\\frac Ni\\rfloor\\lfloor \\frac Mj\\rfloor[\\gcd(i,j)=1] \\] 那么就转化了题设的公式，可以基于这个公式进行莫比乌斯反演了。 反演 根据上面的讨论，我们已经得到了一个包含了 \\(e(\\gcd(i, j))\\) 形态的公式，现在对它进行操作： 根据 Dirichlet 卷积的单位元的性质，也就是 \\(e = 1*\\mu\\)，得： \\[ \\sum_{i=1}^N\\sum_{j=1}^M\\lfloor\\frac Ni\\rfloor\\lfloor \\frac Mj\\rfloor[\\gcd(i,j)=1] = \\sum_{i=1}^N\\sum_{j=1}^M\\lfloor\\frac Ni\\rfloor\\lfloor \\frac Mj\\rfloor\\sum_{d\\mid\\gcd(i, j)}\\mu(d) \\] 对于最右边这个子式，我们很自然地想到枚举 \\(d\\)；令 \\(\\min(N,M)=N\\)，调换枚举顺序： \\[ \\sum_{i=1}^N\\sum_{j=1}^M\\lfloor\\frac Ni\\rfloor\\lfloor \\frac Mj\\rfloor\\sum_{d=1}^{\\min(N,M)}[d\\mid\\gcd(i,j)]\\mu(d) = \\sum_{d=1}^{N}\\mu(d)\\sum_{i=1}^N\\sum_{j=1}^M\\lfloor\\frac Ni\\rfloor\\lfloor \\frac Mj\\rfloor[d\\mid\\gcd(i,j)] \\] 右边的双层枚举子式又是典型的求 \\(\\gcd\\) 是倍数的类型，进行套路地转换： \\[ \\sum_{d=1}^{N}\\mu(d)\\sum_{i=1}^{\\lfloor\\frac Nd\\rfloor}\\sum_{j=1}^{\\lfloor\\frac Md\\rfloor}\\lfloor\\frac N{id}\\rfloor\\lfloor \\frac M{jd}\\rfloor = \\sum_{d=1}^{N}\\mu(d)\\sum_{i=1}^{\\lfloor\\frac Nd\\rfloor}\\lfloor\\frac N{id}\\rfloor\\sum_{j=1}^{\\lfloor\\frac Md\\rfloor}\\lfloor\\frac M{jd}\\rfloor \\] 综上所述，我们通过反演将原式转化为了： \\[ \\sum_{n=1}^N\\sum_{m=1}^M\\text d(nm) = \\sum_{d=1}^{\\min(N,M)}\\mu(d)(\\sum_{i=1}^{\\lfloor\\frac Nd\\rfloor}\\lfloor\\frac N{id}\\rfloor\\cdot\\sum_{j=1}^{\\lfloor\\frac Md\\rfloor}\\lfloor\\frac M{jd}\\rfloor) \\] 那么这个化简后的式子要怎么去求呢？容易发现两个子求和是近乎一致的，可以预先处理；因此我们定义函数 \\(h(n)=\\sum_{i=1}^n\\lfloor\\frac ni\\rfloor\\)，于是有： \\[ \\sum_{n=1}^N\\sum_{m=1}^M\\text d(nm) = \\sum_{d=1}^{\\min(N,M)}\\mu(d)h(\\lfloor\\frac Nd\\rfloor)h(\\lfloor\\frac Md\\rfloor) \\] 而实际上，\\(h(n)\\) 就是约数个数函数 \\(\\text d(x)\\) 的前缀和，这个也可以用线性筛求出来维护前缀和；当然如果不想使用线性筛来维护这个，也可以直接分块计算后加起来——复杂度是 \\(\\mathcal O(n\\sqrt n)\\)； 代码实现 综上所述，我们可以用分块和分块求解上面反演得到的式子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061constexpr int N = 5e4 + 50;int h[N + 1], mu_sum[N + 1];int mu_sec(llong l, llong r) &#123; return mu_sum[r] - mu_sum[l - 1];&#125;template &lt;int n&gt; auto mobius_sieve() &#123; static vector&lt;int&gt; prime; static array&lt;int, n + 1&gt; mu; bitset&lt;n + 1&gt; vis; mu[1] = 1; for (int i = 2; i &lt;= n; ++ i) &#123; if (!vis[i]) prime.push_back(i), mu[i] = -1; for (auto &amp; pp : prime) &#123; auto ipp = (llong)i * pp; if (ipp &gt; n) break; vis[ipp] = true; if (i % pp == 0) &#123; mu[ipp] = 0; break; &#125; else mu[ipp] = -mu[i]; &#125; &#125; return make_pair(ref(prime), ref(mu));&#125;llong partition(llong n) &#123; llong ret = 0; for (llong l = 1, r; l &lt;= n; l = r + 1) &#123; r = min(n / (n / l), n); ret += (r - l + 1) * (n / l); &#125; return ret;&#125;llong fuck(int n, int m) &#123; if (n &gt; m) swap(n, m); llong ret = 0; for (llong l = 1, r; l &lt;= n; l = r + 1) &#123; r = min(&#123;n / (n / l), m / (m / l), (llong)n&#125;); ret += (llong) mu_sec(l, r) * h[n / l] * h[m / l]; &#125; return ret;&#125;signed main() &#123;#ifndef ONLINE_JUDGE freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif const auto [prime, mu] = mobius_sieve&lt;N&gt;(); for (int i = 1; i &lt;= N; ++ i) mu_sum[i] = mu_sum[i - 1] + mu[i]; for (int i = 1; i &lt;= N; ++ i) h[i] = (int) partition(i); for (auto T = read(); T --;) &#123; auto n = read(), m = read(); cout &lt;&lt; fuck(n, m) &lt;&lt; endl; &#125; return 0;&#125; 如果用线性筛维护 \\(\\text d(x)\\) 再求其前缀和 \\(h(x)\\)，则需要引入新的线性筛： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677constexpr int N = 5e4 + 50;int h[N + 1], mu_sum[N + 1];int mu_sec(llong l, llong r) &#123; return mu_sum[r] - mu_sum[l - 1];&#125;template &lt;int n&gt; auto mobius_sieve() &#123; static vector&lt;int&gt; prime; static array&lt;int, n + 1&gt; mu; bitset&lt;n + 1&gt; vis; mu[1] = 1; for (int i = 2; i &lt;= n; ++ i) &#123; if (!vis[i]) prime.push_back(i), mu[i] = -1; for (auto &amp; pp : prime) &#123; auto ipp = (llong)i * pp; if (ipp &gt; n) break; vis[ipp] = true; if (i % pp == 0) &#123; mu[ipp] = 0; break; &#125; else mu[ipp] = -mu[i]; &#125; &#125; return make_pair(ref(prime), ref(mu));&#125;template &lt;int n&gt; auto divisor_sieve() &#123; static vector&lt;int&gt; prime; static array&lt;int, n + 1&gt; d, c; bitset&lt;n + 1&gt; vis; d[1] = 1, c[1] = 1; for (int i = 2; i &lt;= n; ++ i) &#123; if (!vis[i]) &#123; prime.push_back(i); d[i] = 2, c[i] = 1; &#125; for (auto &amp; pp : prime) &#123; auto ipp = (llong)i * pp; if (ipp &gt; n) break; else vis[ipp] = true; if (i % pp == 0) &#123; c[ipp] = c[i] + 1; d[ipp] = d[i] / c[ipp] * (c[ipp] + 1); break; &#125; else c[ipp] = 1, d[ipp] = d[i] * 2; &#125; &#125; return make_pair(ref(prime), ref(d));&#125;llong fuck(int n, int m) &#123; if (n &gt; m) swap(n, m); llong ret = 0; for (llong l = 1, r; l &lt;= n; l = r + 1) &#123; r = min(&#123;n / (n / l), m / (m / l), (llong)n&#125;); ret += (llong) mu_sec(l, r) * h[n / l] * h[m / l]; &#125; return ret;&#125;signed main() &#123;#ifndef ONLINE_JUDGE freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif const auto [prime, mu] = mobius_sieve&lt;N&gt;(); for (int i = 1; i &lt;= N; ++ i) mu_sum[i] = mu_sum[i - 1] + mu[i]; const auto &amp;d = divisor_sieve&lt;N&gt;().second; for (int i = 1; i &lt;= N; ++ i) h[i] = h[i - 1] + d[i]; for (auto T = read(); T --;) &#123; auto n = read(), m = read(); cout &lt;&lt; fuck(n, m) &lt;&lt; endl; &#125; return 0;&#125; 当然，肯定是要把两个线性筛写在一起的；像上面那样写的人脑子多半是有点大病（ 于是，这个问题就解决了！ 后记 莫比乌斯反演还是比较有趣的；这里列举的也仅仅是最基础最基础的板子题，用来加深对这个公式的推导以及这种方法的理解——也就是说有趣的题还有很多……之后有时间做了再整理一篇吧（ 参考资料 莫比乌斯反演 - OI Wiki (oi-wiki.org) 数论小白入门-- 莫比乌斯反演 - 知乎 (zhihu.com) 莫比乌斯反演 - pengym - 博客园 (cnblogs.com) 【bzoj3994】约数个数和_喵~-CSDN博客 莫比乌斯反演-让我们从基础开始 - An_Account 的博客 - 洛谷博客 (luogu.com.cn) 形形色色的素数 -- 质数定理 - 知乎 (zhihu.com)","categories":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"算法/数学","permalink":"https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"数论","slug":"数论","permalink":"https://shiraha.cn/tags/%E6%95%B0%E8%AE%BA/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://shiraha.cn/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"}]},{"title":"NTT 简单入门","slug":"The-concept-of-ntt-introducing-edition","date":"2021-07-12T14:51:20.000Z","updated":"2021-07-12T14:51:20.000Z","comments":true,"path":"2021/The-concept-of-ntt-introducing-edition/","link":"","permalink":"https://shiraha.cn/2021/The-concept-of-ntt-introducing-edition/","excerpt":"","text":"《退役人的自我救赎系列》——其二，也就是差不多算是初等数论的知识。 一句话简介：NTT 即快速数论变换，是一种可以在 \\(n\\log n\\) 的时间内完成多项式乘法的算法——的一部分。 前置知识 FFT 可以看我之前写过的一篇文章：基础知识：FFT - 简单入门 - 七海の参考書 (shiraha.cn) FFT 需要使用复数——这样就无法回避大量的浮点运算，然后精度就会爆炸；但是由于已经证明了在复数域内，具有循环卷积特性的唯一变换是DFT，所以在复数域中不存在具有循环卷积性质的更简单的离散正交变换；因此，我们就提出了以数论为基础的具有循环卷积性质的快速数论变换（NTT）：它的特点在于用有限域上的单位根来取代复平面上的单位根。 上面这段话是上网抄的。虽然我现在还理解不了，但是有一件事情十分清楚——和 FFT 利用单位根的性质减少运算量一样，NTT 利用了原根的性质来减少运算量，达到了同样的复杂度。 阶 定义 若 \\(a, p\\in\\N^+\\) 满足 \\(\\gcd(a, p)=1\\) 和 \\(p&gt;1\\)，那么： 对于使得 \\(a^n \\equiv 1\\ \\text{mod}\\ p\\) 成立的最小的 \\(n\\)，我们称之为 \\(a\\) 模 \\(p\\) 的阶，记作 \\(\\delta_p(a)\\) 或 \\(\\text{ord}_pa\\)。 性质 1. 对于 \\(i\\in[0, \\delta_p(a))\\)，所有的 \\(a_i\\ \\text{mod}\\ p\\) 都互不相同 反证法：令有 \\(j\\ne k\\) 在该范围内并且模意义下相同，那么显然有 \\(a^{|j-k|}\\equiv1\\ \\text{mod}\\ p\\)，且 \\(|j-k|\\) 也属于该范围内，和定义矛盾。 2. 对于任何 \\(a^n \\equiv 1\\ \\text{mod}\\ p\\)，有 \\(\\delta_p(a) \\mid n\\) 显然。否则，把 \\(n\\) 表示为 \\(k\\delta_p(a) + m\\)，显然 \\(m \\in (0, \\delta_p(a))\\) 且满足 \\(a^m \\equiv 1\\ \\text{mod}\\ p\\)，和性质 1 冲突。 推论 1：若有 \\(\\gcd(a, p)=1\\)，那么 \\(\\delta_p(a) \\mid \\phi(p)\\) 由欧拉定理可知：若 \\(\\gcd(a, p) = 1\\)，则 \\(a^{\\phi(p)} \\equiv 1 \\ \\text{mod} \\ p\\)。那么由性质 2 可得 \\(\\delta_p(a) \\mid \\phi(p)\\)。 3. 若 \\(q\\in\\Z^+\\)，\\(p\\) 是素数，那么 \\(\\delta_p(q^i)=\\delta_p(q) \\iff \\gcd(\\delta_p(q), i)=1\\) 首先，我们记 \\(q^i = q^{\\gcd(\\delta_p(q), i)\\cdot r}\\)，显然 \\(r=\\frac i{\\gcd(\\delta_p(q), i)} \\in\\Z^+\\) 由性质 2 和题设条件欧拉函数的性质，可得：\\(\\delta_p(q) \\mid \\phi(p) = (p-1)\\) （好像没用） 那么，有：\\((g^i)^{\\frac{\\delta_p(q)}{\\gcd(\\delta_p(q), i)}}=(g^{\\delta_p(q)})^{\\frac i{\\gcd(\\delta_p(q), i)}}=g^{r\\cdot \\delta_p(q)}\\equiv1\\ \\text{mod}\\ p\\) 假设 \\(\\gcd(\\delta_p(q), i)\\ne1\\)，那么 \\(\\gcd(\\delta_p(q), i)&gt;1\\)，那么 \\(\\frac{\\delta_p(q)}{\\gcd(\\delta_p(q), i)}&lt;\\delta_p(q)\\) 因为 \\((g^i)^{\\frac{\\delta_p(q)}{\\gcd(\\delta_p(q), i)}}\\equiv1\\ \\text{mod}\\ p\\)，由性质 2 可得 \\(\\delta_p(q^i)\\mid\\frac{\\delta_p(q)}{\\gcd(\\delta_p(q), i)}\\)，因此 \\(\\delta_p(q^i)\\le\\frac{\\delta_p(q)}{\\gcd(\\delta_p(q), i)}\\) 综上所述，可得：\\(\\delta_p(q^i)\\le\\frac{\\delta_p(q)}{\\gcd(\\delta_p(q), i)}&lt;\\delta_p(q)\\) 即 \\(\\gcd(\\delta_p(q), i)\\ne1\\Rightarrow \\delta_p(q^i)\\ne\\delta_p(q)\\)，必要条件得证。 继承上述的证明，若有 \\(\\gcd(\\delta_p(q), i)=1\\)，那么 \\(\\frac{\\delta_p(q)}{\\gcd(\\delta_p(q), i)}=\\delta_p(q)\\) 由上述证明就可以得到：\\(\\delta_p(q^i)\\le\\delta_p(q)\\) 因为 \\(g^{i\\cdot\\frac{\\delta_p(q)}{\\gcd(\\delta_p(q), i)}}\\equiv1\\ \\text{mod}\\ p\\)，和性质 2 和 4 可知：\\(\\delta_p(q)\\mid i\\cdot\\delta_p(q^i)\\) 因为 \\(\\gcd(\\delta_p(q), i)=1\\)，所以 \\(上式\\Rightarrow\\delta_p(q)\\mid \\delta_p(q^i)\\)，也就是 \\(\\delta_p(q)\\le\\delta_p(q^i)\\) 综上所述，\\(\\because \\delta_p(q^i)\\le\\delta_p(q) \\and \\delta_p(q)\\le\\delta_p(q^i)\\)，\\(\\therefore \\delta_p(q)=\\delta_p(q^i)\\) 即 \\(\\gcd(\\delta_p(q), i)=1\\Rightarrow \\delta_p(q^i)=\\delta_p(q)\\)，充分条件得证。 综上所述，\\(\\gcd(\\delta_p(q), i)=1\\) 是 \\(\\delta_p(q)=\\delta_p(q^i)\\) 的充分必要条件。 4. \\(\\delta_p(a^b) = \\frac{\\delta_p(a)}{\\gcd(\\delta_p(a), b)}\\)，其中 \\(a, p, b \\in \\Z^+\\) 由阶的定义可知：\\((a^b)^{\\delta_p(a^b)} \\equiv a^{b\\cdot\\delta_p(a^b)}\\equiv1\\ \\text{mod} \\ p\\) 又由性质 2，可以得到：\\(\\delta_p(a)\\mid b\\cdot\\delta_p(a^b) \\Rightarrow \\frac{\\delta_p(a)}{\\gcd(\\delta_p(a), b)}\\mid \\frac{b}{\\gcd(\\delta_p(a), b)}\\cdot\\delta_p(a^b)\\) 显然，因为 \\(\\gcd(\\frac{\\delta_p(a)}{\\gcd(\\delta_p(a), b)}, \\frac{b}{\\gcd(\\delta_p(a), b)})=1\\)，因此：\\(上式\\Rightarrow \\frac{\\delta_p(a)}{\\gcd(\\delta_p(a), b)}\\mid\\delta_p(a^b)\\) 又因为定义：\\(a^{b\\cdot\\frac{\\delta_p(a)}{\\gcd(\\delta_p(a), b)}}\\equiv a^{\\delta_p(a)\\cdot\\frac{b}{\\gcd(\\delta_p(a), b)}} \\equiv 1\\ \\text{mod}\\ p\\)，\\(\\frac{b}{\\gcd(\\delta_p(a), b)}\\) 显然是整数。 所以由性质 2 可得：\\(\\delta_p(a^b)\\mid\\frac{\\delta_p(a)}{\\gcd(\\delta_p(a), b)}\\) 综上所述：\\(\\because \\frac{\\delta_p(a)}{\\gcd(\\delta_p(a), b)}\\mid\\delta_p(a^b)\\ \\and\\ \\delta_p(a^b)\\mid\\frac{\\delta_p(a)}{\\gcd(\\delta_p(a), b)}\\)，\\(\\therefore \\delta_p(a^b)=\\frac{\\delta_p(a)}{\\gcd(\\delta_p(a), b)}\\) 5. \\(p \\in \\N^+,\\ a, b\\in\\Z\\)，\\(\\gcd(a, p) = \\gcd(b, p) = 1\\)，那么 \\(\\gcd(\\delta_p(a),\\delta_p(b))=1\\) \\(\\iff\\) \\(\\delta_p(ab)=\\delta_p(a)\\delta_p(b)\\) 由定义可得 \\(a^{\\delta_p(a)}\\equiv1\\ \\text{mod}\\ p\\) 和 \\(b^{\\delta_p(b)}\\equiv1\\ \\text{mod}\\ p\\)，那么：\\((ab)^{\\text{lcm}(\\delta_p(a),\\delta_p(b))}\\equiv1\\ \\text{mod}\\ p\\) 由性质 2，可得：\\(\\delta_p(ab)\\mid\\text{lcm}(\\delta_p(a),\\delta_p(b))\\) 设 \\(\\delta_p(ab)=\\delta_p(a)\\delta_p(b)\\) 成立，那么：\\(上式 \\Rightarrow \\delta_p(a)\\delta_p(b)\\mid\\text{lcm}(\\delta_p(a),\\delta_p(b))\\) 又因为 \\(\\text{lcm}(\\delta_p(a),\\delta_p(b)) = \\frac{\\delta_p(a)\\delta_p(b)}{\\gcd(\\delta_p(a),\\delta_p(b))}\\)，可得 \\(\\gcd(\\delta_p(a),\\delta_p(b))=1\\) 即 \\(\\delta_p(ab)=\\delta_p(a)\\delta_p(b)\\) \\(\\Rightarrow\\) \\(\\gcd(\\delta_p(a),\\delta_p(b))=1\\)，必要性得证。 又由阶的定义：\\((ab)^{\\delta_p(ab)}\\equiv1\\ \\text{mod}\\ p\\)，可以进行如下推导： \\[ (ab)^{\\delta_p(ab)}\\equiv(ab)^{\\delta_p(ab)\\delta_p(b)}\\equiv a^{\\delta_p(ab)\\delta_p(b)}\\cdot b^{\\delta_p(ab)\\delta_p(b)}\\equiv a^{\\delta_p(ab)\\delta_p(b)}\\cdot 1\\equiv1\\ \\text{mod}\\ p \\] 由性质 2，可得：\\(\\delta_p(a)\\mid\\delta_p(ab)\\delta_p(b)\\)；因为 \\(\\gcd(\\delta_p(a),\\delta_p(b))=1\\)，所以 \\(\\delta_p(a)\\mid\\delta_p(ab)\\) 同理，可得：\\(\\delta_p(b)\\mid\\delta_p(ab)\\)；因为 \\(\\gcd(\\delta_p(a),\\delta_p(b))=1\\)，所以 \\(\\delta_p(a)\\delta_p(b)\\mid\\delta_p(ab)\\) 由定理可得：\\(a^{\\delta_p(a)}\\equiv a^{\\delta_p(a)\\delta_p(b)}\\equiv1\\ \\text{mod}\\ p\\) 和 \\(b^{\\delta_p(b)}\\equiv b^{\\delta_p(a)\\delta_p(b)}\\equiv1\\ \\text{mod}\\ p\\)，因此： \\[ a^{\\delta_p(a)\\delta_p(b)} \\cdot b^{\\delta_p(a)\\delta_p(b)} \\equiv (ab)^{\\delta_p(a)\\delta_p(b)} \\equiv1\\ \\text{mod}\\ p \\] 由性质 2，可得 \\(\\delta_p(ab)\\mid\\delta_p(a)\\delta_p(b)\\)；因此，可证 \\(\\delta_p(ab)=\\delta_p(a)\\delta_p(b)\\) 即 \\(\\gcd(\\delta_p(a),\\delta_p(b))=1\\) \\(\\Rightarrow\\) \\(\\delta_p(ab)=\\delta_p(a)\\delta_p(b)\\)，充分性得证。 综上所述：\\(\\gcd(\\delta_p(a),\\delta_p(b))=1\\) 是 \\(\\delta_p(ab)=\\delta_p(a)\\delta_p(b)\\) 的充分必要条件。 原根 定义 \\(m \\in \\N^+,g\\in\\Z\\)，若有 \\(\\delta_m(g)=\\phi(m)\\) 且 \\(\\gcd(m,g)=1\\)，那么称 \\(g\\) 是模 \\(m\\) 的一个原根。 若整数 \\(g\\) 模正整数 \\(m\\) 的阶（这要求它们互质）和 \\(\\phi(m)\\) 相等，那么 \\(g\\) 是模 \\(m\\) 的一个原根。 性质 ……我一定是哪里变得奇怪了才会想着抄录全部性质并键证它们== 哪天闲的没事干再补全吧（） 7Q6A_S_AWQFY__Q5NEZI_E.jpg 定理 原根的存在条件 判断对于一个整数 \\(p\\) 是否存在原根： 对于整数 \\(p=2,4\\)，它们的原根显然存在 奇素数 \\(p\\) 的原根存在；对于 \\(\\alpha\\in\\N^+\\)，\\(p^\\alpha\\) 的原根存在 对于奇素数 \\(p\\)，\\(\\alpha\\in\\N^+\\)，\\(2p^\\alpha\\) 的原根存在 若 \\(p\\) 不符合上述的任何条件，则对于 \\(\\forall a\\in\\Z\\) 和 \\(\\gcd(a, p)=1\\)，都有 \\(\\delta_p(a) &lt; \\phi(p)\\)，即 \\(p\\) 不存在原根 与之相关的一些定理： 对于奇素数 \\(p\\)，若 \\(g\\) 是其原根，则 \\(g\\) 或者 \\(g+p\\) 是 \\(p^2\\) 的原根 对于奇素数 \\(p\\)，\\(\\alpha \\in \\N^+\\)，若 \\(g\\) 是模 \\(p^\\alpha\\) 的原根，则 \\(g\\) 和 \\(g+p^\\alpha\\) 中的奇数是 \\(2p^\\alpha\\) 的原根 简单地说，对于奇素数 \\(p\\)，\\(\\alpha\\in\\N^+\\)，有原根的数包括：\\(\\{2,4,p^\\alpha,2p^\\alpha\\}\\) 求法 对于一个数 \\(n\\)，如果它存在原根，那么首先找到它的最小原根并令其为 \\(g\\)；那么，\\(n\\) 的所有原根都可以表示为 \\(g^k\\)，\\(k\\) 是正整数并且满足 \\(\\gcd(\\phi(n),k)=1\\)，共 \\(\\phi(\\phi(n))\\) 个。 最小原根 \\(g\\) 的大小已经证明是不会超过 \\(\\sqrt[4]{n}\\) 的，所以可以通过暴力枚举来确定，然后按照定义要求来验证某个数字是否是原根——但是定义要求 \\(\\delta_n(g)=\\phi(n)\\)，我们无法对于每一个备选 \\(g\\) 都枚举 \\(i\\in[1,\\phi(n))\\) 来计算 \\(g^i\\)，观察它不和 \\(1\\) 同余来判定它是阶。 注意到阶的性质 2 的推论 1，我们可以知道 \\(\\delta_n(g)\\mid\\phi(n)\\)；也就是说，对于备选 \\(g\\)，如果它模 \\(n\\) 下的阶不满足原根的要求，而是另有 \\(k &lt; \\phi(n)\\) 存在，那么它满足 \\(k\\mid\\phi(n)\\)；那么，我们只需要检查 \\(\\phi(n)\\) 的所有真因数就可以找到可能存在的 \\(k\\) 了，而不需要枚举整个 \\([1,\\phi(n))\\)；具体地，若 \\(\\phi(n)\\) 的质因子被记为 \\(p_1,\\dots,p_r\\)，那么实际上我们只需要检查所有的 \\(\\frac{\\phi(n)}{p_i}\\) 即可——它覆盖了所有的真因数的倍数，检查它们等同于检查了所有的真因数。 综上所述，找到最小原根 \\(g\\) 所需要的时间是 \\(\\mathcal{O}(\\sqrt[4]n\\cdot\\log n)\\) 的；利用最小原根 \\(g\\) 求出所有原根所需要的时间是 \\(\\mathcal O (\\phi(n)\\cdot\\log n^{\\frac{\\phi(n)}4})\\) 的。完整代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192template&lt;int n&gt;auto &amp;linear_sieve() &#123; static vector&lt;int&gt; prime; static array&lt;int, n + 1&gt; vis; for (int i = 2; i &lt;= n; ++i) &#123; if (!vis[i]) prime.push_back(i), vis[i] = i; for (auto &amp;pp : prime) &#123; if ((llong) i * pp &gt; n) break; vis[i * pp] = pp; if (i % pp == 0) break; &#125; &#125; static auto ret = make_pair(ref(prime), ref(vis)); return ret;&#125;llong fast_pow(llong a, llong b, llong mod) &#123; llong ans = 1; while (b) &#123; if (b &amp; 1u) ans = (ans * a) % mod; a = (a * a) % mod, b &gt;&gt;= 1u; &#125; return ans % mod;&#125;constexpr int N = 1e6 + 5;bool check_primitive_root( const set&lt;int&gt; &amp;de, llong g, llong phi, llong n) &#123; if (fast_pow(g, phi, n) == 1) &#123; return none_of(de.begin(), de.end(), [&amp;](int p) &#123; return fast_pow(g, phi / p, n) == 1; &#125;); &#125; else return false;&#125;signed main() &#123;#ifndef ONLINE_JUDGE freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif const auto [p, dc] = linear_sieve&lt;N&gt;(); const auto decompose = [&amp;dc = dc] (llong x, set&lt;int&gt; &amp;de) &#123; de.clear(); for (auto ii = x; ii &gt; 1;) &#123; de.insert(dc[ii]); ii /= dc[ii]; &#125; &#125;; bitset&lt;N&gt; has_primitive_root; has_primitive_root.set(1).set(2).set(4); for (llong pp : p) &#123; if (pp == 2) continue; for (auto now = pp; now &lt; N; now *= pp) &#123; has_primitive_root.set(now); if (now * 2 &lt; N) has_primitive_root.set(now * 2); &#125; &#125; vector&lt;llong&gt; ans; for (auto T = read(); T--;) &#123; auto n = read(), d = read(), phi = n; if (has_primitive_root[n]) &#123; set&lt;int&gt; de_n, de_phi; decompose(n, de_n); for (auto pi : de_n) (phi /= pi) *= (pi - 1); decompose(phi, de_phi); llong g = 0, lim = n; for (int i = 1; i &lt;= lim; ++ i) if (check_primitive_root(de_phi, i, phi, n)) &#123; g = i; break; &#125; if (!g) &#123; cout &lt;&lt; 0 &lt;&lt; endl &lt;&lt; endl; continue; &#125; ans.clear(); for (auto gi = g, i = 1ll; i &lt;= phi; ++ i, (gi *= g) %= n) &#123; if (gcd(i, phi) == 1) ans.push_back(gi); &#125; sort(ans.begin(), ans.end()); cout &lt;&lt; ans.size() &lt;&lt; endl; for (auto id = d - 1; id &lt; ans.size(); id += d) cout &lt;&lt; ans[id] &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl; &#125; else cout &lt;&lt; 0 &lt;&lt; endl &lt;&lt; endl; &#125; return 0;&#125; 首先筛出质数，再筛出所有的可能有原根的数——这一步是 \\(\\mathcal O (n\\log n)\\) 的；对于一个有原根的数 \\(n\\)，首先利用筛的结果（当然也可以直接用线性筛直接算好了存起来）根据定义求出 \\(\\phi(n)\\)，然后再利用筛维护的数据（或者埃氏筛直接存起来）分解其质因数存好备用；暴力枚举，并且利用上面说的方法来检查其是否为原根，求出最小原根——这一步是理论 \\(\\mathcal O (\\sqrt[4]n\\log n)\\) 的；最后再利用最小原根生成所有的原根：这需要重复 \\(\\phi(n)\\) 次，每次使用 \\(\\gcd\\) 检查——这一步是 \\(\\mathcal O(\\phi(n)\\log n)\\) 的。 上面的代码可以通过 P6091 【模板】原根。需要注意虽然最小原根有这个理论界限，但是求的时候只遍历到 \\(\\lceil n^\\frac14\\rceil\\) 似乎会暴毙…… 阶和原根 那么如何理解这两个抽象的概念呢？ 后记 参考资料 题解 P3803 【【模板】多项式乘法（NTT）】2 - attack 的博客 - 洛谷博客 (luogu.com.cn) 快速数论变换（NTT）超详解 - 知乎 (zhihu.com) 阶与原根 - 知乎 (zhihu.com) 算法学习笔记(40): 原根 - 知乎 (zhihu.com)","categories":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"算法/数学","permalink":"https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"数论","slug":"数论","permalink":"https://shiraha.cn/tags/%E6%95%B0%E8%AE%BA/"},{"name":"FFT","slug":"FFT","permalink":"https://shiraha.cn/tags/FFT/"},{"name":"NTT","slug":"NTT","permalink":"https://shiraha.cn/tags/NTT/"}]},{"title":"数论分块入门","slug":"The-concept-of-number-theory-partition","date":"2021-07-08T07:19:09.000Z","updated":"2021-07-11T14:29:09.000Z","comments":true,"path":"2021/The-concept-of-number-theory-partition/","link":"","permalink":"https://shiraha.cn/2021/The-concept-of-number-theory-partition/","excerpt":"","text":"《退役人的自我救赎系列》——其一，也就是基础的数论知识。 整除分块 求解 \\(\\sum_{i=1}^n \\frac{n}i\\) 的值，\\(n\\) 是 \\(10^{10}\\) 级别。 暴力是 \\(\\mathcal{O}(n)\\) 的，死了；但是 \\(\\lfloor \\frac{n}i\\rfloor\\) 的结果是根据块状分布的，且最多只会有 \\(2\\sqrt{n}\\) 种不同的值。因此，我们可以利用这个性质得到一个 \\(\\mathcal{O}(\\sqrt{n})\\) 的算法。 直接地说，\\(\\lfloor \\frac{n}i\\rfloor\\) 的值在一段连续的区间内具有相同的值，且这个区间具有右端点 \\(\\lfloor \\frac{n}{\\lfloor\\frac{n}i\\rfloor}\\rfloor\\)。 1234for (int l = 1, r; l &lt;= n; l = r + 1) &#123; r = min(n / (n / l), n); procedure(l, r); // [l, r] 的值是 n / l&#125; 上述的写法需要注意的就是 n / l 可能为 0 导致除法除零，一般来说需要特判一下。 CQOI2007：余数求和 那来点模板题。求的是模数和，看起来和上面的整除分块没有什么关系，但是： \\[ \\sum_{i=1}^n k\\mod i = \\sum_{i=1}^n k - \\lfloor\\frac{k}i\\rfloor i = nk - \\sum_{i=1}^n \\lfloor\\frac{k}i\\rfloor i \\] 这样处理之后，右边的部分仍然不是我们熟悉的整出分块形式，所以还需要进一步处理； 我们已经知道了 \\(\\sum_{i=1}^n \\lfloor\\frac{k}i\\rfloor\\) 在一定范围内具有相同的值，那么在块内我们令 \\(T_j = \\lfloor\\frac{k}j\\rfloor\\)，那么就可以进行如下形式的化简: \\[ \\sum_{i=1}^n \\lfloor\\frac{k}i\\rfloor i = \\sum_{i=1}^n T_i\\cdot i = \\sum_j\\sum_{i=L}^R T_i\\cdot \\sum_{i=L}^R i \\] 这样，在每一个分块内，左边是整除分块，右边是一个公差为 1 的等差数列；块内只需要一个定值和一个很好求的和，就可以分块来做了： 1234567891011121314signed main() &#123;#ifndef ONLINE_JUDGE freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif auto n = read(), k = read(); auto ans = n * k; for (llong l = 1, r; l &lt;= n; l = r + 1) &#123; if (k / l) r = min(k / (k / l), n); else r = n; ans -= (r - l + 1) * (l + r) / 2 * (k / l); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 好了，现在你已经学会了数论分块了！ 清华集训2012：模积和 题目是要求了 \\(i\\ne j\\)，所以我们需要转化为下面的形式： \\[ \\sum_{i=1}^n\\sum_{j=1}^m[i\\ne j](n\\ \\text{mod}\\ i)(m\\ \\text{mod}\\ j) \\\\ = \\sum_{i=1}^n\\sum_{j=1}^m(n\\ \\text{mod}\\ i)(m\\ \\text{mod}\\ j) - \\sum_{i=1}^{\\min(n, m)}(n\\ \\text{mod}\\ i)(m\\ \\text{mod}\\ i) \\] 然后，先处理上述式子的第一项；最直接的做法就是拆开化简： \\[ {align} \\begin{align} 原式 &amp;= \\sum_{i=1}^n\\sum_{j=1}^m (n-\\lfloor\\frac{n}i\\rfloor i)(m - \\lfloor\\frac{m}j\\rfloor j) \\\\ &amp;= \\sum_{i=1}^n\\sum_{j=1}^m nm - \\lfloor\\frac{n}i\\rfloor im - \\lfloor\\frac{m}j\\rfloor jn + \\lfloor\\frac{m}j\\rfloor\\lfloor\\frac{n}i\\rfloor i j \\\\ &amp;= n^2m^2 - nm^2\\sum_{i=1}^n\\lfloor\\frac{n}i\\rfloor i-n^2m\\sum_{j=1}^m\\lfloor\\frac{m}j\\rfloor j + nm\\sum_{i=1}^n\\lfloor\\frac{n}i\\rfloor i\\cdot\\sum_{j=1}^m\\lfloor\\frac{m}j\\rfloor j \\end{align} \\] 当然，也可以类似于上面求余数和的做法那样直接拆成： \\[ \\sum_{i=1}^n(n\\ \\text{mod}\\ i) \\cdot \\sum_{j=1}^m(m\\ \\text{mod}\\ j) \\] 也可以拆出相同的结果。 总而言之，上面的式子就被拆成了一些和上面模数求和一样的形式的组合，只需要分别求出两个互不相关的部分的和就可以算出题目种式子的左边部分；接下来处理右边部分，我们先约定 \\(k = \\min(n, m)\\)： \\[ \\begin{align} 原式 &amp;= \\sum_{i=1}^k (n-\\lfloor\\frac{n}i\\rfloor i)(m - \\lfloor\\frac{m}i\\rfloor i) \\\\ &amp;= \\sum_{i=1}^k(nm - m\\lfloor\\frac{n}i\\rfloor i - n\\lfloor\\frac{m}i\\rfloor i + \\lfloor\\frac{m}i\\rfloor\\lfloor\\frac{n}i\\rfloor i^2) \\\\ &amp;= knm - m\\sum_{i=1}^k\\lfloor\\frac{n}i\\rfloor i - n\\sum_{i=1}^k\\lfloor\\frac{m}i\\rfloor i + \\sum_{i=1}^k\\lfloor\\frac{n}i\\rfloor \\lfloor\\frac{m}i\\rfloor i^2 \\end{align} \\] 还是一样可以使用模数分块的方法求出。 此外，提一下考研常用公式：\\(\\sum_{i=1}^n i^2 = \\frac16n(n+1)(2n+1)\\) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364constexpr lll mod = 19940417;lll fast_pow(lll a, lll b = mod - 2) &#123; lll ret = 1; while (b) &#123; if (b &amp; 1) (ret *= a) %= mod; (a *= a) %= mod, b &gt;&gt;= 1; &#125; return ret %= mod;&#125;llong euler_phi(llong n) &#123; auto ans = n; for (llong i = 2; i * i &lt;= n; ++i) if (!(n % i)) &#123; ans = ans / i * (i - 1); while (!(n % i)) n /= i; &#125; if (n &gt; 1) ans = ans / n * (n - 1); return ans;&#125;signed main() &#123;#ifndef ONLINE_JUDGE freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif lll n = read(), m = read(), k = min(n, m); auto nm = n * m % mod, n2m = nm * n % mod; auto n2m2 = nm * nm % mod, nm2 = nm * m % mod; const auto calc = [](lll n, lll k) &#123; lll ret = 0; minimize(n, k); for (lll l = 1, r; l &lt;= n; l = r + 1) &#123; if (k / l) r = min(k / (k / l), n); else r = n; auto sum = (r - l + 1) * (l + r) / 2 % mod; (ret += sum * (k / l) % mod) %= mod; &#125; return ret %= mod; &#125;; const auto sum_mod = [&amp;calc](lll n, lll k) &#123; return (n * k % mod - calc(n, k) + mod) % mod; &#125;; const auto phi_mod = euler_phi(mod) - 1; const auto inv6 = fast_pow(6, phi_mod); const auto sum_i2 = [inv6](lll n) &#123; return n * (n + 1) % mod * (2 * n + 1) % mod * inv6 % mod; &#125;; const auto lp = sum_mod(n, n) * sum_mod(m, m) % mod; auto knm = k * nm % mod, rp = knm; for (lll l = 1, r; l &lt;= k; l = r + 1) &#123; if (n / l &amp;&amp; m / l) r = min(&#123;n / (n / l), m / (m / l), k&#125;); else r = k; auto si2 = (sum_i2(r) - sum_i2(l - 1) + mod) % mod; auto inm = (n / l) * (m / l) % mod; (rp += inm * si2 % mod) %= mod; &#125; auto ckn = calc(k, n), ckm = calc(k, m); auto tmp = (m * ckn % mod + n * ckm % mod) % mod; rp = (rp + mod - tmp) % mod; cout &lt;&lt; llong((lp + mod - rp) % mod) &lt;&lt; endl; return 0;&#125; 需要注意的是，\\(19940417 = 7\\times2848631\\)，并不是一个质数，所以不能用费马小定理求出模它意义下的逆元；但是 \\(6\\) 和它互质，故应当使用欧拉定理： 欧拉定理：若 \\(\\gcd(a, m) = 1\\)，则 \\(a^{\\phi(m)} \\equiv 1 \\ (\\text{mod} \\ m)\\)。 欧拉函数：\\(\\phi(n)\\)，表示了小于等于 \\(n\\) 的正整数和 \\(n\\) 互质的整数的个数。 标准分解式：将质因数分解的结果按照大小，由小到大排列，并将相同质因数连乘以指数形式表示。 如果一个数字的标准分解式可以写成：\\(n = p_1^{k_1}p_2^{k_2}\\cdots p_r^{k_r}\\)，那么： \\[ \\phi(n) = \\prod_{i=1}^rp_i^{k_i-1}(p_i-1)=\\prod_{p|n}p^{\\alpha_p-1}(p-1)=n\\prod_{p|n}(1-\\frac1p) \\] 可以使用上述公式计算欧拉函数。 求解单个欧拉函数值，可以使用 Pollard Rho 算法优化后根据定义求解；多个欧拉函数值则可以使用线性筛求解。 实战（？） 给了 \\(x_1, x_2, y_1, y_2\\)，求解： \\[ \\sum_{i=x_1}^{x_2}\\sum_{j=y_1}^{y_2}(\\lfloor\\frac{i}{x_1}\\rfloor+\\lfloor\\frac{x_2}i\\rfloor+\\lfloor\\frac{j}{y_1}\\rfloor+\\lfloor\\frac{y_2}j\\rfloor)^2 \\] 结果对 \\(10^9+7\\) 取模。 这是 CCPC 湘潭邀请赛 2021 的 C 题，无处补题。 ___MEL_9_R6YR3N0GK8937H.jpg 首先还是直接把它们乘开： \\[ \\begin{align} 原式 =&amp; (y_2-y_1+1)\\sum_{i=x_1}^{x_2}(\\lfloor\\frac{i}{x_1}\\rfloor+\\lfloor\\frac{x_2}i\\rfloor)^2 + (x_2-x_1+1)\\sum_{j=y_1}^{y_2}(\\lfloor\\frac{j}{y_1}\\rfloor+\\lfloor\\frac{y_2}j\\rfloor)^2 + \\\\ &amp;2\\sum_{i=x_1}^{x_2}\\sum_{j=y_1}^{y_2}(\\lfloor\\frac{i}{x_1}\\rfloor+\\lfloor\\frac{x_2}i\\rfloor)(\\lfloor\\frac{j}{y_1}\\rfloor+\\lfloor\\frac{y_2}j\\rfloor) \\end{align} \\] 可以看出前两项是一类的，第三项是另一类的；其中，前两项又可以进行这样的拆分： \\[ 原式 = \\sum_{i=x_1}^{x_2}\\lfloor\\frac{i}{x_1}\\rfloor^2 + 2\\sum_{i=x_1}^{x_2}\\lfloor\\frac{i}{x_1}\\rfloor\\lfloor\\frac{x_2}i\\rfloor + \\sum_{i=x_1}^{x_2}\\lfloor\\frac{x_2}i\\rfloor^2 \\] 又可以分成三项；其中第三项是我们这里提到的整除分块问题，第一项是我们再熟悉不过的“分块”，可以直接计算；那么问题就变成了中间的一部分——在这里我想要说的是这并没有什么特殊的性质（或者是我没有发现），只需要分块再分块然后直接计算就可以了。 那么回到第一组式子的第三项；注意到 \\(i\\) 和 \\(j\\) 是互不相关的，所以直接分别计算然后乘起来就行： \\[ 原式 = \\sum_{i=x_1}^{x_2}(\\lfloor\\frac{i}{x_1}\\rfloor+\\lfloor\\frac{x_2}i\\rfloor)\\cdot\\sum_{j=y_1}^{y_2}(\\lfloor\\frac{j}{y_1}\\rfloor+\\lfloor\\frac{y_2}j\\rfloor) \\] 只需要分别计算后求和，之后再在模意义下乘起来就得到了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899constexpr llong mod = 1e9 + 7;constexpr lll fast_pow(lll a, lll b = mod - 2) &#123; lll ret = 1; while (b) &#123; if (b &amp; 1) (ret *= a) %= mod; (a *= a) %= mod, b &gt;&gt;= 1; &#125; return ret %= mod;&#125;constexpr lll inv6 = fast_pow(6), inv2 = fast_pow(2);lll sum_i2(lll n) &#123; return n * (n + 1) % mod * (2 * n + 1) % mod * inv6 % mod;&#125;lll sum_i(lll n) &#123; return (n + 1) * n % mod * inv2 % mod;&#125;lll xi2(lll l, lll n, lll k) &#123; lll ret = 0; minimize(n, k); for (lll r; l &lt;= n; l = r + 1) &#123; if (k / l) r = min(k / (k / l), n); else r = n; auto val = (k / l) * (k / l) % mod; (ret += (r - l + 1) * val % mod) %= mod; &#125; return ret;&#125;lll xi(lll l, lll n, lll k) &#123; lll ret = 0; minimize(n, k); for (lll r; l &lt;= n; l = r + 1) &#123; if (k / l) r = min(k / (k / l), n); else r = n; (ret += (r - l + 1) * (k / l) % mod) %= mod; &#125; return ret;&#125;lll sum_ix(lll n, lll x) &#123; auto m = n % x + 1, d = n / x; if (!d) return 0; lll ret = x * sum_i(d - 1) % mod; (ret += m * d % mod) %= mod; return ret;&#125;lll sum_ix2(lll n, lll x) &#123; auto m = n % x + 1, d = n / x; if (!d) return 0; lll ret = x * sum_i2(d - 1) % mod; auto d2 = d * d % mod; (ret += m * d2 % mod) %= mod; return ret;&#125;lll ix(lll l, lll r, lll k) &#123; return (sum_ix(r, k) + mod - sum_ix(l - 1, k)) % mod;&#125;lll ix2(lll l, lll r, lll k) &#123; return (sum_ix2(r, k) + mod - sum_ix2(l - 1, k)) % mod;&#125;lll ix_xi(lll l, lll n, lll x1, lll x2) &#123; lll ret = 0; minimize(n, x2); for (lll r; l &lt;= n; l = r + 1) &#123; if (x2 / l) r = min(x2 / (x2 / l), n); else r = n; auto tmp = ix(l, r, x1); (ret += tmp * (x2 / l) % mod) %= mod; &#125; return ret;&#125;signed main() &#123;#ifndef ONLINE_JUDGE freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif for (auto T = read(); T --;) &#123; auto x1 = read(), x2 = read(), y1 = read(), y2 = read(); auto dy = y2 - y1 + 1, dx = x2 - x1 + 1; auto part1 = ix2(x1, x2, x1) + xi2(x1, x2, x2) + ix_xi(x1, x2, x1, x2) * 2; auto part2 = ix2(y1, y2, y1) + xi2(y1, y2, y2) + ix_xi(y1, y2, y1, y2) * 2; auto part3L = (ix(x1, x2, x1) + xi(x1, x2, x2)) % mod; auto part3R = (ix(y1, y2, y1) + xi(y1, y2, y2)) % mod; auto part3 = part3L * part3R % mod * 2 % mod; auto part12 = (part1 %= mod) * dy % mod + (part2 %= mod) * dx % mod; auto ans = (part12 + part3) % mod; cout &lt;&lt; (llong)ans &lt;&lt; endl; &#125; return 0;&#125; 已通过五组测试样例。 后记 参考资料 学习总结-莫比乌斯反演 - __allenge - 博客园 (cnblogs.com) 数论分块 - henry_y - 博客园 (cnblogs.com)","categories":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"算法/数学","permalink":"https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"数论","slug":"数论","permalink":"https://shiraha.cn/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"计算机网络实验报告（三合一）","slug":"computer-network-experiment-report-3-in-1","date":"2021-06-16T13:31:27.000Z","updated":"2021-06-16T13:31:27.000Z","comments":true,"path":"2021/computer-network-experiment-report-3-in-1/","link":"","permalink":"https://shiraha.cn/2021/computer-network-experiment-report-3-in-1/","excerpt":"","text":"本报告涉及到的源代码的位置：https://github.com/ma-hunter/cn_exp 班级 姓名 学号 软件工程 18XX 班 XXX U2018XXXXX 实验一：Wireshark 抓包工具使用 系统环境 软件版本 Windows 10 Pro 21H1 WIRESHARK Version 3.4.6 (v3.4.6-0-g6357ac1405b8) 一、实验目的 学习 Wireshark 抓包工具的使用 了解 Wireshark 抓包工具的功能 通过学习，进一步理解协议及网络体系结构思想 二、实验内容 使用 Wireshark，并学习使用它进行网络包分析。 三、实验原理 Wireshark 是网络包分析工具；网络包分析工具的主要作用是尝试捕获网络包，并尝试显示包的尽可能详细的情况。Wireshark 常见的应用如下： 网络管理员用来解决网络问题 网络安全工程师用来检测安全隐患 开发人员用来测试协议执行情况 这里，我们通过 Wireshark 来学习常见的网络协议。 四、实验过程 包含了从安装 Wireshark 开始到使用 Wireshark 观察一些现象的过程： 4.1 下载 Wireshark Wireshark 的官方网站是：https://www.wireshark.org/，下载地址是https://2.na.dl.wireshark.org/win64/Wireshark-win64-3.4.6.exe 4.2 准备工作 再 Powershell 中输入 ipconfig 查询本机的 IP 信息： 查看IP地址 在同局域网下打开另一台设备，启动一个服务器： 局域网内开启服务器 查看局域网内的这台设备的 IP 地址： 检查局域网内服务器IP 可以得到的信息汇总如下： 机器 IP(v4) 地址 子网掩码 默认网关 主机 192.168.3.2 255.255.255.0 192.168.3.1 服务器 192.168.3.71 255.255.255.0 192.168.3.1 因为只需要这些信息，所以直接在 Powershell 中获取；需要更详细的信息也可以通过网络适配器选项中来获得。接下来使用 Wireshark 捕获两者之间的通讯数据包，并且进行分析。 4.3 启动 Wireshark 首先需要先选择监听的网络设备： 打开网络设备 然后，就可以开始捕获以太网的通信数据包： 正在捕获以太网 接下来，可以进行捕获通过它的特定报文，并且分析内容。 4.4 TCP握手 浏览器访问上面查询到的服务器的地址 http://192.168.3.71，并且在 Wireshark 中设定限制条件（过滤器） ip.src == 192.168.3.71 or ip.dst == 192.168.3.71 来只捕获来自这两个 IP 地址之间的通信。 TCP握手 高亮的部分就是 TCP 的三次握手。 4.5 TCP报文分析示例 这是上述三次握手过程中的第二次握手的报文的详细信息： 报文详细分析 项目 信息 说明 源端口 80 服务器的 HTTP 默认端口，服务确实开在 80 端口上 目的端口 61577 用户浏览器当前开启的用于和服务器通信的端口 TCP 段长度 0 该报文不携带数据 Sequence 数字 0 Seq=0 Acknowledge 数字 1 期望收到的下一个报文满足 Seq=1 首部长度 32 bytes (8) 8 * 4B = 32 bytes 标志 0x012 SYN 和 ACK 位为 1 校验和 0x5426 校验和为 0x5426，未验证 4.6 HTTP报文分析 在 TCP 握手完成之后，服务器将使用 HTTP 协议传输数据到浏览器；我们在紧接着握手完成后面的位置找到了使用 HTTP 协议传输的数据包；可以打开查看其详细信息： HTTP报文 内容 信息 GET / HTTP/1.1 操作类型：GET；遵循了 HTTP 1.1 版本的协议 Host: 192.168.3.71 主机名：192.168.3.71；当绑定域名的场合下会是主机的域名 Connection: keep-alive 连接类型是保持持久连接 User-Agent: ... 用户的客户端信息；这里有个 Mozilla/5.0 (Windows NT 10.0 ...) 说明是运行在 Windows 10 上的火狐浏览器 …… …… HTTP 头能塞的东西还挺多的，这里就不全部说明了；当然，这里所包含的项目也未必完整。 五、思考题 网络工程师能通过 Wireshark 做哪些工作？ 检查网络协议的执行情况 排查网络故障，解决网络问题 网络攻防，检测网络安全隐患 实验二：WinPcap 编程 系统环境 开发环境 Windows 10 Pro 21H1 CLion 2021.1; CMake 3.19; tdm-gcc 9.3; NpCap SDK 1.07 一、实验目的 了解 NpCap 架构和运行逻辑 学习使用 NpCap SDK 进行编程 二、实验内容 通过学习 NpCap SDK，编写一个网络抓包程序 三、实验原理 本实验主要基于 NpCap 完成，所以这里主要是关于 NpCap 的介绍： 3.1 NpCap概述 WinPcap 是一个基于Win32平台的，用于捕获网络数据包并进行分析的开源库；在 Linux 上也有对应的 LibPcap；目前 WinPcap 已经处于无人维护的状态，对于 Windows 10 有更新的且目前有人维护的开源项目 NpCap。 大多数网络应用程序通过被广泛使用的操作系统元件来访问网络，比如 sockets——这是一种简单的实现方式，因为操作系统已经妥善处理了底层具体实现细节（比如协议处理，封装数据包等等工作），并且提供了一个与读写文件类似的，令人熟悉的接口；但是有些时候，这种“简单的实现方式”并不能满足需求，因为有些应用程序需要直接访问网络中的数据包：也就是说原始数据包——即没有被操作系统利用网络协议处理过的数据包。而 WinPcap/NpCap 则为 Win32 应用程序提供了这样的接口： 捕获原始数据包；无论它是发往某台机器的，还是在其他设备（共享媒介）上进行交换的 在数据包发送给某应用程序前，根据指定的规则过滤数据包 将原始数据包通过网络发送出去 收集并统计网络流量信息 SDK 提供的这些功能需要借助运行在 Win32 内核中的网络设备驱动程序来实现；在安装完成驱动之后，SDK 将这些功能作为一个接口表现出来以供使用。 3.2 要使用的接口 以下介绍了实现后文提到的 demo 所需要使用的 NpCap API 的简单介绍： 3.2.1 pcap_findalldevs NpCap 提供了 pcap_findalldevs_ex 和 pcap_findalldevs 函数来获取计算机上的网络接口设备的列表；此函数会为传入的 pcap_if_t 赋值——该类型是一个表示了设备列表的链表头；每一个这样的节点都包含了 name 和 description 域来描述设备。 除此之外，pcap_if_t 结构体还包含了一个 pcap_addr 结构体；后者包含了一个地址列表、一个掩码列表、一个广播地址列表和一个目的地址的列表；此外，pcap_findalldevs_ex 还能返回远程适配器信息和一个位于所给的本地文件夹的 pcap 文件列表。 3.2.2 pcap_open 用来打开一个适配器，实际调用的是 pcap_open_live；它接受五个参数： name：适配器的名称（GUID） snaplen：制定要捕获数据包中的哪些部分。在一些操作系统中 (比如 xBSD 和 Win32)，驱动可以被配置成只捕获数据包的初始化部分：这样可以减少应用程序间复制数据的量，从而提高捕获效率；本次实验中，将值定为 65535，比能遇到的最大的MTU还要大，因此总能收到完整的数据包。 flags：主要的意义是其中包含的混杂模式开关；一般情况下，适配器只接收发给它自己的数据包， 而那些在其他机器之间通讯的数据包，将会被丢弃。但混杂模式将会捕获所有的数据包——因为我们需要捕获其他适配器的数据包，所以需要打开这个开关。 to_ms：指定读取数据的超时时间，以毫秒计；在适配器上使用其他 API 进行读取操作的时候，这些函数会在这里设定的时间内响应——即使没有数据包或者捕获失败了；在统计模式下，to_ms 还可以用来定义统计的时间间隔：设置为 0 说明没有超时——如果没有数据包到达，则永远不返回；对应的还有 -1：读操作立刻返回。 errbuf：用于存储错误信息字符串的缓冲区 该函数返回一个 pcap_t 类型的 handle。 3.2.3 pcap_loop API 函数 pcap_loop 和 pcap_dispatch 都用来在打开的适配器中捕获数据包；但是前者会已知捕获直到捕获到的数据包数量达到要求数量，而后者在到达了前面 API 设定的超时时间之后就会返回（尽管这得不到保证）；前者会在一小段时间内阻塞网络的应用，故一般项目都会使用后者作为读取数据包的函数；虽然在本次实验中，使用前者就够了。 这两个函数都有一个回调函数；这个回调函数会在这两个函数捕获到数据包的时候被调用，用来处理捕获到的数据包；这个回调函数需要遵顼特定的格式。但是需要注意的是我们无法发现 CRC 冗余校验码——因为帧到达适配器之后，会经过校验确认的过程；这个过程成功，则适配器会删除 CRC；否则，大多数适配器会删除整个包，因此无法被 NpCap 确认到。 3.2.4 pcap_datalink 用于对 MAC 层进行了检测，以确保在处理一个以太网络，确保 MAC 首部是14位的。IP 数据包的首部就位于 MAC 首部的后面，将从 IP 数据包的首部解析到源 IP 地址和目的 IP 地址。 3.2.5 pcap_compile &amp; pcap_setfilter 用来设置过滤器，以避免处理一些无用的包，提高包处理的效率。在本次实验中我们需要将过滤器字符串设置成 ip and udp，使得我们传入的回调只处理基于 IPv4 的 UDP 数据包；大大简化了解析过程和回调函数的调用次数。 3.3 其他的补充 处理 UDP 数据包的首部时存在一些困难：因为 IP 数据包的首部的长度并不是固定的，但是可以通过 IP 数据包的 length 域来得到它的长度；一旦知道了 UDP 首部的位置，就能解析到源端口和目的端口。 四、实验过程 从安装 NpCap 到运行 NpCap 示例程序的全部过程； 4.1 安装 NpCap NpCap 是 WinPcap for Windows 10；它的官方下载页面是 Npcap: Windows Packet Capture Library &amp; Driver (nmap.org)；在这里我们需要下载： NpCap 内核驱动：Npcap 1.31 installer NpCap SDK 文件：Npcap SDK 1.07 安装完成驱动后，再在 IDE 中为项目配置导入 NpCap SDK 文件。NpCap SDK 文件包中包括了使用 NpCap 实现的基本功能的 demo。 4.2 使用 NpCap 的功能 项目的文件结构如下： 123456789CMake target: if_list udp_dump basic_dump_ex(root)├ module│ └ (NpCap Library files) NpCap SDK 库文件├ src│ ├ basic_dump_ex.c 目标 basic_dump_ex 的源文件│ ├ if_list.c 目标 if_list 的源文件│ └ udp_dump.c 目标 udp_dump 的源文件└ CMakeList.txt CMake 项目定义文件 这些使用 NpCap 功能的 demo 的实现代码都位于：https://github.com/ma-hunter/cn_exp 五、实验结果 上述代码包括的，使用 NpCap 实现的几项基本功能的运行结果（非截图）。 5.1 读取网络设备列表 使用 CMake，构建并运行上述项目中的目标 if_list： 1234567&quot;D:\\Program Files\\JetBrains\\Toolbox\\apps\\CLion\\ch-0\\211.6693.114\\bin\\cmake\\win\\bin\\cmake.exe&quot; --build D:\\Workspaces\\CLion\\cn_exp\\cmake-build-debug --target if_list -- -j 4Scanning dependencies of target if_list[ 50%] Building C object CMakeFiles&#x2F;if_list.dir&#x2F;src&#x2F;if_list.c.obj[100%] Linking C executable if_list.exe[100%] Built target if_list构建已完成 运行结果如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495D:\\Workspaces\\CLion\\cn_exp\\cmake-build-debug\\if_list.exe \\Device\\NPF_&#123;5C8B26D4-9439-4304-B8FB-48A81CB33CF9&#125; Description: WAN Miniport (Network Monitor) Loopback: no\\Device\\NPF_&#123;C21F9683-BA8A-4AFE-827A-166030BB1466&#125; Description: WAN Miniport (IPv6) Loopback: no\\Device\\NPF_&#123;1C99E263-4855-4786-97ED-ECAC30A11761&#125; Description: WAN Miniport (IP) Loopback: no\\Device\\NPF_&#123;1A386F2B-3A3E-49A7-B899-2629C46C4FB3&#125; Description: Hyper-V Virtual Ethernet Adapter #2 Loopback: no Address Family: #23 Address Family Name: AF_INET6 Address Family: #2 Address Family Name: AF_INET Address: 172.26.112.1 Netmask: 0.240.255.255 Broadcast Address: 255.31.112.1\\Device\\NPF_&#123;A30B9DA2-E755-4DF6-8BD4-010B6590B072&#125; Description: Hyper-V Virtual Ethernet Adapter Loopback: no Address Family: #23 Address Family Name: AF_INET6 Address Family: #2 Address Family Name: AF_INET Address: 172.26.0.1 Netmask: 0.240.255.255 Broadcast Address: 255.31.0.1\\Device\\NPF_&#123;21EAB23F-F3E5-48E0-B370-35B69F40B833&#125; Description: Bluetooth Device (Personal Area Network) #3 Loopback: no Address Family: #23 Address Family Name: AF_INET6 Address Family: #2 Address Family Name: AF_INET Address: 169.254.62.143 Netmask: 0.0.255.255 Broadcast Address: 255.255.62.143\\Device\\NPF_&#123;5CCBE082-6FB3-4754-B27A-3659F98979BE&#125; Description: Realtek RTL8188EU Wireless LAN 802.11n USB 2.0 Network Adapter Loopback: no Address Family: #23 Address Family Name: AF_INET6 Address Family: #2 Address Family Name: AF_INET Address: 169.254.125.212 Netmask: 0.0.255.255 Broadcast Address: 255.255.125.212\\Device\\NPF_&#123;E919BE86-5601-4998-B187-2C629DE1F9B9&#125; Description: Microsoft Wi-Fi Direct Virtual Adapter #2 Loopback: no Address Family: #23 Address Family Name: AF_INET6 Address Family: #2 Address Family Name: AF_INET Address: 169.254.194.126 Netmask: 0.0.255.255 Broadcast Address: 255.255.194.126\\Device\\NPF_&#123;FF7337C5-5DA3-4AF4-8C55-5A066C578D65&#125; Description: Microsoft Wi-Fi Direct Virtual Adapter Loopback: no Address Family: #23 Address Family Name: AF_INET6 Address Family: #2 Address Family Name: AF_INET Address: 169.254.180.74 Netmask: 0.0.255.255 Broadcast Address: 255.255.180.74\\Device\\NPF_&#123;43524049-AA60-4F6E-A89E-8AE5BA1EAA93&#125; Description: Realtek PCIe GbE Family Controller Loopback: no Address Family: #23 Address Family Name: AF_INET6 Address Family: #2 Address Family Name: AF_INET Address: 192.168.3.2 Netmask: 0.255.255.255 Broadcast Address: 255.168.3.2\\Device\\NPF_Loopback Description: Adapter for loopback traffic capture Loopback: yes进程已结束，退出代码为 0 于此同时可以看到控制面板下的网络适配器页面；可以看到基本的适配器信息是一致的： 网络适配器.png 我们的 demo 输出的更多是因为包含了一些被操作系统用户级别隐藏的接口。 5.2 打开设别并抓包监听 使用 CMake，构建并运行上述项目中的目标 basic_dump_ex： 1234567&quot;D:\\Program Files\\JetBrains\\Toolbox\\apps\\CLion\\ch-0\\211.6693.114\\bin\\cmake\\win\\bin\\cmake.exe&quot; --build D:\\Workspaces\\CLion\\cn_exp\\cmake-build-debug --target basic_dump_ex -- -j 4Scanning dependencies of target basic_dump_ex[ 50%] Building C object CMakeFiles&#x2F;basic_dump_ex.dir&#x2F;src&#x2F;basic_dump_ex.c.obj[100%] Linking C executable basic_dump_ex.exe[100%] Built target basic_dump_ex构建已完成 运行结果如下： 1234567891011121314151617181920212223D:\\Workspaces\\CLion\\cn_exp\\cmake-build-debug\\basic_dump_ex.exe1. \\Device\\NPF_&#123;5C8B26D4-9439-4304-B8FB-48A81CB33CF9&#125; (WAN Miniport (Network Monitor))2. \\Device\\NPF_&#123;C21F9683-BA8A-4AFE-827A-166030BB1466&#125; (WAN Miniport (IPv6))3. \\Device\\NPF_&#123;1C99E263-4855-4786-97ED-ECAC30A11761&#125; (WAN Miniport (IP))4. \\Device\\NPF_&#123;1A386F2B-3A3E-49A7-B899-2629C46C4FB3&#125; (Hyper-V Virtual Ethernet Adapter #2)5. \\Device\\NPF_&#123;A30B9DA2-E755-4DF6-8BD4-010B6590B072&#125; (Hyper-V Virtual Ethernet Adapter)6. \\Device\\NPF_&#123;21EAB23F-F3E5-48E0-B370-35B69F40B833&#125; (Bluetooth Device (Personal Area Network) #3)7. \\Device\\NPF_&#123;5CCBE082-6FB3-4754-B27A-3659F98979BE&#125; (Realtek RTL8188EU Wireless LAN 802.11n USB 2.0 Network Adapter)8. \\Device\\NPF_&#123;E919BE86-5601-4998-B187-2C629DE1F9B9&#125; (Microsoft Wi-Fi Direct Virtual Adapter #2)9. \\Device\\NPF_&#123;FF7337C5-5DA3-4AF4-8C55-5A066C578D65&#125; (Microsoft Wi-Fi Direct Virtual Adapter)10. \\Device\\NPF_&#123;43524049-AA60-4F6E-A89E-8AE5BA1EAA93&#125; (Realtek PCIe GbE Family Controller)11. \\Device\\NPF_Loopback (Adapter for loopback traffic capture)Enter the interface number (1-11):10listening on Realtek PCIe GbE Family Controller...13:36:31,027242 len:20813:36:31,068904 len:107113:36:31,122063 len:5413:36:31,423026 len:6013:36:31,423094 len:5413:36:31,750427 len:33613:36:31,750466 len:32013:36:31,782177 len:66 程序将会运行到被外部中断阻止后才会停止运行。 5.3 捕获UDP包并分析 使用 CMake，构建并运行上述项目中的目标 basic_dump_ex： 1234&quot;D:\\Program Files\\JetBrains\\Toolbox\\apps\\CLion\\ch-0\\211.6693.114\\bin\\cmake\\win\\bin\\cmake.exe&quot; --build D:\\Workspaces\\CLion\\cn_exp\\cmake-build-debug --target udp_dump -- -j 4[100%] Built target udp_dump构建已完成 运行结果如下： 12345678910111213141516171819202122D:\\Workspaces\\CLion\\cn_exp\\cmake-build-debug\\udp_dump.exe1. \\Device\\NPF_&#123;5C8B26D4-9439-4304-B8FB-48A81CB33CF9&#125; (WAN Miniport (Network Monitor))2. \\Device\\NPF_&#123;C21F9683-BA8A-4AFE-827A-166030BB1466&#125; (WAN Miniport (IPv6))3. \\Device\\NPF_&#123;1C99E263-4855-4786-97ED-ECAC30A11761&#125; (WAN Miniport (IP))4. \\Device\\NPF_&#123;1A386F2B-3A3E-49A7-B899-2629C46C4FB3&#125; (Hyper-V Virtual Ethernet Adapter #2)5. \\Device\\NPF_&#123;A30B9DA2-E755-4DF6-8BD4-010B6590B072&#125; (Hyper-V Virtual Ethernet Adapter)6. \\Device\\NPF_&#123;21EAB23F-F3E5-48E0-B370-35B69F40B833&#125; (Bluetooth Device (Personal Area Network) #3)7. \\Device\\NPF_&#123;5CCBE082-6FB3-4754-B27A-3659F98979BE&#125; (Realtek RTL8188EU Wireless LAN 802.11n USB 2.0 Network Adapter)8. \\Device\\NPF_&#123;E919BE86-5601-4998-B187-2C629DE1F9B9&#125; (Microsoft Wi-Fi Direct Virtual Adapter #2)9. \\Device\\NPF_&#123;FF7337C5-5DA3-4AF4-8C55-5A066C578D65&#125; (Microsoft Wi-Fi Direct Virtual Adapter)10. \\Device\\NPF_&#123;43524049-AA60-4F6E-A89E-8AE5BA1EAA93&#125; (Realtek PCIe GbE Family Controller)11. \\Device\\NPF_Loopback (Adapter for loopback traffic capture)Enter the interface number (1-11):10listening on Realtek PCIe GbE Family Controller...13:38:26.314222 len:181 192.168.3.2.7726 -&gt; 180.97.33.12.882913:38:26.339699 len:163 180.97.33.12.8829 -&gt; 192.168.3.2.772613:38:28.517235 len:361 223.166.151.86.8000 -&gt; 192.168.3.2.401713:38:28.517526 len:97 192.168.3.2.4017 -&gt; 223.166.151.86.800013:38:29.100916 len:82 192.168.3.2.60173 -&gt; 192.168.3.1.5313:38:29.151404 len:149 192.168.3.1.53 -&gt; 192.168.3.2.6017313:38:30.577642 len:129 223.166.151.86.8000 -&gt; 192.168.3.2.4017 程序将会运行到被外部中断阻止后才会停止运行。 六、思考题 WINPCAP是否能实现服务质量的控制？ 不能。WinPcap 可以独立地通过主机协议发送和接受数据，如同TCP/IP；这就意味着 WinPcap 不能阻止、过滤或操纵同一机器上的其他应用程序的通讯：它仅仅能简单地“监视”在网络上传输的数据包。所以，它不能提供类似网络流量控制、服务质量调度和个人防火墙之类的支持，因而不能实现服务质量的控制。 实验三：协议分析&amp;流量统计程序的编写 系统环境 开发环境 Windows 10 Pro 21H1 CLion 2021.1; CMake 3.19; tdm-gcc 9.3; NpCap SDK 1.07 一、实验目的 理解协议在通信中的作用，掌握常见 IP 协议； 掌握基于 NpCap 的抓包软件的开发； 掌握协议解析和流量统计的编程方法； 二、实验内容 利用 NpCap 编写协议分析工具；输出抓取的包和协议分析结构，并统计 IP 的流量（即包的数量）。 功能要求： 利用 NpCap 捕获数据包，并可根据要求进行数据包过滤。 根据IP协议，解析每个数据包的PCI，展示其在不同网络层次所使用的协议结构和具体信息。 根据IP地址，统计源自该IP地址的流量，即捕获到的数据包的数量。 运行程序后将捕获的信息输出到标准输出流中。 三、实验原理 实验的设计依据的原理，包括协议的概念和 NpCap 的接口使用逻辑。 3.1 协议说明 下面的内容包含了本次实验所涉及到的协议类型的说明。 3.1.1 协议栈分析 因为 TCP/IP 协议采用分层的结构，所以网络通信时，要传输的数据在发送端是一个逐层封装的过程；而相应地在接收端则是一个逐层分解的过程；如下图所示： 协议栈分析 在接收端的逐层分解，就是上述封装的逆过程； 3.1.2 以太网协议 以太网 II 格式时一种帧格式，应用最为广泛，几乎成为了当前以太网的现行标准；它由 RFC894 定义，如下图所示： 以太网协议.png 3.1.3 IP 协议 IP 协议是 Internet 的核心协议，它工作在网络层，提供了不可靠无连接的数据传送服务；协议格式如图所示： IP协议 3.1.4 ICMP协议 ICMP 的全称是 Internet 控制信息协议 (Internet Control Message Protocol)。它提供了很多 Internet 的信息描述服务：例如能够检测网络的运行状况，通知协议有用的网络状态信息；ICMP 是基于 IP 协议的，ICMP 协议格式如图所示： ICMP协议.png 3.1.5 TCP协议 TCP协议是基于连接的可靠的协议：它负责发收端的协定，然后保持正确可靠的数据传输服务；它在 IP 协议上运行，而 IP 无连接的协议，所以TCP丰富了IP协议的功能，使它具有可靠的传输服务；TCP 协议格式如图所示： TCP协议.png 可以看到 TCP 报文段结构由以下的部分组成： 源端口：指定了发送端的端口 目的端口：指定了接受端的端口号 序号：指明了段在即将传输的段序列中的位置 确认号：规定成功收到段的序列号，确认序号包含发送确认的一端所期望收到的下一个序号 TCP 偏移量：指定了段头的长度。段头的长度取决与段头选项字段中设置的选项 保留：指定了一个保留字段，以备将来使用 标志：SYN、ACK、PSH、RST、URG、FIN SYN： 表示同步 ACK： 表示确认 PSH： 表示尽快的将数据送往接收进程 RST： 表示复位连接 URG： 表示紧急指针 FIN： 表示发送方完成数据发送 窗口：指定关于发送端能传输的下一段的大小的指令 校验和：校验和包含 TCP 段头和数据部分，用来校验段头和数据部分的可靠性 紧急指针：指明段中包含紧急信息，只有当 U R G 标志置1时紧急指针才有效 选项：指定了公认的段大小，时间戳，选项字段的末端，以及指定了选项字段的边界选项 TCP 连接的建立和释放采用了三步握手法，如下图所示： TCP连接建立.jpg 其过程可以描述如下步骤： 主机一发出连接序号为 x（seq=x） 主机二应答接受主机一的连接请求，并声明自己的序号为 y（sqe=y，ACK=x+1） 主机一收到确认后，发送第一个数据 TPDU 并确认主机二的序号（seq=x，ACK=y+1） 至此，整个连接建立过程正常结束，数据传输已经正式开始。 3.1.6 UDP 协议 用户数据报协议 UDP 是在 IP 协议上的传输层协议，它提供了无连接的协议服务；它在IP协议基础上提供了端口的功能，因此既可让应用程序之间进行通信了。UDP 协议格式如图3.7所示： UDP协议.png 3.2 协议处理 NpCap 按照一定的规则提供了 API，和本次实验相关的逻辑如下： 3.2.1 NpCap 处理流程 NpCap 的工作周期可以被描述为如下序列： pcap_findalldevs &amp; pcap_findalldevs_ex：获得网络接口设备的列表 pcap_open &amp; pcap_dump_open &amp; pcap_open_live：打开设备/打开设备数据包 pcap_freealldevs：释放获得的设备列表结构所占用的内存 pcap_compile &amp; pcap_setfilter：编译并设置过滤器 pcap_loop：根据设定的数量来循环捕获数据包，并调用指定的回调处理数据包 packet_handler：传入 loop 的回调函数，用来处理被捕获的数据包 pcap_close：关闭 NpCap 句柄（即打开的网络设备） 简单地说，使用 NpCap 获得网络接口列表后，我们打开一个设备，并设定循环次数，传入指定类型的回调函数来处理被捕获的数据包，并在程序退出之前关闭设备。 3.2.2 回调函数设计 因为上述协议栈分析中提到了，接收端分析包的内容就是一个逆封装的过程，所以我们可以采用逐层递归的方法来设计我们的回调函数；基本设计如下： (pkt)：用来传入 NpCap 循环的，帧处理函数 (ethernet)：用来处理以太网协议的部分 (ipv4) &amp; (ipv6) &amp; (arp)：处理 IPv4、IPv6、ARP 协议的报头 (icmp) &amp; (tcp) &amp; (udp)：处理 ICMP、TCP、UDP 的报文 根据设计需求，在判断上一层的协议类型后，将待处理的报文递归给下一层的处理函数即可。 四、实验设计 关于代码实现方面的设计： 4.1 项目组成 项目可以分为 handlers、helpers 和 utils 三个部分组成； utils 包含了可复用的无后效逻辑的实现，尽量避免重复代码片段 handlers 包含了传给 NpCap 的回调函数以及递归下降法实现的逆封装函数 helpers 包含了要实现的额外功能，比如本次实验中的流量统计 这三个部分分别使用独立的头文件和源文件组成，被 main 模块引用。 4.2 预定义 项目所需要的类型定义都包含在 definitions.h 中；包含了根据协议的组成而设计的报文和报头的类型定义；因为最后捕获的数据包是指向一片连续内存块的指针，这里的定义必须保证指定的内存块可以完全转化为对应的包类型才行；因此，需要保证顺序和使用的基本数据类型完全和定义符合。 4.3 项目结构 最后，整个项目的文件结构如下： 123456789101112131415CMake target: cn_exp(root)├ module│ └ (NpCap Library files) NpCap SDK 库文件├ include│ ├ definitions.h 预定义的类型声明│ ├ handlers.h 递归下降法的包处理回调函数的声明│ ├ helpers.h 流量统计相关方法的声明│ └ utils.h 可复用模块的函数声明├ src│ ├ utils.cpp 可复用模块的函数实现│ ├ helpers.cpp 流量统计相关方法的实现│ └ handlers.cpp 递归下降法的包处理回调函数的实现├ CMakeList.txt CMake 项目定义文件└ main.cpp 主进程文件 使用 CMake 加载项目，并构建运行 cn_exp 即可生成目标。 五、实现代码 Github 链接：https://github.com/ma-hunter/cn_exp 六、实验结果 完成实现上文所述的程序后，运行程序，可以得到下面的结果： 6.1 运行结果 因为上传截图非常的麻烦，这里仅粘贴标准输出的文本。 6.1.1 选择网络设备 12345678910111213Hello, World! Hello NpCap!1.\\Device\\NPF_&#123;5C8B26D4-9439-4304-B8FB-48A81CB33CF9&#125;WAN Miniport (Network Monitor)2.\\Device\\NPF_&#123;C21F9683-BA8A-4AFE-827A-166030BB1466&#125;WAN Miniport (IPv6)3.\\Device\\NPF_&#123;1C99E263-4855-4786-97ED-ECAC30A11761&#125;WAN Miniport (IP)4.\\Device\\NPF_&#123;1A386F2B-3A3E-49A7-B899-2629C46C4FB3&#125;Hyper-V Virtual Ethernet Adapter #25.\\Device\\NPF_&#123;A30B9DA2-E755-4DF6-8BD4-010B6590B072&#125;Hyper-V Virtual Ethernet Adapter6.\\Device\\NPF_&#123;21EAB23F-F3E5-48E0-B370-35B69F40B833&#125;Bluetooth Device (Personal Area Network) #37.\\Device\\NPF_&#123;5CCBE082-6FB3-4754-B27A-3659F98979BE&#125;Realtek RTL8188EU Wireless LAN 802.11n USB 2.0 Network Adapter8.\\Device\\NPF_&#123;E919BE86-5601-4998-B187-2C629DE1F9B9&#125;Microsoft Wi-Fi Direct Virtual Adapter #29.\\Device\\NPF_&#123;FF7337C5-5DA3-4AF4-8C55-5A066C578D65&#125;Microsoft Wi-Fi Direct Virtual Adapter10.\\Device\\NPF_&#123;43524049-AA60-4F6E-A89E-8AE5BA1EAA93&#125;Realtek PCIe GbE Family Controller11.\\Device\\NPF_LoopbackAdapter for loopback traffic captureEnter the interface number (1-11): 6.1.2 设置监听循环的次数 123Enter the interface number (1-11):10 listening on Realtek PCIe GbE Family Controller....Please input the num of packets you want to catch(0 for keeping catching): 6.1.3 TCP协议解析示例 123456789101112131415161718192021222324Time: 12:54:00, 129446 Length: 60Type: 0x800 (IPv4)Destination address: c:c:b:6:c:eSource address: 8:a:0:c:6:cVersion: 5Header length: 5 (20B)Type of service: 96Total length: 40Identification: 22603Flags: 0Fragment offset: 64 (512 B)Protocol: TCPChecksum: 32469Source IP address: 39.96.132.69Destination IP address: 192.168.3.2Source port: 443Destination port: 55308Sequence: 744910189Acknowledgement: 846425137Data offset: 0 (0 B)Flags: ACKWindow: 28927Checksum: 54318Urgent pointer: 0 6.1.4 UDP协议解析示例 12345678910111213141516171819Time: 12:54:00, 148551 Length: 106Type: 0x800 (IPv4)Destination address: 8:a:0:c:6:cSource address: c:c:b:6:c:eVersion: 5Header length: 5 (20B)Type of service: 0Total length: 92Identification: 21792Flags: 0Fragment offset: 0 (0 B)Protocol: UDPChecksum: 0Source IP address: 192.168.3.2Destination IP address: 112.32.50.208Source port: 7726Destination port: 28078Length: 72Checksum: 26356 6.1.5 流量统计示例 1234567Flow counts: IP Flow111.206.210.75 3112.32.50.208 213.107.136.9 53192.168.3.2 3439.96.132.69 8 6.2 构建记录 123456789101112&quot;D:\\Program Files\\JetBrains\\Toolbox\\apps\\CLion\\ch-0\\211.6693.114\\bin\\cmake\\win\\bin\\cmake.exe&quot; -DCMAKE_BUILD_TYPE&#x3D;Debug -G &quot;CodeBlocks - MinGW Makefiles&quot; D:\\Workspaces\\CLion\\cn_exp-- Configuring done-- Generating done-- Build files have been written to: D:&#x2F;Workspaces&#x2F;CLion&#x2F;cn_exp&#x2F;cmake-build-debug&quot;D:\\Program Files\\JetBrains\\Toolbox\\apps\\CLion\\ch-0\\211.6693.114\\bin\\cmake\\win\\bin\\cmake.exe&quot; --build D:\\Workspaces\\CLion\\cn_exp\\cmake-build-debug --target cn_exp -- -j 4Scanning dependencies of target cn_exp[ 20%] Building CXX object CMakeFiles&#x2F;cn_exp.dir&#x2F;src&#x2F;handlers.cpp.obj[ 40%] Linking CXX executable cn_exp.exe[100%] Built target cn_exp构建已完成 七、思考题 应用WINPCAP能实现哪些网络应用? 捕获原始数据包。不管这个包是发往本地机，还是其他机器之间的交换包 在数据包被发送到应用程序之前，通过用户定义的规则过滤 向网络发送原始数据包 对网络通信量做出统计 参考资料 计算机网络 | 实验一 wireshark抓包工具使用_哆啦一泓的博客-CSDN博客 计算机网络 | 实验二 WINPCWP编程_哆啦一泓的博客-CSDN博客 计算机网络 | 实验三 协议分析程序的编写_哆啦一泓的博客-CSDN博客 Winpcap进行抓包，分析数据包结构并统计IP流量_include的博客-CSDN博客","categories":[{"name":"课业","slug":"课业","permalink":"https://shiraha.cn/categories/%E8%AF%BE%E4%B8%9A/"}],"tags":[{"name":"课内作业","slug":"课内作业","permalink":"https://shiraha.cn/tags/%E8%AF%BE%E5%86%85%E4%BD%9C%E4%B8%9A/"},{"name":"实验报告","slug":"实验报告","permalink":"https://shiraha.cn/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://shiraha.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Wireshark","slug":"Wireshark","permalink":"https://shiraha.cn/tags/Wireshark/"},{"name":"抓包","slug":"抓包","permalink":"https://shiraha.cn/tags/%E6%8A%93%E5%8C%85/"},{"name":"NpCap","slug":"NpCap","permalink":"https://shiraha.cn/tags/NpCap/"}]},{"title":"使用 Nginx 和 Keepalived 部署一个高可用的负载均衡的 web 应用","slug":"use-nginx-and-keepalived-to-host-a-web-server","date":"2021-06-08T16:06:59.000Z","updated":"2021-06-08T16:06:59.000Z","comments":true,"path":"2021/use-nginx-and-keepalived-to-host-a-web-server/","link":"","permalink":"https://shiraha.cn/2021/use-nginx-and-keepalived-to-host-a-web-server/","excerpt":"","text":"一般的 Web 应用是将写好的程序使用手段放在服务器上，然后在服务器上运行这些程序；这样其他计算机访问这台服务器的时候就可以使用这个应用。但是这样有一个明显的缺点就是一台主机的性能存在上限，当业务规模扩大，且业务要求提高的情况下，这种简单的部署形式就不能满足要求了。 实验环境：Ubuntu 20.04 电脑两台，处于同一局域网下。 首先，关于 Nginx 是什么和 Keepalived 是什么就不再赘述；这里仅简单说明实验操作过程： Nginx 开启负载均衡 具体来说可以按照以下步骤进行；我的第一台主机作为常用机，其上已经运行了 apache2 的服务；那么此时如果要再使用 nginx 的负载均衡，就需要先关闭原有的 apache2 以释放 80 端口。之后设置 nginx 的转发规则就可以实现负载均衡了； 安装基本的工具 即使是像 Ubuntu 这样已经成熟的发行版，也需要安装相当多的工具才能进行服务器的搭建： 1sudo apt install net-tools nginx vim 最主要的是第一项的 net-tools，它包含了重要的工具 ifconfig 可以用来查看 Linux 网络接口的信息；再完成了安装之后，我们可以运行下面的命令，来启动防火墙和 nginx： 1234sudo ufw app list # 列出所有可用的预设配置sudo ufw allow &#x27;Nginx Full&#x27; # 允许 Nginx 的所有 HTTP/HTTPS 链接sudo ufw enable # 根据设置的规则启用 UFW 防火墙sudo service nginx start 但是因为我的主机上同时还运行了 apache2 占用了 80 端口，所以需要先处理它，才能重新运行 Nginx； 关闭 Apache2（如果存在 我在尝试关闭 apache2 的时候遇到了如何关闭都无法解放端口占用的问题；后来通过修改 apache2 的监听端口+重启主机才释放了 80 端口给 nginx 使用。 修改 apache2 的监听端口1.png 修改 apache2 的监听端口2.png 根据 Ubuntu apache 默认页面，可以知道 apache2 的配置文件位于 /etc/apache2 目录下；首先需要修改 port.conf 中的端口监听信息，然后再根据文件的提示修改 sites-enabled/ 下的站点的监听信息。 做完这些重启 apache2 服务之后，就可以释放 apache2 对于端口 80 的占用了；此时运行 nginx 就可以正常启动服务了； 检查 Nginx 正常运行 使用 service 命令或者 systemctl 命令检查 nginx 的状态，可以看到如下页面： Nginx 已经正常运行.png 此时，apache2 和 nginx 同时运行，分别监听 8080 和 80 端口；分别访问这两个端口，可以在响应头中看到它们的响应分别来自不同的服务器： apache2 的服务器.png Apache2 监听的 8080 端口 nginx 的服务器.png Nginx 监听的 80 端口 至于为什么两个页面都是 “Apache2 Ubuntu Default Page”，是因为我先安装了 apache2，所以后安装的 nginx 创建的 index.html 被改名了；所以我们需要观察响应标头来判断相应的来源。 启动两个服务器 首先，我们需要写一个简单的页面，然后再把它们假设起来；这里也使用 Nginx 感觉有点麻烦了，所以使用了 Node.js 提供的简易 HTTP 服务器工具 serve；如果没有安装，需要先安装： 12sudo apt install npmsudo npm i -g serve 之后，我们需要写一个简单的网页： 写一个网页.png 然后复制两份，分别修改端口的标记； 复制两份并且修改端口标记.png 修改完成后，使用 serve 分别将服务启动在对应的端口，终端最后如下： 启动两个简易的 HTTP.png 在浏览器分别访问两个端口，以确认可以正常访问： 两个端口都可以正常运行.png 这样，我们就将这个简单的网页部署到了“两个不同的服务器”上了，接下来需要通过 Nginx 来实现负载均衡。 配置 Nginx 实现负载均衡需要先在配置文件中指定一个 upstream，其中包含了负载的服务器集群和它们的权重；Nginx 支持你选择特定的负载均衡的算法，如果不指定就是默认的轮询的方法；我们在 /etc/nginx/conf.d/ 下创建 nginx.conf；配置文件如下： nginx 配置文件.png 完成配置文件的编写之后，使用 sudo nginx -t 来检查配置文件是否有误或产生了冲突；如果没有意外，则重启 nginx 服务，就可以看到 80 端口会根据设置的权重自动转发到两个简易 HTTP 服务器上。 需要注意的是…… Nginx 有一个默认的服务器配置，位于 /etc/nginx/sites-enabled/ 目录下；这个服务器也是默认监听 80 端口的，会和我们已有的服务器产生冲突，所以要先移除；此外，不需要将我们创建的配置文件软链接到该目录，因为这样 Nginx 会扫描两次这个文件，从而继续得出端口冲突的结论。 移除多余的默认服务器，否则服务将无法启动.png 可以看到如果不删除这个配置文件，是无法通过 Nginx 的配置文件的测试的。同时，删除的只是链接到 sites-available 目录下的配置文件的软连接，并不会丢失这个配置；可以随时通过创建软连接的方式将这个配置文件拉回来。 大功告成！ 接下来，本机访问 localhost 或局域网内访问 http://192.168.3.2/（本机 IP），反复刷新，就可以看到端口标识根据配置文件中设置的权重反复横跳； 因为不好放视频，所以这里就不放了（ Keepalived 实现高可用 keepalived 的高可用基于多台 Nginx 服务器共用一个虚拟网关，当其中的一台炸了的时候，会自动从这个虚拟的地址中退出，从而保证了对于这个虚拟地址的访问总是有效的（只要有一台服务器在正常运行）；因此，这要求至少将这样的 nginx 部署到多个服务器上形成 nginx 服务器集群；因此，首先我们要像上一部分所做的那样在另一个服务器上操作一遍； 安装基本软件以远程操作 比起上面的软件，还需要额外安装 SSH 服务器，以在第一台主机上访问第二台主机： 1sudo apt install vim nginx net-tools openssh-server 安装完成后使用 ifconfig 获得第二台主机在局域网中的 IP，就可以在第一台主机上访问了： 连接 SSH 到第二台服务器.png 完成了基本软件安装后，启动 nginx，浏览器访问局域网 IP，可以看到 Nginx 欢迎页面，说明 Nginx 安装成功： 第二台服务器 Nginx 配置成功.png 因为这台主机上没有先装 apache2，所以 NginX 完成安装后就自动启动了； 配置 Nginx 的负载均衡并测试 按照上一个部分部署完负载均衡之后，发现在第一台服务器上无法访问我们部署的页面： 发现第二台服务器无法访问.png 在第二台主机上尝试直接访问 http://192.168.3.2:1919 和 http://192.168.3.2:9191 会发现无法打开页面，再联想到安装 Nginx 之后自动配置的防火墙，判断 1919 和 9191 端口被 ufw 屏蔽；所以在第一台主机上手动开放这两个端口，第二台服务器上的负载均衡就可以正常使用了。 在第一台服务器上修改防火墙配置开放端口，成功.png 使用 ufw 开放端口可以使用 sudo ufw allow &lt;port&gt; 来实现。 安装 Keepalived 在两台主机上安装 keepalived 并尝试运行： 12sudo apt install keepalivedsudo service keepalived start 会发现它们无法启动，因为缺少了配置文件： 无法启动keepalived，因为没有配置文件.png 因此我们需要为它们添加配置文件； 配置 Keepalived 这一步主要是为第一台主机（主机）和第二台主机（从机）分别增加 Keepalived 配置文件和对于 Nginx 服务器的监控脚本；这使得它们在可以正常工作的状态下连接了同一个虚拟网关，且在检测到 Nginx 服务器出现异常时即使退出，保持虚拟地址的访问总是可用的。 配置文件 配置文件主要需要指明本机 IP、检测脚本和虚拟网关三个部分，其他部分都可以照葫芦画瓢（）本机 IP 在进行前面的操作的时候我们已经都知道了，而检测脚本是可以直接 CV 的（bushi；虚拟网关需要在对应的主机上使用 ifconfig 查看你的 IP 是由哪一个名字的接口提供的；就像下面的图片中一样——192.168.3.2 这一局域网 IP 是由 enp2s0 提供的，所以虚拟网关的接口是该接口； 编写 keepalived 配置文件，利用 ifconfig 查看网卡.png 除此之外，还需要找到一个没有被占用的局域网 IP 地址作为对外暴露的虚拟地址，以隐藏背后的 Nginx 服务器集群；在这里，我选择的是没有被使用过的 192.168.3.216；最后的主从机配置文件分别如下： Master 的 keepalived.png 主机的配置文件 注意 virtual_ipaddress 的值实际上是 192.168.3.216 这一没有被任何主机占用的局域网 IP，并且和下面从机配置的虚拟 IP 地址保持一致。这里的截图里是错误示范（ Slave 的 keepalived.png 从机的配置文件 因为从机只有一个 USB 网卡，所以 interface 和一般的 Ubuntu 主机的默认网卡不一样。 检测脚本 用来检测 Nginx 服务器是否增长工作的脚本；我不懂，直接网上 CV 来的： 检查 Nginx 是否正常运行的脚本.png 遵循上面的配置文件，我们将这个脚本放在和配置文件同一个目录下，然后使用 chmod 赋予它可执行的权限，并运行一次——如果 Niginx 服务器当前正在正常运行，那么这个脚本会直接退出。 大功告成！ 完成这些操作之后，使用 service 或 systemctl 命令启动 keepalived 服务，就完成了部署： 增加权限并启动 keeplalived.png 此时，我们使用 ip a 可以观察到在我们指定的网络接口下多了额外的虚拟 IP 地址： 观察到虚拟 IP.png 现在，将主机和从机中的任意一个的 Nginx 服务中止，访问虚拟网关还是可以打开这个页面（并且包含了负载均衡）；Web 应用的可用性提高了！ 总结 首先，我们使用多个服务器部署了我们的 Web 应用；然后使用多台安装了 Nginx 的服务器部署负载均衡——这个集群中的每一台服务器都可以根据设定的权重将来自外部的请求分配到部署了 Web 应用的服务器上；同时，这些 Nginx 服务器通过 Keepalived，通过一个公共的虚拟网关对外部开放；当这些服务器中的任何一个机能出现了故障时，Keepalived 都会通过预先编写的脚本察觉到问题并立即使该服务器断开和虚拟网关的连接直到恢复，保证了来自外部的请求都会通过这个虚拟网关到达正常工作的服务器上，从而实现了高可用。 参考资料 历史记录丢失","categories":[{"name":"课业","slug":"课业","permalink":"https://shiraha.cn/categories/%E8%AF%BE%E4%B8%9A/"}],"tags":[{"name":"课内作业","slug":"课内作业","permalink":"https://shiraha.cn/tags/%E8%AF%BE%E5%86%85%E4%BD%9C%E4%B8%9A/"},{"name":"实验报告","slug":"实验报告","permalink":"https://shiraha.cn/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"nginx","slug":"nginx","permalink":"https://shiraha.cn/tags/nginx/"},{"name":"Linux","slug":"Linux","permalink":"https://shiraha.cn/tags/Linux/"},{"name":"Web","slug":"Web","permalink":"https://shiraha.cn/tags/Web/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://shiraha.cn/tags/Ubuntu/"}]},{"title":"2020 NWERC 回顾","slug":"2020-nwerc","date":"2021-05-21T15:30:21.000Z","updated":"2021-05-22T02:35:00.000Z","comments":true,"path":"2021/2020-nwerc/","link":"","permalink":"https://shiraha.cn/2021/2020-nwerc/","excerpt":"","text":"题目链接：https://codeforces.com/gym/103049 习题册文档：https://2020.nwerc.eu/files/nwerc2020problems.pdf 题解文档：https://2020.nwerc.eu/files/nwerc2020slides.pdf 唉，要是国内区域赛的网页也能像国外的这些这样就好了（）赛后关闭服务器不能说离谱，只能说非常离谱== 前言 银川站你科表现喜人，但是相应地，对于我这种目前还没有什么奖项的队伍而言的压力也是非同一般。更何况沈阳也因为疫情原因延期了我已经承受了太多，队内总体士气低下，所以就以欢乐赛的形式进行这一次周周练，希望可以找找比赛的感觉—— 也许是受了刺激不能再碌碌无为了！，在真机上装了 Ubuntu，这是第一次在较为接近现场赛的环境下作答（ 虽然但是，接下来还有下个赛季的邀请赛，还要好好打才行！要加油了！ 反思 首先是这次 VP 的成绩： Penalty A B C D E F G H I J K 713 -1 + +3 +1 + + 因为性质上是欢乐赛，所以打的挺懒散的——一直拖到三点半才开，中途甚至还有打了一半队友补了个觉的恶性事件以及打了一半队友泡方便面吃的鬼事情，所以总归是在意料之中；五个题也和最近 VP 这场的几个实力相近的队伍差不太多，所以倒也问题不大（ 唯一感觉有点发寒的就是大量的低级错误……只能说是我太久没有写代码没有读英文了，唉，我自裁（ 题解 K - Keyboardd 给了俩字符串，其中一个是另一个字符串中部分字符重复后得到的；得到所有重复了的字符（只输出一次） 虽然是模拟，但是实现还是没有那么直接； 1234567891011121314151617signed main() &#123; freopen(&quot;/home/nanami/CLionProjects/untitled/input.txt&quot;, &quot;r&quot;, stdin); string a, b, ans; getline(cin, a); getline(cin, b); auto al = a.length(), bl = b.length(); set&lt;char&gt; out; for (int i = 0, j = 0, k, l; i &lt; al;) &#123; for (l = i; l &lt; al; ++ l) if (a[i] != a[l]) break; for (k = j; k &lt; bl; ++ k) if (b[k] != a[i]) break; if (k - j &gt; l - i) out.insert(a[i]); j = k, i = l; &#125; for (auto ch : out) putchar(ch);&#125; 模拟的话就好好地用最正确的做法，不要无谓地浪费时间！当然，熟练度上来了就可以写出更漂亮的实现就是了。 C - Contest Struggles 给了 \\(n\\) 个数字的平均值和其中大小为 \\(k\\) 的子集的平均值，求剩余部分的平均值。 123456789101112int n, k, d, s;signed main() &#123; n = read(); k = read(); d = read(); s = read(); if(n == k) printf(&quot;impossible\\n&quot;); else &#123; long double ans = (long double) (n * d - s * k) / (long double) (n - k); if(ans &gt;= 0 &amp;&amp; ans &lt;= 100) printf(&quot;%.7Lf\\n&quot;, ans); else printf(&quot;impossible\\n&quot;); &#125;&#125; 没什么好说的。 H - Hot Springs 重新排序长度为 \\(n \\leq 2\\cdot10^5\\) 的数组，使得其差分数组的绝对值递增。 排序之后找到中间一个位置，然后左右横跳就行了； 123456789101112131415161718const int N = 1e5 + 5;int t[N];signed main() &#123;#ifndef ONLINE_JUDGE freopen(&quot;/home/nanami/CLionProjects/untitled/input.txt&quot;, &quot;r&quot;, stdin);#endif int n = read(); for (int i = 1; i &lt;= n; ++ i) t[i] = read(); sort(t + 1, t + 1 + n); int mid = n / 2 + 1, l = mid - 1, r = mid + 1; cout &lt;&lt; t[mid]; for (int i = 1; i &lt; n; ++ i) if (i % 2) cout &lt;&lt; &#x27; &#x27; &lt;&lt; t[l --]; else cout &lt;&lt; &#x27; &#x27; &lt;&lt; t[r ++]; cout &lt;&lt; endl;&#125; 注意别跳出边界了就行。 D - Dragon Balls 大小为 \\(10^6\\times10^6\\) 的平面上有不超过七个龙珠；每次你可以询问一个位置 \\((x, y)\\)，交互器会回答其中与你给出的位置直线距离最近的龙珠和你给出的点的距离；如果你询问了一个龙珠的位置，那么视为你已经将它收集，它不再出现在平面上；要求在 \\(1000\\) 次询问内收集所有龙珠。 虽然但是，龙珠只能在整点上；而众所周知，一个圆上的整点数量是极其有限的；所以我们随便问一个点，得到半径之后就遍历所有的可行的整点就可以找到了。更何况这个题时间限制足足给了 9s，还有和 7 一点关系都看不出来的 1000 次询问，我觉得这明摆着就是教我暴力（ 123456789101112131415161718192021222324252627const int N = 1e6 + 5;llong ii[N];signed main() &#123;#ifndef ONLINE_JUDGE freopen(&quot;/home/nanami/CLionProjects/untitled/input.txt&quot;, &quot;r&quot;, stdin);#endif for (int i = 1; i &lt; N; ++ i) ii[i] = (llong)i * i; auto n = read(); unordered_map&lt;llong, int&gt; mem; while (n) &#123; cout &lt;&lt; &quot;0 0&quot; &lt;&lt; endl; llong d = read(), lim = d / 2; if (!d) &#123; -- n; continue; &#125; for (int i = mem[d]; ii[i] &lt;= lim; ++ i) &#123; auto pos = lower_bound(ii, ii + N, d - ii[i]) - ii; auto res = ii[pos]; if (res + ii[i] != d) continue; cout &lt;&lt; pos &lt;&lt; &#x27; &#x27; &lt;&lt; i &lt;&lt; endl; if (!read()) &#123; -- n; mem[d] = i; break; &#125; if (res == ii[i]) continue; cout &lt;&lt; i &lt;&lt; &#x27; &#x27; &lt;&lt; pos &lt;&lt; endl; if (!read()) &#123; -- n; mem[d] = i; break; &#125; &#125; &#125;&#125; 但是非常不凑巧的是，我最开始的代码会在某些情况下处理完所有的龙珠之后继续询问，导致一开始 T 的飞起，我甚至一度怀疑我的判断是否合理（）只能说蠢到家了 == 实际上理性分析，每一次遍历一个圆，时间复杂度实际上是 \\(\\mathcal{O}(10^6\\log10^6)\\) 的，最多只有 7 个圆但是却 9s 的时间；就算询问次数爆了，也不会超时而是 WA 才对；这样一来怎么想都不可能超时……所以一定是逻辑写错了（）看来还是因为最近训练的不够多，导致对于这种问题不太敏感了== 一些思路 除了这种暴力的办法，我们当然可以想到一些更加“理智”的办法来求解；只是代码会难写许多： 随机取俩点，然后测试圆的交点：不难想象交点极可能是龙珠，不是的情况是引入了其他龙珠的干扰 “伪四分树”：每次找到一个点，找到半径之后试探上下左右半径，这样半径总是在缩小；只是要注意不要测试的四个点都到平面外面去了，要规范一下它的最大值保证至少有一个边界出现在平面内 平面上的二分、三分：这就给我整不会了…… 这些想法在比赛时 T 飞了的情况下都有考虑，但是最后几乎都因为代码不太好写而作罢……属实不是很行；实际上第二种思路也写了代码，只是也没有处理这个问题导致同样 T 飞了（） F - Flight Collision 有 \\(n \\leq 2\\cdot10^5\\) 个点在一条直线上做匀速直线运动；第 \\(i\\) 个点的 \\(x\\)-\\(t\\) 方程是 \\(x_i = d_i + v_i\\cdot t\\)；如果某个时刻，有两个点在同一个位置，那么这两个点就会湮灭；问最后可以存活的点的数量，并按照顺序输出。题目保证不会有任何时刻三个或更多的点出现在同一位置。 首先要发现，相撞的点必须是初始位置相邻的点——不然中间那个点又没有撞，却变成小透明让它左右的两个点穿过它并相撞，岂不是很滑稽——题目也限定了不可能出现三个点相撞的情况，所以完全不考虑这个问题。 要是考虑三个或更多点同时相撞的话，这题可就给我整不会力 因此，我们就可以将所有相邻的两个点相撞的时间先算出来，然后塞到一个堆里；每次取出最先相撞的两个点，它们湮灭后，将新成为的邻居相撞的时间计算出来；维护的过程中，可能会出现两个点其中有一个死点的情况，此时要记得直接弹栈不做处理； 然后是最基础的：速度相等的话不可能相撞，直接不入堆；相撞时间是负数，说明它们相背而行，也不管。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const int N = 1e5 + 5;int x[N], v[N], l[N], r[N];bitset&lt;N&gt; dead;ldouble solve(int i, int j) &#123; if (v[i] == v[j]) return -1; ldouble dx = x[j] - x[i], dv = v[i] - v[j]; return dx / dv;&#125;signed main() &#123;#ifndef ONLINE_JUDGE freopen(&quot;/home/nanami/CLionProjects/untitled/input.txt&quot;, &quot;r&quot;, stdin);#endif int n = read(); for (int i = 1; i &lt;= n; ++ i) x[i] = read(), v[i] = read(); for (int i = 2; i &lt; n; ++ i) l[i] = i - 1, r[i] = i + 1; l[1] = r[n] = -1, r[1] = 2, l[n] = n - 1; priority_queue&lt;tuple&lt;ldouble, int, int&gt;&gt; heap; for (int i = 1; i &lt; n; ++ i) &#123; if (v[i] != v[i + 1]) &#123; auto t = solve(i, i + 1); if (t &gt; 0) heap.emplace(-t, i, i + 1); &#125; &#125; while (!heap.empty()) &#123; auto [_t, ll, rr] = heap.top(); heap.pop(); if (dead[ll] || dead[rr]) continue; dead.set(ll), dead.set(rr); auto nl = l[ll], nr = r[rr]; if (nl &lt; 0 || nr &lt; 0) continue; else r[nl] = nr, l[nr] = nl; if (v[nl] != v[nr]) &#123; auto nt = solve(nl, nr); if (nt &gt; 0) heap.emplace(-nt, nl, nr); &#125; &#125; auto ans = n - dead.count(); cout &lt;&lt; ans &lt;&lt; endl; for (int i = 1; i &lt;= n; ++ i) if (!dead[i]) cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl; return 0;&#125; 观察代码，大概能发现有一个名字怪异的变量 _t；因为这个题的一发罚时就交在它上——这个变量本没有什么用处，但是却屏蔽了全局空间里的 t，带来了错误…… 写代码要养成好习惯！以后这种没有用处的变量都要用这种不容易输入的名字，相当于直接屏蔽了（（ A - Atomic Energy 假设原子内有 \\(x\\) 个中子，那么它分解后释放的能量有如下关系： \\[ \\begin{cases} a_x &amp;, x \\in [1, n] \\\\ \\min_{i + j = x}(a_i + a_j) &amp;, x &gt; n \\end{cases} \\] 现在给定 \\(n \\leq 100\\) 以及对应的数组 \\(a\\)，进行 \\(q\\) 次询问：每次询问有 \\(x \\leq 10^9\\) 个中子的核释放能量。 首先，如果这个 \\(x\\) 没有那么大，那么可以使用 DP 维护出上界之内所有核释放的能量；但是因为题目里这个 \\(x\\) 极端地大，所以这种做法 pass（ 让我们贪心地考虑：如果存在某个 \\(m \\in [1, n]\\) 使得 \\(\\frac{a_m}m\\) 最小，那么为了使得最后的分解能量尽可能地小，我们要尽可能的选择分解得到 \\(m\\)；但是这样存在一个问题：用 \\(m\\) 并不能凑出所有的范围内的正整数；因此，我们需要选择其他的核，但这样就需要抉择优解了。 不难想象，当 \\(x\\) 大到一定程度之后，它一定可以被表示为一些 \\(m\\) 和一些其他的核的组成；相应地，在一定范围内，\\(x\\) 可能存在不使用 \\(m\\) 的分解方式，而这种方式最优。因此，一种比较理智的思路就是找到这样的一个范围，在这个范围（如果可以接受）内使用严谨的 DP；而在这个范围外，则贪心地使用 \\(m\\) 直到剩余的中子数落到范围之内，再使用范围内存储的值拼出答案。 这里，首先给出结论：在不少于 \\(m\\) 个正整数中，一定存在一个子集使得子集的和被 \\(m\\) 整除；对应到这个问题里来看，就是这个子集的所有核都可以换成 \\(m\\)，从而使得单位能量更低；那么接下来来说明这个结论的正确性： 首先，我们将这 \\(m\\) 个数字按照某种方式任意排序，然后对于得到的数组求前缀和；接下来，我们使用 \\(pre_i\\) 表示对于这个数组长度为 \\(i\\) 的前缀和，我们就得到了一个长度为 \\(m\\) 的 \\(pre\\) 数组；然后，我们在 \\(\\text{mod}\\ m\\) 的意义下对于数组 \\(pre\\) 分类： 如果 \\(\\equiv 0\\) 类不为空，那么就说明存在某个前缀满足其和可以被 \\(m\\) 整除，符合约束条件 否则，这就意味着 \\(m\\) 个元素要被放在余数为 \\([1, m - 1]\\) 共 \\(m - 1\\) 个类中；由抽屉原理可知，一定有一个类中放了两个元素——也就是有两个不同的前缀和具有相同的余数 此时，我们只需要将这两个前缀做差，得到的就是一段连续区间的和，显然它的余数为 \\(0\\) 至此，我们已经证明了给出的结论；对于这个题目而言，这意味着只要 \\(x\\) 不可能被分解成少于 \\(m\\) 个数字，那么就一定可以被 \\(m\\) 代替；而 \\(m - 1\\) 个数字可以组成的最大的数字是 \\((m - 1)n\\)； 是不是做到这里，这个边界就找到了呢？我们先考虑一个很显然的情况：我们能否将 \\(x\\) 分解成 \\(x\\) 个 \\(1\\) 呢？显然，除非 \\(n = 1\\)，否则一定会分解出一个非 \\(1\\) 的数字，因为最后一次分裂一定是 \\(x&#39; &gt; n\\) 分解为 \\(i,j &lt; n\\)；也就是说对于 \\(x\\) 的分解序列，如果它满足本题要求，那么一定存在 \\(i\\) 和 \\(j\\) 使得 \\(i + j &gt; n\\)；这一部分无关最小能量，是这个分解符合题意的基本条件。 那么，我们要怎么修正我们的严谨边界呢？因为这个要求也最多影响到两个基础分裂结果，所以只要在我们的边界上加上它就可以了；两个基础数最大是 \\(2n\\)，我们现在的边界是 \\((m + 1)n\\)。 12345678910111213141516171819202122232425262728293031const int N = 110, M = 12315;llong a[N], f[M], inf = 1e18;bool compare(int i, int j) &#123; auto ii = a[i] * j, jj = a[j] * i; if (ii == jj) return i &lt; j; else return ii &lt; jj;&#125;signed main() &#123; int n = read(), q = read(), _[N]; for (int i = 1; i &lt;= n; ++ i) a[i] = read(); iota(_, _ + n, 1); auto m = *min_element(_, _ + n, compare); auto lim = (m + 1) * n; fill(f + 1, f + 1 + lim, inf); memcpy(f + 1, a + 1, sizeof(llong) * n); for (int i = n + 1; i &lt;= lim; ++ i) for (int j = 1; j &lt;= n; ++ j) f[i] = min(f[i], f[i - j] + a[j]); while (q --) &#123; int x = read(); if (x &lt;= lim) printf(&quot;%lld\\n&quot;, f[x]); else &#123; int t = (x - lim + m - 1) / m; int mt = m * t, res = x - mt; printf(&quot;%lld\\n&quot;, f[res] + a[m] * t); &#125; &#125; return 0;&#125; 其实完全没有必要想这么多；因为著名的 \\(x \\cdot y - x - y\\) 问题（大概是这个式子吧，不排除我记错了的可能）我们都有常识：使用一些正整数组成更大的正整数，在某个边界之后可以组成任何正整数；虽然不完全一样，但是这并不影响我们想到上面的猜想；至于这个边界，去取一个足够大但是又时间足够求出的范围就完全没问题（）就算再蠢想不到贪心 \\(m\\)，检查所有的元素作为首要替代也可以通过此题…… 只能说确实拉了== E - Endgame 有一个 \\(n\\times n\\) 的棋盘，有 \\(n\\) 个二维向量；现在 Alice 和 Bob 各有一个棋子，在不同的位置；接下来他们按顺序选择下面操作之一执行： 从 \\(n\\) 个向量中带放回地选择两个作为位移并顺次执行；吃掉经过位置的敌方棋子 瞬移到某个没有放置棋子的位置 什么也不做 Alice 现在想知道他是否可以吃到 Bob 的棋子，或者在吃不到的情况下是否能通过瞬移回避被 Bob 吃掉。 首先考虑 Bob 是否能被 Alice 抓到；如果要暴力搜索那复杂度是 \\(\\mathcal{O}(n^2)\\) 的，大概是过不了的；但是对于这种搜索有一种很经典的做法就是两端搜索——这样复杂度就是 \\(\\mathcal{O}(n)\\) 的；对于两个点求出合法的 \\(n\\) 个转移中点，然后进行匹配即可。 那么现在应该如何确定是否可以瞬移到 Bob 抓不到的地方呢？对于每一个位置都进行测试？未免也太蠢了一些；考虑以下从 \\(n\\) 种操作中选出两个，可以有 \\(n^2\\) 种不同的排列；然而除去自交的 \\(n\\) 种，剩下的部分都是对称的，可以到达的位置是相同的；所以总共可以到达的位置是 \\(\\frac{n(n-1)}2 + 2n\\) 种；观察式子，不难发现： \\(n \\leq 3\\) 时，\\(\\frac{n(n-1)}2 + 2n \\geq n^2\\)；此时可能 Alice 无处可逃，但也仅限于少数情况。 \\(n \\to \\infty\\) 时，\\(\\frac{n(n-1)}2 + 2n \\to \\frac{n^2}2\\)；即使在极端情况下，Alice 也总是有的放矢。 所以一种理智的方法就是当 \\(n\\) 较小的时候，就暴力地检查每一个位置是否可达；否则，则可以进行有限次数的随机坐标；因为 \\(n\\) 较大的时候，在极端的情况下不可达的位置占比接近 \\(\\frac12\\)，如果进行 \\(k\\) 次随机，那么找不到不可达位置的几率将无限接近 \\(0\\)；事实上，在实现上，我们也可以设置随机直到找到一个逃逸位置后中断。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100const int N = 1e5 + 5;struct coord &#123; int x, y; coord operator+(coord rhs) const &#123; return &#123;x + rhs.x, y + rhs.y&#125;; &#125; coord operator-(coord rhs) const &#123; return &#123;x - rhs.x, y - rhs.y&#125;; &#125; bool operator==(coord rhs) const &#123; return x == rhs.x &amp;&amp; y == rhs.y; &#125; bool operator!=(coord rhs) const &#123; return x != rhs.x || y != rhs.y; &#125; coord() = default; coord(int x, int y) : x(x), y(y) &#123;&#125;&#125; d[N], a, b;unordered_set&lt;int&gt; ta[N], vis[N];#define valid(x, y) ((x) &gt; 0 &amp;&amp; (x) &lt;= n &amp;&amp; (y) &gt; 0 &amp;&amp; (y) &lt;= n)void clear(int n) &#123; for (int i = 1; i &lt;= n; ++ i) ta[i].clear();&#125;bool test(coord S, coord T, int n) &#123; if (S == T) return true; for (int i = 1; i &lt;= n; ++ i) &#123; auto t = S + d[i]; if (t == T) return true; if (valid(t.x, t.y)) ta[t.x].insert(t.y); &#125; for (int i = 1; i &lt;= n; ++ i) &#123; auto t = T - d[i]; if (valid(t.x, t.y) &amp;&amp; ta[t.x].count(t.y)) return true; &#125; return false;&#125;auto createRandomMachine(int lb, int rb) &#123; if (lb &gt; rb) swap(lb, rb); uniform_real_distribution&lt;double&gt; dm (lb, rb); random_device rd; default_random_engine rm(rd()); return [=]() mutable &#123; return (int) dm(rm); &#125;;&#125;coord gen(const function&lt;int()&gt;&amp; rand_int) &#123; int x = rand_int(), y = rand_int(); while (vis[x].count(y)) x = rand_int(), y = rand_int(); return &#123;x, y&#125;;&#125;signed main() &#123; int n = read(); a.x = read(), a.y = read(); b.x = read(), b.y = read(); for (int i = 1; i &lt;= n; ++ i) d[i].x = read(), d[i].y = read(); if (test(a, b, n)) puts(&quot;Alice wins&quot;); else if (n &lt;= 10) &#123; for (int i = 1; i &lt;= n; ++ i) for (int j = 1; j &lt;= n; ++ j) &#123; auto t = coord(i, j); if (t != a &amp;&amp; t != b) &#123; clear(n); auto res = test(b, t, n); if (!res) &#123; printf(&quot;tie %d %d\\n&quot;, t.x, t.y); return 0; &#125; &#125; &#125; puts(&quot;Bob wins&quot;); &#125; else &#123; vis[b.x].insert(b.y); const auto rd = createRandomMachine(1, n + 1); for (int tt = 100; tt; -- tt) &#123; auto t = gen(rd); vis[t.x].insert(t.y), clear(n); auto res = test(b, t, n); if (!res) &#123; printf(&quot;tie %d %d\\n&quot;, t.x, t.y); return 0; &#125; &#125; puts(&quot;Bob wins&quot;); &#125; return 0;&#125; 只要随机的合理，那么随机也是算法！ I - Island Tour 有一个环形公路，路边有 \\(n\\) 个风景；现在有三个人准备从某个景区出发，顺时针绕环形公路欣赏所有风景，且彼此不希望被其他人打扰；现在已知风景 \\(i \\to i + 1\\) 的路途需要用时 \\(d_i\\) 的时间（当然，\\(n \\to 1\\)），第 \\(j\\) 个人想要在第 \\(i\\) 处风景停留时间 \\(t_{i, j}\\)；当一个人看完了所有的风景，他将瞬移回酒店； 现在要调度三人的出发景点以尽量满足他们的愿望；求是否存在一种安排，满足他们不会互相打扰； 考虑以下暴力怎么做：我们枚举安排 \\((i, j, k)\\)，然后在线性时间内模拟出三人的行程安排，再用线性时间去检查是否发生了冲突；显然，这样做的复杂度是 \\(\\mathcal{O}(n^4)\\) 的，不合题意；因此，我们可以考虑使用一些方法来加快这个模拟的进程，或者说省去没有必要的暴力。 注意到如果三个人发生了冲突，那么一定可以规约成其中两个人的冲突；而暴力枚举两个人行程的冲突的情况只需要 \\(\\mathcal{O}(n^3)\\) 的时间复杂度；因此，我们可以对于每两个人暴力枚举一次，并记录冲突情况；然后再遍历三人的安排情况，就可以 \\(\\mathcal{O}(1)\\) 地求出三人的冲突的情况，从而解出。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const int N = 405;array&lt;bitset&lt;N&gt;, N&gt; ab, ac, bc;int d[N], a[N], b[N], c[N];llong iil[N], iir[N], jjl[N], jjr[N];#define step(x) ((x) % n + 1)#define assign(x) (x##x##l[x] = x##l, x##x##r[x] = x##r)#define calcL(x) (x##l = x##r + d[x])#define calcR(x) (x##r = x##l + x##t[x])bool simulator(const int *it, const int *jt, int i0, int j0, int n) &#123; if (i0 == j0) return true; int i = i0, j = j0; llong il = 0, jl = 0, ir, jr; calcR(i), calcR(j); for (int t = 0; t &lt; n; ++ t) &#123; assign(i), assign(j), calcL(i), calcL(j); i = step(i), j = step(j), calcR(i), calcR(j); &#125; for (int x = 1; x &lt;= n; ++ x) if (iil[x] &lt; jjr[x] &amp;&amp; jjl[x] &lt; iir[x]) return true; return false;&#125;signed main() &#123; int n = read(); for (int i = 1; i &lt;= n; ++ i) d[i] = read(); for (int i = 1; i &lt;= n; ++ i) a[i] = read(); for (int i = 1; i &lt;= n; ++ i) b[i] = read(); for (int i = 1; i &lt;= n; ++ i) c[i] = read(); for (int i = 1; i &lt;= n; ++ i) for (int j = 1; j &lt;= n; ++ j) &#123; ab[i][j] = simulator(a, b, i, j, n); ac[i][j] = simulator(a, c, i, j, n); bc[i][j] = simulator(b, c, i, j, n); &#125; for (int i = 1; i &lt;= n; ++ i) for (int j = 1; j &lt;= n; ++ j) for (int k = 1; k &lt;= n; ++ k) if (!(ab[i][j] || ac[i][k] || bc[j][k])) return printf(&quot;%d %d %d\\n&quot;, i, j, k), 0; puts(&quot;impossible&quot;); return 0;&#125; 突然感觉这一场是不是实际上挺水的……这也是聪明的暴力啊（ G - Great Expectations 你要速通一个游戏，它目前的记录是 \\(r\\)；你现在设想了一种通关方式，如果一切顺利只需要 \\(n &lt; r\\) 的时间；这种通关方式路径上有 \\(m\\) 个高难点，对于第 \\(i\\) 个点：它预期出现在 \\(t_i\\) 时间，你有 \\(p_i\\) 的把握可以成功通过，如果失败你将浪费 \\(d_i\\) 的时间。 因为是你一个人在刷记录，所以如果你一轮失误过多，你会考虑重置游戏，从最初开始进行进程；但没有人想重复劳动，如果失误在可控制的范围内，你也会考虑就这样继续游戏；现在要求出你能刷新记录的最少的期望时间——这个时间是你从开始尝试直到打破纪录所花费的时间。 在开始之前，我们先做如下定义；游戏开始时存在一个事件 \\((t_0, p_0, d_0)\\)，其中 \\(t_0 = 0\\)，\\(p_0 = 1.0\\)；当然，惩罚时间没有意义；游戏结束时存在一个事件 \\((t_E, p_E, d_E)\\)，其中同样有 \\(t_E = n\\)，\\(p_E = 1.0\\)；此外，我们计算两个事件之间所需要消耗的时间 \\(\\text{d}t_i = t_{i + 1} - t_i\\)；特殊地，有 \\(\\text{d}t_n = t_E - t_n\\)。 此外，考虑我们对于重开和继续游戏的抉择——我们有一个最大可容忍的犯错时间 \\(r - n - 1\\)；我们暂且将它记为犯错边界 \\(M\\)；如果我们犯错的时间尚未超过它，那么可以考虑重开和继续游戏的最佳预期时间；否则，我们只能重开，因为继续游戏已然毫无意义。 因此，我们可以考虑一个 DP：令 \\(f_{i, j}\\) 表示即将面对第 \\(i\\) 个事件，在这之前已经浪费了 \\(j\\) 的时间的情况下，速通还需要的期望时间；显然，我们要求的答案就是从最开始进行游戏的时间，也就是 \\(f_{0, 0}\\)；根据这个定义，我们也不难想到下面的转换： \\[ f_{i, j} \\to \\begin{cases} f_{i + 1, j} + \\text{d}t_i &amp;, \\text{success} \\\\ f_{0, 0} &amp;, \\text{failed} \\ \\and \\ j + d_i &gt; M \\\\ \\min(f_{0, 0}, \\text{d}t_i + d_i+ f_{i + 1, j + d_i}) &amp;, \\text{failed} \\ \\and \\ j + d_i \\leq M \\end{cases} \\] 实现上，不难想到这样的 DP 应该从后向前更新答案，最后求出 \\(f_{0, 0}\\)；但是注意到转移的过程中是需要 \\(f_{0, 0}\\) 作为参数的，而这个值是我们最后才能求出的，形成了一个循环；对于这种类似方程的情况，我们可以考虑使用二分的方法，猜测一个 \\(F_{0, 0}\\) 作为参数先代入转移，并与最后求出的 \\(f&#39;_{0, 0}\\) 对比，直到两者足够接近。 因此，将上述的转移套上概率 \\(p_i\\) 之后就可以写出一个对于 \\(F_{0, 0}\\) 的 check 函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546using trick = tuple&lt;int, double, int&gt;;const int N = 5050, M = 110;double f[M][N], tt[N];const double eps = 1e-7;template &lt;typename T&gt;int sgn(T x) &#123;return x &lt; 0 ? -1 : x &gt; 0;&#125;int compareTo(double a, double b) &#123; return fabs(a - b) &lt; eps ? 0 : sgn(a - b);&#125;signed main() &#123; ios::sync_with_stdio(false); cin.tie(nullptr), cout.tie(nullptr); int n, r, m; cin &gt;&gt; n &gt;&gt; r &gt;&gt; m; vector&lt;trick&gt; ts(n + 2); ts[0] = make_tuple(0, 1.0, 0); ts[m + 1] = make_tuple(n, 1.0, 0); for (int i = 1; i &lt;= m; ++ i) &#123; auto &amp;[t, p, d] = ts[i]; cin &gt;&gt; t &gt;&gt; p &gt;&gt; d; tt[i] = t - get&lt;0&gt;(ts[i - 1]); &#125; tt[m + 1] = n - get&lt;0&gt;(ts[m]); const int margin = r - n - 1; const auto binary = [&amp;](double f00) &#123; for (int i = m; i &gt;= 0; -- i) for (int j = 0; j &lt;= margin; ++ j) &#123; auto [t, p, d] = ts[i]; f[i][j] = p * (tt[i + 1] + f[i + 1][j]); if (j + d &gt; margin) f[i][j] += (1 - p) * f00; else f[i][j] += (1 - p) * min(f00, tt[i + 1] + d + f[i + 1][j + d]); &#125; return compareTo(f00, f[0][0]) &lt; 0; &#125;; double ll = 0, rr = 3e18; while (compareTo(ll, rr) &lt; 0) &#123; auto mm = (ll + rr) / 2; if (binary(mm)) ll = mm; else rr = mm - eps; &#125; cout &lt;&lt; fixed &lt;&lt; setprecision(7) &lt;&lt; ll &lt;&lt; endl; return 0;&#125; 这种做法——二分解方程——确实算是一个比较有意思的技巧；学到了许多（）此外对于概率论 DP 的题目而言，还是要注意不要陷入了误区——比如考虑重来是不是未来成功的可能性更高更加省时间这种；因为这样带来的优势无法量化，所以也就无从考察；而概率或者说是成本则是一个理智的量化标准——不用想别的，只要考它就好（ 当然，上面说的这些也非常的主观……只能说之后有了更好的理解再来补充说明吧（ J - Joint Excavation 有一张图，首先你需要从中选出一些点组成一个 non-self-intersecting path，然后将剩下来的点平均分成 A 和 B 两组。要求整张图不存在任何一条边，使得这条边的两个端点一个属于 A 而另一个属于 B。 没有太看懂题，，只能说英语或者说理解能力属实不是很行（）最后对着答案才算搞懂题目是什么意思== 在图中怎么样动态地维护一条边？当然是 DFS 了啊！在图中怎么样保证两种节点不直接连接？当然把连接到链上的一棵子树全部划给一个组啊！于是，就有了标准题解的构造方法： 首先，将所有的节点都划给组 A；设 #A 表示 A 组的容量，#B 同上；此时 #A = n，#B = 0 从任何一个点开始 DFS；当有 #A &lt; #B 成立时，重复下面的步骤： 若访问了一个新节点，则将它加入到 path 中——既不属于 A，也不属于 B，但是必须成链 若退出了一个节点，则将它从 path 末端移出，加入组 B 当 #A = #B 时，退出 DFS；已经求得了满足题目要求的 A 和 B 和简单路 path 这相当于我们使得 path 总是经过我们选择的根节点，然后将不同的子树根据 A 和 B 实时的大小关系分配给它们；因为总是从下而上分配，所以粒度是小的；又因为 DFS 是单点步进的，所以得到的 path 是一条简单路。而从过程的最开始，A 和 B 就不可能公用一条边。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const int N = 2e5 + 10;int belong[N], A, B;vector&lt;int&gt; path;bitset&lt;N&gt; vis;struct fws &#123; using edge = pair&lt;int, int&gt;; vector&lt;int&gt; head; vector&lt;edge&gt; e; void renew(size_t siz) &#123; head.resize(siz), e.clear(); fill(head.begin(), head.end(), -1); &#125; void add_edge(int u, int v) &#123; edge tmp(v, head[u]); head[u] = (int) e.size(); e.emplace_back(move(tmp)); &#125;&#125; g;void dfs(int u) &#123; if (!vis[u] &amp;&amp; A != B) &#123; belong[u] = 0; path.push_back(u); -- A; &#125; vis[u] = true; for (int i = g.head[u]; i &gt;= 0; i = g.e[i].second) &#123; int v = g.e[i].first; if (vis[v]) continue; dfs(v); if (A != B) &#123; path.pop_back(); belong[v] = -1; ++ B; &#125; &#125;&#125;signed main() &#123; int n = read(), m = read(); g.renew(n + 1), g.e.reserve(m * 2 + 5); for (int i = m; i --;) &#123; int u = read(), v = read(); g.add_edge(u, v); g.add_edge(v, u); &#125; fill(belong, belong + 1 + n, 1); A = n, B = 0, dfs(1); vector&lt;int&gt; aa, bb; for (int i = 1; i &lt;= n; ++ i) if (belong[i] &lt; 0) bb.push_back(i); else if (belong[i]) aa.push_back(i); cout &lt;&lt; path.size() &lt;&lt; &#x27; &#x27; &lt;&lt; A &lt;&lt; endl; for (auto i : path) cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl; for (auto i : aa) cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl; for (auto i : bb) cout &lt;&lt; i &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl; return 0;&#125; 如果要是需要更加不巧妙的方法，也可以维护子树大小和，然后保证递归处理分裂的只有一颗子树（因为 path 必须是简单链）——这可以通过最后处理重儿子来保证。 B - Bulldozer 有一些方块堆的高高；现在你每次操作可以推/拉一个方块，使得它的上面，右边发生一个位移；位移之后收到重力影响方块可能会下落。水平空间无限，问你使得所有的方块落到平面上需要最小的操作次数。 注意：这里的推拉操作相对之前的类似的题目要随意许多；你可以拉动任意连续的方块，也可以从夹缝中推动方块（而不需要这一面空出来） 瞄了一眼题解，这个题竟然还是个最短路……麻了麻了，想摸了，有时间在补吧（） 后记 补了这么多题目之后，感觉这套题其实真的不错——指的是比较适合我们这种基础不扎实的队伍；因为绝大多数的题目都是意在考察思维能力，而不是考察某种数据结构或者是知识点；如果区域赛是这种形式的，我们发挥正常的可能性也相对而言是更高的。当然，这一场还是很拉就是了（ L_O2R3_1QZCDBV0DO909UMX.gif 此外，队伍的配合也存在相当的问题——我能明显的感受到我和队友之间羁绊的不足；因为英文阅读能力低下的原因，我基本也只能被动地听队友给讲题意，但是这样就会因为不默契导致交流效率的低下（）此外，我个人的精神力也十分弱小——或许我真的应该正视——我能不能够集中注意力地坐五个小时还保持思维的敏捷性——这个问题了…… 更多的话也不想说了；也许是因为各种各样的事情，这个月可以说过的很摸了——上一篇博文还是三周之前……回头月度总结的时候再哈好说说吧（）","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://shiraha.cn/tags/Codeforces/"},{"name":"Gym","slug":"Gym","permalink":"https://shiraha.cn/tags/Gym/"}]},{"title":"关于 Ubuntu 20.04 的自用配置","slug":"some-self-use-configure-for-ubuntu-20-04","date":"2021-05-18T17:26:14.000Z","updated":"2021-05-24T17:42:00.000Z","comments":true,"path":"2021/some-self-use-configure-for-ubuntu-20-04/","link":"","permalink":"https://shiraha.cn/2021/some-self-use-configure-for-ubuntu-20-04/","excerpt":"","text":"5 月就快要结束了，因为各种各样的原因，这个月可以说是几乎没有怎么训练的（）所以就演变成了交一篇这样子的水文的模样。 实际上这篇水文也写了一个星期，只能说不愧是我 安装 背景说明 为了能够更好地模拟 XCPC 大多数区域赛现场的比赛环境恰好又受到了金川的刺激，有因为手头边恰好有一个笔记本上拆下来的 SSD，所以就决定这么给台式机上整一个 Ubuntu 的双系统了。 准备 现在的 Ubuntu 官方镜像已经十分智能了，基本上官方的安装向导已经可以满足绝大多数情况下的要求了；所以这里也就不没事找事了；需要准备两个硬盘——一个一般的 U 盘用来制作启动盘，另一个速度快一点（至少得是移动硬盘）的硬盘作为安装目标盘。 制作启动盘就是先从官网下载镜像，然后用免费的 Ultra ISO 写入硬盘镜像即可；制作完启动盘之后先关机进入 BIOS，暂时关闭安全启动——因为这会阻止我们从安装介质启动电脑；然后再重启，进入临时启动菜单，从制作的启动盘启动即可； 第一次进入系统，Ubuntu 需要先检查各种文件，所以会需要较长的时间；之后就会进入到熟悉的安装界面——然后对着向导点点点就行了；分区什么的也非常智能，安装向导已经预制了双系统和全新安装两种默认配置，只需要拖动 GUI 组建就可以完成分区——当然，swap 什么的它都帮你做好了。如果有网络的话，可以直接在安装的时候选择安装必要的驱动，这样也省的进了系统之后还要手动（（ 安装完成之后，先进 BIOS 重新打开安全启动，再将默认启动顺序改回先 Windows 再 Ubuntu；这样每次进 Ubuntu 只需要先插上 SSD，然后进临时启动菜单选择 Ubuntu 的引导就可以了。 配置 &amp; 偏好 以下部分的内容都是个人偏好的配置，仅供参考（）大概会持续更新把（ 系统设置相关 GNOME 桌面的设置已经提供了相当多的配置选项；直接修改既方便，也直接影响了使用体验；下面的内容就设置的每一个大栏目下要做的事情简要的说明一下： 键盘快捷键 声音和媒体：如果你使用的是 Windows 键盘，那么可以将键盘上的媒体键在这里手动绑定——比如播放/暂停，上一首下一首和调节音量这种。 截图：和 Windows 的习惯不一样，但是个人觉得功能比 Windows 全多了；可以把对应的公共按钮调成和 Windows 一致的按钮（比如复制（选区）截图到剪切板换成 shift + super + S） image.png 这是个人关于屏幕截图快捷键的偏好，如果更新了大概会换掉这张图吧（ 还有要提一嘴的就是，Ubuntu 的截图，虽然看起来很高级（比如这些截取窗口，都是直接绘图甚至还保留了窗口阴影的透明度），但是并不能实现“抓拍”——并不是按下 Print 键就会截图== 显示器 主要是为了设置缩放；就算是 2018 年的电脑，一般都大概是笔记本 1080p 或者是台式机 1400p；不管是哪种 Windows 设置的都是 125% 缩放；但是 Ubuntu 的分数缩放做得很怪，所以如果怕麻烦的话 100% 也挺好（）否则，要先开启下面的 Fractional Scaling 才能选择 125% 2021-05-24 21-32-09 的屏幕截图.png 看到这个选项没被汉化，下面还有 May increase power usage, lower speed, or reduce display sharpness 就觉得不太对劲；这种不好的预感主要体现在各种第三方软件上（）因为实际上 Ubuntu 似乎只会整数倍数缩放，分数的缩放是先将你的逻辑分辨率放大到 2 倍下的对应尺寸，然后再压缩到你物理屏幕上的——比如我的电脑两个屏幕都是 2560*1440 的，开启 1.25 缩放就是先将逻辑分辨率设为 4096*2304（也就是 1.6 倍，两倍缩放下的 0.8），再压缩到物理分辨率来的；所以不管是显卡驱动还是其他应用程序（甚至系统自带的截图）“看到”的分辨率都是 4096*2304；此时，如果应用程序不支持缩放，那么 100% 的缩放在屏幕上看起来就只有原来大小的 80%，十分痛苦== 外观 强烈建议选择 Dark；如果默认，那么 VS Code 就会黑色窗口下有白色工具栏；白色的话不是很适合写代码 image.png 总而言之要选择纯色（）另一个想要吐槽的就是 Dock 栏不能像 Windows 一样一个在左边一个在右边== 自动隐藏 Dock 栏总归还是不太方便，更何况 GNOME 的 Dock 没有那么舒服的可以被调出来，所以最好还是一直显示；和 Windows 看齐，将 Dock 栏的图标大小调到 32*32 就不会显得那么占地方了。 终端 关于 zsh，你可以参考我的这篇文章和我的朋友的那篇文章； 安装 oh-my-zsh Ubuntu 官方镜像的 apt 使用的已经是国内访问起来较为舒服的源了，所以不需要换源，使用 sudo apt install zsh 安装 zsh； 完成之后，运行对应的脚本以安装 oh-my-zsh： 123sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;# ↑ 通过 curl 或者 通过 wget ↓sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 之后输入密码修改默认终端为 zsh 即可；Ubuntu 20.04 似乎要求重启之后，默认的终端才会自动进入 zsh. 为了方便以后使用，这里再把安装 powerlevel10k 的操作复述一次： 克隆代码仓库：git clone https://github.com/romkatv/powerlevel10k.git $ZSH_CUSTOM/themes/powerlevel10k 修改 ~/.zshrc：ZSH_THEME=\"powerlevel10k/powerlevel10k\" 回到 zsh，自动或手动使用 p10k configure 更换终端主题风格，详情参考其文档 然后，我们需要为 zsh 安装最低限度所需要的插件：zsh-syntax-highlighting 和 zsh-autosuggestions 运行下面的命令以安装 zsh-syntax-highlighting： 1234cd ~/.oh-my-zshgit clone https://github.com/zsh-users/zsh-syntax-highlighting.gitecho &quot;source $&#123;(q-)PWD&#125;/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot; &gt;&gt; $&#123;ZDOTDIR:-$HOME&#125;/.zshrcsource ./zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 克隆 zsh-autosuggestions 的源代码：git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions 修改 ~/.zshrc：plugins=(git zsh-autosuggestions) 重启 zsh 或者打开一个新的会话，就会发现插件已经成功应用了 安装 zsh-syntax-highlighting 之前要先进入一个合理的目录，用来存放其源代码。 终端字体 此外，Ubuntu 默认的字体并不支持 Powerline 的众多图标；解决方法就是更换字体——既可以使用上一篇文章中介绍的 Hack Nerd Font，也可以用 Ubuntu Nerd Font 不过字体图标比例感人；下载后安装，然后在终端中新建配置文件，选择字体即可。 image.png 如果觉得一个个安装这些字体文件很麻烦，可以先在终端中将这些字体文件复制到 /usr/share/fonts/ 下的某个子目录中，然后再运行下面的命令刷新字体缓存即可： 123sudo mkfontscalesudo mkfontdirsudo fc-cache -fv 这样，应该就可以在其他的程序中看到这些字体了；最终终端看起来就像下面这样： image.png 别名 现在，我们默认使用 zsh 作为默认终端，而作为 Linux 终端，zsh 也支持使用 alias 指令为一些命令增加别名；如果我们将这些 alias 指令放在 zsh 的 rc 文件中，这些别名就会在 zsh 启动的时候装载，我们就可以直接使用了； zsh 有两个 rc 文件；一个全局级别的 /etc/zsh/zshrc，修改它需要 su 权限；另一个用户级别的 ~/.zshrc，可以方便的修改；为了方便，我们都修改用户级别的 rc 文件： 1234567alias cls=&quot;clear&quot;alias &quot;cd..&quot;=&quot;cd ..&quot;alias py=&quot;python3&quot;# alias reload=&quot;source ~/.zshrc &amp; source /etc/zsh/zshrc&quot; # WSL 上正常，但是 Ubuntu 上似乎不能正常工作alias omzsh=&quot;vim ~/.zshrc&quot;alias zshrc=&quot;sudo vim /etc/zsh/zshrc&quot;alias explorer=&quot;nautilus&quot; 值得提一嘴的是 GNOME 默认的文件管理器是 Nautilus file manager，但是 Windows 上默认的是 Windows 资源管理器（explorer）；为了不去记这个奇怪的名字，我们可以制定一个别名== 别的就持续更新之后再说吧！ 开发环境 当然，既然是为了用来打 XCPC 而准备的 Ubuntu 环境，那么开发环境当然是必定不会少了： 基本 首先是一些基本的程序，Ubuntu 未必全部预装： 1sudo apt install wget curl vim git 然后就是一些编译工具，主要就是 CMake、OpenJDK、Python 等等 123sudo apt install build-essential cmakesudo apt install openjdk-14-jdk openjdk-14-jre sudo apt install python3-pip nodejs Ubuntu 内置了 python3，但是不能通过 python 命令唤起；我们可以为它创建一个软连接： 12sudo ln -s &#x2F;usr&#x2F;bin&#x2F;python3 &#x2F;usr&#x2F;bin&#x2F;python sudo ln -s &#x2F;usr&#x2F;bin&#x2F;pip3 &#x2F;usr&#x2F;bin&#x2F;pip 这样执行 python 和 pip 就会默认运行 python3 相关的程序了。 关于 Node.js 除了从官网下载之外，还有一种相对比较简单的方式，可以方便地通过 apt 下载并安装 Node.js： 首先，使用 apt 安装 npm：sudo apt install npm 然后，使用 npm 安装 n —— 一个用来安装 Node.js 的工具：sudo npm install n -g 然后，再使用 n 安装最新的 LTS 版本 Node.js：sudo n lts 安装完成之后，运行 PATH=\"$PATH\" 或者重开终端，刷新系统变量，就可以检查 node -v 了 这个工具会自动从官网下载 tar.xz 包并自动安装最新的 Node.js。 日用软件 只有开发软件当然还是远远不够的；这里列出的大多数日用软件都只需要按照官网的或者是网上到处流传的说明安装就不会出什么问题，这里只是作为列表列出防止忘记（ Microsoft Edge Firefox 当然很好用，但是 Edge 承载了大量的同步书签之类的，而且 Chromium 内核的浏览器的表现也确实比 Firefox 要好；所以也确实得装一个： 官方网址：https://www.microsoftedgeinsider.com/zh-cn/download 下载 *.deb 包之后使用 sudo dpkg -i 安装即可。 Visual Studio Code 可以从 snap 商店安装；但是听说 snap 安装的版本无法使用中文输入法，所以还是要从官网上下载包来手动安装；前半句话我实践了，是真的；但是后半句话懒得测试了，测试完了再更新文章吧！ 个人偏好：安装了插件 C/C++、Chinese (Simplified) Language Pack for Visual Studio Code、vscode-icons、CMake Tools。 123456789&#123; &quot;workbench.iconTheme&quot;: &quot;vscode-icons&quot;, &quot;files.autoSave&quot;: &quot;afterDelay&quot;, &quot;editor.fontSize&quot;: 18, &quot;terminal.integrated.fontFamily&quot;: &quot;Hack Nerd Font&quot;, &quot;terminal.integrated.fontSize&quot;: 16, &quot;git.confirmSync&quot;: false, &quot;http.proxyAuthorization&quot;: null&#125; 然后这里是自用的 VS Code 的配置文件；如果之后有改动再更新这里吧！ Jetbrains Toolbox 用来快速地安装所有的 Jetbrains IDE，教育版可以登陆账号之后一键全部激活； 官方网址：https://www.jetbrains.com/zh-cn/toolbox-app/download/download-thanks.html 下载的是个 *.appimage，给执行权限之后打开就会自动安装到电脑，之后就可以使用它安装 JB IDE 了； 它默认将 IDE 安装到 ~/.local/share 目录下，所以如果要创建快捷方式，可以在 ~/.local/share/applications/ 目录下看到对应的 *.desktop 文件；复制到桌面允许运行即可。 其他一般通过软件 因为基本都没什么坑，所以这里就列个表记录一下算了： 软件名 来源 类型 备注 Typora https://typora.io/#linux apt Markdown 编辑器，还可以搭配 PicGo 可惜输入法太拉了，没什么写博客的体验 QQ 音乐 QQ 音乐下载页 deb/appim行age FileZilla snap 商店 snap 功能完备的 FTP 客户端 百度网盘 客户端下载 deb Sublime Text 3 snap 商店 snap XMind 2020 下载页面 deb 思维导图软件 截至 2021-05-25，这些软件更新的时间还是比较阳间的。 花里胡哨 当然，毕竟是把整块 SSD 都用来作为 Ubuntu 的系统盘了，所以不搞点花里胡哨似乎也不是很对劲； 网易云音乐 官方下载网址：https://music.163.com/#/download，在某个不起眼的小角落可以下载 deb 包；Ubuntu 20.04 双击大概是装不了的，乖乖 sudo dpkg -i 吧（） 缓存首次启动就会发现有缩放问题，修改 desktop 文件（位于 /usr/share/applications）里的执行命令 --force-device-scale-factor 不起作用，但是直接终端运行带上这个参数有作用（？）；分析发现执行的实际上是一个脚本 /opt/netease/netease-cloud-music/netease-cloud-music.bash，而且是一个 Qt 程序；因此考虑使用针对 Qt 程序的办法）——在执行脚本中加入一个环境变量 QT_SCALE_FACTOR 表示缩放，如下图： 2021-05-25 04-27-08 的屏幕截图.png 之后再安装一个依赖 sudo apt install libcanberra-gtk-module -y，就可以正常使用网易云音乐了。 这种做法对于所有 Qt 程序都有效，只要你能够找到程序的运行脚本在哪里（ Steam 可以官网下载 deb 包，也可以直接使用 apt 安装； 首次启动大概缩放是有问题的，而且万不用的 --force-device-scale-factor 不起作用；此时需要打开它的 desktop 文件，修改它的启动命令，在前面加上环境变量 GDK_SCALE=2 image.png 这样的修改大概还是不起作用的，但是非常玄学的是进去之后，调成大屏幕模式，再退出大屏幕模式，之后的缩放就一直正确了；不说奇怪只能说是非常奇怪（（（ GDK_SCALE 听说好像是 Chromium 相关的参数，看来 Steam 客户端的 GUI 可能是浏览器套壳） 杂项 一些各种各样的小问题以及一些小操作： 偏好字体 首先，可以从 Windows 的字体目录 C:\\WINDOWS\\Fonts 目录下拷贝字体到 /usr/share/fonts 目录下，然后运行 sudo fc-cache -fv 来生成新的字体缓存。 字体 下载链接 PingFang SC https://github.com/45921/font-collection/tree/main/PingFangSC Hack Nerd Font https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/Hack.zip Fira Code https://github.com/tonsky/FiraCode/releases/tag/5.2 这里先放置一些必用字体的下载链接吧；但是只是这些是不够的，不过日后遇到了问题再说吧！ 和 Windows 同步时间 Ubuntu 和 Windows 对于 BIOS 时间的处理方式不同；Ubuntu 认为 BIOS 上的时间就是 UTC 时间，然后会根据用户的设置的时区加上对应的偏移时间得到系统显示的时间；而 Windows 认为 BIOS 上的时间就是本地时间，不会做任何处理就会直接读取到系统上显示给用户——这导致的问题就是 Ubuntu 同步时间之后，Windows 的时间慢了八个小时。 因此，作为副系统的 Ubuntu 需要适应 Windows 的时间管理方式： 123sudo apt-get install ntpdatesudo ntpdate time.windows.comsudo hwclock --localtime --systohc 这样，再从 Ubuntu 进入 Windows 后的系统时间就是正常的了！ 处理图片 Ubuntu 上有两个很好用的命令行工具，可以用来压缩图片文件的大小；分别是 jpegoptim 和 optipng：它们都可以通过 apt 来安装，并支持使用参数控制输出的质量； 可以使用 find . -type f -name \"*.png\" -exec optipng &#123;&#125; \\; 来递归的处理目录下的图片。 此外，文件管理器 nautilus 也有一个不错的插件 nautilus-image-converter 可以用来调整图片的尺寸，并且也可以方便地通过 apt 安装；安装完成后运行 nautilus -q; nautilus &amp; 重启文件管理器服务，找到任意一张图片，右击打开上下文菜单，可以看到出现了 Resize Image 的选项： 2021-05-25 04-00-39屏幕截图.png 单击打开之后，就可以缩放图像： 2021-05-25 03-59-18 的屏幕截图.png 此外，如果还需要对于图像进行基本的编辑（比如裁剪），还需要安装 gthumb；它也可以通过 apt 安装。 代理服务器设置 因为需要访问校园网内网，所以需要设置代理（迫真 还不会搞，等以后会搞了再更新吧 == 一些说明 有些东西感觉放在上一板块显得过于冗长，但是感觉又不能不写；所以就开了一个这样的分块 桌面图标 / 快捷方式 Linux 没有一个明确的桌面标准，但是现在大家都在用的发行版大多都遵循了类似的规则；比如 GNOME 或者大家耳熟能详的 KDE Plasma、xorg 等等；它们显示的图标都是一类赋予了可执行权限的 *.desktop 文件；这些文件一般都在 /usr/share 的目录下，有的也会在 /opt 目录下；如果你通过 Jetbrains Toolbox 来安装 JB 全家桶的话，那么它安装的默认地址是 ~/.local/share 下；snap 商店有的时候也会安装在 /snap 目录下。 一般创建快捷方式的方法，就是到这些目录下，复制出对应的 .desktop 文件，然后属性给可执行，并允许执行即可；使用文本方式打开这个文件，还可以看到它实际运行的命令；在有必要的情况下可以对其进行修改。 也许之后可以使用一些办法得到 GNOME 桌面获得的应用程序列表的文件来源（ 关于缩放 前面的内容已经或多或少地提到了 Ubuntu 桌面混乱的缩放；在我的桌面环境下，实际只有 2560*1440 的屏幕上实际上跑着 4096*2304 的分辨率，100% 的程序肉眼可见的只有 80% 的大小。不仅对于没有很好适配的应用程序，对于浏览器呈现的页面来说也是这样—— Ubuntu 是有一个算是比较通用的强制缩放的开关 --force-device-scale-factor=2；可惜经过我的尝试，对于绝大多数软件来说都不起作用（（ 文件系统 在双系统的 Ubuntu 下，是可以通过自带文件管理器看到 Windows 下的盘符的（实际上是物理硬盘），并可以从其中读取文件，但是不能写入——这并不是因为 Ubuntu 不支持 NTFS——实际上，你插入任何一个 NTFS 移动硬盘都是可以正常读写的；导致 Ubuntu 将系统硬盘看作只读文件系统的原因是因为 Windows 默认开启快速启动，导致硬盘上写入了缓存，这会影响到 Ubuntu 对于它的访问。 当然，毕竟 Windows 是主要操作系统，为了 Ubuntu 稍微舒服一点就大改 Windows 的设置显得非常的没有必要，所以这里也就不再多作评论了（（ 有待考据……如果发现什么问题之后再来更新吧！ 安装应用程序 一般而言，在 Ubuntu 里有几种安装程序的途径： APT 本 APT 具有超级牛力 非常熟悉；通过它可以方方便便地安装很多命令行应用和非命令行应用；通过增加 GPG 和仓库可以使得它更加广泛，可以安装更多的程序；比如 deepin-wine 就可以通过引入仓库后使用 apt 安装； 在使用 WSL 的时候，它自带的 apt 其实并不全面，很多软件都需要导入外部的仓库才能安装——比如说 yarn 又比如说 openjdk 等等；但是 Ubuntu 20.04 的 apt 已经很全面了，说实话确实省了许多功夫。 dpkg dpkg 用来安装 *.deb 的包；很多时候下载的 *.deb 文件双击并不能正确安装；这个时候就需要在终端中 sudo dpkg -i 来安装它；当然，运行起来是什么样就保证不了了（（ 可执行文件 诸如流行的 *.appimage 以及一些 *.run 或者 *.app 的文件，只需要在属性中赋予它可执行的权限就可以执行，并打开一个 GUI 窗口；有的是直接原位置运行了，有的会直接给安装到电脑中。比如 Jetbrains Toolbox 和 Qt 等程序。 命令查表 一些不那么常用的，但是确实有可能用到的命令；硬要说肯定是可以围绕着它们写文章的，但是因为我很懒等各种客观因素，这里就先放在这里——以后补充说明的时候再更新吧！ 命令 说明 备注 nvidia-smi 查看 Nvidia 独立显卡的运行状态 optipng &lt;file&gt; -out &lt;file&gt; 使用 optipng 压缩图片的文件大小 需要先安装 optipng scrcpy 使用 adb 使得 Android 手机投屏 之后再开篇文章讲 实际上它们如果变得常用了，我很大概率会给它们弄个别名吧（（ 后记 这篇文章是在安装好之后的 Ubuntu 上写的；只能说是非常难受了…… 一看输入法还是 2011-2012…… 只能说很努力了，这个年份的微软拼音还在玩泥巴呢（（ 2021-05-24 20-50-43 的屏幕截图.png 不过，虽然打字万分难受，但是还是把这篇文章写完了（ 屏幕截图 temp.png 尚未解决的问题 当然，毕竟是 Ubuntu，想要用的和 Windows 一样舒服还是有一些距离的（ 名称 说明 有道词典缩放问题 经典不适配系统缩放导致观感 80%；通用的做法无效 Typora 不显示在 Dock 不仅仅是从命令行启动的 typora，从 GNOME 启动的也会先不显示图标 Wine TIM 无字体 安装了多个字体均无效，当然缩放也有问题（ 如果以后有解决办法，再在后续的更新中说明吧！ 更新历史 记录了本文件从创建以来进行的更新： 日期 更新内容 2021-05-19 创建了本文档，更新了网易云音乐的缩放调整方法，更新了 Node 和快捷方式的说明 2021-05-25 增加了终端的配置说明，增加了一些截图，整理成文章 大概下次有机会再整一个配置文件的备份仓库吧，Jetbrains IDE 每次重新配置老实说挺麻烦的（（","categories":[{"name":"折腾记录","slug":"折腾记录","permalink":"https://shiraha.cn/categories/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://shiraha.cn/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://shiraha.cn/tags/Ubuntu/"},{"name":"持续更新","slug":"持续更新","permalink":"https://shiraha.cn/tags/%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"}]},{"title":"Educational Codeforces Round 108 回顾","slug":"codeforces-educational-round-108","date":"2021-05-03T10:54:58.000Z","updated":"2021-05-03T10:54:58.000Z","comments":true,"path":"2021/codeforces-educational-round-108/","link":"","permalink":"https://shiraha.cn/2021/codeforces-educational-round-108/","excerpt":"","text":"补题链接：https://codeforces.com/contest/1519 记录 竟然足足一周没有正经的训练了…… 唉，这样可不行啊 这一场的话 ABC 肯定是没啥问题的，D 能不能做出来心里还真的没底；毕竟正式 CF 也不会允许我打了三个题然后出去吃顿饭什么的，所以只能说悬（ 题解 A - Red and Blue Beans 有手就行没手不行（ 123456789101112131415signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); int T, r, b, d; for (input, T; T --;) &#123; input, r, b, d; longs times = min(r, b); longs delta = abs(r - b); bool ok = delta &lt;= times * d; output, ok ? &quot;YES&quot; : &quot;NO&quot;, endl; &#125; return 0;&#125; 记得开 long long （ B - The Cake Is a Lie 稍微手玩一会就会发现其实答案是固定的值；所以只需要计算答案之后比较大小就行： 123456789101112131415161718192021const auto null = nullptr;int sum[105];signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); for (int i = 1; i &lt; 105; ++ i) sum[i] = sum[i - 1] + i; int n, m, k, T; for (input, T; T --;) &#123; input, n, m, k; int sq = min(n, m); int cost = abs(n - m) * sq; cost += sum[sq] * 2 - sq - 1; bool ok = cost == k; output, ok ? &quot;YES&quot; : &quot;NO&quot;, endl; &#125; return 0;&#125; 手玩正方形，发现固定显然；再手玩长方形，发现多余的部分安哪里都一样，所以（ C - Berland Regional 有 \\(n \\leq 2\\cdot10^5\\) 个学生，每个学生都有自己所属的大学 \\(u_i\\) 和实力 \\(s_i\\)；设一组有 \\(k\\) 人，第 \\(j\\) 所大学一共有 \\(\\#j\\) 人：那么每个大学将会派出自己所属的实力最强的 \\(\\lfloor \\frac{\\#j}k\\rfloor \\cdot k\\) 人参加比赛；设比赛的影响力是所有参赛者的实力之和，求出 \\(k \\in [1, n]\\) 时赛站的实力。 对于某个大学，它只能对 \\(k \\in [1, \\# j]\\) 的比赛做出贡献——直接计算后累加就可以了；但是因为还要对每个大学的所有学生的实力进行排序，所以总复杂度是 \\(\\mathcal{O}(n\\log n)\\) 的。 1234567891011121314151617181920212223242526272829303132333435const int N = 1e5 + 5;int h[N], ans[N];signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); int T = $.nextInt(), n, m, x; priority_queue&lt;pair&lt;longs, int&gt;&gt; heap; while (T --) &#123; $(n, m, x).nextArray(h + 1, h + 1 + n); sort(h + 1, h + 1 + n); for (int i = 0; i &lt; m; ++ i) &#123; ans[n - i] = i + 1; heap.push(&#123; -h[n - i], i + 1 &#125;); &#125; for (int i = n - m; i; -- i) &#123; auto [value, id] = heap.top(); heap.pop(); ans[i] = id, value -= h[i]; heap.push(&#123; value, id &#125;); &#125; longs mi = INT64_MAX, ma = 0; while (!heap.empty()) &#123; auto [value, id] = heap.top(); minimize(mi, -value); maximize(ma, -value); heap.pop(); &#125; if (ma - mi &lt;= x) $.put(&quot;YES&quot;).putArray(ans + 1, ans + 1 + n); else $.put(&quot;NO&quot;); &#125; return 0;&#125; 答案其实挺显然的，但是我还是想了半天（ D - Maximum Sum of Products 给了长度为 \\(n \\leq 5000\\) 的数组 \\(a\\) 和 \\(b\\)，现在你可以翻转数组 \\(a\\) 的一个连续子区间，问 \\(\\sum_{i = 1}^n a_i \\cdot b_i\\) 的最大值 暴力枚举反转区间 \\([i, j]\\)，时间复杂度是 \\(\\mathcal{O}(n^3)\\) 的；考虑字符串算法中处理回文串的一些做法，我们可以枚举中间位置 \\(i\\)，然后左右拓展翻转的区间，这样就可以使翻转的复杂度降维；总复杂度 \\(\\mathcal{O}(n^2)\\)； 实现 123456789101112131415161718192021222324252627282930313233343536373839const int N = 2e5 + 5;int ll[N], rr[N], lc[N], rc[N];signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); int T = $.nextInt(), n, l, r; while (T --) &#123; $(n, l, r).nextArray(ll + 1, ll + 1 + l) .nextArray(rr + 1, rr + 1 + r); memset(lc, 0, sizeof(int) * (n + 1)); memset(rc, 0, sizeof(int) * (n + 1)); for (int i = 1; i &lt;= l; ++ i) ++ lc[ll[i]]; for (int i = 1; i &lt;= r; ++ i) ++ rc[rr[i]]; int lp = 0, rp = 0, lct = 0, rct = 0; for (int i = 1; i &lt;= n; ++ i) &#123; int ded = min(lc[i], rc[i]); lc[i] -= ded, rc[i] -= ded; lp += lc[i] / 2, lct += lc[i]; rp += rc[i] / 2, rct += rc[i]; &#125; int ded = min(lp, rp), ans = 0; lct -= ded * 2, rct -= ded * 2; lp -= ded, rp -= ded, ans += ded * 2; if (lct &gt; rct) swap(lct, rct), swap(lp, rp); int more = rct - lct; ded = min(more / 2, rp); ans += ded, more -= ded * 2, rct -= ded * 2, rp -= ded; if (rct &gt; lct) &#123; ded = more / 2, more = 0; rct -= ded, lct += ded, ans += ded; &#125; ans += rct; $.put(ans); &#125; return 0;&#125; 比赛中的话我真的能写出来吗？应该把，应该把（ E - Off by One 二维平面的第一象限上有 \\(n \\leq 2\\cdot10^5\\) 个点；每次操作，你可以选择两个没有被选中过的点，分别将它们向右或者向上移动一个单位，如果这两个点和原点三点共线，那么这次操作是有效的。问你最多可以执行的有效操作数量，并输出一种可能的操作序列。 看起来很没有办法，但是涉及到简单平面几何，能想到的关键字也就那么多。但是即使这样，我也属实没有考虑到这实际上是一个暴力搜索的题目（ 我们将每个点经过两种不同的移动之后得到的位置计算出来；那么，如果两个点可以进行一次有效的操作，就等价于它们变换得到的一个位置到原点的斜率是相等的；一个点可以进行两种不同的移动，就意味这一个点可以关联两种不同的斜率：这样，我们就得到了一张以斜率为点，而以每个可操作节点为边的图。 那么，问题就变成了找到最多的边对，它们之间共享了一个端点；或者说将每一条边分给一个端点，令端点 \\(i\\) 分到的边数为 \\(v_i\\)，那么答案就是 \\(\\sum\\lfloor\\frac{v_i}2\\rfloor\\)；这是一个非常经典的问题，一种解决思路就是 DFS：对于点 \\(i\\)，如果 \\(v_i\\) 是奇数，就把从父亲到自己的边给自己，否则就给父亲；这样就完成了对树边的分配： 那么 DFS 树中的其他边呢？因为这是一个无向图，对于其中的每一个连通块而言，其 DFS 都是一个生成树，也就是说不存在跨越边——剩下的边对于父亲来说是前向边，对于后代来说是后向边。那么对于这些边，为了实现方便，全部都给父亲即可——而且这样也可以显然得到，这种方案只会在总边数为奇数的时候，在根节点处浪费一条边。 很经典，就是利用到父亲的边平衡子树的奇偶性；最多浪费的那条边也就是连通块生成树的根节点，他没有父亲，所以如果真的不能匹配也就只能浪费掉了。 实现 因为斜率是铁分数，所以需要离散化（标号） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const int N = 2e5 + 5;using Frac::frac;pair&lt;frac, frac&gt; p[N];array&lt;int, N&gt; vis;vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; g;vector&lt;pair&lt;int, int&gt;&gt; ans;int dfs(int u) &#123; vis[u] = 1; int cur = -1; for (auto [v, ii] : g[u]) &#123; if (vis[v] == 1) continue; int now = ii; if (!vis[v]) &#123; int tmp = dfs(v); if (tmp != -1) &#123; ans.emplace_back(now, tmp); now = -1; &#125; &#125; if (now != -1) if (cur != -1) &#123; ans.emplace_back(cur, now); cur = -1; &#125; else cur = now; else; &#125; return vis[u] = 2, cur;&#125;signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); int n = $.nextInt(), a, b, c, d; g.resize(2 * n + 1); map&lt;frac, int&gt; id; int tot = 0; const auto one = frac(1); for (int i = 1; i &lt;= n; ++ i) &#123; $(a, b, c, d); auto x = frac(a, b), y = frac(c, d); p[i] = pair(x.reduce(), y.reduce()); auto k1 = (y + one) / x, k2 = y / (x + one); k1.normal(), k2.normal(); if (!id[k1]) id[k1] = ++ tot; if (!id[k2]) id[k2] = ++ tot; g[id[k1]].emplace_back(id[k2], i); g[id[k2]].emplace_back(id[k1], i); &#125; for (int i = 1; i &lt;= tot; ++ i) if (!vis[i]) dfs(i); $.put(ans.size()); for (auto [a, b] : ans) $.put(a, b); return 0;&#125; 实现意外简单（ F - Chests and Keys 有 \\(n\\) 个宝箱，其中第 \\(i\\) 个包含了 \\(a_i\\) 个硬币；有 \\(m\\) 把钥匙，其中第 \\(j\\) 把可以卖 \\(b_j\\) 个硬币。这些钥匙分别对应了不同种类的锁；如果要在第 \\(i\\) 个箱子上安装可以用第 \\(j\\) 把钥匙打开的锁，需要 \\(c_{i, j}\\) 的成本；如果一个箱子上挂了多把锁，那么只有持有所有的这些钥匙才可以打开宝箱。 现在，Alice 持有这些宝箱和钥匙，并付出一定的成本来为箱子上锁；随后，Bob 会花一些硬币购买钥匙，并打开可以打开的所有宝箱以拿走其中的硬币；如果最后 Bob 的净利润严格大于 0，Bob 胜利；否则 Alice 胜利；现在，要求求出 Alice 必定胜利所需要付出的最少成本。 数据范围： \\(1\\leq n, m \\leq 6\\)；\\(1\\leq a_i, b_j \\leq 4\\)；\\(1\\leq c_{i, j} \\leq 10^7\\)； 只能说看到这个题目，是非常的没有想法了；但是数据又很小，像极了乱搞……那么问题就是怎么乱搞了（ 首先，在解决这个问题之前，我们先解决一个经过劣化后的问题—— 如果 Alice 上锁的方式已经确定，那么 Bob 要怎么购买钥匙才能获得最大的收益呢？ 为了解决这个劣化后的问题，我们对题目中描述的模型进行建模：将宝箱全部看作连接了源点的节点，且和源点连边容量为 \\(a_i\\)；将钥匙全部看作链接了汇点的节点，且连边的容量为 \\(b_j\\)；根据宝箱的上锁情况，从宝箱出发到对应的钥匙连边，边权是 \\(\\infin\\)；这样，我们就将上面的问题变成了一个网络流的问题。 那么，这个网络流的含义是什么呢？首先，我们可以获得的最大的收益是所有箱子的硬币之和，我们所支出的成本最多是所有的钥匙的价格之和；每当上锁，我们就相当于增加一个箱子打开的门槛—— 对于一个具体的箱子，我们打开它的成本是它所使用到的锁的钥匙的价格总和，但是不超过箱子能提供的硬币数量—— 没有人会去做一件亏本的事情。初始情况下，我们可以免费打开所有的箱子，但是因为上锁，所以我们需要付出额外的成本：因此，连边就代表了上锁带来的额外成本——这个箱子的成本需要由它上的锁对应的钥匙分担；综上所述，确定了上锁方案的情况下，Bob 得到的最大收益是： \\[ \\sum_{i = 1}^n a_i - \\text{maxFlow} \\] 如果一个箱子的收益完全被需要用来开它的钥匙抵消了，那么就没有开的价值了；但是如果一把钥匙承担了超过它本身价值的收益的话，那么这把钥匙就有买的必要；一种达到这个最大收益的办法是购买所有出边满流的钥匙，但是购买的钥匙数量未必是最少的。 虽然，这种建模方法和常见的裸的网络流并不一样：因为钥匙和箱子的关系是 &amp; 的，因此如果按照代价建模的话，网络流可以恰好地考虑到钥匙开锁的性质和成本。 但是，即使数据范围像本题这样小，上锁方案还是有 \\(nm\\) 种；如果要枚举所有的上锁方案，其时间复杂度是 \\(\\mathcal{O}(2^{nm})\\) 的；因此，我们回到这个问题本身：注意到，如果 Bob 总是按照最大收益来进行操作的话，那么 Bob 的收益是不可能为负数的——因为 Bob 总是可以选择不购买任何钥匙，不打开任何的箱子，这样最后的总收入是 0；那么带入到上面的网络流模型中，就是所有的宝箱的价值都作为成本流量流入了汇点；换句话说，这个网络流的一个最小割是源点和其他所有节点。 那么考虑上述的网络流中没有任何上锁的连边，我们现在来考虑在这张图中连边；我们用状态 \\([F_{1..n}, L, R, P]\\) 来表示当前的网络流图的连边状态：\\(F_i\\) 代表从源点到宝箱 \\(i\\) 的连边流出的成本，\\(L\\) 表示当前考虑的宝箱，\\(R\\) 表示当前考虑的钥匙编号 \\(j\\)，\\(P\\) 表示从钥匙 \\(j\\) 到汇点的连边流入的成本；现在，我们考虑所有的 \\(i \\to j\\) 的连边，进行动态规划： 跳过 \\(i \\to j\\)：也就是这条边不上锁 利用这条边转移一些成本：这条边上锁，但是转移的一部分流量 如果使用这条边转移流量，那么需要满足 \\(S \\to i\\) 和 \\(j \\to T\\) 的边都还有足够的流量剩余；更新状态之后，若所有的 \\(F_i\\) 都已经满流了，则说明成本已经足够抵消所有的宝箱了，更新答案；同时，按照一个特定的顺序考虑 \\([L, R]\\)，将下一对要考虑的点对更新到状态中。如果状态合法，就更新到 dp 数组中。 简单地说，因为数据范围小，我们枚举所有满足了约束条件的转移方法导致的状态，并计算所有的流空的状态的花费的最小值。因为流量最多为 \\(4\\)，而最多的情况下也只有 \\(36\\) 条边，在考虑到每条边容量的约束条件，实际上状态数是相当有限的。 实现 一些小细节：我们考虑 \\([L, R]\\) 的顺序是先改变 \\(L\\) 再改变 \\(R\\)，这需要体现到映射函数中。 此外，因为考虑使用边运输流量的过程，一定是 \\(S\\) 流出的递增的过程，所以在映射函数中这一部分的值总是在最高位； 因为每次要将所有的 \\([L, R]\\) 的状态考虑周全，所以流出流量 \\(P\\) 在映射函数中是最低位的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485int n, m, a[10], b[10], c[10][10];const int F = 4e7, inf = 0x3f3f3f3f;int dp[F];struct state &#123; vector&lt;int&gt; flow&#123;&#125;; int lf&#123;&#125;, rt&#123;&#125;, push&#123;&#125;; state() = default; state(const vector&lt;int&gt; &amp;flow, int lf, int rt, int push) : flow(flow), lf(lf), rt(rt), push(push) &#123;&#125;&#125;;template &lt;&gt;struct std::hash&lt;vector&lt;int&gt;&gt; : public __hash_base&lt;size_t, vector&lt;int&gt;&gt; &#123; size_t operator()(const vector&lt;int&gt; &amp;x) const noexcept &#123; size_t _hashcode = 0; for (auto el : x) _hashcode = _hashcode * 5 + el; return _hashcode; &#125; vector&lt;int&gt; operator[](size_t hashcode) const noexcept &#123; vector&lt;int&gt; _ret(n); for (int i = n - 1; i &gt;= 0; -- i) _ret[i] = int(hashcode % 5), hashcode /= 5; return _ret; &#125;&#125;;template &lt;&gt;struct std::hash&lt;state&gt; : public __hash_base&lt;size_t, state&gt; &#123; size_t operator()(const state &amp;x) const noexcept &#123; size_t _hashcode = hash&lt;vector&lt;int&gt;&gt;&#123;&#125;(x.flow); _hashcode = _hashcode * 6 + x.rt; _hashcode = _hashcode * 6 + x.lf; _hashcode = _hashcode * 5 + x.push; return _hashcode; &#125; state operator[](size_t hashcode) const noexcept &#123; auto _push = int(hashcode % 5); auto _lf = int((hashcode /= 5) % 6); auto _rt = int((hashcode /= 6) % 6); return state( hash&lt;vector&lt;int&gt;&gt;&#123;&#125;[hashcode /= 6], _lf, _rt, _push); &#125;&#125;;signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); $(n, m).nextArray(a, a + n).nextArray(b, b + m); const vector&lt;int&gt; va(a, a + n), vb(b, b + m); for (int i = 0; i &lt; n; ++ i) $.nextArray(c[i], c[i] + m); memset(dp, 0x3f, sizeof dp); int ans = inf; dp[0] = 0; for (int i = 0; i &lt; F; ++ i) &#123; if (dp[i] == inf) continue; auto s = hash&lt;state&gt;&#123;&#125;[i]; for (auto f : &#123;0, 1, 2, 3, 4&#125;) &#123; if (s.flow[s.lf] + f &gt; a[s.lf] || s.push + f &gt; b[s.rt]) break; int pay = !f ? 0 : c[s.lf][s.rt]; auto now = s; now.flow[s.lf] += f, now.push += f; if (s.lf + 1 == n) &#123; now.lf = now.push = 0; now.rt = s.rt + 1; &#125; else now.lf = s.lf + 1; if (now.flow == va) minimize(ans, dp[i] + pay); if (now.rt &lt; m) &#123; auto id = hash&lt;state&gt;&#123;&#125;(now); minimize(dp[id], dp[i] + pay); &#125; &#125; &#125; $.put(ans == inf ? -1 : ans); return 0;&#125; 只能说从网络流建模，到最后的那个 DP 求解，没有一个是现在的我能想出来的（）图论，网络流，恐怖如斯——这也不是我近来第一次被网络流题目锤了== 得想点办法才行。 实际上，这个题涉及到的东西远不止这篇题解胡说八道的这么点，与之相关的知识点比想象中还是要多出许多的。 后记 没什么特别想说的，一周不写代码手感属实全无了== 实际上 E 也不算是什么难题虽然我也没有想到极角排序什么的，但是为什么每一次遇到这种题（不管是我自己打 cf 还是在线下训练中遇到了）都做的非常的费劲呢——还是做题思维的问题吧，ACM 之所以我这种人也能勉强打打，就是因为比起 OI 而言它会更加的注重思维水平；所以还是得多想多学（ 此外，我的图论属实有些拉跨——这个 F 实际上还有很多关键词相关联：比如什么最大权闭合子图啊，什么霍尔定理啊，什么二分图匹配啊之类的，但是十分恐怖的是我都不会；就算是偏向思维的比赛，也是要建立在你有足够的知识积累的基础上，只能说这样属实不行（）得花个专门的时间搞搞图论才行啊 ==","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://shiraha.cn/tags/Codeforces/"}]},{"title":"在 Windows 10 设备上启动 FTP 服务","slug":"host-a-ftp-server-on-your-windows-10-pc","date":"2021-04-25T16:15:25.000Z","updated":"2021-04-25T16:15:25.000Z","comments":true,"path":"2021/host-a-ftp-server-on-your-windows-10-pc/","link":"","permalink":"https://shiraha.cn/2021/host-a-ftp-server-on-your-windows-10-pc/","excerpt":"","text":"一些关于在 Windows 电脑上折腾 FTP 文件传输的记录。毕竟虽然但是，华科大内网的连接速度还是非常可以的，如果能够很好的借助 FTP 传输文件的话，倒也省得我带着移动硬盘在寝室和实验室来回跑了（ 本文的服务器端仅使用 Windows 10 自带的 IIS 控制面板。 前置准备 一些开始教程之前的准备； 增加 Windows 功能 使用 Win + R 运行 optionalfeatures，或者在搜索菜单中搜索“启用或关闭 Windows 功能”； 找到 Internet Information Services，将其下的“FTP 服务器”的所有子选项勾选，并勾选“Web 管理工具”下的“IIS 管理控制台”。 image.png 打开设置，进入应用 -&gt; 应用与功能，点击“可选功能”；搜索 OpenSSH，找到并安装“OpenSSH 服务器”和“OpenSSH 客户端”。 image.png 现在，你应该可以通过计算机管理，或者搜索菜单找到“Internet Information Services (IIS) 管理器” 了。IIS 管理器就有点像之前的云服务器面板一样，不过是 Windows 自带的就是了（ 但是因为 Windows 自身也是有防火墙的，我们要先允许 FTP 服务通过 Windows 的防火墙；在搜索菜单中搜索“允许应用通过 Windows 防火墙”，点更改设置，找到并勾选“FTP 服务器”；然后点击窗口右下角的“允许其他应用”按钮，浏览路径，找到 C:\\Windows\\System32\\svchost.exe，并添加，确定。 其实在配置远程桌面服务的时候也需要在这里配置这一项目 FTP &amp; SFTP &amp; FTPS 其实你要我说也说不太清楚，截至今天我总共已经翘了 2/2（100%）节计算机网络的课了；但是一些常识性的东西还是能简单的说说的： 协议类型 端口 备注 FTP 21 Windows 资源管理器唯一支持的 FTP 形式；明文传输，安全性差，但是很方便 SFTP 22 使用 sshd 作为守护进程；安全，但是传输效率较为低下 FTPS（Explicit） 21 需要一个证书；客户端先发起一个明文的请求，然后再切换到加密连接进行 FTPS（Implicit） 990 同样需要证书；全程加密连接，服务端会拒绝掉所有尝试不通过加密的请求 实际上 FTP 开放的端口并不止一个——有命令通道和数据通道，21 一般指命令通道；FTP 的连接分为主动模式（Standard）和被动模式（Passive）： 主动模式下，客户端首先通过 TCP-21 端口和服务器连接；客户端需要接受数据的时候发送 PORT 命令告诉服务器客户端用来接收数据的端口，然后服务器使用 TCP-20 端口与客户端建立连接，也就是数据通道； 被动模式下，通过 TCP-21 建立连接后发送 PASV 命令；服务端接收命令后打开一个临时端口并通知客户端，客户端再连接服务器的此端口，进行数据传送； 一般来说，由于防火墙一般不允许接受外部发起的连接，所以外网的客户端可能无法使用 Passive 模式连接； FTP 家族比较混乱，一般来说都用 SFTP 了；FTP 协议由于非常的不安全，近年来主流的浏览器都已经放弃了在浏览器中内置 FTP 的支持了——毕竟基础的支持 Windows 资源管理器也提供了。 配置服务器 对于 FTP、SFTP、FTPS 三种服务器的配置方法： FTP 进入 IIS 管理器，在左侧的连接栏中找到“网站”，右键增加 FTP 站点； image.png 在弹出的窗口中指定名称和映射的物理地址，点下一步： image.png 关于 IP 地址，你可以填写你的 IP；如果你不知道填写哪一级别的 IP，你也可以默认“全部为分配”，相当于填入了通配符 *；如果设置了其他的端口，那么访问时的 IP 地址需要带上端口号；如果提供了虚拟主机名，那么访问时还需要加上虚拟主机名，因为没有必要所以这里统统默认。 因为我们现在还不是配置 FTPS，所以选择“无 SSL”。 接下来是配置权限的页面；如果是作为一个公开的 FTP 服务器，可以勾选匿名身份验证，授权全部用户读写权限（当然，这是不可能的）；否则需要进行配置密码： Windows 专业版 用户组策略设置只有专业版的 Windows 10 才有；在计算机管理中的本地用户和组菜单中可以新建用户（组），并且进行细致的组策略管理。我们新建一个一般用户，并设置用户名和密码 image.png 注意需要取消勾选用户下次登陆时须更改密码，不然会比较麻烦。 image.png 然后我们回到 IIS 面板，进入我们刚才创建的服务器的主页；首先进入 FTP 身份验证页面，并且关闭匿名验证： image.png image.png 然后再进入到旁边的 FTP 授权规则页面，增加允许规则，并选择我们刚创建的用户（们）： image.png 不出意外，现在已经可以正常在 Windows 资源管理器里输入 ftp://localhost/ 来输入密码访问了。 Windows 家庭版 Windows 10 家庭版不支持组策略管理，但是支持创建账户；我们可以直接在设置页面创建一个本地的标准账户，并赋予密码，也可以在这里设置允许规则；唯一的问题就是无法进行精细的权限管理，当然，作为一个实用派的萌新，倒也没有必要搞过于精细的权限管理；真要怕被日用时开不用时关就行了，而且 FTP 一个明晃晃的明文传输，人家要真想抓包搞你你也没有什么办法（ 还有一种做法是在服务器主页的右侧栏中的基本设置里（如下）的连接为中设置用户名密码，而在服务器设置里设置允许所有用户： image.png 但是因为我实在是不太理解微软的权限管理，所以这里也就没有尝试，不多废话了。 当然，如果你怕麻烦而且心很大，也可以使用你当前的账户直接连接到 FTP 服务器；此时你的账号名可以通过在 CMD 中运行 echo %username% 获得；如果你当前使用的账户连接到了 Microsoft 账户，那么也可以使用 MicrosoftAccount/your@email.com 作为你的用户名，登陆密码作为你的密码。 FTPS FTPS 是 FTP over SSL 的简称，分为显式和隐式两种；很遗憾 XFTP 7 学生版并不支持似乎标准版也不支持，所以如果你想要通过 FTPS 连接你的 FTP 服务器，那么你需要下载合适的客户端： FileZilla 客户端 ES 文件浏览器 SSL 证书 当然，既然是走 SSL，那么你首先要有一个 SSL 证书；可以自签，也可以绑了域名后申请一个免费的；因为我有在 DNSpod 上托管腾讯云买的域名，所以可以直接方便地申请到免费的证书；下面介绍腾讯云的证书使用方法： 下载 SSL 证书压缩包后，可以看到其中包含了一个 IIS 专用证书的目录；我们进入 IIS 面板，选择计算机名称进入到服务器主页，进入服务器证书页面： image.png 然后再右侧栏中选择导入证书，选择下载的证书文件；然后根据你的 SSL 证书提供商的说明来填入相应的信息。 image.png 增加完成后，你就可以在所有的需要使用 SSL 的证书的地方找到你刚增加的 SSL 证书了。当然，如果要使用这种来自运营商颁发的证书，建议在 DNS 处增加一条解析记录，这样访问也更加优雅。 修改服务器配置 进入你创建的 FTP 服务器的主页，打开 FTP SSL 设置： image.png 进入之后就可以指定 SSL 策略了；如果选择允许 SSL 连接，那么使用 Windows 资源管理器等软件的基本 FTP 的访问将还可以进行（当然，它们依然不安全）；如果选择需要 SSL 连接，等于强制 FTPS，此时只能通过支持 FTPS 协议的客户端来访问 FTP 服务器，当然，也相对更加安全。 隐式 FTPS 因为 FTPS 隐式是通过一个固定的端口 990 来确立安全连接的，所以我们需要使得我们的服务器允许来自 990 端口的连接；进入 FTP 服务器主页，在右侧的操作栏中找到“绑定”并进入；增加对 990 端口的监听，并将类型设置为 ftp，就像下面这样： image.png 这样重启服务器后，我们就可以通过支持 FTPS 的客户端，使用隐式的方式访问 FTP 服务器了；当然，即使不做这一步操作，我们也可以通过显式的方式使用 FTPS 协议访问 FTP 服务器。 SFTP SFTP 和 FTP 完全不是一个东西；它借助了 sshd 运行，是 SSH 套件中的一个。所以在使用它之前，我们首先要在设置菜单中增加 OpenSSH 服务器功能； 然后，我们可以在管理员权限下的 Powershell 中运行： 1net start sshd 来启动 SSH 的守护进程；现在，我们应该可以在其他电脑上是用 SSH 或者客户端访问它了；使用支持 SFTP 的客户端（比如 Xftp 7）来访问它，可以直接访问到整个电脑的根目录。 当然，也可以像在 Linux 中修改 sshd 的配置文件一样修改；在 Windows 10 中，这个配置文件的绝对路径一般是 C:\\ProgramData\\ssh\\sshd_config； 限定某用户只能访问固定文件夹 比如我们限制 ftpuser 只能访问 D 盘 12Match User ftpuser ChrootDirectory D:\\ 可以把上面的内容增加到 sshd_config 的末尾。 限制本机 SSH 只能用来 SFTP 将下面这句话增加到配置文件的末尾： 1ForceCommand internal-sftp 当然也可以配合缩进，限制特定用户的 SSH 功能（像上面那样） 一些吐槽 配置过程中出现的一些神秘问题的记录 XFTP 竟然不支持 FTPS，这是我万万没有想到的（ 博主最开始尝试在 IIS 增加用户允许规则的时候甚至没有发挥作用，但是重新创建一个 FTP 服务器就没有问题了；只能说是十分神秘了（ SFTP 查看的文件列表似乎存在不全的情况，比如下图： 可以稳定地在各种客户端上复现，不知道是什么原因（）不然就用 SFTP 算了，谁搁着 FTPS 呢== 哎，不能再折腾了，凑合着能用就要干活了，那这篇文章先到这里；如果有什么错误的话欢迎指正，如果可以解释上面的这些神秘问题的话也欢迎补充（）","categories":[{"name":"折腾记录","slug":"折腾记录","permalink":"https://shiraha.cn/categories/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"水","slug":"水","permalink":"https://shiraha.cn/tags/%E6%B0%B4/"},{"name":"Windows 10","slug":"Windows-10","permalink":"https://shiraha.cn/tags/Windows-10/"}]},{"title":"Codeforces Round#717 div.2 回顾","slug":"codeforces-round-717-div2","date":"2021-04-23T18:51:18.000Z","updated":"2021-04-23T18:51:18.000Z","comments":true,"path":"2021/codeforces-round-717-div2/","link":"","permalink":"https://shiraha.cn/2021/codeforces-round-717-div2/","excerpt":"","text":"记录 比赛的那天 KS 酱办生日聚会，所以玩的有点晚——于是为了避免掉分就又开了个小号——结果还真的算是预防成功了（（只能说不愧是我== 和上一场一样的出题人，也是熟悉的五个题目；但是这场总感觉比之前那一场要难一些——可能出题人不经意间触及了我较多的知识盲区吧（ 题解 A - Tit for Tat 右手就行可是我白给了一发；只要取出前面的加到最后一个元素上就行了： 12345678910111213141516171819202122const int N = 100;int a[N];signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); int T = $.nextInt(), n, k; while (T --) &#123; input, n, k; $.nextArray(a + 1, a + 1 + n); int l = 1, r = n; while (k &amp;&amp; l &lt; r) &#123; auto ded = min(k, a[l]); k -= ded, a[l] -= ded, a[r] += ded; ++ l; &#125; $.putArray(a + 1, a + 1 + n); &#125; return 0;&#125; 到底是什么样的小天才才能写出 ++ l, -- r 这种代码呢？以为很对称🐎（ B - AGAGA XOOORRR 考虑到最后只可能剩下两个相同的元素或三个相同的元素——因为更多的元素都可以合并到这两种情况上，所以只需要分别处理即可： 1234567891011121314151617181920212223242526const int N = 2060;uint a[N], sum[N];signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); int T = $.nextInt(), n; while (T --) &#123; $(n).nextArray(a + 1, a + 1 + n); for (int i = 1; i &lt;= n; ++ i) sum[i] = sum[i - 1] ^ a[i]; bool found = false; for (int i = 1; i &lt;= n; ++ i) if (sum[i] == (sum[n] ^ sum[i])) found = true; for (int i = 1; i &lt;= n; ++ i) for (int j = i; j &lt;= n; ++ j) if (sum[i] == (sum[j] ^ sum[i]) &amp;&amp; sum[i] == (sum[n] ^ sum[j])) found = true; $.put(found ? &quot;YES&quot; : &quot;NO&quot;); &#125; return 0;&#125; 之前白给成了直接排除一个元素，显然这是不科学的（ C - Baby Ehab Partitions Again 提供长度为 \\(n \\leq 100\\) 的数组 \\(a\\)，你要从中删除一些元素，使得不可以将这个数组拆分成两个部分，使得两个部分的和相等；要求最小化删除元素的数量并输出删除元素的坐标。 首先，显然当 \\(\\sum_{i = 1}^n a_i\\) 是奇数的时候不用删除任何元素；然后，为偶数情况下可以进行背包 \\(DP\\) 来判断是否可能完成这样的划分；如果可以，那么问题就变成了如何删除元素。 不难想到最多只会删除一个元素，那么问题就是删除什么样的元素；我最开始因为删除最小的元素然后白给了一些罚时，因为这样是不正确的——比如删除 2，可以通过交换两个 2 和一个 5 来使得再次平衡；那么我们在考虑其他的一定可行的情况，就不难想到删除一个奇数。 如果整个数组都是偶数怎么办？那么我们可以整体右移 \\(1\\) 位，显然和原数组是等价的；我们可以一直右移，直到我们找到了可以删除的奇数为止；显然，这一定可以找到； 从右移等价，我们可以联想到整个数组除以任何同一个数都是等价的；所以，一个最简单的方法就是首先约去整个数组的 \\(\\gcd\\)，然后找到一个奇数删除就行了——因为是等价的，所以这样的删除是合理的； 代码实现 这个使用 bitset 的可行性背包实现属实颇有雅趣（ 1234567891011121314151617181920212223242526272829303132const int N = 2050, M = 110;int a[N]; bool check(int n) &#123; int sum = accumulate(a + 1, a + 1 + n, 0); if (sum % 2) return false; bitset&lt;N * M&gt; dp; dp.set(0); for (int i = 1; i &lt;= n; ++ i) dp |= (dp &lt;&lt; a[i]); return dp[sum / 2];&#125; signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); int n = $.nextInt(); $.nextArray(a + 1, a + 1 + n); if (check(n)) &#123; int g = 0; for (int i = 1; i &lt;= n; ++ i) g = gcd(g, a[i]); for (int i = 1; i &lt;= n; ++ i) if (a[i] / g % 2) &#123; $.put(1).put(i); break; &#125; &#125; else $.put(0); return 0;&#125; 于是这个卵题我白给了近十发，，我是真的菜（ D - Cut 给一个长度为 \\(n \\leq 10^5\\) 的数组 \\(a\\)，进行 \\(q\\leq10^5\\) 次询问：每次询问关于一个区间 \\([l, r]\\)，将它分成的最少的段数，使得每一段的 \\(\\text{LCM}\\) 都和连乘的乘积相等；求这个段数。 首先，不难意识到 \\(\\text{LCM}\\) 和连乘积相等就是说这一段的 \\(\\gcd\\) 为 \\(1\\)。那么问题就转化为了对于任意段 \\([l, r]\\)，将它划分成互质的最小的段数。 那么一种很显然的想法就是对于范围内的所有质数（约 \\(9600\\) 个）分别维护一个列表，包含了包含它为质因数的数字的下标；然后对于一个位置，对于它的每一个质因子在对应的表上二分查找出下一个位置，取最小值作为下一个区间开始的备选位置；但是这样做显然非常的啥b，因为有显而易见地简单优化但是我也显而易见的没有想到： 我们可以倒着维护每一个质数的下一个位置，这样就不用对每个质数二分查找了 倒着转移的时候也考虑后一个位置的备选位置，这样就不用考虑到备选区间之间的冲突了 那么这样，我们就可以维护出一个表 \\(F_i\\)，表示从 \\(i\\) 开始可以转移到的最远的备选位置； 但是这样还存在一个问题：如果所有的数字都是 \\(1\\)，那么上面的做法会被卡成 \\(n^2\\)；因此，为了能够快速的跳转求出区段数，我们可以利用倍增的思想，维护下两个、下四个备选位置；这样，就可以在 \\(\\log n\\) 的时间内完成转移，并且像二进制拆位那样构造出任何一个数字。 代码实现 使用类筛的方法完成质因数分解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const int N = 1e5 + 5;const int M = 9600;int a[N], f[20][N], to[M];auto decomposition(const int n) &#123; static vector&lt;int&gt; p; static vector&lt;vector&lt;int&gt;&gt; de(n); for (int i = 2; i &lt; n; ++i) if (de[i].empty()) &#123; for (int j = i; j &lt; n; j += i) de[j].push_back(i); p.push_back(i); &#125; return make_pair(ref(p), ref(de));&#125;signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); int n, q, l, r; $(n, q).nextArray(a + 1, a + 1 + n); auto [p, de] = decomposition(N); unordered_map&lt;int, int&gt; desc; const auto ps = p.size(); const auto bound = n + 1; desc.reserve(ps * 4); for (int i = 0; i &lt; ps; ++ i) &#123; desc[p[i]] = i, to[i] = bound; &#125; f[0][bound] = bound; for (int i = n; i; -- i) &#123; f[0][i] = f[0][i + 1]; for (auto j : de[a[i]]) &#123; minimize(f[0][i], to[desc[j]]); to[desc[j]] = i; &#125; &#125; for (int i = 1; i &lt; 20; ++ i) for (int j = 1; j &lt;= bound; ++ j) f[i][j] = f[i - 1][f[i - 1][j]]; while (q --) &#123; $(l, r); uint ans = 0; for (int i = 19; i &gt;= 0; -- i) if (f[i][l] &lt;= r) &#123; ans += (1u &lt;&lt; i); l = f[i][l]; &#125; $.put(ans + 1); &#125; return 0;&#125; 即使可以想到正确的维护方法，但是倍增的思想也不能不说是十分的高妙…… 学到许多（ E - Baby Ehab Plays with Permutations 现在有长度为 \\(n \\leq 10^9\\) 的排列 \\(\\{1, \\dots,n\\}\\)，可以进行对于两个不同的下标两两交换的操作 \\(k \\leq 200\\) 次；问对于 \\([1, k]\\) 次操作可以得到的不同的排列数量； 首先，先说明一种贪心地将长度为 \\(n\\) 的排序 \\(p\\) 复位的做法——对于排列的最后一个位置 \\([n]\\)： 如果 \\(p_n = n\\)，那么可以忽略这个位置；将原排列看作长度为 \\(n - 1\\) 否则，将 \\(p_n\\) 和 \\(p_{p_n}\\) 交换位置；此时至少可以使得 \\(p_n\\) 复位，继续递归，但是操作次数 \\(+1\\) 可以证明，这样处理完整个序列就可以得到将序列 \\(p\\) 复位的最小操作次数。 那么，基于这种思想，我们可以构造出一种递推关系——假设 \\(F_{n, j}\\) 表示了进行 \\(j\\) 次交换后可以复位的、长度为 \\(n\\) 的排列（或者说从复位的排列开始，进行 \\(j\\) 次交换可以产生的排列）的数量： \\(j = 0\\)：此时，只有初始复位的排列一种情况；因此总是为 \\(1\\) 现在，我们考虑通过 \\(F_{n - 1}\\) 向 \\(F_n\\) 转移；即每次将 \\(n\\) 放入长度为 \\(n - 1\\) 的排列中： 如果新放入的 \\(n\\) 不进行交换，那么对答案没有贡献：可以直接转移 如果和前面的 \\(n - 1\\) 个位置中的一个进行交换：那么贡献 \\(1\\) 次次数，有 \\(n - 1\\) 种转移方法 综上所述，可以得到递推公式 \\(F_{n, j} = F_{n - 1, j} + (n - 1) \\cdot F_{n - 1, j - 1}\\)； 那么，基于这个动态规划，我们可以有两种不同的做法： 阳间做法 注意到题目中的 \\(k\\) 非常的小，所以即使进行 \\(k\\) 次交换，最多只会使得 \\(2k\\) 个位置错位；所以我们每次只需要能选出错位的位置长度，然后对于在这个范围内的长度求 \\(F_{n, j}\\) 即可；那么，一种很显然的做法就是确定一个允许的错位位置的长度 \\(i\\)，对于这个长度求 \\(F\\)，最后统一考虑—— 那么，答案长下面这样吗？ \\[ \\text{ans?}_{j} = \\sum_{i = 0}^{\\min(2j, n)} \\mathbf{C}_n^{i} \\times F_{i, j} \\] 不，当然不对——因为我们的 \\(F_{n, j}\\) 可能实际上只变动了其中很少一部分的位置——而这样的话就会不可避免的和其他情况重合，导致计数的不准确；所以为了解决这个问题，我们可以考虑在错排问题种采用的解决方法——使用容斥原理包含/排除重复的部分： 现在，我们定义 \\(G_{n, j}\\) 和 \\(F_{n, j}\\) 类似，但是每一个位置都是错排的情况数量 然后，我们在 \\(F_{n, j}\\) 中选择一个位置固定，然后剩下的位置的任何排序就都符合要求，需要排除 但是这样的话，就会导致两个位置固定的情况被多排除了一次，需要重新包含 …… 所以，我们就可以在 \\(\\mathcal{O}(k^2)\\) 的时间内完成一次 \\(G\\) 的求解；算法总复杂度是 \\(\\mathcal{O}(k^3)\\)。 代码实现 一个很容易注意到的事情就是 \\(\\text{ans}_i\\) 可以由 \\(\\text{ans}_{i - 2}\\) 转移过来——因为你可以连续两次进行相同的交换来浪费两次交换机会== 由此，也很容易联想到奇偶分开（ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const int N = 500;const int mod = 1e9 + 7;longs inv[N], c[N][N], f[N][N];void initInverse(int n, longs p) &#123; inv[0] = inv[1] = 1; for(int i = 2; i &lt;= n; i++) inv[i] = (p - p / i) * inv[p % i] % p; inv[0] = 0;&#125;longs nCr(int n, int r) &#123; longs ret = 1; for (int i = n - r + 1; i &lt;= n; ++ i) ret = ret * i % mod; for (int i = 1; i &lt;= r; ++ i) ret = ret * inv[i] % mod; return ret;&#125;signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); int n = $.nextInt(), k = $.nextInt(); c[0][0] = 1; for (int i = 1; i &lt;= 2 * k; ++ i) &#123; f[i][0] = 1, c[i][0] = 1; for (int j = 1; j &lt;= 2 * k; ++ j) &#123; f[i][j] = (f[i - 1][j] + (i - 1) * f[i - 1][j - 1]) % mod; c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod; &#125; &#125; initInverse(2 * k, mod); longs ans[] = &#123;1, 0&#125;; vector&lt;int&gt; out; for (int j = 1; j &lt;= k; ++ j) &#123; const auto lim = min(n, 2 * j); for (int i = 1; i &lt;= lim; ++ i) &#123; longs cnt = 0, fix, fl; for (fix = 0, fl = 1; fix &lt;= i; ++ fix, fl = -fl) &#123; cnt = cnt + fl * c[i][fix] * f[i - fix][j] % mod; do cnt = (cnt + mod) % mod; while (cnt &lt; 0); &#125; ans[j % 2] = (ans[j % 2] + nCr(n, i) * cnt) % mod; &#125; out.push_back((int) ans[j % 2]); &#125; $.putArray(out.begin(), out.end()); return 0;&#125; 一些说明：很显然 \\(\\mathbf{C}_i^j = \\mathbf{C}_{i - 1}^j + \\mathbf{C}_{i - 1}^{j - 1}\\)； 阴间做法 首先，我们需要先观察上面得到的那个递推公式，并考虑更深刻的理解它： 考虑到 \\(F_{n, 0} = 1\\)，除了递推的转移引入之外，都是通过 \\(n - 1\\) 的形式引入的； 什么情况下会引入 \\(n - 1\\)？当新加入的 \\(n\\) 不放在 \\([n]\\) 而是参与了与前面的位置交换的场合下； 引入时产生了什么副作用？因为进行了交换，所以奉献了一次交换次数，\\(j = j + 1\\)； 所以，我们可以将 \\(F_{n, j}\\) 看作从“下标”集合 \\([0, n - 1]\\) 中选出一个大小 \\(j\\) 的子集求积后求和的结果； 形式化的说，我们可以得到下面的 \\(F_{n, j}\\) 的表示形式： \\[ F_{n, j} = \\sum_{s \\subset [0, n - 1] \\and |s| = j} \\ \\prod_{i = 1}^j s_i \\] 那么接下来，对于全部需要的 \\(j\\)，我们考虑从 \\(F_{n}\\) 转移到 \\(F_{2n}\\)： 一个很显然的想法，就是我们从 \\([0, n - 1]\\) 中选择 \\(l\\) 个，从 \\([n, 2n - 1]\\) 中选出剩下的，组成上面所提到的从集合 \\([0, 2n-1]\\) 中选出的大小为 \\(j\\) 子集；形式化地说就是将两部分的结果乘起来 前半部分的答案很显然是 \\(F_{n, l}\\)，而后半部分的答案我们没有维护；但是我们可以把它看作从 \\([0, n - 1]\\) 中选择了 \\(j - l\\) 个，然后对于每一个都加上了 \\(n\\)，也就是下面这样： \\[ F&#39;_{n, j&#39;} = \\sum_{s\\subset [n, 2n-1] \\and |s| = j&#39;} \\ \\prod_{i = 0}^{j&#39;}s_{i} = \\sum_{s\\subset [0, n-1] \\and |s| = j&#39;} \\ \\prod_{i = 0}^{j&#39;}(s_{i} + n) \\] 那么这个式子展开是什么样的呢？因为这个连乘长得非常像二项式展开但是不是，残念（，所以我们可以想象一下它展开后的样子： \\[ F&#39;_{n, j&#39;} = \\sum_{l = 0}^{j&#39;} \\mathbf{C}_{n - l}^{j&#39;-l} \\times n^{j&#39;-l} \\times \\sum_{s\\subset [0, n-1] \\and |s| = l} \\prod_{i = 0}^{l}s_i \\] 上面的式子中，有 \\(\\mathbf{C}_{n - l}^{j&#39; - l} = \\mathbf{C}_n^{j&#39;} \\times \\mathbf{C}_{j&#39;}^l\\)；首先是选出坐标的组合数，然后乘上“二项式系数”。 然后，观察上面的式子的后半部分，我们会惊喜地发现它就是 \\(F_{n, l}\\)，是我们已经维护的东西！ 综上所述，我们可以通过下面的转移方程完成从 \\(F_{n}\\) 到 \\(F_{2n}\\) 的转移： \\[ F_{2n, J} = \\sum_{j = 0}^J F_{n, j} \\times F&#39;_{n, j&#39;}, \\ \\ j + j&#39; = J \\] 上式中的 \\(F&#39;_{n, j}\\) 可以通过 \\(F_{n, j}\\) 通过下面的多项式乘法转移得到： \\[ F&#39;_{n, j} = \\sum_{l = 0}^j \\mathbf{C}_{n - l}^{j - l} \\times n^{j - l} \\times F_{n, l} \\] 当然，基础的从 \\(F_{n - 1, j}\\) 和 \\(F_{n - 1, j - 1}\\) 向 \\(F_{n, j}\\) 的转化仍然有效；因此我们可以转化到任何的 \\(n\\)：相当于我们从 \\(n = 1\\) 出发，然后使用 \\(\\times2\\) 和 \\(+1\\) 操作构造任何的 \\(n\\) ——在构造的过程中完成上面的转移就可以了；一种很显然的思路就是二进制拆位，然后按位构造 \\(n\\)： 代码实现 基本的思路就是每次扩增 \\(\\times2\\)，如果这一位为 1 就再额外进行一次 \\(+1\\) 扩增： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const int N = 500;const int mod = 1e9 + 7;longs inv[N], f[N], big[N], np[N], tmp[N];void initInverse(int n, longs p) &#123; inv[0] = inv[1] = 1; for(int i = 2; i &lt;= n; i++) inv[i] = (p - p / i) * inv[p % i] % p; inv[0] = 0;&#125;longs nCr(longs n, longs r) &#123; longs ret = 1; for (auto i = n - r + 1; i &lt;= n; ++ i) ret = ret * i % mod; for (int i = 1; i &lt;= r; ++ i) ret = ret * inv[i] % mod; return ret;&#125;void calculateBig(int k, longs n) &#123; memset(big, 0, sizeof(longs) * (k + 1)); memset(np, 0, sizeof(longs) * (k + 1)); np[0] = 1; for (int i = 1; i &lt;= k; ++ i) np[i] = n * np[i - 1] % mod; const auto lim = min((longs)k, n); for (int i = 0; i &lt;= lim; ++ i) for (int j = 0; j &lt;= i; ++ j) &#123; auto t = nCr(n - j, i - j) * f[j] % mod * np[i - j] % mod; big[i] = (big[i] + t) % mod; &#125;&#125;signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); int n = $.nextInt(), k = $.nextInt(); const bitset&lt;32&gt; binary = n; initInverse(N - 1, mod); longs now = f[0] = 1; for (int i = 30 - __builtin_clz(n); i &gt;= 0; -- i) &#123; calculateBig(k, now); memset(tmp, 0, sizeof(longs) * (k + 1)); for (int s = 0; s &lt;= k; ++ s) for (int b = 0; b &lt;= k; ++ b) if (s + b &lt;= k) tmp[s + b] = (tmp[s + b] + f[s] * big[b]) % mod; else break; memcpy(f, tmp, sizeof(longs) * (k + 1)); now *= 2; if (binary.test(i)) &#123; memset(tmp, 0, sizeof(longs) * (k + 1)); tmp[0] = 1; for (int j = 1; j &lt;= k; ++ j) tmp[j] = (f[j] + now * f[j - 1]) % mod; memcpy(f, tmp, sizeof(longs) * (k + 1)); ++ now; &#125; &#125; longs ans[] = &#123;1, 0&#125;; vector&lt;int&gt; out; for (int j = 1; j &lt;= k; ++ j) &#123; ans[j % 2] = (ans[j % 2] + f[j]) % mod; out.push_back((int) ans[j % 2]); &#125; $.putArray(out.begin(), out.end()); return 0;&#125; 上面的代码中的 30 - __builtin_clz(n) 的含义是： int 类型的 n 的最高位的 1 的所在的位置的低一位的下标；我们使用它作为扩增起点——不使用最高位的原因是我们已经从 \\(1\\) 出发了，所以不需要对于首位的 \\(1\\) 进行额外的扩增。 当然，上面的实现中的每次转移的时间复杂度是 \\(\\mathcal{O}(k^2)\\) 的，进行 \\(\\log_2n\\) 次转移；如果可以使用各种手段加快单次转移的速度，理论上可以做到 \\(k \\leq 10^5\\)（时间复杂度 \\(\\mathcal{O}(k\\cdot \\log k\\log n)\\)）但是我不会，原作者也不会 后记 罚时是真的多，，明明还是可以回到 1700 的场嗯给我打成了防掉分场，只能说非常地不行了（ JVS2TR2_F28UCRC3K_YG_3B.jpg 最近的准度不行啊，还是以后要多加注意才行；补题也要进行的更加迅速才行，不然题目真的补不完力昨天半夜的 Div.1 + Div.2 还没有下落呜呜（呜呜呜","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://shiraha.cn/tags/Codeforces/"}]},{"title":"基础知识：错排问题","slug":"The-concept-of-dearangement-problems","date":"2021-04-22T12:12:51.000Z","updated":"2021-04-22T12:12:51.000Z","comments":true,"path":"2021/The-concept-of-dearangement-problems/","link":"","permalink":"https://shiraha.cn/2021/The-concept-of-dearangement-problems/","excerpt":"","text":"什么是错排问题？重排指的是在排列组合中，一个排列的所有的元素都不在原来的位置上；更加地形式化说明的话，就是对于一个包含 \\(1\\cdots n\\) 全部 \\(n\\) 个元素的排列 \\(p\\)，按照 \\(1\\)-下标方法，对于任何 \\(i \\in [1, n]\\) 都满足 \\(p_i \\ne i\\)；这类问题常见的应用有信封问题（经典原型），书架问题（换皮原型）等。 那么，这篇文章着眼于如何推出错排问题的式子，以及它的简化式子展开介绍： 递推公式 现在，我们假设有一个包含 \\(1\\cdots n\\) 全部 \\(n\\) 个元素的排列 \\(p\\)，并且按照 \\(1\\)-下标方法定位；最开始时，对于任何 \\(i \\in [1, n]\\) 都满足 \\(p_i = i\\)；那么我们对它进行操作，将它变成一个重排： 首先从原来的序列中取出一个下标；因为不管选择哪个都是等价的，我们选择 \\([n]\\) 位置，取出 \\(n\\) 再从剩下来的 \\(n - 1\\) 个正确的位置中，选择一个位置 \\([k]\\)；我们将要把 \\(n\\) 放入 \\([k]\\) 位置，取出 \\(k\\) 显然，这一步对于位置 \\([k]\\) 的选择有 \\(n - 1\\) 种不同的选择。 接下来，我们要将 \\(k\\) 放回序列中；我们有两种选择： 将 \\(k\\) 放入位置 \\([n]\\)；这样相当于交换了 \\(n\\) 和 \\(k\\) 的位，使得了这两个位置符合了错排的考虑 现在还剩下 \\(n - 2\\) 个位置，它们都是有序的；可以被作为一个子问题递归地处理 将 \\(k\\) 放入位置 \\([i \\ne n]\\)，也就是不放入位置 \\([n]\\)；这种情况下，我们可以这样考虑： 对于位置 \\([k] = n\\)，已经是确定的了，所以可以忽略它 我们暂时将 \\(k\\) 放入 \\([n]\\)，因为最终会将 \\(k\\) 放到其他位置上，所以可以认为此时是未重排状态 此时，剩下的排列包含了 \\(n - 1\\) 个元素，它们都“未经过重排”，可看作一个子问题递归 综上所述，第一种选择是作为 \\(n - 2\\) 的子问题，第二种选择 \\(n - 1\\) 的子问题递归。 那么，由于乘法法则和加法法则；令 \\(D_n\\) 表示长度为 \\(n\\) 的重排排列的数量，那么可得到： \\[ D_n = (n - 1) \\cdot (D_{n - 1} + D_{n - 2}) \\] 且特殊地存在 \\(D_0 = 1\\) 和 \\(D_1 = 0\\)；这就是我们得到的第一个递推式子； 化简 这一步的化简网上一般有两种做法；作者选择了她喜欢的一种详细介绍： 对于上述得到的重排公式，我们在等式的两侧同时减去 \\(nD_{n -1}\\)，可得： \\[ \\begin{align} D_n - nD_{n - 1} &amp;= -D_{n - 1} + (n - 1)D_{n - 2} \\\\ &amp;= -[D_{n - 1} - (n - 1)D_{n - 2}] \\\\ &amp;= (-1)^2[D_{n - 2} - (n - 2)D_{n - 3}] \\\\ &amp;= \\cdots \\\\ &amp;= (-1)^{n - 1}(D_1 - D_0) \\\\ &amp;= (-1)^n \\end{align} \\] 所以，可以得到化简后的递推公式：\\(D_n = nD_{n - 1} + (-1)^n\\)，特别地 \\(D_1 = 0\\)； 另一种的做法假设 \\(D_n = n!M_n\\)，那么 \\(M_1 = 0\\)，\\(M_2 = \\frac12\\)； 对于 \\(n \\geq 3\\) 的场合，将第一个递推公式 \\(D_n = (n - 1) \\cdot (D_{n - 1} + D_{n - 2})\\) 根据定义拆分： \\[ \\begin{align} n!M_n &amp;= (n - 1)(n - 1)!M_{n - 1} + (n - 1)(n - 2)!M_{n - 2} \\\\ &amp;= n!M_{n - 1} - (n - 1)!M_{n - 1} + (n - 1)!M_{n - 2} \\\\ n!M_n - n!M_{n - 1} &amp;= -((n - 1)!M_{n - 1} - (n - 1)!M_{n - 2}) \\\\ M_n - M_{n - 1} &amp;= -\\frac1n(M_{n - 1} - M_{n - 2}) \\\\ \\end{align} \\] 其实这种推导和上面的是完全等价的——不如说看起来几乎完全没有怎么化简；只是因为这种推导方法在得到通项公式的时候更加的自然再推导一步就得到通项公式了，所以删了（。 通项公式 只有递推公式有的时候是不够的，所以我们还需要依据上面求出的递推公式求出通项公式；这里作者提供了三种不同的推导方法： 套公式 对于形如 \\(f(n) = g(n)f(n - 1) + h(n)\\) 的递推方程，经过暴力展开，可以得到下面的公式： \\[ f(n) = \\prod_{i = 1}^n g(i) \\cdot [f(0) + \\sum_{i = 1}^n \\frac{h(i)}{\\prod_{j = 1}^ig(j)}] \\] 对于我们求得的递推公式 \\(D_n = nD_{n - 1} + (-1)^n\\)，不难通过观察得出三个部分是 \\(f(x) = D_x\\)、\\(g(x) = x\\)、\\(h(x) = (-1)^x\\)；带入上面的暴力公式中，可以求出： \\[ D_n = n! \\cdot [1 + \\sum_{k = 1}^n \\frac{(-1)^k}{k!}] = n! \\cdot \\sum_{k = 0}^n \\frac{(-1)^k}{k!} \\] 那么就得到了错排数量的通项公式。 继续推导 在板块一提到的第二种方法化简得到的：\\(M_n - M_{n - 1} = -\\frac1n(M_{n - 1} - M_{n - 2})\\)；我们将代入多个 \\(n\\) 并将得到的式子的左侧和右侧全部相加，可以得到： \\[ \\begin{align} M_n - M_1 &amp;= (-1)^2\\frac1{2!} + (-1)^3\\frac1{3!}+\\dots+(-1)^n\\frac1{n!} \\\\ M_n &amp;= \\sum_{k = 2}^n (-1)^n\\frac1{k!} + 1 + (-1)\\frac1{1!} \\\\ M_n &amp;= \\sum_{k = 0}^n (-1)^n\\frac1{k!} \\end{align} \\] 又因为 \\(D_n = n!M_n\\)，所以 \\(D_n = n!\\cdot\\sum_{k = 0}^n (-1)^n\\frac1{k!}\\)，和上面的化简结果一样。 容斥定理 对于长度为 \\(n\\) 的排列，一共有 \\(n!\\) 种不同的排列；我们要求的重排排列是它的子集；因此我们考虑，如果我们将所有不是重排排列的情况去除，那么剩下的就全部是重排排列了！ 假定排列的长度为 \\(n\\)，我们令 \\(A_i\\) 为满足 \\(p[i] = i\\) 的排列种数，那么显然可以得到： \\[ \\begin{align} |A_i| &amp;= (n - 1)! \\\\ |A_i \\cap A_j| &amp;= (n - 2)! \\\\ |A_i \\cap A_j \\cap A_k| &amp;= (n - 3)! \\\\ &amp;\\vdots \\end{align} \\] 因此，每个元素都不在对应位置的时间就是对于 \\(1 \\leq i \\leq n\\) 的 \\(\\overline{A_i}\\)： \\[ \\begin{align} \\bigcap_{i = 1}^n \\overline{A_i} &amp;= n! - \\mathbf{C}_n^1(n - 1)! + \\mathbf{C}_n^2(n - 2)! - \\cdots \\mp \\mathbf{C}_n^{n - 1}2! \\pm \\mathbf{C}_n^n1! \\\\ &amp;= \\sum_{k = 0}^n (-1)^k \\cdot \\mathbf{C}_n^k(n - k)! \\\\ &amp;= n!\\sum_{k = 0}^n (-1)^k \\cdot \\frac1{k!} \\end{align} \\] 显然，这也和之前的推导结果是一致的； 那么我们可以怎么理解式子中的加加减减呢？我们首先删除以每一个 \\(i\\) 不满足的位置，但是这样对于排列中出现了两个不满足的位置的情况额外减了一次，所以要加回来——首先组合选出两个位置，然后其他的位置全排列；但是这样又会导致有三个不满足的位置的情况多加了…… 以此类推直到所有的位置都不正确的唯一情况。 母函数方法 阿哲，一下子给我整不会了.jpg 百度百科的证法实在是太过玄妙，，如果有看懂了的欢迎讲给博主听（ 化简公式 但是在算法竞赛中使用这样的超级复杂的多项式通项公式约等于没有，甚至效率不如直接递推；所以我们需要使用起来更加方便的通项公式： 首先我们考虑 \\(e^x\\) 的幂级数展开（麦克劳林公式/泰勒展开）： \\[ \\forall x \\in \\mathbb{C}, \\ e^x = \\sum_{n = 0}^{+\\infty}\\frac{x^n}{n!} \\approx 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\cdots + \\frac{x^n}{n!} \\] 泰勒展开后面还带一个余项，不过这我就真的不会了高数早就还给微积分老师力（ 对于 \\(x = -1\\)，我们可以得到如下的泰勒展开式： \\[ e^{-1} = \\sum_{i = 0}^n \\frac{(-1)^i}{i!} + R_n \\ , \\ R_n = \\frac{e^{-c}(c - 1)^n}{(n + 1)!} \\ , \\ c \\in [0, 1] \\] 所以，我们可以认为：\\(e^{-1} = \\frac{D_n}{n!} + R_n\\)，或者 \\(n!e^{-1} - D_n = n!R_n\\)；又因为余项 \\(R_n\\) 在 \\(c\\) 取 \\(c = 0\\) 时取到上界 \\(\\frac1{(n + 1)!}\\)，因此可以得到： \\[ |n!\\cdot e^{-1} - D_n| = |n!\\cdot R_n| \\leq \\frac{n!}{(n + 1)!} = \\frac1{n + 1} \\] 在我们的通项公式的可行域 \\(n \\geq 1\\) 中，显然满足 \\(\\frac1{n + 1} \\leq \\frac12\\)；因此我们可以认为 \\(D_n\\) 和最接近 \\(\\frac{n!}e\\) 的整数相同；所以最后我们可以将化简后的通项公式写成下面这样： \\[ D_n = \\lfloor \\frac{n!}e + \\frac12\\rfloor \\] 向下取整在代码中实现也非常方便，就达到化简通项公式的目的。 练习题 这种裸题应该还是挺多的；所以我就随便挂一个经典原型了： cses.fi 1717 有 \\(n\\) 个小盆友，每个小盆友都买了一个圣诞礼物与其他的小盆友交换；要求每个小盆友都要得到来自其他小盆友的礼物；问一共有多少种交换方式。 1234567891011121314151617const int mod = 1e9 + 7;const int N = 1e6 + 5;int ans[N];signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); int n; input, n; ans[0] = ans[2] = 1, ans[1] = 0; for (longs i = 3; i &lt;= n; ++ i) ans[i] = int((ans[i - 1] + ans[i - 2]) % mod * (i - 1) % mod); output, ans[n], endl; return 0;&#125; 因为数据范围很小，所以只需要使用递推公式就可以通过此题了。 后记 虽然推的时候还是很痛苦的，但是写博文的时候又觉得言之无物，，看来还是昨天晚上睡少了（ 如果有机会的话再完善一下关于错排生成算法的东西吧…… 参考资料 https://blog.csdn.net/Ber_Bai/article/details/77112975 https://baike.baidu.com/item/%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98/3849290","categories":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"算法/数学","permalink":"https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"组合数学","slug":"组合数学","permalink":"https://shiraha.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"推导","slug":"推导","permalink":"https://shiraha.cn/tags/%E6%8E%A8%E5%AF%BC/"}]},{"title":"Codeforces Round#716 div.2 回顾","slug":"codeforces-round-716-div2","date":"2021-04-21T06:15:36.000Z","updated":"2021-04-21T06:15:36.000Z","comments":true,"path":"2021/codeforces-round-716-div2/","link":"","permalink":"https://shiraha.cn/2021/codeforces-round-716-div2/","excerpt":"","text":"补题地址：https://codeforces.com/contest/1514 记录 就是我上一篇博文中提到的那个因为记错时间而忘记打的 Div2；顺便一提，这一场的下一场也是非经典时间 21:35 开始，希望可以正常打起来吧……？ 曾经也在本博客的博文里登场的学弟打了 ABD 三个题，C 题奇妙的被 hack 了（）着实有点恐怖；本以为我至少也能打个 ABCD 的，没想到 CD 全都挂了，，属实不行== 题解 A - Perfectly Imperfect Array 逻辑关系略绕，但是也没啥好说的（） 12345678910111213141516171819202122const int N = 120;int a[N];set&lt;int&gt; pre;signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); int T = $.nextInt(), n; for (int i = 1; i &lt;= 1e4; ++ i) pre.insert(i * i); while (T --) &#123; $(n).nextArray(a + 1, a + 1 + n); bool found = false; for (int i = 1; i &lt;= n; ++ i) &#123; found |= !pre.count(a[i]); &#125; output, found ? &quot;YES&quot; : &quot;NO&quot;, endl; &#125; return 0;&#125; 应该算是有手就行吧，主要就是看能几分钟写出来了） B - AND 0, Sum Big 因为要求和最大，把每一个数字按照二进制拆分，那么就是每一位的 \\(1\\) 尽可能的多；又因为所有的数的按位与的和为 \\(0\\)，所以每一个位都要有一个 \\(0\\)，那么问题就变成将每一位的 \\(0\\) 分配到不同的数字中了。显然，对于总长度为 \\(k\\) 二进制数字，每一位都可以安放在任何数字中，总共有 \\(n^k\\) 种。 12345678910111213141516171819202122232425262728const int N = 1e5 + 5;const int mod = 1e9 + 7;longs fastPow(longs a, longs b)&#123; longs ans = 1; while(b) &#123; if (b &amp; 1u) ans = (ans * a) % mod; a = (a * a) % mod; b &gt;&gt;= 1u; &#125; return ans % mod;&#125;signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); int n, k, T; input, T; while (T --) &#123; input, n, k; output, fastPow(n, k), endl; &#125; return 0;&#125; 经典看样例猜做法（ C - Product 1 Modulo N 给 \\(n \\leq 10^5\\)；现在要求求出 \\(1, \\dots, n-1\\) 的最长子序列 \\(a\\)，满足 \\(\\prod a_i \\mod n \\equiv 1\\)；输出子序列 \\(a\\) 的长度以及它包含的元素； 一种很显然的想法是现将它们都乘起来，然后取余数，再将余数的数字从列表中删除（当然，如果为 1 就算了）从而得到了答案序列；如果再打表的话还会意识到如果 \\(n\\) 是素数，那么答案是 \\(1, \\dots, n-2\\)；但是再稍微打表就会意识到，如果 \\(n\\) 不是素数，那么你删除模数之后的乘积未必是 1，于是这种做法显而易见的错误了——毕竟就连样例都过不了（ 稍事思考：对于任何数 \\(n\\) 都显然有 \\(\\gcd(1, n) = 1\\)；由辗转相除法的转移式子 gcd(a, b) = gcd(b, a % b) 可知 \\(\\gcd(\\prod a_i \\mod n, n) = \\gcd(\\prod a_i, n)\\)；联立一下就是我们选择的序列的乘积和 \\(n\\) 互素：如果这样，那么选择的序列中的每一个 \\(a_i\\) 都应该和 \\(n\\) 互素（这是必要条件）；在这样的基础上，我们先以此作为标准，过滤掉所有和 \\(n\\) 不互质的数字。 同理，我们可以通过将剩下的数字全部乘起来取模，得到这个很大的数字和 \\(n\\) 的最大公因数；因为现在所有的数字都和 \\(n\\) 互素，所以这个因子一定出现在了我们选择的数字中；此时我们只要把它移除就可以了；当然，如果你打表，你也能发现在删除了所有的不互质的数字之外还需要删除一个数字（ 1234567891011121314151617signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); int n = $.nextInt(); set&lt;int&gt; ans; longs tmp = 1; for (int i = 1; i &lt; n; ++ i) if (gcd(i, n) == 1) &#123; ans.insert(i); tmp = tmp * i % n; &#125; if (tmp != 1) ans.erase((int)tmp); $.put(ans.size()).putArray(ans.begin(), ans.end()); return 0;&#125; 看代码也能看出来这个过程实际上非常的自然；但是说又说不清楚…… 只能说需要补习数论了== D - Cut and Stick 定义“好序列”是其中没有元素出现的次数超过 \\(\\lceil \\frac{n}2 \\rceil\\)，其中 \\(n\\) 是序列的长度；对于一个序列，如果它不是好序列，但你可以将它划分为 \\(m\\) 个子序列，它们都是好序列，那么这个序列的权值是 \\(m\\)；显然，对于一个好序列自身而言，它的权值是 \\(1\\)。 现提供长度为 \\(n \\leq 3 \\cdot 10^5\\) 的序列；进行 \\(q \\leq 3 \\cdot 10^5\\) 次询问：每次询问 \\([l, r]\\) 区间的字串序列的权值。 可以说是一个很乱搞的题目了；如果有差不多的算法素养或者代码能力的话应该就能写出来的只可惜我没有，残疾人竟是我自己。下面介绍一下这个题目的三种思路： 首先，如果暴力移动区间，显然每次扩张和收缩都可以 \\(O(1)\\) 完成：需要维护的是区间内每个数字出现的次数，以及这个次数出现的次数；因为每次移动只会使得某数字出现的次数变化 1，所以转移一定可以直接完成。 那么，对于这种询问次数很大，又可以这样暴力维护的问题，而且还没有在线的要求；我们就可以考虑使用莫队算法离线维护；时间复杂度是 \\(\\mathcal{O}(n \\sqrt n)\\) 的： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374const int N = 3e5 + 5;int a[N];namespace MO &#123; int block_size = 1; struct query &#123; int l, r, id; query() = default; query(int l, int r, int id) : l(l), r(r), id(id) &#123;&#125; bool operator &lt;(const query &amp;rhs) const &#123; if (l / block_size == rhs.l / block_size) return r &lt; rhs.r; else return l &lt; rhs.l; &#125; &#125;; vector&lt;query&gt; req; vector&lt;int&gt; ans; int cnt[N], tim[N]; void step(int pos, int sig, int &amp;now) &#123; auto &amp;times = tim[a[pos]]; if (times &gt;= 0) -- cnt[times]; times += sig; if (times &gt;= 0) ++ cnt[times]; if (sig &gt; 0) maximize(now, times); else while (!cnt[now]) -- now; &#125; void solve(int n) &#123; int l = 0, r = 0, tmp = 0; const auto increase = [&amp;](int pos) &#123; step(pos, +1, tmp); &#125;; const auto decrease = [&amp;](int pos) &#123; step(pos, -1, tmp); &#125;; for (auto [ql, qr, qid] : req) &#123; while (ql &lt; l) increase(-- l); while (qr &gt; r) increase(++ r); while (ql &gt; l) decrease(l ++); while (qr &lt; r) decrease(r --); const auto len = qr - ql + 1; ans[qid] = max(1, 2 * tmp - len); &#125; &#125; void run(int n, int m) &#123; ans.resize(m + 1); block_size = (int) n / sqrt(m * 2 / 3); stable_sort(req.begin(), req.end()); solve(n); &#125;&#125;signed main() &#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int n = scanner.nextInt(), m = scanner.nextInt(); for (int i = 1; i &lt;= n; ++ i) a[i] = scanner.nextInt(); for (int i = 1; i &lt;= m; ++ i) &#123; int l = scanner.nextInt(), r = scanner.nextInt(); MO::req.emplace_back(l, r, i); &#125; MO::run(n, m); for (int i = 1; i &lt;= m; ++ i) println(MO::ans[i]); return 0;&#125; 特别说明：分块的方法没有采用经典的 \\(\\lceil \\sqrt{n} \\rceil\\)，写法采用的分块方法在本题的表现更好其实是抄学弟的； 虽然这样修改分块方法已经使得我的莫队运行时间从 2200ms 变成了 1800ms，但是学弟原本的代码跑到了令人发指的 900ms…… MSYS2 这么拉的嘛（） 虽然如果要求众数，只能使用莫队这种优雅的暴力来维护；但是我们还是应该敏感地注意到众数和“过半数”的微妙的区别；虽然前者没办法用树形数据结构维护，但是后者是可以的——考虑将两个区间的结果合并成的大区间的结果：显然大区间的“过半数”必为两个子区间的“过半数”中的一个，因此可以使用线段树维护。 那么我们应该如何合并结果呢？查找一个数字在区间 \\([l, r]\\) 中出现的次数，我们可以将这些位置存进数组里，然后使用二分查找确定上下界，那么两界之差就是我们要求的结果；这个询问的时间复杂度是 \\(\\mathcal{O}(\\log n)\\) 的。 确定了合并策略，我们就可以写出下面的代码什么嘛，合并策略这个抽象不是挺好用的嘛： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768template &lt;class T&gt;class seg_tree &#123; using merge_method = function&lt;T(T, T, int, int)&gt;; int siz; vector&lt;T&gt; t; merge_method merge; void build(int id, int l, int r, const T *arr) &#123; if (l + 1 == r) &#123; t[id] = arr[l]; return; &#125; int m = (l + r) / 2; build(id * 2 + 1, l, m, arr); build(id * 2 + 2, m, r, arr); t[id] = merge(t[id * 2 + 1], t[id * 2 + 2], l, r); &#125; T query(int id, int l, int r, int ll, int rr) &#123; if (ll &gt;= rr) return (T)-1; else if (ll == l &amp;&amp; rr == r) return t[id]; int m = (l + r) / 2; auto lv = query(id * 2 + 1, l, m, ll, min(rr, m)); auto rv = query(id * 2 + 2, m, r, max(m, ll), rr); return merge(lv, rv, ll, rr); &#125;public: explicit seg_tree(int n, merge_method m) : siz(n), merge(move(m)) &#123; t.resize(4 * n); &#125; void build(const T *arr) &#123; return build(0, 0, siz + 1, arr); &#125; T query(int ll, int rr) &#123; return query(0, 0, siz + 1, ll, rr); &#125;&#125;;const int N = 3e5 + 5;int a[N];vector&lt;int&gt; pos[N];signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); int n, q, l, r; const auto count = [&amp;](int l, int r, int i) -&gt; int &#123; if (i &lt;= 0) return -1; auto ll = lower_bound(pos[i].begin(), pos[i].end(), l); auto rr = lower_bound(pos[i].begin(), pos[i].end(), r); return rr - ll; &#125;; $(n, q).nextArray(a + 1, a + 1 + n); for (int i = 1; i &lt;= n; ++ i) pos[a[i]].push_back(i); seg_tree&lt;int&gt; t(n + 1, [&amp;](int a, int b, int l, int r) -&gt; int &#123; const auto aa = count(l, r, a), bb = count(l, r, b); return aa &gt; bb ? a : b; &#125;); t.build(a); while (q --) &#123; $(l, r); auto id = t.query(l, r + 1); auto ans = count(l, r + 1, id); ans = ans * 2 - (r + 1 - l); $.put(max(ans, 1)); &#125; return 0;&#125; 线段树总体的复杂度大概是 \\(\\mathcal{O}(n\\log n \\cdot X)\\) 的，其中 \\(X\\) 是合并策略的单次操作的复杂度；那么这个问题的整体复杂度是 \\(\\mathcal{O}(n \\log^2n)\\) 的，倒也可以接受。 还有一种比较野的思路，就是随机化：对于每次询问，我们在区间 \\([l, r]\\) 中随机选择一个位置，并假定它的值的出现次数最多，并更新答案，重复多次；如果重复选择的次数足够多，就可以将出错的概率降到很低： 123456789101112131415161718192021222324252627282930313233const int N = 3e5 + 5, T = 40;int a[N];vector&lt;int&gt; pos[N];signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); int n, q, l, r, ans, t; const auto count = [&amp;](int l, int r, int i) -&gt; int &#123; if (i &lt;= 0) return -1; auto ll = lower_bound(pos[i].begin(), pos[i].end(), l); auto rr = upper_bound(pos[i].begin(), pos[i].end(), r); return rr - ll; &#125;; $(n, q).nextArray(a + 1, a + 1 + n); for (int i = 1; i &lt;= n; ++ i) pos[a[i]].push_back(i); mt19937 rng( chrono::steady_clock::now() .time_since_epoch().count() ); while (q --) &#123; $(l, r), ans = 1, t = T; while (t --) &#123; int gen = a[uniform_int_distribution&lt;int&gt;(l, r)(rng)]; maximize(ans, 2 * count(l, r, gen) - (r - l + 1)); &#125; $.println(ans); &#125; return 0;&#125; 什么是真正的乱搞啊（战术后仰）因为我们求的权值是可以像最大值那样合并的，所以这样做非常合理；算法整体的时间复杂度是 \\(\\mathcal{O}(qT\\log n)\\) 的，其中 \\(T\\) 是重复随机的次数。 据出题人说，这个题还可以使用某种方法做到 \\(\\mathcal{O}(n\\log n)\\)，这我就真不会了（）如果会的话欢迎教我== E - Baby Ehab's Hyper Apartment 有 \\(n \\leq 100\\) 个节点，每对节点之间都有一条有向边；现在你可以进行以下两种询问： 询问 \\(u \\to v\\) 的方向，正向返回 1，否则 0；不超过 \\(9n\\) 次 询问 \\(u \\to \\{a_1, \\dots, a_n\\}\\) 中是否存在到其中任一通路，全部不可达返回 0，否则 1；不超过 \\(2n\\) 次 要求你在规定的询问次数内求出 \\(n \\times n\\) 矩阵 \\(M\\)，\\(M_{i, j}\\) 代表 \\(i \\to j\\) 是否可达。 完全没有思路，，看了题解才发现需要的知识基本也都还给离散老师了，直接埋了吧（无慈悲 首先，我们考虑只使用其中的一部分边来完成所有的转移——其他的边都是多余的；然后，发现这张图是一个竞赛图：因此它必定存在一条按照某种顺序可以到达所有的点仅一次的哈密顿通路；在这条哈密顿通路上，处于偏序位置较低的点可以到达任何偏序位置较高的点。 那么，在这样的基础上，我们只需要考虑从偏序位置较高的点到达较低的点即可；假设从某个高位置 \\(i\\) 可以到达的最低的位置是 \\(p\\)，那么所有在 \\(p\\) 点上，在 \\(i\\) 点下的位置都可以从 \\(i\\) 出发到达，而在 \\(p\\) 点下的位置不可到达；因此，只需要找到所有位置可以到达的最低的位置，就可以知道 \\(i\\) 点到达其他任何节点的可达情况。 那么我们应该怎么样实现呢？在竞赛图中，我们将每一条有向边都看作是一对偏序关系，然后使用归并排序，就可以得到一条哈密顿路（所代表的偏序顺序）；这也很好理解：假设我们将所有的节点分成两个部分，它们内部都已经找到了哈密顿路的偏序；那么我们就比较两个部分的最低点——它们之间一定存在偏序关系——找到其中较低的插入待求的偏序中；因为它比接下来的两个部分的最低点都要低，所以可以继续将更低的点插入其中。 在 C++ STL 中，已经有了默认的归并排序的实现 stable_sort，直接调用，并将第一种询问作为排序方式即可完成哈密顿路的求解。显然，这样最多会询问 \\(n\\log_2n\\) 次，对于 \\(n \\leq 100\\) 显然满足小于 \\(9n\\)。 然后，我们维护一个指针 \\(p\\)，指向当前可以到达的最低位置；我们只需要使用第二种询问询问在 \\(p\\) 之前的前缀是否可以包含可以到达的位置，就可以判断是否继续将 \\(p\\) 左移。这样，对于每个前缀位置 \\(p\\)，都会存在一次询问的返回为 1 从而使得 \\(p\\) 左移；对于每个位置 \\(i\\)，都有一次询问返回 0 说明当前的 \\(p\\) 为它可以到达的最低距离，所以询问次数也是满足 \\(2n\\) 的限制的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152bool askTheEdge(int a, int b) &#123; int res = $.put(1, a, b).flush().nextInt(); if (res == -1) exit(EXIT_SUCCESS); else return (bool) res;&#125;bool askEdges(int a, const vector&lt;int&gt; &amp;b) &#123; int res = $.print(2, &#x27; &#x27;, a, &#x27; &#x27;, b.size(), &#x27; &#x27;). putArray(b.begin(), b.end()).flush(). nextInt(); if (res == -1) exit(EXIT_SUCCESS); else return (bool) res;&#125;signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); int T = $.nextInt(), n; bitset&lt;128&gt; g[128]; while (T --) &#123; int n = $.nextInt(); for (int i = 0; i &lt; n; ++ i) g[i].reset(), g[i] = ~g[i]; vector&lt;int&gt; path(n), tmp; iota(path.begin(), path.end(), 0); stable_sort(path.begin(), path.end(), askTheEdge); int p = n - 2; const auto makeTmp = [&amp;](int p) -&gt; vector&lt;int&gt;&amp; &#123; tmp.assign(path.begin(), path.begin() + p + 1); return tmp; &#125;; for (int i = n - 1; i &gt;= 0; -- i) &#123; if (p == i) &#123; for (int j = 0; j &lt;= i; ++ j) for (int k = i + 1; k &lt; n; ++ k) g[path[k]][path[j]] = false; -- p; &#125; while (askEdges(path[i], makeTmp(p))) -- p; &#125; $.put(3).putArray(0, n, [&amp;](int i, cquery $) &#123; $.putArray(0, n, [&amp;i](int j, cquery $) &#123; $.print(g[i].test(j) ? 1 : 0); &#125;, &quot;&quot;); &#125;, &quot;&quot;).flush(); int res = $.nextInt(); if (-1 == res) exit(EXIT_SUCCESS); &#125; return 0;&#125; 实际上，第二种询问还可以使用缓存减少一定的询问次数，不过优势不明显，也实在没有必要就是了（ 后记 做 C 题的时候，博主也和恰好在旁边的同学 tmc 讨论了为什么会想不出来——得到的回复是只是单纯的对于数论不够敏感，换句话说就是做的少了（）真的得多加注意了== 年轻人的第一个莫队题目竟然是在这样的场合…… 只能说对比就是生产力啊（","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://shiraha.cn/tags/Codeforces/"}]},{"title":"Codeforces Round#715 div.2 回顾","slug":"codeforces-round-715-div2","date":"2021-04-19T18:28:13.000Z","updated":"2021-04-19T18:28:13.000Z","comments":true,"path":"2021/codeforces-round-715-div2/","link":"","permalink":"https://shiraha.cn/2021/codeforces-round-715-div2/","excerpt":"","text":"补题链接：https://codeforces.com/contest/1509 记录 其实本来今天晚上是有一个 Codeforces Round #716 (Div.2) 的；但是因为我盲目确信它的开始时间是传统艺能 22:35，而忽略了它的开始时间和往常不同，所以最后没有打成== 但是也因此，本懒狗可以好好地补完上一场拉跨的不行的 Div2 了。 这一场可以说非常的拉跨，ABC 选手都没有当成；明明才 1700 分的我都能直接俯冲 100 分，只能说使得本菜鸡本就不高的 rating 雪上加霜（）话虽这么说，补完了发现只是自己傻逼……这是不是有点似曾相识？ 题解 A - Average Height 没什么好说的，偶数和奇数分别放在一起就完事了（ 12345678910111213141516171819202122232425262728const int N = 2050;int a[N];signed main() &#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int T = scanner.nextInt(); while (T --) &#123; int n = scanner.nextInt(); for (int i = 1; i &lt;= n; ++ i) a[i] = scanner.nextInt(); vector&lt;int&gt; ans; for (int i = 1; i &lt;= n; ++ i) if (a[i] % 2) ans.push_back(a[i]); for (int i = 1; i &lt;= n; ++ i) if (a[i] % 2 == 0) ans.push_back(a[i]); for (auto ii : ans) print(ii, &#x27; &#x27;); println(); &#125; return 0;&#125; B - TMT Document 也没啥难度，总的来说只要时刻保证前缀的 T 比 M 多，并且保证最后 T 和 M 的比例正确，且每一个 M 的后面都一定出现了一个 T 就可以保证合法性。 12345678910111213141516171819202122232425262728293031323334const int N = 1e5 + 4;char s[N];signed main() &#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int T = scanner.nextInt(), n; while (T --) &#123; scanner(n, s + 1); if (n % 3) &#123; println(&quot;NO&quot;); continue; &#125; int cntT = 0, cntM = 0, close = 0; bool ok = true; for (int i = 1; i &lt;= n; ++ i) &#123; if (s[i] == &#x27;T&#x27;) &#123; ++ cntT; if (close &lt; cntM) ++ close; &#125; else ++ cntM; if (cntM &gt; cntT) ok = false; &#125; if (cntM * 2 != cntT || close &lt; cntM) ok = false; println(ok ? &quot;YES&quot; : &quot;NO&quot;); &#125; return 0;&#125; 说是这么说，可是我还是因为没有长手所以白给一发残疾人竟是我自己（ C - The Sports Festival 给一个长度为 \\(n &lt; 2000\\) 的数组，现在要求你对这个数组进行重排序，使得下列式子的值最小： \\[ \\sum_{i=1}^n\\max_{j=1}^i a_j - \\min_{j=1}^i a_j \\] 要求输出上面式子的最小值。 这个题做的过程可以说是十分丑陋了（）尽显本人菜逼本质 == 本弱鸡甚至能在考虑出了 \\(\\mathcal{O}(n^2)\\) 的贪心的假做法的情况下不自知，甚至还迷之自信的交了一二三四发，只能说是十分地滑稽可笑了。 当然，本题的正确做法也是 \\(\\mathcal{O}(n^2)\\) 的，只不过是比贪心更加合理的多的 DP； 首先，就像我的假做法考虑到的那样：首先对于这个数组排序，然后答案的构造方法一定是从中间的某个位置向两侧发散；考虑 \\(dp_{l..r}\\) 表示当前已经扩散到了区间 \\([l, r]\\) 时，上面的式子的最小值；那么它只有两种转移来源——要不是加入了新的最小值 \\(a_l\\)，又或者是加入了新的最大值 \\(a_r\\)；所以不难得到下面的转移关系： \\[ dp_{l..r} = (a_r - a_l) + \\min(dp_{l+1..r}, dp_{l..r-1}) \\] 那么就可以写出代码通过此题了； 1234567891011121314151617181920const int N = 2060;longs dp[N][N], s[N], n;signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); $(n).nextArray(s + 1, s + 1 + n); sort(s + 1, s + 1 + n); for (int k = 1; k &lt; n; ++ k) for (int l = 1; l &lt;= n; ++ l) if (l + k &gt; n) break; else &#123; int r = l + k; dp[l][r] = s[r] - s[l] + min(dp[l + 1][r], dp[l][r - 1]); &#125; output, dp[1][n], endl; return 0;&#125; 当初辅导某学长机试时，我苦口婆心地说“找到递推关系就是动态规划”的神态还历历在目，结果自己却深陷这样一个简单的 DP 而不自知，为自己的 \\(\\mathcal{O}(n^2)\\) 贪心假做法而沾沾自喜，属实是个小丑（ D - Binary Literature 给你一个长度 \\(n \\leq 10^5\\)，以及三个长度为 \\(2n\\) 的 01 字符串；现在你要构造一个 01 字符串，要求它至少以子序列的方式包含提供的三个字符串中的两个，且长度不能超过 \\(3n\\)；保证这种构造一定是成立的。 首先，考虑两个长度为 \\(2n\\) 的字符串；我们一定可以构造出长度为 \\(4n - L\\) 的满足子序列包含它们的串；其中 \\(L\\) 的含义是这两个字符串的最长公共子串（LCS）。构造方法也非常的简单：对于 LCS 中的 \\(L\\) 个字符，只插入构造的串中一次，其他的字符按照正确的顺序全部插入结果串即可。 但是众所周知，求 LCS 的算法的复杂度是 \\(\\mathcal{O}(n^2)\\) 的，而这个题目显然不允许这样的复杂度；但是因为题目中的字符串是 01 串，所以我们可以利用它的性质来考虑： 01 串中不是 0 就是 1，所以长度为 \\(2n\\) 的 01 串中至少有一个字符出现的次数大于等于 \\(n\\) 因为我们有三个这样的 01 串，所以至少有两个字符串中的某个相同的字符出现次数大于等于 \\(n\\) 综上所述，我们找到这样的两个字符串；将这个字符出现的位置作为 LCS 的字符；然后使用上面的构造方法，就可以构造出长度为 \\(4n - L \\leq 3n\\)，其中 \\(L \\geq n\\) 的目标串了。 在这种思想的基础上，我们还有一种更加优雅的构造方法：首先，维护三个指针，分别指向三个字符串，并且最开始都初始化为指向串首；然后，对于每一个位置，都选择较多的字符加入答案串，并推进对应的指针；这样，当一个字符串已经完全被加入答案串之后，我们假设答案串的长度为 \\(k\\)： 因为有一个长度为 \\(2n\\) 的字符串被完全推入了，所以 \\(k \\geq 2n\\)； 因为每次推入字符都要求了至少两个字符串当前位置为该字符，所以至少消耗了 \\(2k\\) 个字符； 这样，三个字符串总共有 \\(6n\\) 个字符，现在最多剩下 \\(6n - 2k\\) 个字符，分配在两个串中； 这样，其中剩余较少的那个串最多包含 \\(3n - k\\) 个字符； 综上所述，如果我们将那个剩余最少的字符串完全推入答案串，那么答案串至少会包含这两个已经压入的字符串作为子序列，并且答案串的长度最大为 \\(k + 3n - k = 3n\\)，符合题意； 12345678910111213141516171819202122232425262728293031323334const int N = 1e5 + 5;char a[N * 2], b[N * 2], c[N * 2];char ans[N * 3];signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); int T = $.nextInt(), n, p; const auto concat = [&amp;](char *aa, char *bb) &#123; const auto na = strlen(aa), nb = strlen(bb); strcpy(ans + p, na &lt; nb ? aa : bb); &#125;; while (T --) &#123; $(n, a, b, c); const int n2 = n * 2; auto ae = a + n2, be = b + n2, ce = c + n2; auto pa = a, pb = b, pc = c; p = 0; while (pa != ae &amp;&amp; pb != be &amp;&amp; pc != ce) &#123; int cnt1 = *pa + *pb + *pc - &#x27;0&#x27; * 3; int ch = (cnt1 &gt;= 2) + &#x27;0&#x27;; pa += (ch == *pa), pb += (ch == *pb), pc += (ch == *pc); ans[p ++] = (char) ch; &#125; if (pa == ae) concat(pb, pc); else if (pb == be) concat(pa, pc); else concat(pa, pb); $.println(ans); &#125; return 0;&#125; 其实真要说的话，我觉得在知道 LCS 是哪些位置的情况下构造这样一个串还挺……不好写的；至少写出来大概都不会太好看；更何况还要使用那个 \\(\\mathcal{O}(n^2)\\) 的 DP 求出 LCS 的位置；实际上的写法只能说是很高妙了（ E - Almost Sorted 现在定义差不多有序的排序指对于任意下标 \\(i\\)，都满足 \\(p_{i+1} \\geq p_i - 1\\)；现在给长度为 \\(n\\) 的初始排列（即字典序最小的排列 \\(1\\dots n\\)，要求求出字典序第 \\(k\\) 小的差不多有序的排序； 这题我从最开始就没往正确的地儿想；我最开始想要打表找规律，但是实际上我想找的那个规律可以说是显然的，但是更高级的规律可以说打表什么也看不出来…… zcysky 提示我要画树我也没领会他的意思，盲目地漫无目的地思考了一会就缴械投降了，看到题解才发现是真的高： 首先，我们要正确的理解题目的定义：差不多有序的排序，如果出现了下降的情况，定义只允许步长为 1 的递减；所以，一个差不多有序的序列可以被表示为多个公差为 1 的递减区块；而且，我们可以用反证法证明——一旦确定了序列的递减区块的划分方法，那么这个序列是唯一的——且是初始排列按照这个划分方式划分之后，将每一个区间都翻转得到的序列。 那么接下来我们考虑 \\(k\\)-大问题：因为每个区块都是由初始排序倒转区块得到的，所以我们可以贪心的考虑，第一个区块的大小越小，那么处理后得到的序列最小；同时，再确定了第一个区块的长度之后，我们将它从原排序中移除，那么就得到了一个长度缩小的子问题；我们可以递归地处理这个问题。 然后，我们考虑对于长度为 \\(n\\) 的排序，差不多有序的序列数量：假设我们现在有一个和这个排序等长的 01 序列，且初始它的每一位都已经置零；对于每一个划分后的区块 \\([l, r]\\)，我们将 \\(l\\) 位置为 1；那么可以看到除了第 0 位必须为 1，其他的每一位都可以为 1/0；因此，一共有 \\(2^{n-1}\\) 种不同的差不多有序的序列。 至此，我们已经可以使用上面说的递归的方法来求解本题了；但是实际上还有一种更加优秀的构造方法： 考虑上面说的标记 01 序列的方法：首先我们将上面的 01 序列看作一个二进制数；并且翻转下标的对应关系——让更小的下标对应更高的位；然后改为标记右边界，即区块中最低的位；然后翻转标记方法：即初值为 1，标记的位为 0；这样就可以得到满足上面所有约束；第 \\(k\\) 小的排列就是 \\(k-1\\) 的二进制表示左移 1 位（最低位始终为 0）对应的二进制表示所代表的划分方式；我们根据它构造答案即可。 123456789101112131415161718192021222324252627282930313233343536const int N = 1e5 + 5;int a[N], tmp[N];lll fact[N];bitset&lt;N&gt; x;signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); longs T = $.nextInt(), n, k; while (T --) &#123; input, n, k; if (n &lt; 128) &#123; lll cnt = 1; cnt &lt;&lt;= uint(n - 1); if (k &gt; cnt) &#123; output, -1, endl; continue; &#125; &#125; else x.reset(); x = k - 1, x &lt;&lt;= 1; iota(a, a + n, 1); reverse(a, a + n); for (int i = 0; i &lt; n; ++ i) if (!x.test(i)) &#123; int j = i + 1; while (j &lt; n &amp;&amp; x.test(j)) ++ j; reverse(a + i, a + j); i = j - 1; &#125; reverse(a, a + n); $.putArray(a, a + n); &#125; return 0;&#125; 非常地巧妙；不管是证明了划分和排列的对应性还是划分和二进制表示的对应性都非常的巧妙（）这不比你最开始考虑的先映射 \\(k\\) 和排序的关系，再用康托展开要阳间多了？更何况康托展开是 \\(\\mathcal{O}(n^2)\\) 的呢！ F - Complete the MST 现在给你一个有 \\(n \\leq 2 \\cdot 10^5\\) 的节点的无向完全图；其中有 \\(m\\) 条连边已经有权值（保证这部分的边的数量不超过 \\(2 \\cdot 10^5\\)），部分边没有权值（保证至少有一条边没有权值）；现在要求你为这些没有权值的边赋非负值的权值，并且整张图所有边的权值异或和为 \\(0\\)，且图的 MST 的权值和最少。 看起来麻烦的一匹实际上也麻烦的一匹，首先进行一些思考：首先，我们一定最多只给一条边赋非零值——因为把它拆分给多条边完全没有任何好处；然后，MST 肯定是尽可能的用没有权值的边——因为如果条件允许，我们可以把我们选作 MST 的边全部赋值为 0；其次，我们赋值的那条边的权值，一定是所有有权值的边的权值的异或和。 那么，我们可以通过下面的过程来求解： 首先，考虑在空边构成的图上 DFS，以求出仅使用空边可以维系的连通块； 如果在选出这些边之后仍有未使用的空边，那么我们可以把异或和赋给它：这样对权值和无贡献； 否则，我们先暂记异或和，作为将要赋给某条空边的值； 然后，我们考虑使用 MST 算法，使用实边将第一步求出的连通块连成一个生成树； 如果一条实边不能被选入 MST，但是它连接了两个本需要依靠空边连接的连通块，那么： 如果这条边的权值比将要赋值给空边的权值要少，那么我们可以将空边赋给这条边，并取代它； 否则，那么还是维持原判，忽略这条边； 实际上，这个取代的过程可以通过缩小这个待赋值空边权值代销来实现。 这样，我们就可以使用我们的思考，构造出这个题目的答案虽然有些过程显得非常玄学就是了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const int N = 2e5 + 5;set&lt;int&gt; disc, adj[N];signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); int n, m, u, v, w; input, n, m; auto res = (longs) n * (n - 1) / 2 - m; for (int i = 1; i &lt;= n; ++i) disc.insert(i); ya_dsu all(n + 1), real(n + 1); vector&lt;tuple&lt;int, int, int&gt;&gt; edge; const function&lt;void(int)&gt; dfs = [&amp;](int u) &#123; disc.erase(u); for (int v = 0;;) &#123; auto it = disc.lower_bound(v); if (it == disc.end()) return; else v = *it; if (!adj[u].count(v)) &#123; all.connect(u, v); dfs(v), --res; &#125; ++v; &#125; &#125;; uint xs = 0; while (m--) &#123; input, u, v, w; adj[u].insert(v), adj[v].insert(u); edge.emplace_back(w, u, v); xs ^= (uint) w; &#125; for (int i = 1; i &lt;= n; ++i) if (disc.count(i)) dfs(i); if (res &gt; 0) xs = 0; sort(edge.begin(), edge.end()); longs ans = 0; for (auto[w, u, v] : edge) &#123; if (all.connect(u, v)) &#123; ans += w; real.connect(u, v); &#125; else if (real.connect(u, v)) minimize(xs, (uint)w); &#125; output, ans + xs, endl; return 0;&#125; 这个 DFS 就显得尤其离谱……在 \\(n = \\sqrt{N}\\) 的准完全图里，它最坏的情况下会跑掉 \\(\\mathcal{\\Theta}(n^2\\log n)\\)，在其他的情况下我甚至都无法分析它的复杂度（算法设计课全还给院长了），但是就是可以过，所以…… 等我会证明它的复杂度的时候再补充说明把（ 此外还值得一提的就是它的标程提供了一种优雅的路径压缩+按秩合并的并查集实现： 123456789101112131415161718192021222324class ya_dsu &#123; vector&lt;int&gt; fa; void join(int u, int v) &#123; if (fa[u] &gt; fa[v]) swap(u, v); fa[u] += fa[v], fa[v] = u; &#125;public: explicit ya_dsu(int n) : fa(n, -1) &#123;&#125; void clear() &#123; fill(fa.begin(), fa.end(), -1); &#125; int id(int u) &#123; return fa[u] &lt; 0 ? u : fa[u] = id(fa[u]); &#125; bool connect(int u, int v) &#123; u = id(u), v = id(v); if (u == v) return false; else return join(u, v), true; &#125; int size(int u) &#123; return -fa[id(u)]; &#125;&#125;; 简单的说就是那个数组非根节点记录根节点的编号，而根节点为负数，且绝对值等于连通块的大小；比起我之前的经典实现节约了一个 siz 数组的大小，本彩笔惊为天人，高，实在是高（ 后记 这周，准确地说应该是上周，因为各种各样的事情——比如博客的花里胡哨啊等等——导致了我在考研复习和训练上投入的时间大幅减少；这是一个危险的信号，这周需要尽量避免。 欲辩已忘言，，明明在开始写这篇文章的时候还是感觉有好多的废话想要说的，，但是现在却对着窗口发呆，一句话也说不出来…… 唉，四点了，今天的墨墨背单词的卡又打不成了（）……因为实在是太晚了所以就不再多说些啥了，早点休息力 == 最后送给自己一句话： 自分の光になれ！ 没有任何的典故，只是想对自己这么说而已——","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://shiraha.cn/tags/Codeforces/"}]},{"title":"使用 pandoc 正确渲染多行 MathJax 公式","slug":"use-pandoc-to-render-multiline-formulas-correctly","date":"2021-04-18T08:04:03.000Z","updated":"2021-04-18T08:04:03.000Z","comments":true,"path":"2021/use-pandoc-to-render-multiline-formulas-correctly/","link":"","permalink":"https://shiraha.cn/2021/use-pandoc-to-render-multiline-formulas-correctly/","excerpt":"","text":"随着 Hexo 的发展，有越来越多的小伙伴使用 Hexo 搭建技术博客，其中不乏大量包含数学公式的场合：为了满足这种需要，一般是在 Markdown 中使用部分 \\(\\LaTeX\\) 语法书写数学公式，Hexo 也支持使用 Mathjax 渲染这些公式；本是一件很舒服的事情，但是当编写多行公式的时候，会发现渲染出现错误： 比如下面的数学公式： 12345678910111213\\begin&#123;bmatrix&#125; 1 &amp; x_0 &amp; x_0^2 &amp; \\cdots &amp; x_0^n \\\\ 1 &amp; x_1 &amp; x_1^2 &amp; \\cdots &amp; x_1^n \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 1 &amp; x_n &amp; x_n^2 &amp; \\cdots &amp; x_n^n \\end&#123;bmatrix&#125;\\begin&#123;bmatrix&#125; a_0 \\\\ a_1 \\\\ \\vdots \\\\ a_n\\end&#123;bmatrix&#125;=\\begin&#123;bmatrix&#125; y_0 \\\\ y_1 \\\\ \\vdots \\\\ y_n\\end&#123;bmatrix&#125; 是一个和范德蒙矩阵相关的算式；它正确渲染后的样子应该是这样的： \\[ \\begin{bmatrix} 1 &amp; x_0 &amp; x_0^2 &amp; \\cdots &amp; x_0^n \\\\ 1 &amp; x_1 &amp; x_1^2 &amp; \\cdots &amp; x_1^n \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 1 &amp; x_n &amp; x_n^2 &amp; \\cdots &amp; x_n^n \\end{bmatrix} \\begin{bmatrix} a_0 \\\\ a_1 \\\\ \\vdots \\\\ a_n \\end{bmatrix} = \\begin{bmatrix} y_0 \\\\ y_1 \\\\ \\vdots \\\\ y_n \\end{bmatrix} \\] 但是实际上，渲染出来的结果很有可能是下面这样…… \\[ \\begin{bmatrix} 1 &amp; x_0 &amp; x_0^2 &amp; \\cdots &amp; x_0^n \\ 1 &amp; x_1 &amp; x_1^2 &amp; \\cdots &amp; x_1^n \\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\ 1 &amp; x_n &amp; x_n^2 &amp; \\cdots &amp; x_n^n \\end{bmatrix} \\begin{bmatrix} a_0 \\ a_1 \\ \\vdots \\ a_n \\end{bmatrix} = \\begin{bmatrix} y_0 \\ y_1 \\ \\vdots \\ y_n \\end{bmatrix} \\] 实在是让人头秃（ 原因分析 一般而言，Hexo 是将公式块（被 $ 或者 $$ 包裹）渲染为一个元素，然后在页面中加载 MathJax 的 JS 文件。浏览器加载页面的时候运行 MathJax 读取这些元素中的公式并渲染完成替换的。但是 marked 会优先转义 Markdown 的语法，再考虑数学公式；因此当两者的语法冲突的时候，就会使得最终提供给 MathJax 的公式出现异常，导致渲染错误。 解决方法 既然已经确定了渲染不正确的原因是 hexo-renderer-marked 的原因，那么就可以从这方面入手考虑解决方法了： 修改 Marked.js 源码 因为 Marked.js 会先将下划线 escape 成 &lt;em&gt;，将 \\(LaTeX\\) 中用于换行的 \\\\ 转移成 \\，使得客户端的 MathJax 在渲染的时候无法正确读取公式导致渲染异常。因此，可以修改 nodes_modules 中的 marked 的源代码，或自行发布一个私有的 marked 作为依赖。 在 marked/lib/marked.js 中： 去掉 \\ 的额外转义 将 em 标签对应的符号中，去掉 _ ：因为 markdown 中有 * 可以表示斜体 修改方式如下： 首先删除对于反斜杠的转义 12- escape: /^\\\\([\\\\`*&#123;&#125;\\[\\]()# +\\-.!_&gt;])/,+ escape: /^\\\\([`*&#123;&#125;\\[\\]()# +\\-.!_&gt;])/, 再删除对于 em 的多余的转义： 12- em: /^\\b_((?:[^_]|__)+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,+ em:/^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/, 遗憾地是上述做法并不适合目前较新版本的 Marked.js，所以现在无法使用。如果有新版本的 Marked.js 的修改方法也欢迎分享（ 强行适配渲染规则 因为主要受到影响的是多行公式，所以在需要使用多行公式的时候，使用 \\\\\\\\ 替换 \\\\，就可以保证页面的正常渲染。 但是这样并不能解决关于下划线的渲染问题还是得看脸，而且这样在 Typora 等可以正确渲染的本地环境下，看到的公式之间会有莫名的空行（并不优雅）。 更换渲染引擎（推荐） 既然是渲染引擎的锅，那么换一个渲染引擎就好了；下面列举作者尝试过的一些渲染引擎，并简单介绍一下它们的优缺点： 作者的博客在进行这些尝试的时候使用的主题是 Volantis 的 4.3.1 版本。 hexo-renderer-markdown-it 和 Hexo 默认使用的 hexo-renderer-marked 不同，在博文的 front-matter 不开启 mathjax 的情况下，似乎会先使用 Katex 渲染公式。Katex 会在生成静态文件的过程中就完成数学公式的渲染，而不是在客户端的浏览器中。因此可以获得很棒的加载速度（毕竟在一些性能较差的设备上经常能看见公式半天加载不出来的情况）；但是问题在于 katex 支持的 \\(\\LaTeX\\) 实在是太少了，远远不够用。 一些 Hexo 主题的作者也会基于这个渲染器进行一些修改，作者就没有一一尝试了。 hexo-renderer-kramed 这是一个 hexo-renderer-marked 的分支，也会和 hexo-renderer-marked 产生冲突。本来应该是一个很不错的选项，但是作者在使用它作为渲染引擎后运行 gulp 来最小化 HTML 会报错…… 所以就没有继续尝试了。 hexo-renderer-syzoj-renderer 大佬 Menci 出品，使用她为开源的 SYZOJ 写的 Markdown 渲染器来渲染文章的插件其实使用的还是 markdown-it。优点是渲染行为和 marked 非常类似，且对于 MathJax 的支持和语法容忍度非常高：基本上是你在 Typora 里写的什么样，Hexo 渲染出来的就是什么样特别是对于 SYZOJ 用户，可以说是非常的舒服。 而且，虽然此渲染器使用 MathJax 渲染，但是这个过程也是在后端完成的。因此客户端浏览器的公式渲染速度很快，解决了 MathJax 公式渲染阻塞留白的问题。 但它的缺点就是在某些兼容性上可能有一些微妙的问题：博主使用的主题 Volantis 在开启 Pjax 后，包含数学公式的页面的 Pjax 跳转会失效（Issue #621 · volantis-x/hexo-theme-volantis）；此外，很多主题会对于配置文件里写的字符串在布局的 ejs 文件中调用 markdown() 接口渲染成 Markdown，这个渲染器没有提供这个接口（也就是说，还得保留 hexo-rederer-marked 才可以使得这些部分正常渲染）。 如果你使用的博客主题没有 Pjax，或者和这个渲染器没有什么冲突的话，还是非常推荐使用的。 hexo-renderer-pandoc 目前本博客采取的方案，在客户端使用 mathjax 渲染数学公式。相比于上面的 hexo-renderer-syzoj-renderer 容忍性较差：用来包裹行内公式的 $ 和公式之间不能有空格，否则会渲染失败。此外，它对于一些其他的元素的渲染行为和 hexo-renderer-marked 的行为不同：比如对于 Markdown 图片 ![alt](url)，它们的渲染结果分别如下： 使用 hexo-renderer-marked 的渲染结果： 1&lt;img alt src=&quot;url&quot;&gt; 使用 hexo-renderer-pandoc 的渲染结果： 123456&lt;figure&gt; &lt;img alt src=&quot;url&quot;&gt; &lt;figcaption&gt; alt &lt;/figcaption&gt;&lt;/figure&gt; 此外，另一个显著的问题是：直接写在文本中的链接（没有被 &lt; &gt; 和 []() 包裹的链接）不会被自动加上超链接。 不过这对于 Volantis 而言倒也问题不大：上面这个问题实际上只要外挂一个 CSS 就没什么问题了；至少这样的渲染并不会影响到 z-lazyload 的脚本对于图片的标记。但是对于其他的，按照 hexo-renderer-marked 的渲染行为而设计主题，就可能会产生兼容性问题。 并且，使用 hexo-renderer-pandoc 可以正常渲染配置文件中那些使用 markdown() 渲染的字符串。因此真的可以卸载 hexo-renderer-marked 了！ 另一个问题就是 hexo-renderer-pandoc 的渲染需要依赖本地的 pandoc：Pandoc - Installing pandoc；如果只是本机生成静态文件再上传到服务器 / Github Page 倒也不算是什么问题了，但是如果我们使用自动部署，就需要对原来的部署脚本进行一些修改： Github Action 在编译和部署的命令之前增加安装 Pandoc 的命令： 1234+ - name: Setup Pandoc+ run: |+ wget https://github.com/jgm/pandoc/releases/download/2.10.1/pandoc-2.10.1-1-amd64.deb+ sudo dpkg -i pandoc-2.10.1-1-amd64.deb Vercel 目前无法在 Vercel 上安装 Pandoc，所以无法使用 Vercel 来构建博客的静态文件。 总结 hexo-renderer-syzoj-renderer：如果对 Pjax 没有什么要求，且使用的主题没有兼容性的问题； hexo-renderer-pandoc：兼容性略好，但是无法使用 Vercel 自动构建静态页面； Volantis 的社区里也确实没有说这个相关的文章啊，还是写一篇好了（ 虽然但是，还是希望能够解决这个兼容性问题能用上 hexo-renderer-syzoj-renderer 啊（）用 Pandoc 渲染在各种方面还是有点麻烦了==","categories":[{"name":"折腾记录","slug":"折腾记录","permalink":"https://shiraha.cn/categories/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"水","slug":"水","permalink":"https://shiraha.cn/tags/%E6%B0%B4/"},{"name":"hexo","slug":"hexo","permalink":"https://shiraha.cn/tags/hexo/"},{"name":"废话","slug":"废话","permalink":"https://shiraha.cn/tags/%E5%BA%9F%E8%AF%9D/"}]},{"title":"Codeforces Round#714 div.2 回顾","slug":"codeforces-round-714-div2","date":"2021-04-12T04:58:33.000Z","updated":"2021-04-12T04:58:33.000Z","comments":true,"path":"2021/codeforces-round-714-div2/","link":"","permalink":"https://shiraha.cn/2021/codeforces-round-714-div2/","excerpt":"","text":"补题链接：https://codeforces.com/contest/1513 记录 总算是最后勉勉强强地成为了 ABCD 选手，，但是因为失明不长脑子以及没有手等众多因素，导致我这场比赛的罚时高的离谱，，四个题都会做甚至排名 500+（ 当然，这场的题目比昨天发的那篇文章的那套题还要水的多，，只能说…什么也说不出（ S3DP4B0L_1J2VG8J0_7_W.jpg 然后吃午饭的时候看一 20 级学弟在群里装杯，一查 CF 结果昨天这场他做了五个题，罚时也把我吊起来打……老年人的眼泪不争气地掉了下来（ 题解 A - Array and Peaks 没什么好说的，由手就行，没手也行（ 12345678910111213141516171819202122232425const int N = 110;int a[N];signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); int T = $.nextInt(), n, k; while (T --) &#123; input, n, k; if (k &gt; (n - 1) / 2) output, -1, endl; else &#123; memset(a, 0, sizeof a); for (int i = 0; i &lt; k; ++ i) a[i * 2 + 2] = n - i; int cur = 0; for (int i = 1; i &lt;= n; ++ i) if (!a[i]) a[i] = ++ cur; $.putArray(a + 1, a + 1 + n); &#125; &#125; return 0;&#125; B - AND Sequences 显然，考虑极端情况 \\(a_1 \\&amp; a_2 \\&amp; \\cdots \\&amp; a_{n - 1} = a_n\\) 是成立的，那么显然有 \\(\\&amp;_{i = 1}^n a_i = a_n\\)；同理也可以证明 \\(\\&amp;_{i = 1}^n a_i = a_1\\)；因此只需要先对数组求按位与的和，然后查找这个数字在数组里出现的次数；从中选择两个放在头尾，剩下的数字放在中间随便摆。 很简单的一个题，思路也很清晰…… 123456789101112131415161718192021222324252627const int N = 2e5 + 5;const int mod = 1e9 + 7;int a[N], fact[N];signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); fact[0] = fact[1] = 1; for (longs i = 2; i &lt; N; ++ i) fact[i] = int(fact[i - 1] * i % mod); int T = $.nextInt(), n; while (T --) &#123; $(n).nextArray(a + 1, a + 1 + n); uint mask = ~0u; for (int i = 1; i &lt;= n; ++ i) mask &amp;= (uint) a[i]; longs cnt = 0; for (int i = 1; i &lt;= n; ++ i) if (mask == a[i]) ++ cnt; cnt = cnt * (cnt - 1) % mod; output, cnt * fact[n - 2] % mod, endl; &#125; return 0;&#125; 本来应该是这样的，，但是因为我最开始预处理的时候没有赋值 fact[0] = 1，导致我 WA 的生活不能自理直接放弃，直到最后面才意识到这个问题的，，，我是傻逼嘛（ C - Add One 显然，对于一个具体的数字，我们进行 \\(n\\) 次变换的结果时独立确定的，也可以表现为 10 个数字的个数。因为变换的上线也只有 \\(2 \\times 10^5\\) 级别，所以完全可以预处理后，对于具体的数字变形后查询得到答案： 123456789101112131415161718192021222324252627282930313233343536373839404142434445const int mod = 1e9 + 7;const int N = 2e5 + 5;int dp[10][N], f[10][10], tmp[10], cnt[10];char s[100];int transfer(int id) &#123; memset(tmp, 0, sizeof tmp); for (int i = 0; i &lt; 9; ++ i) tmp[i + 1] = f[id][i]; tmp[1] += f[id][9], tmp[0] += f[id][9]; tmp[1] %= mod, tmp[0] %= mod; longs ret = 0; for (auto i : tmp) ret += i; memcpy(f[id], tmp, sizeof tmp); return int(ret %= mod);&#125;signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); for (int i = 0; i &lt; 10; ++ i) f[i][i] = dp[i][0] = 1; for (int i = 1; i &lt; N; ++ i) for (int j = 0; j &lt; 10; ++ j) dp[j][i] = transfer(j); int T = $.nextInt(), n, m; while (T --) &#123; input, n, m; longs ans = 0; itoa(n, s, 10); char *st = s; memset(cnt, 0, sizeof cnt); while (*st) ++ cnt[*st - &#x27;0&#x27;], st ++; for (int i = 0; i &lt; 10; ++ i) &#123; ans += 1ll * dp[i][m] * cnt[i]; ans %= mod; &#125; output, ans, endl; &#125; return 0;&#125; 显然，我这样写还是有点蠢的：实际上并不需要枚举每一个数字的变换，只需要枚举 0 的变换即可。 D - GCD and MST 一张图，有 \\(n\\) 个节点，每个点都有权值 \\(a_i\\)；相邻节点之间连接了权值为 \\(p\\) 的边（共 \\(n - 1\\) 条）；此外，对于下标 \\(i\\) 和 \\(j\\) 即 \\(1 \\leq i &lt; j \\leq n\\)，如果满足 \\(\\gcd_{k = i}^j a_k = \\min_{k = i}^j a_k\\)，则 \\(i \\leftrightarrow j\\) 之间连接一条权重为 \\(\\min_{k = i}^j a_k\\) 的边； 现在要求求出这张图的最小生成树的边权值之和。 看到最小值，就联想到要考虑最小值的区间；先对于 \\(a[i]\\) 排序，然后对于每个最小值，向左向右尝试找到包含这个最小值的连续区间；显然，这个连续区间中的每一个节点都可以互相连接边权为这个最小值的边；对于长度为 \\(l\\) 的这样的区间，我们只需要连接 \\(l - 1\\) 条这样的边即可。 这样虽然解决了最小值区间内的问题，但是最小值区间之间也可能连边；所以最小值探边界的时候，如果遇到了已经被之前的（更小的）最小值占领的区间，仍需要额外考虑一次来判断是否可以连边来连接两个区间。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const int N = 2e5 + 5;int a[N], vis[N];signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); int T = $.nextInt(), n, p; memset(vis, -1, sizeof vis); priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;&gt;&gt; heap; while (T --) &#123; $(n, p).nextArray(a + 1, a + n + 1); while (!heap.empty()) heap.pop(); for (int i = 1; i &lt;= n; ++ i) heap.emplace(a[i], i); int res = n - 1; longs ans = 0; while (!heap.empty()) &#123; auto [x, ii] = heap.top(); if (x &gt;= p) break; else heap.pop(); if (vis[ii] == T) continue; else vis[ii] = T; int g = x, l = ii - 1, r = ii + 1; while (l &gt; 0) &#123; auto gg = gcd(x, a[l]); if (gg == g) &#123; if (vis[l] == T) &#123; -- l; break; &#125; else vis[l --] = T; &#125; else break; &#125; while (r &lt;= n) &#123; auto gg = gcd(x, a[r]); if (gg == g) &#123; if (vis[r] == T) &#123; ++ r; break; &#125; else vis[r ++] = T; &#125; else break; &#125; ans += longs(r - l - 2) * x; res -= r - l - 2; &#125; ans += 1ll * res * p; output, ans, endl; &#125; return 0;&#125; 想通了实际上也就这么一回事，但是我却还是白给了两发…… 因为我认为我的手会敲出和我脑子想象中一样的代码，但是实际上手没有，，导致我一度以为我想错了开始胡思乱想，，还是菜的离谱了点（ E - Cost Equilibrium 有一个长度为 \\(n\\) 的数组，每个位置都有值 \\(a_i\\)；现在你可以花费 \\(x \\cdot |i - j|\\) 的成本，使得 \\(a_i\\) 减少 \\(x\\) 并使得 \\(a_j\\) 增加 \\(x\\)，操作中不能有任何值变为负数；每个点只能进行一类操作（减少操作和增加操作不能出现在同一个节点上）；将数组中的所有值全部变为相等而进行的操作带来的成本和定义为数组的成本。 现在要求你重新排列数组，使得数组的成本的最小值和最大值相等。求出这样重新排列后的数组的个数。 题目一通花里胡哨完了之后实际上没啥内容；首先排除 \\(\\sum a_i \\mod n \\neq 0\\) 的情况。那么剩下来的情况就都满足 \\(n \\ | \\sum a_i\\)；令 \\(x = \\sum a_i \\div n\\)。 然后考虑：因为每个节点只能承担一种角色，所以 \\(a_i &gt; x\\) 的节点只能是出点，\\(a_i &lt; x\\) 的节点只能是入点 \\(a_i \\neq x\\) 的节点不能参与任何操作 失明的我一开始把这个限制条件看成了每个节点只能运入一次运出一次，然后鼓捣了个假做法，发现和题解完全不同但是过了样例，要是比赛中这样那我大概也是个假人了，不过似乎可以出个新题（？） 我们记小于平均值的节点的数量为 \\(l\\)，大于平均值的节点数量为 \\(g\\)；那么可以进行下面的猜想： \\(l = 0\\) 并且 \\(g = 0\\)：显然，全数组已经相同，只有 \\(1\\) 种排列满足要求 \\(l = 1\\) 或 \\(g = 1\\)：出点/入点是确定的，所以运输方案只有一种；任何排列都满足要求 否则：出点们和入点们分布在数组的两侧且互不相交时才可以满足要求 关于第三条，很显然如果出入点之间产生了交错，那么中间节点的运输方向的改变会影响到答案。 又因为输出的是重排后的序列的种类数，所以在直接求排列数之后需要特殊处理出现了相同数字的位置：将它们的排列数从总的排列数中除掉；而等于平均值插入到排序中可以使用组合数求出。 补题代码 因为涉及到了排列组合，并且是模意义下运算，所以需要预处理阶乘和阶乘的逆元。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374const int N = 1e5 + 5;const int mod = 1e9 + 7;int a[N], n, fact[N], inv[N];namespace Inverse &#123; longs fastPow(longs a, longs b, longs mod) &#123; longs ans = 1; while (b) &#123; if (b &amp; 1u) ans = (ans * a) % mod; a = (a * a) % mod; b &gt;&gt;= 1u; &#125; return ans % mod; &#125; longs inverse(longs a, longs p) &#123; if (a &gt; p || a &lt;= 0) return -1; else if (a == 1 &amp;&amp; p) return 1; else return fastPow(a, p - 2, p) % p; &#125;&#125;signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); fact[0] = fact[1] = 1; for (longs i = 2; i &lt; N; ++i) fact[i] = int(fact[i - 1] * i % mod); inv[N - 1] = (int)Inverse::inverse(fact[N - 1], mod); for (longs i = N - 2; i &gt;= 0; --i) inv[i] = (int)(inv[i + 1] * (i + 1) % mod); const auto nCr = [](int a, int b) &#123; if (b &lt; 0 || b &gt; a) return 0; longs ret = fact[a]; ret = (ret * inv[a - b]) % mod; ret = (ret * inv[b]) % mod; return (int)ret; &#125;; $(n).nextArray(a + 1, a + 1 + n); lll sum = accumulate(a + 1, a + 1 + n, (lll) 0); if (sum % n) &#123; output, 0, endl; return 0; &#125; auto x = sum / n; int less = 0, greater = 0, equal = 0; unordered_map&lt;int, int&gt; cnt; cnt.reserve(N * 2); for (int i = 1; i &lt;= n; ++i) ++cnt[a[i]]; for (int i = 1; i &lt;= n; ++i) if (a[i] &gt; x) ++greater; else if (a[i] &lt; x) ++less; else ++equal; if (!less &amp;&amp; !greater) &#123; output, 1, endl; &#125; else if (less == 1 || greater == 1) &#123; lll ans = fact[n]; for (auto [k, v] : cnt) ans = (ans * inv[v]) % mod; output, ans, endl; &#125; else &#123; auto ans = (lll)fact[less] * fact[greater] % mod; for (auto [k, v] : cnt) if (k != x) ans = (ans * inv[v]) % mod; ans *= 2, ans %= mod; ans = (ans * nCr(n, equal)) % mod; output, ans, endl; &#125; return 0;&#125; 因为最开始没有特判全数组相等的情况，所以白给了一发（ F - Swapping Problem 现在你有两个长度为 \\(n\\) 的数组 \\(a\\) 和 \\(b\\)；数组的权值之和是 \\(\\sum|a_i - b_i|\\)；你现在可以进行最多 1 次的交换：将 \\(b\\) 中的两个数字交换位置；问可以求得的最小权值是多少。 对于每个位置 \\(i\\)，我们可以将它看作一个区间；那么权值和就是所有的区间大小的和。我们能做的是交换其中某两个区间的特定端点，从而使得总区间大小变小。要想实现这种交换，我们交换的两个端点在对应的区间中的角色必须不同（显然，如果角色相同，交换了没有任何意义）； 而进行简单的推导我们可以得出猜想：交换了两个在对应区间中角色不同的端点，带来的贡献是两个区间重复部分的 2 倍；如果两个区间没有重叠，那么就会造成两个区间间隔的两倍的负贡献。因此，我们只要找到来自两个部分的，且有最大覆盖的区间，就可以求出最小的权值。 我们将所有的区间分成两类：\\(I\\) 类以 \\(a_i\\) 为左端点，而 \\(II\\) 类以 \\(b_i\\) 为左端点；因此，交换的两个区间必须一个来自 \\(I\\)，另一个来自 \\(II\\)；在按照左边界排序之后，维护每组的前缀的最大右边界；这样我们就可以快速的查找对于某个区间而言，可能形成最大覆盖的来自另一组的区间；遍历一组，查找另一组，更新答案即可。 补题代码 当然，这个经典的问题也可以使用双指针来解决，就像下面这样； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152const int N = 2e5 + 5;int a[N], b[N], n;template &lt;typename T&gt;void sortVector(vector&lt;T&gt; &amp;vec) &#123; sort(vec.begin(), vec.end());&#125;signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); $(n).nextArray(a + 1, a + 1 + n) .nextArray(b + 1, b + 1 + n); lll ans = 0, origin = 0, pp = 0; vector&lt;pair&lt;int, int&gt;&gt; I, II; for (int i = 1; i &lt;= n; ++ i) &#123; if (a[i] &lt; b[i]) &#123; I.emplace_back(a[i], b[i]); &#125; else &#123; II.emplace_back(b[i], a[i]); &#125; origin += abs(a[i] - b[i]); &#125; const auto sizI = I.size(), sizII = II.size(); sortVector(I), sortVector(II); priority_queue&lt;int&gt; heap; ans = origin, pp = 0; for (auto [L, R] : I) &#123; while (pp &lt; sizII &amp;&amp; II[pp].first &lt;= L) &#123; heap.push(II[pp].second), ++ pp; &#125; if (!heap.empty()) &#123; auto lastR = heap.top(); minimize(ans, origin - 2 * (min(lastR, R) - L)); &#125; &#125; while (!heap.empty()) heap.pop(); pp = 0; for (auto [L, R] : II) &#123; while (pp &lt; sizI &amp;&amp; I[pp].first &lt;= L) &#123; heap.push(I[pp].second), ++ pp; &#125; if (!heap.empty()) &#123; auto lastR = heap.top(); minimize(ans, origin - 2 * (min(R, lastR) - L)); &#125; &#125; output, ans, endl; return 0;&#125; 老年人光是想着怎么维护这个区间的最大覆盖就想了半个上午，属实不行（ 后记 唉，感觉这一场也没什么难的啊，只可惜前面罚时实在是太多了，，写代码的时候竟然连 \\(0!=1\\) 这种常识性的东西都能不注意，也算是重新认识了自己== 今晚还有 EDU 场，不废话了，好好打啊（","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://shiraha.cn/tags/Codeforces/"}]},{"title":"Codeforces Round#712 div.2 回顾","slug":"codeforces-round-712-div2","date":"2021-04-11T11:31:23.000Z","updated":"2021-04-11T11:31:23.000Z","comments":true,"path":"2021/codeforces-round-712-div2/","link":"","permalink":"https://shiraha.cn/2021/codeforces-round-712-div2/","excerpt":"","text":"补题链接：https://codeforces.com/contest/1504 记录 只能说进入四月一来一直颓的可以，，不仅没怎么训练没怎么准备考研，倒是莫名其妙地出去混了一天又一天，真的是愧对父母，，虽然出了各种各样的事情，但是再怎么说成年人还是应该对自己的行为负责…… 不废话了（ 题目的话，A 白给一发，不过当时带人来 401 玩了，我还没有牛逼到一心二用还能好好写代码（）然后干脆直接 Div1 起步，从 C 开始做；然后做出了 C 和 D（当然，也花了相当的时间）之后就没怎么管了，，再之后（指一个星期之后的今天）补完了所有的题目。 但是听说这场 ABC 蓝名选手是要掉分的，做出了 ABCD 四个题的喜悦瞬间荡然无存，， 题解 A - Déjà Vu 反正就是破坏回文串：最简单的方法就是在前面加或者在后面加；都不行就输出 NO 就完事了（ 123456789101112131415161718192021222324252627282930313233const auto null = nullptr;const int N = 3e5 + 5;char a[N], b[N], c[N];signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); int T = $.nextInt(); while (T --) &#123; input, a; auto n = strlen(a); strcpy(b, a); b[n] = &#x27;a&#x27;, b[n + 1] = &#x27;\\0&#x27;; strcpy(c, b); reverse(c, c + 1 + n); if (strcmp(b, c) != 0) &#123; $.put(&quot;YES&quot;).put(b); continue; &#125; strcpy(b + 1, a); b[0] = &#x27;a&#x27;, b[n + 1] = &#x27;\\0&#x27;; strcpy(c, b); reverse(c, c + 1 + n); if (strcmp(b, c) != 0) &#123; $.put(&quot;YES&quot;).put(b); continue; &#125; else $.put(&quot;NO&quot;); &#125; return 0;&#125; 顺便，这是我第一次使用全新的傻逼快读板子 cquery，IO 交互和以往的代码可能有较大的差距（ B - Flip the Bits 和前缀和很想，可以很容易的想到如果要反转，反转的端点一定要出现在可以翻转的位置上； 本来想着先遍历维护端点，在遍历求区间，在验证区间是否合法的；但是实际上只需要双指针（甚至单个指针）就完事了；代码量远没有我想象的那么大…… 1234567891011121314151617181920212223242526272829303132const auto null = nullptr;const int N = 3e5 + 5;char a[N], b[N];signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); int T = $.nextInt(); while (T --) &#123; int n = $.nextInt(); $(a + 1, b + 1); int cnt0 = 0, cnt1 = 0, ok = 1; for (int i = 1; i &lt;= n; ++ i) &#123; if (a[i] != b[i]) &#123; if (cnt1 != cnt0) &#123; ok = 0; break; &#125; int j = i; while (a[j] != b[j]) &#123; ++ (a[j] == &#x27;1&#x27; ? cnt1 : cnt0); ++ j; &#125; if (cnt1 != cnt0) &#123; ok = 0; break; &#125; else i = j; &#125; ++ (a[i] == &#x27;1&#x27; ? cnt1 : cnt0); &#125; $.put(ok ? &quot;YES&quot; : &quot;NO&quot;); &#125; return 0;&#125; 只能说写代码还是写少了，，惭愧惭愧（ C - Balance the Bits 给一个 01 字符串：现在你要构造两个等长的括号序列，要求字符串为 0 的位置两个序列的括号不同，为 1 的位置相同；输出一种构造或者声明这是不可能的。 显然，0 和 1 的位置必须都是偶数个，并且两端的数字都为 1；否则显然不行。 现在分开考虑 0 和 1；0 本身构成的序列一定是一个合理的序列，但是要求翻转之后也要成立；为了避免麻烦的括号嵌套，只能构造为 ()()()... 的序列了；这样翻转之后的 )()()(... 也可以和两端为 1 的位置匹配。 同样还是为了解决麻烦的括号嵌套问题：因为 0 位置翻转之后可能会造成不必要的闭括号，所以考虑尽量提高嵌套层数；构造为 ...((()))... 的形式可以达到这个目标；至此，我们得到了一种构造方法； 1234567891011121314151617181920212223242526272829303132333435363738const int N = 2e5 + 5;char s[N], ans[N];signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int T = scanner.nextInt(); while (T --) &#123; int n = scanner.nextInt(); scanner(s); int cnt0 = 0; for (int i = 0; i &lt; n; ++ i) if (s[i] == &#x27;0&#x27;) ++ cnt0; if (cnt0 % 2 || s[0] == &#x27;0&#x27; || s[n - 1] == &#x27;0&#x27;) println(&quot;NO&quot;); else &#123; println(&quot;YES&quot;); int cnt1 = n - cnt0, half = cnt1 / 2; int flag0 = 0, flag1 = 0; for (int i = 0; i &lt; n; ++ i) if (s[i] == &#x27;1&#x27;) ans[i] = flag1 ++ &lt; half ? &#x27;(&#x27; : &#x27;)&#x27;; else ans[i] = flag0 ? &#x27;(&#x27; : &#x27;)&#x27;, flag0 = 1 - flag0; ans[n] = &#x27;\\0&#x27;, println(ans); for (int i = 0; i &lt; n; ++ i) if (s[i] == &#x27;0&#x27;) ans[i] = ans[i] == &#x27;(&#x27; ? &#x27;)&#x27; : &#x27;(&#x27;; println(ans); &#125; &#125; return 0;&#125; 我也不知道怎么证明，，题解也什么都没有说清楚……只能说想到了就是想到了（ D - 3-Coloring 有 \\(n \\times n\\) 的棋盘和三种颜料；提供一个长度为 \\(n^2\\) 操作序列，对于每个操作，你可以将任意一个没有染色的格子染色为提供的颜色之外的颜色；要求染色完成后没有任何四联通的两个位置同色，过程强制在线。 没长眼睛的我一开始看成了必须染色为提供的颜色；然后白乎了半天证明了这个问题是无解的——还好我后来又重新读题了== 将两种指示归因为一种颜色，另一个指示归因为另一个颜色，然后交叉的填即可——如果有一种颜色先填满，那么这个指令就以另一种颜色填入另一组位置即可；显然，这样是合理的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int n, b, x, y, a; cin &gt;&gt; n; const int t = n * n; int T = t; queue&lt;pair&lt;int, int&gt;&gt; pos1, pos2; for (int i = 1; i &lt;= n; ++ i) for (int j = 1; j &lt;= n; ++ j) ((i + j) % 2 ? pos2 : pos1).emplace(i, j); while (T --) &#123; cin &gt;&gt; a; switch (a) &#123; case 1: if (!pos2.empty()) x = pos2.front().first, y = pos2.front().second, b = 2, pos2.pop(); else x = pos1.front().first, y = pos1.front().second, b = 3, pos1.pop(); break; case 2: if (!pos1.empty()) x = pos1.front().first, y = pos1.front().second, b = 1, pos1.pop(); else x = pos2.front().first, y = pos2.front().second, b = 3, pos2.pop(); break; case 3: if (!pos1.empty()) x = pos1.front().first, y = pos1.front().second, b = 1, pos1.pop(); else x = pos2.front().first, y = pos2.front().second, b = 2, pos2.pop(); break; default: break; &#125; cout &lt;&lt; b &lt;&lt; &#x27; &#x27; &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; y &lt;&lt; endl; &#125; return 0;&#125; 愿天堂没有失明🙏 E - Travelling Salesman Problem 有 \\(n\\) 个城市，每个城市有一个美丽值 \\(a_i\\) 和起步价 \\(c_i\\)，初始在 \\(1\\) 号城市；现在我们要到达所有的 \\(n\\) 个城市一次后返回 \\(1\\) 号城市；路途 \\(i \\to j\\) 的花费是 \\(\\max(c_i, a_j - a_i)\\)，求出达成目标的最少花费。 从哪个城市出发无所谓的，因为路程是一个环；考虑这个起步价是一条路途出边决定的，而我们确定要从每个城市出去一次，所以这笔钱省不了；问题就在如何最小化额外花费；考虑路途 \\(i \\to j\\) 的额外花费，我们不难得到： \\[ \\max(c_i, a_j - a_i) = c_i + \\max(0, a_j - a_i - c_i) \\] 显然，我们可以把美丽值看作是海拔：这样下坡就是免费的，上坡的话根据起点有所减费。我们的旅途反正是一个环，此时就转变为从最高点俯冲而下，然后再借助某些位置作为减费跳板回到山顶；这样的话会重复访问节点？拜托，俯冲的时候跳过这些节点不就完了，反正又不要钱（ 此时，我们已经可以将这个问题转化为一个最短路问题，建模求解；建图方式如下： 下坡：相邻的位置之间连边，显然免费 上坡：在坡上二分查找，找到最高的可以被减至 0 费的位置 对于这个位置，显然连免费边：定义里都已经这么说了 对于这个位置的更高位置，连边，并用公式计算费用 其实原问题就可以朴素建图解决，但是边数是 \\(O(n^2)\\) 的只能作罢；但是为什么可以这么建图呢？现在对于这个建图方法的合理性进行简单的说明： 下坡的话已经没有什么好说的了，我直接连免费边和从一堆免费边过去有什么区别呢？上坡的话可这么理解：首先上坡肯定是尽量的最大化的利用减费的——但是并不是没有代价：如果你要采用某个点的减费政策，就要放弃看来自更低的位置的减费；而前者未必比后者优。因此这个抉择就可以转化为：对于每个节点的减费政策，我是直接采用还是放弃前面的减费政策。 在前面的减费非常诱人的情况下，可能包含了多个可以免费的上坡位置——但是我们只需要建最高的位置即可：因为其他的位置可以用下坡边回流；但是一定会有一个位置，它可以减费但是无法减至免费：这个位置是关键位置，不可以被其他的边表示，因此也要连边。 综上所述，上述建图就可以完成对原问题的描述；在建图上跑最短路就可以得到答案。 当然，题解还提供了一种更简单的做法，但是相应地也更加的抽象难懂： 就像上面说的那样，下坡已经无所畏惧了，问题就是怎么巧妙利用减费来上坡；因此我们可以对所有节点根据“海拔”排序之后，从底部出发，递推地维护上坡到每个位置之后的最小花费。转化的答案可以描述为下面： \\[ \\sum_{i = 2}^n \\max(0, a_i - \\max_{j&lt;i}(a_j + c_j)) \\] 即维护在更低位置中的最大折扣，到达每个位置的费用都等于到达最大折扣的位置的最少费用加上利用这个折扣跳转到当前位置的费用之和。但是我们毕竟只关注到达顶点的费用，如对于每一个位置都严格的维护这个又显的太过于复杂；所以只需要维护到达每个位置使用可用的最大减费之后的费用和即可。 那么为什么这样是正确的呢？显然，在没有这个减费的情况下，上坡的费用完全就是势能的转化：那个高中物理名词叫啥我忘记了；减费政策就相当于在坡上放倒三角；我们维护的总是当前势能加上减费后能量最高的位置——也就是加上减费后最高的位置。我们爬斜坡需要能量，但是倒三角覆盖的部分不需要能量；因此，我们只需要尽量用倒三角覆盖斜坡，就可以统计得到最小的费用。 补题代码 贪心也得取之有道啊，瞎**贪心是做不出题目的啊（ 1234567891011121314151617181920212223242526272829303132const int N = 1e5 + 5;int a[N], c[N], id[N];bool compare(int l, int r)&#123;return a[l] &lt; a[r];&#125;signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int n = scanner.nextInt(); longs ans = 0; for (int i = 1; i &lt;= n; ++ i) a[i] = scanner.nextInt(), c[i] = scanner.nextInt(), ans += c[i]; iota(id, id + 1 + n, 0); sort(id + 1, id + 1 + n, compare); longs discount = a[id[1]] + c[id[1]]; for (int i = 2, p = id[i]; i &lt;= n; p = id[++ i]) &#123; ans += max(0ll, a[p] - discount); maximize(discount, (longs)a[p] + c[p]); &#125; println(ans); return 0;&#125; 只能说做题的时候还是瞎想多了，， F - Flip the Cards 有 \\(n\\) 张牌，牌的两面写了互不相同的 \\([1, 2n]\\) 的数字；现在你需要对牌进行排序，并翻转部分牌，得到一个新的牌的序列：满足正面的数字递增且反面的数字递减。求出最少的翻转次数或者证明这不可能。 我距离做出这个题的距离还是挺遥远的…… 甚至当晚看题解都没有看懂……菜爆了（ 首先需要意识到有解的套牌必须满足一张牌的两面必须一个属于 \\([1, n]\\) 另一个属于 \\([n+1, 2n]\\)，否则无解；这也很好理解，毕竟我问我的学弟队友，他也是一眼意识到这个只有我这个老东西后知后觉了呜呜 满足了上述限制的套牌，我们先进行翻转，保证正面比反面的数字小，那么就可以桶排序；按照正面数字排序之后的套牌，第 \\(i\\) 张的正面数字是 \\(i\\)，反面的数字记为 \\(f[i]\\)； 首先给出一种确定可以构造出满足题意的排序的构造方法：如果上述的 \\(f[i]\\) 构成的序列，可以拆分成两个递减的子序列，那么可以将拆解得到的两个部分中的一部分翻转后倒序，拼装到另一个部分的后面组成一个满足题意的序列；如果考虑到最少翻转次数，只需要翻转其中翻转成本较低的一组即可。 翻转成本的计算也非常简单：分成的序列中可能包含了一些在桶排序的时候翻转的卡牌，翻转一个序列的成本就是另一个序列中的这些卡牌的数量加上待翻转序列中除此之外的卡牌的数量。 但是问题就是 \\(f[i]\\) 可能有多种分割的方法；而上述翻转的成本中的冗余都是因为有些卡牌可以放到另一个序列中避免翻转或者翻转回来导致的。因此我们有必要进行唯一的最优分解，才能求出这个答案；最优的分解很显然就是每当出现逆序对的时候，考虑翻转的成本，并选择更优的一侧翻转；之后将这些逆序对合并成序列即可。 但是并不是所有的划分都是可以复原的，所以划分时需要加入条件；这里采用的是 \\(f[i]\\) 的前缀最小值大于后缀最大值的时候可以划分；这至少是一个充分的条件，保证翻转之后的序列的两个部分可以嵌套着还原为原序列。 虽然有很多部分还是没有太清楚的明白，但是还是知道了一些事情：我只需要考虑可以构造出最小花费的序列的方法即可，至于有没有别的方法，Who care？当然，必要性还是需要证明的……这我就实在不太懂了（ 补题代码 经典对着标程猜测题解，，逊（ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const int N = 2e5 + 5;pair&lt;int, int&gt; a[N];bitset&lt;N&gt; rev;int f[N], suf[N];signed main() &#123; ios::sync_with_stdio(false); cin.tie(null), cout.tie(null); int n = $.nextInt(); $.nextArray(a + 1, a + 1 + n); bool legal = true; for (int i = 1; i &lt;= n; ++i) &#123; if (a[i].first &gt; a[i].second) &#123; swap(a[i].first, a[i].second); rev.set(a[i].first); &#125; if (a[i].first &gt; n || a[i].second &lt;= n) &#123; legal = false; break; &#125; else f[a[i].first] = a[i].second; &#125; if (!legal) &#123; output, -1, endl; return 0; &#125; else &#123; suf[n + 1] = -1; for (int i = n; i &gt;= 1; -- i) suf[i] = max(f[i], suf[i + 1]); int pref = 0x3f3f3f3f; int cosA = 0, cosB = 0, ans = 0; vector&lt;int&gt; seqA, seqB; for (int i = 1; i &lt;= n; ++ i) &#123; minimize(pref, f[i]); if (seqA.empty() || seqA.back() &gt; f[i]) seqA.push_back(f[i]), cosA += rev[i]; else if (seqB.empty() || seqB.back() &gt; f[i]) seqB.push_back(f[i]), cosB += rev[i]; else &#123; output, -1, endl; return 0; &#125; if (pref &gt; suf[i + 1]) &#123; int sizA = (int)seqA.size(), sizB = (int)seqB.size(); ans += min(cosA + sizB - cosB, cosB + sizA - cosA); cosA = cosB = 0; seqA.clear(), seqB.clear(); &#125; &#125; output, ans, endl; &#125; return 0;&#125; 这甚至还是个 2-SAT 问题，，可以见得乱搞的方法有很多，只是我都不会罢了（ 后记 想到了昨天 zcysky 说过的：Div2 本身已经足够白给了；突然就再次的感觉到——不管是为了什么的努力，重要的是看到成效，而不仅仅是自虐地自我满足。说教别人警惕这种繁荣的幻想的同时，我自己不也是这样吗？ 对于我这种起步晚，学习慢的残疾 ICPCer 而言，更应该是脚踏实地地讲究训练方法效率，做有用的事情才行啊（ YJ_JI1_O_AZV2_HWPA_YQ.jpg 唉，还是且行且珍惜——","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://shiraha.cn/tags/Codeforces/"}]},{"title":"基础知识：FFT - 简单入门","slug":"The-concept-of-fft-introducing-edition","date":"2021-03-29T11:34:35.000Z","updated":"2021-03-29T11:34:35.000Z","comments":true,"path":"2021/The-concept-of-fft-introducing-edition/","link":"","permalink":"https://shiraha.cn/2021/The-concept-of-fft-introducing-edition/","excerpt":"","text":"一句话简介：FFT 即快速傅里叶变换，是一种可以在 \\(n\\log n\\) 的时间内完成多项式乘法的算法——的一部分。 前置知识 在了解 FFT 之前，你可能需要先知道的一些东西： 多项式 对于数域 \\(\\mathbb{F}\\)，若有 \\(\\forall i\\in\\{1,2,3,\\cdots,n \\}\\)，则： \\[ f(x)=a_0+a_1x+a_2x^2+\\cdots+a_nx=\\sum_{i=0}^n a_ix^i \\ (a_n \\neq 0) \\] 为数域 \\(\\mathbb{F}\\) 上的一个多项式；该多项式的次数即为其中最高次项的次数为 \\(n\\)，记作 \\(\\deg f(x) = n\\)； 表示方法 通常有两种表示方法 系数表示法 即上文定义中的表示方法，是一个向量；可以映射为系数向量 \\(\\vec{a}\\)： \\[ f(x) = \\sum_{i = 0}^n a_ix^i ⇔ \\vec{a} = (a_0, a_1, \\cdots ,a_n) \\ (a_n \\neq 0) \\] 我们将向量 \\(\\vec{a}\\) 成为多项式 \\(f(x)\\) 的系数表示。 点值表示法 设 \\(\\deg f(x) = n\\)；众所周知，确定一个 \\(n\\) 次函数的解析式，需要 \\(n + 1\\) 个点的坐标；同理，这样也可以确定一个有 \\(n + 1\\) 个系数的 \\(n\\) 次多项式。 因此，对于 \\(\\forall x_i \\in \\mathbb{F}, i \\in [0, n]\\)，有 \\(y_i = f(x_i)\\)；如果对于 \\(\\forall i \\neq j\\) 总是满足 \\(x_i \\neq x_j\\)，那么我们可以在数域 \\(\\mathbb{F}\\) 中绘制 \\(n+1\\) 个点，获得 \\(n+1\\) 个不同的方程，从而确定这个多项式； 那么，这 \\(n + 1\\) 个不同的点构成的点集，就是多项式的点值表示。 如果将这 \\(n + 1\\) 个不同的点代入表达式中进行运算，可以得到下面的矩阵等式： \\[ \\begin{bmatrix} 1 &amp; x_0 &amp; x_0^2 &amp; \\cdots &amp; x_0^n \\\\ 1 &amp; x_1 &amp; x_1^2 &amp; \\cdots &amp; x_1^n \\\\ \\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\ 1 &amp; x_n &amp; x_n^2 &amp; \\cdots &amp; x_n^n \\end{bmatrix} \\begin{bmatrix} a_0 \\\\ a_1 \\\\ \\vdots \\\\ a_n \\end{bmatrix} = \\begin{bmatrix} y_0 \\\\ y_1 \\\\ \\vdots \\\\ y_n \\end{bmatrix} \\] 我们将最左侧的 \\(n + 1\\) 阶矩阵称为范德蒙矩阵。 那么如何转换多项式的两种表达方式呢？ 系数表达式 =&gt; 点值表达式 这个还是非常的简单的；只需要选取 \\(n + 1\\) 个不同的 \\(x_i\\)，分别带入解析式中求出 \\(y_i\\) 即可。我们假定使用快速幂计算乘方，那么这样做的复杂度就是 \\(O(n^2\\log n)\\) 的。 点值表达式 =&gt; 系数表达式 这个过程又被称为多项式插值；朴素地，我们可以将多项式看作一个 \\(n\\) 次函数，将点值表达中的 \\(n + 1\\) 个点代入其中得到等数目的方程，然后求解这个方程组得到每个系数，组成系数表达式。 形式化地说，我们可以利用范德蒙矩阵进行高斯消元，就可以在 \\(O(n^3)\\) 的时间内求解；但是这样实在是太慢了，时间上无法接受；因此我们也可以用拉格朗日插值法求解： \\[ f(x) = \\sum_{i = 1}^n y_i \\prod_{i = j} \\frac{x-x_j}{x_i-x_j} \\] 这样，我们可以在 \\(O(n^2)\\) 的时间复杂度内完成多项式插值。 虽然但是，我们可以看到想要在这两种形式中转化，一般会消耗大量的时间。 操作 令参与操作的两个多项式为 \\(f(x)\\) 和 \\(g(x)\\)；若 \\(\\deg f(x) \\neq \\deg g(x)\\)，我们可以为其中度数较小的一方增加系数为 \\(0\\) 的高次项，从而使得两个多项式齐次；因此，下面的讨论都仅针对于两个多项式齐次的情况。 此外，如果两个多项式均仅提供点值表示，那么要求提供的点值的横坐标一一对应且相等。 现在假定 \\(\\deg f(x) = \\deg g(x) = n\\)，系数表示分别为 \\(\\vec{a}、\\vec{b}\\)； 加减法 对于系数表示，若 \\(h(x) = f(x) ± g(x)\\)，则有： \\[ h(x) = f(x) ± g(x) = \\sum_{i = 0}^n (a_i ± b_i)x^i \\] 且 \\(h(x)\\) 的系数表示记为 \\(\\vec{c}\\)，那么 \\(c_i = a_i ± b_i\\)； 对于点值表示，只需要将对应的纵坐标相加/相减即可。 乘法（卷积） 同上，对于系数表示，可以得到多项式乘法的定义如下： \\[ h(x) = (f \\cdot g)(x) = f(x) \\times g(x) = \\sum_{i = 0}^n \\sum_{j = 0}^n a_ib_jx^{i + j} \\] 显然，两个 \\(n\\) 次的多项式相乘会得到一个 \\(2n\\) 次的多项式；若 \\(h(x)\\) 的系数表示记为 \\(\\vec{c}\\)，那么也有： \\[ c_i= \\sum_{j+k=i}a_jb_k = \\sum_{j = i}^{n} a_jb_{i - j} \\] 那么系数向量 \\(\\vec{c}\\) 为稀疏向量 \\(\\vec{a}、\\vec{b}\\) 的卷积，记作：\\(\\vec{c} = \\vec{a} ∗ \\vec{b}\\)； 对于点值表示，依然只需要将对应的纵坐标相乘即可；但是因为新得到的多项式次数更高，所以每个因子多项式都需要提供 \\(2n\\) 个点参与运算； 综上所述，我们可以看到：因为多项式运算本质上还是多项式的值进行运算，所以对于点值表示法而言，这些运算都是可以 \\(O(n)\\) 完成的（即仅将对应点值的纵坐标进行运算即可）；唯一需要注意的就是多项式乘法，点值表示法需要提供更多组点值进行运算。 复数 高 等 数 学 和 复 变 函 数 的 完 全 败 北 首先定义虚数单位 \\(i^2 = -1\\)；则所有形如： \\[ z = a + bi, \\ \\ a,b \\in \\mathbb{R} \\] 的数字为复数，它们构成的集合成为复数集，记为 \\(\\mathbb{C}\\)；上面的表达式中，\\(a\\) 被称为实部，\\(b\\) 被称为虚部。 复平面 复平面是一个笛卡尔平面，有两条坐标轴，纵轴为虚轴，横轴为实轴，两轴相互垂直；对于每一个复数 \\(z = a + bi\\)，它都可以在复平面上被表示为一个从原点指向点 \\((a, b)\\) 的向量；显然，复数和复平面上从原点出发的向量之间的映射关系是双射。 和一般向量一样，以实轴正方向为始，\\(\\vec{z}\\) 为终的角 \\(\\theta\\) 称为复数 \\(z\\) 的幅角。 基本操作 模：即复数在复平面上所对应的向量的模，记作 \\(|z|\\)；\\(|z| = \\sqrt {a^2 + b^2}\\) 共轭复数：复数在复平面上所对应的向量关于实轴对称后对应的复数，记为 \\(\\bar{z}\\)； \\(z\\) 和 \\(\\bar{z}\\) 的实部相同，虚部互为相反数 两者的幅角满足：\\(\\theta_{z} + \\theta_{\\bar{z}} = \\pi\\) 两者的模满足：\\(|z| = |\\bar{z}|\\) 运算 令参与运算的两个复数为 \\(z_1 = a_1 + b_1i\\) 和 \\(z_2 = a_2 + b_2i\\)； 加减法：\\(z = z_1 ± z_2\\) \\(z = (a_1 ± a_2) + (b_1 ± b_2)i\\) 对于向量：按照平行四边形定则 乘法：\\(z = z_1 \\times z_2\\) $z = (a_1 + b_1i) (a_2 + b_2i) = $ \\((a_1a_2 - b_1b_2) + (a_1b_2 + a_2b_1)i\\) 对于向量：它们的幅角满足 \\(\\theta_z = \\theta_{z_1} + \\theta_{z_2}\\) 对于向量：它们的模满足 \\(|z| = |z_1| \\times|z_2|\\) 若 \\(z_2 = \\bar{z_1}\\)，那么 \\(z = a_1^2 + b_1^2\\)，显然是一个实数 除法：\\(z = \\frac{z_1}{z_2}\\) 通分 \\(\\bar{z_2}\\)，可以得到：\\(z = \\frac{z_1\\bar{z_2}}{a_2^2 + b_2^2}\\) 显然，分母是实数，所以可以直接除进分子的实部和虚部 指数幂：首先，有欧拉公式 \\(e^{i\\theta} = \\cos\\theta + i\\sin\\theta\\) 在数学分析和复变函数中，欧拉公式是一个把复指数函数与三角函数联系起来的一个公式： \\[ e^{i\\theta} = \\cos\\theta + i\\sin\\theta \\] 这个恒等式就是欧拉公式，它是数学里最令人着迷的一个公式——它将数学里最重要的几个数字联系到了一起： 两个超越数：自然对数的底 \\(e\\)，圆周率 \\(\\pi\\)； 两个单位：虚数单位 \\(i\\) 和自然数的单位 \\(1\\) ； 以及被称为人类伟大发现之一的 \\(0\\)。 它将指数函数的定义域扩大到复数，建立了三角函数和指数函数的关系，被誉为“数学中的天桥”。因此数学家们评价它是“上帝创造的公式”。 任何复数都可以表示为欧拉公式的形式，即： \\[ z = |z|\\cos\\theta_z + i|z|\\sin\\theta_z = |z|e^{i\\theta_z} \\] 特殊值：当 \\(\\theta = \\pi\\) 时，有 \\(e^{i\\pi} = -1\\) 因此，复数的幂只需要将它转化为欧拉公式的形式，然后取幂即可 和多项式一样，复数的运算也需要根据不同的运算在不同的表示形式中反复切换。 单位根 在 \\(\\mathbb{C}\\) 中，满足 \\(x^n = 1\\) 的 \\(x\\) 被称为 \\(n\\) 次单位根；根据代数基本定理可知，\\(n\\) 次单位根共有 \\(n\\) 个，它们分别是： \\[ x_k = e^{i\\frac{2k\\pi}{n}}, \\ k \\in [0, n) \\] 显然，\\(x_k^n = 1\\)；可以用上一节讲到的欧拉公式来证明。 性质 因为 \\(\\sin\\theta + \\cos\\theta = 1\\)，所有的 \\(n\\) 次单位根的模均为 \\(1\\). 在复平面上，\\(n\\) 个 \\(n\\) 次单位根平分了单位圆，且和单位圆的 \\(n\\)-等分线重叠。 本原单位根 定义：\\(0\\) 到 \\((n - 1)\\) 次幂的值能生成全部 \\(n\\) 个 \\(n\\) 次单位根的 \\(n\\) 次单位根称为为 \\(n\\) 次本原单位根。 显然，对于任何 \\(n &gt; 1\\)，\\(x_1 = e^{i\\frac{2\\pi}{n}}\\) 是一个 \\(n\\) 次本原单位根。 特别地，我们记 \\(\\omega_n = e^{i \\frac{2\\pi}{n}} = \\cos \\frac{2\\pi}{n} + i \\sin \\frac{2\\pi}{n}\\) 为 \\(n\\) 次本原单位根；虽然它未必唯一，但是接下来的所有讨论中的“\\(n\\) 次本原单位根”都特指 \\(\\omega_n\\)。 \\(n\\) 次本原单位根 \\(\\omega_n\\) 有一些特殊的运算性质： 折半定理：\\((\\omega_n^k)^2 = \\omega_{\\frac{n}2}^k\\) 令 \\(n\\) 为偶数：\\(\\omega_n^{\\frac{n}2 + k} = -\\omega_n^k\\) 相消定理：\\(\\omega_{dn}^{dk} = \\omega_n^k\\) 求和定理：可以描述为如下公式： \\[ \\sum_{i = 0}^{n - 1} (\\omega_n^k)^i = \\begin{cases} 0, \\ \\ &amp; k \\neq mn \\ , \\ m \\in \\mathbb{Z} \\\\ n, \\ \\ &amp; k = mn \\ , \\ m \\in \\mathbb{Z} \\end{cases} \\] 在 \\(k \\neq mn\\) 的场合下，由于公比不为 \\(1\\)，我们可以用等比数列的求和公式推导： \\[ \\sum_{i = 0}^{n - 1} (\\omega_n^k)^i = \\frac{1 - (\\omega_n^k)^n}{1 - \\omega_n^k} = \\frac{1 - 1}{1 - \\omega_n^k} = 0 \\] 否则，公比为 \\(\\omega_n^k = 1\\)，上述推导并不成立；但由于 \\(\\omega_n^n = \\omega_n^0 = 1\\)，所以上计算结果为 \\(n\\)； 显然，第一个式子是成立的：每份角度扩大一倍，那么可以等分的份数就减为一半，这很合理； 显然，\\(\\omega_n^{\\frac{n}2}\\) 的幅角是 \\(\\pi\\)；由和差角公式可以知道幅角加上 \\(\\pi\\) 意味着正弦和余弦值都变为原来的相反数，所以第二个式子也非常的正确；证毕（ 相消定理也非常的好理解：两边的表达式转化为欧拉公式的形式是一样的。 不会有人真的连高中数学学的三角函数相关变换的忘记了吧？不会这人就是我吧？ 到现在为止，我们已经把必要的前置知识数学基础给介绍完了。 分析过程 根据上面的描述，我们已经知道了对于多项式的系数表示，计算其乘法需要 \\(O(n^2)\\) 的时间；而对于点值表示法，这个运算只需要 \\(O(n)\\) 的时间；但是如果我们想要通过两个多项式的系数表示得到它们乘积的系数表示，我们需要遵循以下的步骤： 求值：将待乘的多项式转化为点值表示，需要 \\(O(n^2)\\) 运算：点值表示多项式乘法，需要 \\(O(n)\\) 插值：将得到的结果转化为系数表示，朴素算法需要 \\(O(n^3)\\)，不低于 \\(O(n^2)\\) 可以看出，如果仅是将多项式转化为点值表示，并不能做到算法复杂度的降低——但是它为我们提供了思路：如果我们能将求值和插值步骤优化到低于 \\(O(n^2)\\)，就可以降低多项式乘法的整体复杂度。 离散傅里叶变换 特别地，现在对上面的步骤进行一些定义： 离散傅里叶变换（DFT）：指求出一个 \\(n - 1\\) 次多项式在每个 \\(n\\) 次单位根下的点值的过程 离散傅里叶逆变换（IDFT）：将上面求出的那些点值重新插值得到系数表示的过程 对于多项式 \\(f(x)\\)，若 \\(\\deg f(x) = n - 1\\)，那么对它进行的 DFT 被称为长度为 \\(n\\) 的离散傅里叶变换，记作 \\(\\text{DFT}_n(f)\\)。 显然，这个操作就是朴素做法，具有 \\(O(n^2)\\) 的时间复杂度；现在我们考虑使用 FFT 优化它。 快速傅里叶变换 现在，我们假设 \\(n\\) 是偶数，且有 \\(m = \\frac{n}2\\)；有多项式 \\(f(x) = \\sum_{i = 0}^{n - 1} a_ix^i\\)，显然 \\(\\deg f(x) = n - 1\\)； 分治 考虑分治：我们对 \\(f(x)\\) 的系数角标按照奇偶性进行分类，可以得到： \\[ \\begin{align} f(x) &amp;= \\sum_{i = 0}^{m - 1} a_{2i}x^{2i} + \\sum_{i = 0}^{m - 1} a_{2i+1}x^{2i+1} \\\\ &amp;= \\sum_{i = 0}^{m - 1} a_{2i}x^{2i} + x(\\sum_{i = 0}^{m - 1} a_{2i+1}x^{2i}) \\\\ &amp;= \\sum_{i = 0}^{m - 1} a_{2i}(x^2)^i + x(\\sum_{i = 0}^{m - 1} a_{2i+1}(x^2)^i) \\end{align} \\] 我们对于前半部分（偶数部分）记作 \\(f_0(x)\\)，后半部分（奇数部分）记为 \\(f_1(x)\\)： \\[ \\begin{align} f_0(x) &amp;= \\sum_{i = 0}^{m - 1} a_{2i}x^i \\\\ f_1(x) &amp;= \\sum_{i = 0}^{m - 1} a_{2i + 1}x^i \\\\ \\end{align} \\] 那么，\\(f(x)\\) 可以被表示为如下形式： \\[ f(x) = f_0(x^2) + x \\cdot f_1(x^2) \\] 如果知道了 \\(f_0(x)\\) 和 \\(f_1(x)\\) 在 \\(n\\) 个不同的位置的值，那么我们只需要计算 \\(O(n)\\) 次上式，就可以得到 \\(f(x)\\) 的点值表示了；然后可以继续递归处理 \\(f_{0/1}\\)； 但是仅仅是这压根是不够的；根据主定理，因为 \\(f_{0/1}\\) 各需要递归一次，所以复杂度还是 \\(O(n^2)\\) 的。 使用单位根 因此，我们考虑代入单位根求 \\(\\text{DFT}_n(f)\\)。根据单位根的性质，我们知道了 \\(\\omega_n^{m + k} = -\\omega_n^k\\)：这提示我们需要考虑小于 \\(m\\) 次的点值和大于等于 \\(m\\) 次的点值之间存在的关系；因此我们以此进行分类讨论： 对于 \\(k \\in [0, m)\\)，我们可以利用单位根的折半定理进行简化，有： \\[ \\begin{align} f(\\omega_n^k) &amp;= f_0((\\omega_n^k)^2) + \\omega_n^k \\cdot f_1((\\omega_n^k)^2) \\\\ &amp;= f_0(\\omega_m^k) + \\omega_n^k \\cdot f_1(\\omega_m^k) \\end{align} \\] 在考虑 \\(k + m \\in [m, n)\\)，我们同样可以利用单位根的性质得到下面的化简： \\[ \\begin{align} f(\\omega_n^{k + m}) &amp;= f_0((\\omega_n^{k + m})^2) + \\omega_n^{k + m} \\cdot f_1((\\omega_n^{k + m})^2) \\\\ &amp;= f_0((-\\omega_n^k)^2) - \\omega_n^k \\cdot f_1((-\\omega_n^k)^2) \\\\ &amp;= f_0((\\omega_n^k)^2) - \\omega_n^k \\cdot f_1((\\omega_n^k)^2) \\\\ &amp;= f_0(\\omega_m^k) - \\omega_n^k \\cdot f_1(\\omega_m^k) \\end{align} \\] 上面的两个式子又被称为蝴蝶操作，式子中的 \\(\\omega_n^k\\) 又被称为旋转因子； 至于叫“蝴蝶操作”这个名字的原因，现在我们可以考虑两层：一层是我们将要求的 \\(f(x)\\)，它的 DFT 长度为 \\(n\\)；另一层是我们已经求好的（或者将要递归去求的）\\(f_{0/1}(x)\\)，它们的 DFT 长度均为 \\(m\\)；对于 \\(f_{0/1}(\\omega_m^k)\\)，它们能影响到的位置只有 \\(f(\\omega_n^k)\\) 和 \\(f(\\omega_n^{k + m})\\)；所以可以画出下面的图： 要不是不会画矢量图，谁愿意iPad手画呢？ 图中实边贡献的权值为 +1，虚边的权值是 -1；结合推导的式子很容易理解，形状也许确实是蝴蝶（ 综上所述，我们可以发现：\\(k \\geq m\\) 部分的值可以在求 \\(k &lt; m\\) 部分的值时一并求出；因此，只要知道了\\(f_0(x)\\) 和 \\(f_1(x)\\) 在小于 \\(m\\) 次位置的值（显然，这是 \\(m = \\frac{n}2\\) 次），就可以在 \\(O(n)\\) 的时间内求出 \\(f(x)\\) 在整全部 \\(n\\) 个位置的值；显然，和朴素做法一样，这个过程也是递归的。 分析算法的时间复杂度：\\(T(n) = T(\\frac{n}2) + O(n)\\)，典型的 \\(O(n\\log n)\\)； 综上所述，得到的快速计算 \\(\\text{DFT}_n(f)\\) 的方法，就被称为 FFT。 插值方法 在上一个部分，我们已经将朴素求值的过程用 FFT 取代，获得了更优的时间复杂度；但是朴素插值的过程仍然是 \\(O(n^2)\\) 的；这个部分将说明朴素 IDFT 的过程，并尝试压缩它的时间复杂度。 离散傅里叶逆变换 问题 有 \\(\\deg f(x) = n - 1\\) 的多项式 \\(f(x)\\) ；已知其点值表示 \\(\\{(x_k, \\ y_k) \\ | \\ k \\in [0, n)\\}\\)；其中： \\[ \\text{DFT:} \\ \\ y_k = \\sum_{i = 0}^{n - 1} a_ix_i \\ , \\ x_i = \\omega_n^{ik} \\] 现在我们要从这个点集反向求出 \\(f(x)\\) 的系数表示 \\(\\vec{a}\\)。 至于这个问题的推导结果，因为我不会推导我们先给出它的结论： \\[ \\text{IDFT:} \\ \\ a_k = \\frac1n \\sum_{i = 0}^{n - 1}y_i\\omega_n^{-ki} \\] 然后我们进行反向推导，来证明它确实是 \\(\\text{DFT}\\) 式子的逆变换： 将 \\(\\text{IDFT}\\) 式子中的 \\(y_i\\) 展开为 \\(\\text{DFT}\\) 式： \\[ \\begin{align} a_k = \\frac1n \\sum_{i = 0}^{n - 1}y_i\\omega_n^{-ki} &amp;= \\frac1n \\sum_{i = 0}^{n - 1}\\sum_{j = 0}^{n - 1} a_j\\omega_n^{ji}\\omega_n^{-ki} \\\\ &amp;= \\frac1n \\sum_{i = 0}^{n - 1}\\sum_{j = 0}^{n - 1} a_j\\omega_n^{i(j - k)} \\\\ &amp;= \\frac1n \\sum_{j = 0}^{n - 1} a_j\\sum_{i = 0}^{n - 1}(\\omega_n^{j - k})^i \\end{align} \\] 现在我们使用单位根的求和定理来考虑等式右侧的 \\(\\sum_{i = 0}^{n - 1}(\\omega_n^{j - k})^i\\)： \\(j = k\\) 时，\\(\\omega_n^{i(j - k)} = \\omega_n^0 = 1\\)，故： \\[ \\sum_{i = 0}^{n - 1}(\\omega_n^{j - k})^i = 1 \\times n = n \\] \\(j \\neq k\\) 时，由求和定理可知： \\[ \\sum_{i = 0}^{n - 1}(\\omega_n^{j - k})^i = 0 \\] 既可以使用消去定理，也可以使用单位根的定义得到这个值为 0； 综上所述，仅当 \\(j = k\\) 时，外侧的求和会对结果产生 \\(n\\) 倍的贡献。 因此，我们可以继续推导第一步我们得到的式子： \\[ \\begin{align} a_k = \\frac1n \\sum_{i = 0}^{n - 1}y_i\\omega_n^{-ki} &amp;= \\frac1n \\sum_{j = 0}^{n - 1} a_j\\sum_{i = 0}^{n - 1}(\\omega_n^{j - k})^i \\\\ &amp;= \\frac1n a_k \\times n \\end{align} \\] 显然，等式的两侧是相等的。 所以，我们证明了提供的结论确实是 \\(\\text{DFA}\\) 的逆变换。 如果愿意，也可以把式子写成矩阵的形式，然后对对应的矩阵求逆，也能得到这个结果。 分析这种做法的复杂度：对于每一个 \\(k \\in [0, n)\\) 我们都需要 \\(O(n)\\) 的时间去求出等式右侧的求和；所以 \\(\\text{IDFT}\\) 公式的复杂度毫无疑问也是 \\(O(n^2)\\) 的。 快速傅里叶逆变换 那么现在，我们就要考虑如何在更短的复杂度下求解 IDFT。显然 IDFT 公式也是一个多项式，我们定义： \\[ a_k = F(x_k) = \\frac1n \\sum_{i = 0}^{n - 1}y_ix_k^i, \\ \\ x_k = \\omega_n^{-k} \\] 在回忆一下我们前面刚推到完的 FFT： \\[ y_k = f(x_k) = \\sum_{i = 0}^{n - 1}a_ix_k^i, \\ \\ x_k = \\omega_n^k \\] 我们就会发现它们出奇的相似！（好吧，我也是推到这一步才豁然开朗，，只能说我确实把复变函数的一些知识忘得精光，完全的不掌握了把）；\\(\\omega_n^k\\) 和 \\(\\omega_n^{-k}\\) 很显然是一对共轭复数——在复平面的角度来看它们只是幅角的旋转方向不同，实际上还是一一对应的；所以我们完全可以把 FFT 的方法拿到这里来，求出 \\(F(x)\\) 在 \\(\\omega_n\\) 不同幂下的值之后，翻转结果就可以得到答案（\\(\\omega_n^{-k} = \\omega_n^{n-k}\\)）。 是不是突然有些明白了在蝴蝶操作中 \\(\\omega_n^k\\) 被称为旋转因子的原因了（ 综上所述，FFT + 事后翻转 = \\(\\text{IFFT}\\)；这就是快速傅里叶逆变换插值，时间复杂度显然是 \\(O(n\\log n)\\)。 综上所述，我们使用 \\(\\text{FFT}\\) 和 \\(\\text{IFFT}\\) 取代求值和插值步骤朴素的 \\(\\text{DFT}\\) 和 \\(\\text{IDFT}\\) 算法，就可以把多项式的点值表达和系数表达之间的互相转化的复杂度从 \\(O(n^2)\\) 降为 \\(O(n\\log n)\\)，从而得到了一个总体复杂度为 \\(O(n\\log n)\\) 的多项式乘法的算法。 所以严格上来说，快速的多项式乘法算法并不是 FFT；FFT 只是其中非常重要的组成部分罢了。 算法实现 好了，你已经学会了 FFT 了！快上！（指上机写代码 朴素的递归实现 然后我们就写出了像上面说的那样的递归 FFT： 123456789101112131415161718192021222324complex getW(uint n, uint k = 1)&#123; const auto angle = (k % n) * PI * 2 / n; return complex(cos(angle), sin(angle));&#125;void subprocess(addr f, size_t n)&#123; if (n == 1) return; const auto m = n / 2; vector&lt;complex&gt; &amp;sub = _alloc(n); auto f0 = sub.begin(), f1 = f0 + m; for (int i = 0; i &lt; m; ++ i) f0[i] = f[i * 2], f1[i] = f[i * 2 + 1]; subprocess(f0, m); subprocess(f1, m); auto unit = getW(n), w = getW(1, 0); for (int i = 0; i &lt; m; ++ i) f[i] = f0[i] + w * f1[i], f[i + m] = f0[i] - w * f1[i], w *= unit; _free_mem_stack_frame();&#125; 上面的代码是最核心的递归过程；一些包装的函数在下面： 123456789101112131415void start(vector&lt;complex&gt; &amp;p, bool inv)&#123; subprocess(p.begin(), p.size()); if (inv) reverse(++ p.begin(), p.end());&#125;void fft(vector&lt;complex&gt; &amp;p)&#123;start(p, false);&#125;void ifft(vector&lt;complex&gt; &amp;p)&#123; start(p, true); const auto n = p.size(); for (auto &amp;i : p) _post_ifft(i, n);&#125; 如果是系数表达变点值表达，只需要开始递归即可；反之，在得到结果之后还需要进行后处理：首先将答案数组的 \\([1, N - 1]\\) 位置翻转（因为 \\(\\omega_n^0 = \\omega_n^n\\)，所以交换的是 \\(1\\) 和 \\(n - 1\\) 的位置），然后根据推导的表达式，我们还要对每个位置都除 \\(N\\)；需要注意的是这一步也会引入误差，需要 round。 然后我们再为它添加一些头和尾的代码，用来去做模板题检验正确性：【模板】多项式乘法（FFT）；增加的代码就像下面这样： 1234567891011121314151617181920212223signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int n = scanner.nextInt(), m = scanner.nextInt(); vector&lt;FFT::complex&gt; a, b; const auto siz = FFT::stretch(n + m); a.resize(siz), b.resize(siz); FFT::init_mem_pool(siz); for (int i = 0; i &lt;= n; ++ i) a[i].real(scanner.nextInt()); for (int i = 0; i &lt;= m; ++ i) b[i].real(scanner.nextInt()); FFT::fft(a), FFT::fft(b); for (int i = 0; i &lt; siz; ++ i) a[i] *= b[i]; FFT::ifft(a); for (int i = 0; i &lt;= n + m; ++ i) cout &lt;&lt; (int)a[i].real() &lt;&lt; &quot; \\n&quot;[n + m == i]; return 0;&#125; 然后交上去就会发现…… A 了？和别人博客里说的不一样啊？ _SPHGR0A___IYE3_WVFES_3.png 实际上是因为递归带来的较大的常数开销，很大一部分都来自于每层递归重复开辟内存空间用来做分治；因此，我写的时候就使用了一个内存池来处理递归中带来的内存分配和释放，就可以有效的降低它的常数。 当然，这种做法还是不够快的；所以我们还要对它继续优化。 优化迭代实现 因为递归是从上到下的过程，那么我们的迭代实现就是一个从下而上的一个过程。 我们把长度为 \\(8\\) 的情况下，上述朴素的递归做法的调用树画出来，如下图： 1234567Layer 1: 0 1 2 3 4 5 6 7 &#x2F; \\Layer 2: 0 2 4 6 1 3 5 7 &#x2F; \\ &#x2F; \\Layer 3: 0 4 2 6 1 5 3 7 &#x2F; \\ &#x2F; \\ &#x2F; \\ &#x2F; \\Layer 4: 0 4 2 6 1 5 3 7 当然，只看这个我们什么也看不出来；现在我们将焦点集中在最后一层上，并将它们的二进制和二进制反转以及二进制反转后得到的数字写出来，如下表： 1234Layer 4: 0 4 2 6 1 5 3 7Binary: 000 100 010 110 001 101 011 111Reverse: 000 001 010 011 100 101 110 111Decimal: 0 1 2 3 4 5 6 7 可以看出最后一层经过一番操作之后就变成了最开始的数组。因此，我们只需要在最开始的数组上进行这样的一番操作，就可以得到最后一层的这个新的数组，同时第一次合并也只是对相邻的位置进行合并。那么这样上面那几层就可以这样一直合并上去得到最终的数组了。 那么我们要怎么样快速的进行这一波神秘操作呢？现在我们考虑反转后的二进制表示（\\(1, 2, \\dots,2^k-1\\)），我们可以按照这样的顺序构造出这个序列： 123round 1: (1)001 (0)000 round 2: (3)011 (2)010 (1)001 (0)000 round 3: ... (6)110 (5)101 (4)100 (3)011 (2)010 (1)001 (0)000 第一轮，所有的位都是 0；第一个位置是 0 已经满足了要求；我们选择最低位，放置 1，得到了序列 0, 1；第二轮，已经有满足要求的序列长度 2，我们选择次低位，将这一位置 1，那么又可以填两个数字，这两个数字的相对位置就和最开始满足要求的序列那样…… 最终，重复 n 次就可以构造出 \\(0,\\dots,2^k-1\\) 的序列。 那么我们现在构造的是二进制反向的序列，那么只需要从高位开始，重复这个过程就可以了： 12345678910111213vector&lt;uint&gt; &amp;reverse(uint length)&#123; static vector&lt;uint&gt; rev(length); uint msk = length &gt;&gt; 1u, i = 0; rev[i ++] = 0, rev[i ++] = msk; for (uint w = 2; w &lt; length; w &lt;&lt;= 1) &#123; msk &gt;&gt;= 1u; for (uint j = 0; j &lt; w; ++ j) rev[i ++] = rev[j] | msk; &#125; return rev;&#125; 得到的数组是关于原数组的一个排序。我们只需要利用这个排列进行位逆序置换——因为每一个 i 和 rev[i] 都是一一对应的，它们本是有序的，那么只要交换所有逆序的对，就可以得到适用迭代的数组。 计算在 \\(n\\) 次单位根的各幂次点值的时候，令 \\(m=\\frac{n}2\\)，那么 \\(f_0\\) 和 \\(f_1\\) 已经由下层（迭代意义上的上层）计算并储存在 \\(A[k]\\) 和 \\(A[k+m]\\) 处，只需取出来计算后更新对应的值就完成了一层的迭代。到此，我们已经完成了对迭代优化的实现的过程描述，核心代码实现如下： 12345678910111213141516171819void start(vector&lt;complex&gt; &amp;p, bool inv) &#123; const auto siz = p.size(); const auto rev = reverse(siz); for (int i = 1; i &lt; siz; ++ i) if (rev[i] &gt; i) swap(p[rev[i]], p[i]); for (uint n = 2, m = 1; n &lt;= siz; m = n, n &lt;&lt;= 1) &#123; auto unit = get_w(n), w = get_w(1, 0); for (uint l = 0, r = n - 1; r &lt;= siz; l += n, r += n) &#123; complex w0 = w, d, tmp0, tmp1; for (uint i = l, lim = l + m; i &lt; lim; ++ i) d = w0 * p[i + m], tmp0 = p[i] + d, tmp1 = p[i] - d, p[i] = tmp0, p[i + m] = tmp1, w0 *= unit; &#125; &#125; if (inv) reverse(++ p.begin(), p.end()); &#125; 这样也可以通过上面的那个模板题： 1234567891011121314151617181920212223242526signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#ifndef ONLINE_JUDGE freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);// freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout);#endif int n = scanner.nextInt(), m = scanner.nextInt(); vector&lt;FFT2::complex&gt; a, b; const auto siz = FFT2::stretch(n + m); a.resize(siz), b.resize(siz); for (int i = 0; i &lt;= n; ++ i) a[i].real(scanner.nextInt()); for (int i = 0; i &lt;= m; ++ i) b[i].real(scanner.nextInt()); FFT2::fft(a), FFT2::fft(b); for (int i = 0; i &lt; siz; ++ i) a[i] *= b[i]; FFT2::ifft(a); for (int i = 0; i &lt;= n + m; ++ i) cout &lt;&lt; (int)a[i].real() &lt;&lt; &quot; \\n&quot;[n + m == i]; return 0;&#125; 这样，FFT 就简要的介绍完了。 参考资料 https://blog.csdn.net/alpha202/article/details/90737497 https://www.luogu.com.cn/blog/fusu2333/solution-p3803 https://blog.csdn.net/waduan2/article/details/79529900 https://blog.csdn.net/qq_38944163/article/details/81835205","categories":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"算法/数学","permalink":"https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"数论","slug":"数论","permalink":"https://shiraha.cn/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"Codeforces Round#710 div.3 回顾","slug":"codeforces-round-710-div3","date":"2021-03-27T07:08:32.000Z","updated":"2021-03-27T07:08:32.000Z","comments":true,"path":"2021/codeforces-round-710-div3/","link":"","permalink":"https://shiraha.cn/2021/codeforces-round-710-div3/","excerpt":"","text":"比赛链接：https://codeforces.ml/contest/1506 记录 比赛的时候可以说还是有点捞的，，竟然没有时间写完最后一题，属是不是很行（ 但是精彩还是在比完之后： _XMUTFT_4YHFRV__35DML_Y.png 直呼就这？ Penalty A B C D E F G 168 + +1 + -2 -1 + -1 题解 毕竟是 Div3，所以就只贴被 Hack 的题和没写出来的题好了： D - Epic Transformation 原来是 unordered_map 被卡了，，也不能这么说，也许遍历 unordered_map 就是意外的要慢（ 12345678910111213141516171819202122232425const int N = 2e5 + 5;map&lt;int, int&gt; cnt;signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int T = scanner.nextInt(); while (T --) &#123; int n = scanner.nextInt(); cnt.clear(); for (int i = 1; i &lt;= n; ++ i) ++ cnt[scanner.nextInt()]; int major = 0; for (auto [k, v] : cnt) maximize(major, v); println(max(n % 2, major - (n - major))); &#125; return 0;&#125; 哦，，破案了，，实际上是不断扩容消耗了大量的时间，，在使用之前预留空间就没有任何问题（ 12345678910111213141516171819202122232425const int N = 2e5 + 5;unordered_map&lt;int, int&gt; cnt;signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int T = scanner.nextInt(); while (T --) &#123; int n = scanner.nextInt(); cnt.clear(), cnt.reserve(n * 2); for (int i = 1; i &lt;= n; ++ i) ++ cnt[scanner.nextInt()]; int major = 0; for (auto [k, v] : cnt) maximize(major, v); println(max(n % 2, major - (n - major))); &#125; return 0;&#125; 就结果而言实际上跑的比 map 还要快： M_H5_L__9533_L__SQT__EV.png 上面是 unordered_map + reserve 两倍空间，下面是 map； E - Restoring the Permutation 没什么好说的，典型的复杂度估计错误，，这种数据范围 1e5 的，还要求在指定范围内寻找最大最小值的，拿个对数数据结构维护一下是再适合不过了；而且实际上也不难写，，只能说有些意识还是不够（ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const int N = 2e5 + 5;int pmx[N], pmn[N], q[N];set&lt;int&gt; umx, umn;signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int T = scanner.nextInt(); int mx = 0, mn = 0; const auto update = [&amp;](int pos) &#123; while (++ mx &lt; pos) umx.insert(mx); while (++ mn &lt; pos) umn.insert(mn); &#125;; while (T --) &#123; int n = scanner.nextInt(); for (int i = 1; i &lt;= n; ++ i) q[i] = scanner.nextInt(); memset(pmx, 0, sizeof(int) * (n + 1)); memset(pmn, 0, sizeof(int) * (n + 1)); umx.clear(), umn.clear(); pmx[1] = pmn[1] = q[1], mx = mn = 0; update(q[1]); for (int i = 2; i &lt;= n; ++ i) if (q[i] &gt; q[i - 1]) pmx[i] = pmn[i] = q[i]; for (int i = 2; i &lt;= n; ++ i) &#123; if (!pmx[i]) &#123; pmx[i] = *umx.rbegin(); umx.erase(*umx.rbegin()); &#125; else update(pmx[i]); if (!pmn[i]) &#123; pmn[i] = *umn.begin(); umn.erase(umn.begin()); &#125; &#125; for (int i = 1; i &lt;= n; ++ i) print(pmn[i], &quot; \\n&quot;[i == n]); for (int i = 1; i &lt;= n; ++ i) print(pmx[i], &quot; \\n&quot;[i == n]); &#125; return 0;&#125; 看来对 bitset 的无脑崇拜也得差不多得了（ G - Maximize the Remaining String 十分经典的问题，讲清楚了其实就没什么好说的；只能说思考题目的时候应该更加地理性，而不是总是对玄学抱有不切实际的幻想；比如这个题，如果看到就去考虑什么玄学构造方法，瞎几把贪，还欺骗自己的做法是正确的且很有道理，那就会贻笑大方，一辈子也做不出了（ 首先，很显然待构造的 \\(t\\) 是 \\(s\\) 的子序列：这说明我们可能可以按照顺序遍历每个字符，来确定是否要把它加入到 \\(t\\) 的末尾（当然 \\(t\\) 最开始是一个空串）；对于一个构造到一半的 \\(t\\)，在某个位置 \\(i\\) 的字符 \\(s[i]\\) 可以加入 \\(t\\) 的末尾的必要条件是，\\(s\\) 从 \\(i\\) 开始的后缀（后面记作 \\(s_i\\)）包含了所有 \\(t\\) 不包含的字符。 显然，\\(t\\) 的总长度也是确定的（并且极其有限），所以我们可以遍历字符串 \\(t\\) 需要，但是目前的构造阶段还不包含的可能的字符，找到可以插入且尽可能大的字符插入即可。每次插入的字符都确保它的后缀中有足够的其他字符使得构造不会失败，因此我们总是可以找到合理的字符并插入其中。 当然，这里实际上也有一个小小的贪心：字符串前面的字符大的字符串字典序更大（可以说是显然了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const int N = 2e5 + 5;char s[N], t[N];vector&lt;int&gt; pos[30];signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int T = scanner.nextInt(); const auto suffix = [&amp;](char ch, int st) &#123; auto &amp;p = pos[ch - &#x27;a&#x27;]; auto it = lower_bound(p.begin(), p.end(), st); if (it == p.end()) return -1; else return *it; &#125;; const auto count = [&amp;](int st) &#123; if (st == -1) return 0; int ret = 0; for (const auto &amp;ii : pos) &#123; auto it = lower_bound(ii.begin(), ii.end(), st); if (it != ii.end()) ++ ret; &#125; return ret; &#125;; while (T --) &#123; scanner(s); int n = strlen(s), len = 0; set&lt;char&gt; ss(s, s + n); const int siz = ss.size(); for (int i = 0; i &lt; n; ++ i) pos[s[i] - &#x27;a&#x27;].push_back(i); int st = 0; while (len &lt; siz) &#123; char add = 0; for (auto ch : ss) if (count(suffix(ch, st)) + len == siz) maximize(add, ch); t[len ++] = add; st = suffix(add, st) + 1; pos[add - &#x27;a&#x27;].clear(); ss.erase(add); &#125; t[len] = &#x27;\\0&#x27;; println(t); &#125; return 0;&#125; 每次检查一个字符是否合法的复杂度是 \\(O(26\\text{log}n)\\) 的，因为只有小写拉丁字母，所以检查次数是 \\(O(26\\cdot26)\\) 的；上面的代码去重用了 set（其实完全没必要），复杂度是 \\(O(n\\text{log}n)\\) 的；综上所述，总时间复杂度是 \\(O((26^3 + n)\\cdot\\text{log}n)\\) 的；如果不用 set 去重，时间复杂度可以做到 \\(O(\\text{log}n)\\) 的。 后记 不要盲目崇拜 bitset 和 unordered_map；至少要明白使用它们意味着什么： unordered_map 本质是哈希表，它的访问是将键值经过哈希计算映射到本地的连续空间，从而可以快速的“随机访问”的；如果这段连续空间不足以存储数据，就必须要开辟更大的空间，并且 rehash，从而将键值映射到更大的连续空间中；这个过程很显然是极其耗时的，但是在做题的时候我们大概知道元素的数量，所以可以使用它提供的 reserve 方法，预留足够的空间，就可以减少这个过程的发生，从而达到提速的目的。 当然，pb_ds 里的哈希表又是另一回事，得找个时间去了解才行。 至于这个 G，确实是和我还颇有渊源，，，这个就不提了（）但是确实在做题的时候应当舍弃不切实际的无聊幻想，用做题的思维去考虑才行==","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://shiraha.cn/tags/Codeforces/"}]},{"title":"Educational Codeforces Round 106 回顾","slug":"codeforces-educational-round-106","date":"2021-03-19T08:55:06.000Z","updated":"2021-03-19T08:55:06.000Z","comments":true,"path":"2021/codeforces-educational-round-106/","link":"","permalink":"https://shiraha.cn/2021/codeforces-educational-round-106/","excerpt":"","text":"补题链接：https://codeforces.com/contest/1499 记录 一开始还是挺像模像样的，快速地切掉了 ABC 三个题，然后在 D 题处一直瞎想，看着通过人数从 30 涨到 600 左右直到比赛结束……这种感觉是真的不好（）到底是什么使得我变得总是做不出 D 呢…… 确实需要好好反思（ 题解 A - Domino on Windowsill 不用管怎么摆放；因为只有两排，所以只需要看格子数够不够就行； 代码 12345678910111213141516171819signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int T = scanner.nextInt(); while (T --) &#123; int n, k1, k2, w, b; scanner(n, k1, k2, w, b); int ww = (k1 + k2) / 2; int bb = (2 * n - k1 - k2) / 2; println(ww &gt;= w &amp;&amp; bb &gt;= b ? &quot;YES&quot; : &quot;NO&quot;); &#125; return 0;&#125; B - Binary Removals 数据规模很小；所以只需要遍历 0-1 分界点的位置，然后 \\(O(n)\\) 检查是否可行即可。 代码 12345678910111213141516171819202122232425262728293031323334const int N = 120;char s[N];signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int T = scanner.nextInt(); while (T --) &#123; scanner(s); int n = strlen(s); bool ok = false; bitset&lt;N&gt; del; for (int i = 0; i &lt;= n; ++ i) &#123; del.reset(); for (int j = 0; j &lt; i; ++ j) if (s[j] == &#x27;1&#x27;) del.set(j); for (int j = i; j &lt; n; ++ j) if (s[j] == &#x27;0&#x27;) del.set(j); bool _ok = true; for (int j = 1; j &lt; n; ++ j) if (del[j] &amp;&amp; del[j - 1]) _ok = false; if (_ok) ok = true; &#125; println(ok ? &quot;YES&quot; : &quot;NO&quot;); &#125; return 0;&#125; C - Minimum Grid Path 首先，你至少要转一次弯才能到达终点，所以你的路程段数至少是两段；因为只有两个方向，所以你每转一次弯就相当于在两种方向来回横跳；注意到题目说的是第 x 段路的费用是 \\(c_x\\)；所以显然偶数段的路和奇数段的路方向不同，且恰好占据了两个方向——且两个方向都需要走 \\(n\\) 的长度； 因为转方向之后至少要在这一段路之间走 1 个单位，所以如果在某个方向走了 \\(x\\) 段路，其中费用最小的为 \\(c_x&#39;\\)，所有的这些路段的单价总和为 \\(C_x\\)，那么这个方向上最便宜的走法一定是花费 \\(C_x + (n - x)c_x&#39;\\) 的：即在花费最小的路段尽可能地走，但是之前经过的不那么优的路段只走一段； 还需要注意的就是两个方向并不是独立的：因为是连贯的折线，所以在两个方向上走的段数差不能超过 1；一种比较优雅的遍历方法就是遍历所有的段数，然后分别处理两边的最优花费，求和取最小值。 代码 123456789101112131415161718192021222324252627282930313233const int N = 1e5 + 5;longs c[N];signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int T = scanner.nextInt(); while (T --) &#123; int n = scanner.nextInt(); for (int i = 1; i &lt;= n; ++ i) c[i] = scanner.nextInt(); longs ans = c[1] * n + c[2] * n; longs odd = c[1], even = c[2]; longs os = c[1], es = c[2]; longs on = 1, en = 1; for (int i = 3; i &lt;= n; ++ i) &#123; ++ (i % 2 ? on : en); (i % 2 ? os : es) += c[i]; minimize((i % 2 ? odd : even), c[i]); auto tmp = odd * (n - on) + os + even * (n - en) + es; minimize(ans, tmp); &#125; println(ans); &#125; return 0;&#125; D - The Number of Pairs 给定三个整数 \\(c\\)， \\(d\\)，\\(x\\)；它们满足 \\(1 \\leq c, d, x \\leq 10^7\\)；现给定等式： \\[ c \\cdot \\mathrm{lcm}(a, b) - d \\cdot \\mathrm{gcd}(a, b) = x \\] 且 \\(a, b\\) 均为正整数；求出满足该等式的 \\((a, b)\\) 的对数。 这个等式首先一看就是要化简的：令 \\(K = \\mathrm{gcd}(a, b)\\)；那么就可以将 a 和 b 表示为 \\(a = nK, \\ b = mK\\)，其中的 n 和 m 显然满足 \\(n,m \\in N^+\\) 和 \\(\\mathrm{gcd}(n, m) = 1\\)；那么我们就可以进行如下的等价变换： \\[ \\begin{align} c \\cdot \\mathrm{lcm}(a, b) - d \\cdot \\mathrm{gcd}(a, b) &amp;= x \\\\ c \\cdot \\frac{ab}{\\mathrm{gcd}(a, b)} - d \\cdot \\mathrm{gcd}(a, b) &amp;= x \\\\ c \\cdot nmK - d \\cdot K &amp;= x \\\\ K &amp;= \\frac{x}{cnm - d} \\end{align} \\] 那么，记 \\(y = cnm - d\\)，这个问题就变成了求满足这个等式的互质的 \\((n, m)\\) 的对数。具体的做法就是枚举 \\(x\\) 的因子 \\(y\\)：如果满足 \\(c \\mid (d + y)\\)，那么 \\(nm = \\frac{d + y}{c}\\)；记 \\(z = nm\\)，因为 n 和 m 互质，所以 \\(z\\) 的每一个不同的质因子要不全部属于 n，要不全部属于 m；用 \\(P_z\\) 表示 z 的不同的质因子的数量，那么对于 z，满足条件的 (n, m) 一共有 \\(2^{P_z}\\) 对。 实际实现时，可以先用线性筛预处理数据范围内的 \\(P\\) 数组，然后根据输入计算答案。 代码 123456789101112131415161718192021222324252627282930313233343536const int A = 2e7 + 7;namespace linear_sieve &#123; ... &#125;longs fastPow(longs a, ulongs b) &#123; ... &#125;signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int T = scanner.nextInt(), c, d, x; using linear_sieve::cnt; linear_sieve::start(); const auto calc = [&amp;](longs y) -&gt; longs &#123; if ((d + y) % c) return 0; const auto z = (d + y) / c; return fastPow(2, cnt[z]); &#125;; while (T --) &#123; scanner(c, d, x); longs ans = 0, y; for (y = 1; y * y &lt; x; ++ y) if (!(x % y)) ans += calc(y) + calc(x / y); if (y * y == x) ans += calc(y); println(ans); &#125; return 0;&#125; 需要注意的是：虽然数据范围是 1e7 的，但是 z 是有可能大于 1e7 的；所以预处理的数据范围要更广。 事后分析 虽然也确实推了式子，也至少推到了这份题解中提到的第二部；但是这实在是太像 \\(\\mathrm{exgcd}\\) 了：如果假设 lcm 和 gcd 都为未知变量的话；但是就像刚才所推导的那样，这两个未知变量之间本就有所联系，并且这个联系的关系也是不定的（lcm 是 gcd 的倍数），求出了倍数还是要进行这样的拆分，就非常的不合理。 E - Chaotic Merge …… F - Diameter Cuts 等待题解中…… 后记 和之前的发挥不是很正常的比赛是一样的：总是感觉自己的思维非常的不稳定——不在能做出题的频道上；之前解决这种问题是静下心来仔细想想自己到底有哪些地方出了问题，也许现在也是需要这样的时候吧（ 猫猫脸.png 不过我确实需要静下心来好好地想想了…… 愉快犯是不够扎实的（","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://shiraha.cn/tags/Codeforces/"}]},{"title":"Codeforces Round#708 div.2 回顾","slug":"codeforces-round-708-div2","date":"2021-03-18T03:30:13.000Z","updated":"2021-03-23T08:48:00.000Z","comments":true,"path":"2021/codeforces-round-708-div2/","link":"","permalink":"https://shiraha.cn/2021/codeforces-round-708-div2/","excerpt":"","text":"补题链接：Dashboard - Codeforces Round #708 (Div. 2) - Codeforces 记录 推特做题术 7_QMZFWQ_2JMS4Z46F_T9.png 虽然还是勉强保住了 ABC 选手的尊严，但是这场题目是真的偏简单…… ABC 连两千名都进不了（）明明参加人数就只有两万人不到，可以说是很捞了== 赛后一看 E1 比 D 简单，C2 比 C1 简单，也真神秘（ 题解 A - Meximization 看样例猜解法： 1234567891011121314151617181920212223signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int T = scanner.nextInt(); while (T --) &#123; int n = scanner.nextInt(); map&lt;int, int&gt; cnt; for (int i = 1; i &lt;= n; ++ i) ++ cnt[scanner.nextInt()]; for (auto [i, ii] : cnt) print(i, &#x27; &#x27;); for (auto [i, ii] : cnt) while (-- ii) print(i, &#x27; &#x27;); println(); &#125; return 0;&#125; B - M-arrays 按照 \\(\\mathrm{mod} \\ m\\) 进行分组统计答案就行： 1234567891011121314151617181920212223242526272829303132const int N = 1e5 + 5;int a[N], cnt[N];signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int T = scanner.nextInt(); while (T --) &#123; int n = scanner.nextInt(), m = scanner.nextInt(); for (int i = 1; i &lt;= n; ++ i) a[i] = scanner.nextInt(); memset(cnt, 0, sizeof(int) * m); for (int i = 1; i &lt;= n; ++ i) ++ cnt[a[i] % m]; int ans = bool(cnt[0]), lim = m / 2; for (int i = 1; i &lt;= lim; ++ i) &#123; auto aa = cnt[i], bb = cnt[m - i]; if (!aa &amp;&amp; !bb) continue; ans += max(abs(bb - aa), 1); &#125; println(ans); &#125; return 0;&#125; C1 - k-LCM (easy version) 实际上没我代码写的那么复杂；如果是奇数的话就输出 1 k/2 k/2 就行，偶数但是不是 4 的倍数的话就是 2 k/2-1 k/2-1；再不然就是 n/2 n/4 n/4；不用看了，肯定是对的 == 12345678910111213141516171819202122232425signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int T = scanner.nextInt(); while (T --) &#123; int n = scanner.nextInt(), k = scanner.nextInt(); if (__builtin_popcount(n) == 1) &#123; print(n / 2, &#x27; &#x27;, n / 4, &#x27; &#x27;, n / 4, &#x27;\\n&#x27;); continue; &#125; longs mod2 = 1; while (!(n % 2)) n /= 2, mod2 *= 2; int tmp = n / 2; print(mod2, &#x27; &#x27;, mod2 * tmp, &#x27; &#x27;, mod2 * tmp, &#x27;\\n&#x27;); &#125; return 0;&#125; C2 - k-LCM (hard version) 这个题目就更搞了…… 因为服务器中途宕机的原因，我交的很慢，甚至还因为原想法过于花哨边界条件太多而 wa 了一发（）但是实际上这个题比 C1 还要简单： 对于 n 和 k，只需要先输出 k - 3 个 1，然后再用 C1 的办法处理就行了（（（ 显然，C1 的办法保证得到的三个数的 LCM 满足 lcm &lt;= (k - 3) / 2，而我们其他的数都是 1，对 lcm 没有任何贡献，所以最后的结果显然也是满足题意的（ 1234567891011121314151617181920212223242526void C1(int n)&#123; if (n % 2) print(&quot;1 &quot;, n / 2, &#x27; &#x27;, n / 2); else if (n % 4) print(&quot;2 &quot;, n / 2 - 1, &#x27; &#x27;, n / 2 - 1); else print(n / 2, &#x27; &#x27;, n / 4, &#x27; &#x27;, n / 4);&#125;signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int T = scanner.nextInt(); while (T --) &#123; int n = scanner.nextInt(), k = scanner.nextInt(); int m = k - 3; C1(n - m); while (m --) print(&quot; 1&quot;); println(); &#125; return 0;&#125; 就不贴我赛场上写的丑陋的甚至还 WA 了一发代码了…… 我真傻，真的（ XJQ1VOCX5_3_D_4ML2KN.png 还是不够机智== D - Genius 有 \\(1 \\dots n\\) 共 \\(n \\leq 5000\\) 个位置：\\(i\\)-th 位置有 \\(tag_i\\)、\\(c_i = 2^i\\) 和 \\(s_i\\) 分数；初始有 \\(\\mathrm{IQ} = 0\\) 和 \\(S = 0\\)； 如果你当前在 \\(i\\) 点，那么仅当 \\(\\mathrm{IQ} &lt; |c_i - c_j|\\) 和 \\(tag_i \\ne tag_j\\) 同时满足时才能到达 \\(j\\) 点； 到达 \\(j\\) 点之后，你的 \\(\\mathrm{IQ}\\) 变为 \\(|c_i - c_j|\\)，并且获得 \\(|s_i - s_j|\\) 分数； 你可以任意选择起点，问你可以获得的最大分数； 特别说明：内存限制 32MB 首先，定义边权 \\(w_{i, j} = |c_i - c_j|\\)；显然所有的边的“边权”都是不同的；然后考虑动态规划：定义 \\(F_i\\) 表示最后停留在点 \\(i\\) 最大能获得的分数；显然最初情况下全部为 0；然后转换题目限制条件，进行转移： \\(tag_i \\ne tag_j\\)：这个简单，如果不满足直接阻止对应的转移就行了。 \\(\\mathrm{IQ} &lt; |c_i - c_j|\\)：意思就是说走的边越来越长；因此我们总是先转移短边再转移长边就行。 综上所述，我们就可以在一维 DP 内完成答案的求解； 12345678910111213141516171819202122232425262728293031323334const int N = 5050;int s[N], tag[N];longs dp[N];signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int T = scanner.nextInt(); while (T --) &#123; int n = scanner.nextInt(); for (int i = 1; i &lt;= n; ++ i) tag[i] = scanner.nextInt(); for (int i = 1; i &lt;= n; ++ i) s[i] = scanner.nextInt(); memset(dp, 0, sizeof(longs) * (n + 1)); for (int i = 1; i &lt;= n; ++ i) for (int j = i - 1; j; -- j) if (tag[i] != tag[j]) &#123; auto ii = dp[i], jj = dp[j]; auto add = abs(s[i] - s[j]); maximize(dp[i], jj + add); maximize(dp[j], ii + add); &#125; println(*max_element(dp + 1, dp + 1 + n)); &#125; return 0;&#125; 有的时候想问题还是要跳出局部纵观全体；像这个题就是做的时候视野集中在走的策略上，并且还被预处理 tag 连通块的想法所牵制，最后离正解渐行渐远（ E1 - Square-free division (easy version) 给定长度为 \\(n \\leq 2 \\cdot 10^5\\) 的数组；现在你需要将数组划分成一些连续的段，使得每个段中不包含两个数，它们的乘积为完全平方数；求满足此要求可以划分的最少的段数。 首先肯定要对数组里每个数字进行分解质因数；因为相乘就是分解质因数得到的多项式的指数相加，而完全平方数分解得到的多项式的指数均为 2；那么我们可以得到结论：如果 x 和 y 的乘积是完全平方数，那么 x 和 y 分解质因数得到的多项式中关于每一个质数的指数都是 \\(\\mathrm{mod} \\ 2\\) 相等的。 因此，我们只需要记录每个元素质因数分解之后指数 \\(\\mathrm{mod} \\ 2\\) 的情况，然后划分不包含相同 pattern 的元素即可：这样，这个问题就退化为划分不包含相等数字的段；众所周知，这个问题可以贪心的解决。 那么应该如何维持这个 pattern 呢？使用一个很大的 bitset 嘛？完全没有必要：因为 \\(a_i \\leq 10^7\\)，那么质因子指数不会超过 1 的 pattern 的乘积自然也不会超过这个限制；所以只需要将它们乘起来就可以了，即快又优雅（ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const int N = 2e5 + 5, A = 1e7 + 7;int a[N], pattern[N];// PrimeFactorizationSieve()namespace PFS &#123;...&#125;signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int T = scanner.nextInt(); using PFS::prime, PFS::fact; PFS::start(); while (T --) &#123; int n = scanner.nextInt(), k = scanner.nextInt(); for (int i = 1; i &lt;= n; ++ i) a[i] = scanner.nextInt(); fill(pattern, pattern + n + 1, 1); for (int i = 1; i &lt;= n; ++ i) &#123; int exp = 0, base = 0, tmp = a[i]; while (tmp &gt; 1) &#123; int p = fact[tmp]; if (base == p) ++ exp; else &#123; if (exp % 2) pattern[i] *= base; base = p, exp = 1; &#125; tmp /= p; &#125; if (exp % 2) pattern[i] *= base; &#125; int ans = 1; set&lt;int&gt; unique; for (int i = 1; i &lt;= n; unique.insert(pattern[i ++])) if (unique.count(pattern[i])) ++ ans, unique.clear(); println(ans); &#125; return 0;&#125; 真就比 D 简单呗？以后打 CF 也不能盯着一个题死看了，得适当设定递归深度（（ 话说我的欧拉筛写成函数竟然会过不了编译（提示编译得到的文件过大），只好拆成命名空间的形式才能过，倒是挺神秘的有点== E2 - Square-free division (hard version) 在 E1 的基础上，你获得了 \\(k \\leq 20\\) 次的单点修改的机会：你可以将任意位置修改为任意数字不超过 \\(k\\) 次； 看到 k 非常的小，所以可以考虑 DP；令 DP 数组 \\(F_{i, j}\\) 的含义是在长度为 i 的前缀中，允许不超过 j 次的修改，可以得到的最少的分段数；那么，我们至少可以考虑到两种显然的转移： 若 \\(j &gt; 0\\)，那么显然可以从 \\(F_{i,k} (k &lt; j)\\) 转移到 \\(F_{i, j}\\)； 若区间 \\((i, k]\\) 消耗了 \\(x\\) 次修改而得以连续，那么 \\(F_{k, j + x} = F_{i, j} + 1\\) 因此，如果我们可以维护一段区间维持连续而消耗的次数，就可以利用第二种转移求出最后的答案； 当然，我们不可能去维护所有的区间；将第二种转移反过来，我们只需要维护对于每一个满足 \\(x \\leq j\\) 的修改次数，以一个确定的右端点 \\(i\\)，可以到达的最远的左端点 \\(l\\) 即可。这样的转移一定是更优的。而预处理求出这个距离也并不难；我们依然可以像 E1 那样通过一次遍历就完成维护（因为 pattern 的大小是有限的，我们可以使用桶来去重而不是 set，这样时间复杂度就是线性的）；维护 \\(k\\) 中不同的修改情况的复杂度是 \\(O(nk)\\) 的； 这样，我们就可以利用上面说到的两种转移方法进行转移了；时间复杂度是 \\(O(nk^2)\\) 的； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const int N = 2e5 + 5, A = 1e7 + 7;int a[N], pattern[N], cnt[A];int ll[N][25], f[N][25];// PrimeFactorizationSieve()namespace PFS &#123; ... &#125;signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int T = scanner.nextInt(); using PFS::prime, PFS::fact; PFS::start(); while (T --) &#123; int n = scanner.nextInt(), k = scanner.nextInt(); for (int i = 1; i &lt;= n; ++ i) a[i] = scanner.nextInt(); fill(pattern, pattern + n + 1, 1); for (int i = 1; i &lt;= n; ++ i) &#123; int exp = 0, base = 0, tmp = a[i]; while (tmp &gt; 1) &#123; int p = fact[tmp]; if (base == p) ++ exp; else &#123; if (exp % 2) pattern[i] *= base; base = p, exp = 1; &#125; tmp /= p; &#125; if (exp % 2) pattern[i] *= base; &#125; for (int j = 0; j &lt;= k; ++ j) &#123; int cur = n + 1, use = 0; for (int i = n; i &gt; 0; -- i) &#123; while (cur - 1 &gt;= 1 &amp;&amp; use + !!cnt[pattern[cur - 1]] &lt;= j) use += !!(cnt[pattern[-- cur]] ++); ll[i][j] = cur; if (cnt[pattern[i]] --&gt; 1) -- use; &#125; &#125; for (int i = 1; i &lt;= n; ++ i) memset(f[i], 0x3f, sizeof(f[i])); memset(f[0], 0, sizeof(f[0])); for (int i = 1; i &lt;= n; ++ i) for (int j = 0; j &lt;= k; ++ j) &#123; if (j) minimize(f[i][j], f[i][j - 1]); for (int l = 0; l &lt;= j; ++ l) minimize(f[i][j], f[ll[i][l] - 1][j - l] + 1); &#125; int ans = 0x3f3f3f3f; for (int i = 0; i &lt;= k; ++ i) minimize(ans, f[n][i]); println(ans); &#125; return 0;&#125; 后记 《就这》：比赛中：Codeforces 服务器就这？比赛后：你这通过情况就这？ 服务器恢复：拿好你的 15 分钟，我们没有找到任何 unrated 的原因！半小时后：我们 unrated 了！","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://shiraha.cn/tags/Codeforces/"}]},{"title":"牛客 2021 年度训练联盟热身训练赛第二场 回顾","slug":"nowcoder-2021-training-league-warm-up-2","date":"2021-03-14T15:26:35.000Z","updated":"2021-03-14T15:26:35.000Z","comments":true,"path":"2021/nowcoder-2021-training-league-warm-up-2/","link":"","permalink":"https://shiraha.cn/2021/nowcoder-2021-training-league-warm-up-2/","excerpt":"","text":"比赛链接：https://ac.nowcoder.com/acm/contest/12794 非常的垃圾，这一场几乎全部都是水题== 当然还混入了大量说不清道不明的阅读理解一般又臭又长的题面…… 只能说恶心他🐎给恶心开门，恶心到家了（） 实况：AK（10/10），Rank=39 Penalty A B C D E F G H I J 1056 + + + +1 +1 +1 +5 +1 + + 没什么好说的，，直接贴代码好了这将成为目前为止本博客最水题解 题解 A - Binarize It 签到，队友 A 的： 12345678910111213141516int t, n, m, k;int main()&#123;// #define COMP_DATA#ifndef ONLINE_JUDGE freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int tcase; read(tcase); while (tcase--) &#123; read(n); printf(&quot;Input value: %d\\n%d\\n\\n&quot;, n, int(pow(2, int(ceil(log10(n) / log10(2)))))); &#125; return 0;&#125; 虽然有些意义不明的变量（ B - g2g c u l8r 纯字符串暴力题；让我熟悉了在 C++ 中读入整行的一些操作和注意事项 1234567891011121314151617181920212223242526272829303132signed main()&#123; // ios::sync_with_stdio(false); // std::cin.tie(nullptr); // std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int T, q; cin &gt;&gt; T; unordered_map&lt;string, string&gt; dict; string s, t; while (T --) &#123; cin &gt;&gt; s; getline(cin, t); int cur = 0, size = t.length(); while (cur &lt; size) if (t[cur] == &#x27; &#x27;) ++ cur; else break; dict[s] = t.substr(cur); &#125; cin &gt;&gt; q; getline(cin, s); while (q --) &#123; getline(cin, s); stringstream ss(s), out; while (ss &gt;&gt; t) if (dict.count(t)) out &lt;&lt; dict[t] &lt;&lt; &#x27; &#x27;; else out &lt;&lt; t &lt;&lt; &#x27; &#x27;; auto str = out.str(); cout &lt;&lt; str &lt;&lt; endl; &#125; return 0;&#125; 回想起了刚入坑时在洛谷训练场写红题的恐惧（ C - Tip to be Palindrome 签到；虽然可以考虑一些手段，但是因为数据范围实在是太小了，所以只需要模拟就行了…… 123456789101112131415161718192021222324252627282930313233343536bool check(int n)&#123; s = to_string(n); for (int i = 0; i &lt; s.length() / 2; i++) &#123; int j = s.length() - i - 1; if (s[i] != s[j]) return false; &#125; return true;&#125;int main()&#123;// #define COMP_DATA#ifndef ONLINE_JUDGE freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif ios::sync_with_stdio(false); int tcase; cin &gt;&gt; tcase; for (int i = 5; i &lt;= 20000; i++) &#123; if (check(i)) q.push_back(i); &#125; while (tcase--) &#123; cin &gt;&gt; n; int l = ceil(1.0 * n * 1.2); cout &lt;&lt; &quot;Input cost: &quot; &lt;&lt; n &lt;&lt; endl; int ans = q[lower_bound(q.begin(), q.end(), l) - q.begin()]; cout &lt;&lt; ans - n &lt;&lt; &quot; &quot; &lt;&lt; ans &lt;&lt; endl &lt;&lt; endl; &#125; return 0;&#125; 上面的代码就是先预处理完了所有的回文，然后根据输入去查找答案。 D - Soccer Standings 运算符重载题，当然前提是你读完了那又臭又长的题面描述： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int n, t, g; cin &gt;&gt; n; using team = tuple&lt;int, int, int, int, int, int, int&gt;; vector&lt;string&gt; ss; unordered_map&lt;string, int&gt; val; vector&lt;team&gt; cnt; const auto init = [&amp;] &#123; ss.clear(), val.clear(); cnt.clear(); &#125;; const auto cmp = [] (const team &amp;a, const team &amp;b) -&gt; bool &#123; auto &amp;[ano, a1, a0, aw, at, al, apt] = a; auto &amp;[bno, b1, b0, bw, bt, bl, bpt] = b; auto ad = a1 - a0, bd = b1 - b0; if (apt != bpt) return apt &gt; bpt; else if (ad != bd) return ad &gt; bd; else if (a1 != b1) return a1 &gt; b1; else return ano &lt; bno; &#125;; string s, a, b; int aa, bb; for (int i = 1; i &lt;= n; ++ i) &#123; init(); cin &gt;&gt; t &gt;&gt; g; while (t --) &#123; cin &gt;&gt; s; ss.push_back(s); &#125; sort(ss.begin(), ss.end()); t = ss.size(); for (int i = 0; i &lt; t; ++ i) val[ss[i]] = i, cnt.emplace_back(i, 0, 0, 0, 0, 0, 0); while (g --) &#123; cin &gt;&gt; a &gt;&gt; aa &gt;&gt; b &gt;&gt; bb; int aaa = val[a], bbb = val[b]; auto &amp;[ano, a1, a0, aw, at, al, apt] = cnt[aaa]; auto &amp;[bno, b1, b0, bw, bt, bl, bpt] = cnt[bbb]; a1 += aa, b0 += aa, b1 += bb, a0 += bb; if (aa &gt; bb) &#123; ++ aw, ++ bl; apt += 3; &#125; else if (aa &lt; bb) &#123; ++ bw, ++ al; bpt += 3; &#125; else ++ at, ++ bt, ++ apt, ++ bpt; &#125; sort(cnt.begin(), cnt.end(), cmp); cout &lt;&lt; &quot;Group &quot; &lt;&lt; i &lt;&lt; &quot;:\\n&quot;; for (auto &amp;ii : cnt) &#123; auto [no, _1, _0, win, tie, lose, pt] = ii; cout &lt;&lt; ss[no] &lt;&lt; &#x27; &#x27; &lt;&lt; pt &lt;&lt; &#x27; &#x27; &lt;&lt; win &lt;&lt; &#x27; &#x27; &lt;&lt; lose &lt;&lt; &#x27; &#x27; &lt;&lt; tie &lt;&lt; &#x27; &#x27; &lt;&lt; _1 &lt;&lt; &#x27; &#x27; &lt;&lt; _0 &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 确实，属性并不是都同号的 :-) E - NIH Budget 本场为数不多的有点技术含量的题目之一——不过是个背包板子； 123456789101112131415161718192021222324252627282930const int N = 1e5 + 5;int dp[N];array&lt;pair&lt;int, int&gt;, 4&gt; info[20];signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int n = scanner.nextInt(), d, b; for (int i = 1; i &lt;= n; ++ i) &#123; scanner(d, b); memset(dp, 0, sizeof(int) * (b + 1)); for (int j = 0; j &lt; d; ++ j) for (auto &amp;[cost, save] : info[j]) scanner(cost, save); for (int j = 0; j &lt; d; ++ j) for (int x = b; x &gt;= 0; -- x) for (auto &amp;[cost, save] : info[j]) if (x - cost &gt;= 0) maximize(dp[x], dp[x - cost] + save); cout &lt;&lt; &quot;Budget #&quot; &lt;&lt; i &lt;&lt; &quot;: Maximum of &quot; &lt;&lt; dp[b] &lt;&lt; &quot; lives saved.&quot; &lt;&lt; endl &lt;&lt; endl; &#125; return 0;&#125; 不会有人不会写背包吧，不会这个人就是我自己吧（逃 F - Interstellar Love 并查集；注意只有一个的星星的连通块不是一个星座 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162const int N = 1100;namespace DSU&#123; int fa[N], siz[N], cnt[N]; void init(int n) &#123; for (int i = 0; i &lt;= n; ++ i) fa[i] = i, siz[i] = 1, cnt[i] = 0; &#125; int father(int u) &#123;return fa[u] == u ? u : (fa[u] = father(fa[u]));&#125; void join(int x, int y) &#123; int fx = father(x), fy = father(y); if (fx == fy) return void(cnt[fx] ++); if (siz[fx] &lt;= siz[fy]) fa[fx] = fy, siz[fy] += siz[fx], cnt[fy] += cnt[fx] + 1; else fa[fy] = fx, siz[fx] += siz[fy], cnt[fx] += cnt[fy] + 1; &#125;&#125;signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int n = scanner.nextInt(); for (int tt = 1; tt &lt;= n; ++ tt) &#123; int s = scanner.nextInt(), c = scanner.nextInt(); DSU::init(s + 1); while (c --) &#123; int u = scanner.nextInt(), v = scanner.nextInt(); DSU::join(u, v); &#125; bitset&lt;N&gt; star, fix; for (int i = 1; i &lt;= s; ++ i) &#123; auto fa = DSU::father(i); auto e = DSU::cnt[fa], v = DSU::siz[fa]; if (v &lt;= 1) continue; star.set(fa); if (e &gt;= v) fix.set(fa); &#125; cout &lt;&lt; &quot;Night sky #&quot; &lt;&lt; tt &lt;&lt; &quot;: &quot; &lt;&lt; star.count() &lt;&lt; &quot; constellations, of which &quot; &lt;&lt; fix.count() &lt;&lt; &quot; need to be fixed.&quot; &lt;&lt; endl &lt;&lt; endl; &#125; return 0;&#125; G - Plate Spinning 虽然没什么内容但是被恶心到了…… 需要特判当只有一个盘子的时候始终可行。 123456789101112131415161718192021signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int T = scanner.nextInt(); for (int i = 1; i &lt;= T; i++) &#123; int n = scanner.nextInt(), m = scanner.nextInt(); auto t = 1.0 * n * 0.5 * 5; print(&quot;Circus Act &quot;, i, &quot;:\\n&quot;); if (n == 1 || t &lt;= 1.0 * m) println(&quot;Chester can do it!\\n&quot;); else println(&quot;Chester will fail!\\n&quot;); &#125; return 0;&#125; 然后这一个题就奉献了快两个小时的罚时（） H - The Eternal Quest for Caffeine 除了单程往返，还要考虑源点在中间，路径绕一个环的情况；我最开始的时候就没有考虑那种情况，所以莽了（）后来队友给我改成了遍历一个段，就对了（ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748const int N = 16;array&lt;bitset&lt;N&gt;, N&gt; machine;bitset&lt;N&gt; ok; signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int n, s, m, t, x; char state; for (int T = 1; T; ++T) &#123; cin &gt;&gt; n &gt;&gt; s &gt;&gt; m; if (!n &amp;&amp; !s &amp;&amp; !m) return 0; for (auto &amp;ii : machine) ii.reset(); ok.reset(); for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; t; while (t--) cin &gt;&gt; x, machine[i].set(x); cin &gt;&gt; state; if (state == &#x27;Y&#x27;) ok.set(i); &#125; int ans = 0x3f3f3f3f; for (int i = 1; i &lt;= n; ++i) for (int j = i; j &lt;= n; ++j) &#123; bool haveSource = false, flag = false; bitset&lt;N&gt; tmp; for (int k = i; k &lt;= j; ++k) &#123; tmp |= machine[k]; if (k == s) haveSource = true; if (ok[k]) flag = true; &#125; if (haveSource &amp;&amp; flag &amp;&amp; tmp.count() == m) ans = min(ans, (j - i) * 2); &#125; cout &lt;&lt; &quot;Test case #&quot; &lt;&lt; T &lt;&lt; &quot;: &quot;; if (ans &lt; 0x3f3f3f3f) cout &lt;&lt; ans &lt;&lt; endl &lt;&lt; endl; else cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; endl &lt;&lt; endl; &#125; return 0;&#125; 虽然是队友给我改过的，但是这也算是我过的吧（ I - Pegasus Circle Shortcut 平面几何运算板子题：对着题目嗯模拟就成了 123456789101112131415161718192021222324252627282930313233343536373839namespace Geo &#123;...&#125;signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif double cx, cy, sx, sy, tx, ty; const string ans[] = &#123;&quot;Stick to the Circle.&quot;, &quot;Watch out for squirrels!&quot;&#125;; using Geo::point, Geo::number; const number PI = 3.1415926535897932384626; cout &lt;&lt; fixed &lt;&lt; setprecision(8); for (int T = 1, n; T; ++ T) &#123; cin &gt;&gt; cx &gt;&gt; cy &gt;&gt; sx &gt;&gt; sy &gt;&gt; tx &gt;&gt; ty; if (cx == 0. &amp;&amp; cy == 0. &amp;&amp; sx == 0. &amp;&amp; sy == 0. &amp;&amp; tx == 0. &amp;&amp; ty == 0.) break; point s(sx, sy), t(tx, ty), c(cx, cy); point last(sx, sy), now; number interior = 0; for (cin &gt;&gt; n; n --;) &#123; cin &gt;&gt; now.x &gt;&gt; now.y; interior += now.distance(last); last = now; &#125; interior += t.distance(last); auto str0 = s - c, str1 = t - c; auto ang = abs(str0.angle() - str1.angle()); number d = c.distance(s) + c.distance(t); minimize(ang, 2 * PI - ang); number circular = d * ang / 2; bool ok = Geo::compareTo(interior, circular) &lt;= 0; cout &lt;&lt; &quot;Case #&quot; &lt;&lt; T &lt;&lt; &quot;: &quot; &lt;&lt; ans[ok] &lt;&lt; endl &lt;&lt; endl; &#125; return 0;&#125; 当然，前提是要有靠谱的板子。 J - Lowest Common Ancestor 用数组模拟二叉树，给定两个下标求它们的 LCA 的下标；很显然，用数组模拟二叉树的子节点就是 &lt;&lt;= 1；所以 LCA 显然就是在二进制表示下两个节点下标的公共前缀代表的下标。 问题就是题目给的还是恶心的 16 进制；我队友拿 Python 写过了，但是我尝试拿 C++ 写崩了…… 所以最后屈服于 Java: 12345678910111213141516171819202122232425262728import java.math.BigInteger;import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; var sc = new Scanner(System.in); int T = sc.nextInt(); sc.nextLine(); for (int i = 1; i &lt;= T; ++ i) &#123; var line = sc.nextLine(); var ab = line.split(&quot; &quot;); var a = new BigInteger(ab[0], 16); var b = new BigInteger(ab[1], 16); var aa = a.toString(2); var bb = b.toString(2); int lim = Math.min(aa.length(), bb.length()); int cur = 0; while (cur &lt; lim &amp;&amp; aa.charAt(cur) == bb.charAt(cur)) ++ cur; var prefix = aa.substring(0, cur); var c = new BigInteger(prefix, 2); System.out.printf(&quot;Case #%d: %s\\n\\n&quot;, i, c.toString(16)); &#125; &#125;&#125; 🐎的，在 C++ 我都不用 printf，在 Java 里却用的一身的劲儿（ 特别注意：因为 ACM 是只保证有 Java 8 的，所以上面的代码过不了编译（ 后记 没什么好说的…… 只能说这样的比赛差不多得了，好自为之（） H10~JZ__G1_PZGUP1YLLUJ2.jpg 但是打的还是有那么一点点捞；要是模拟题写的这么慢准度这么差那我也差不多得了（","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"https://shiraha.cn/tags/Nowcoder/"},{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/tags/%E9%A2%98%E8%A7%A3/"}]},{"title":"Codeforces Round#705 div.2 回顾","slug":"codeforces-round-705-div2","date":"2021-03-11T04:40:09.000Z","updated":"2021-03-11T04:40:09.000Z","comments":true,"path":"2021/codeforces-round-705-div2/","link":"","permalink":"https://shiraha.cn/2021/codeforces-round-705-div2/","excerpt":"","text":"补题链接：https://codeforces.com/contest/1493/ 记录 很捞，ABC 选手都没有当成，属是不是很行（ a.jpg 补了题之后发现这场甚至还算比较简单的，肺都气炸（ 题解 A - Anti-knapsack 给定 \\(n\\) 和 \\(k\\)，要求选出最大的子集 \\(S \\subset [1, n]\\)，使得不存在集合 \\(T \\subseteq S\\) 满足 \\(\\sum_{i \\in T}i = k\\)； 明明是个签到题但是我却白给一发；最开始写的是由前缀和小于 k 的数字构成小于 k 的部分，但是仔细想想就会发现这个数字集合显然不如 k / 2 大== 1234567891011121314151617181920212223signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int T = scanner.nextInt(); while (T --) &#123; int n, k; $$ n, k; int ans = n - k + k / 2; println(ans); for (int i = (k + 1) / 2; i &lt; k; ++ i) print(i, &#x27; &#x27;); for (int i = k + 1; i &lt;= n; ++ i) print(i, &#x27; &#x27;); println(); &#125; return 0;&#125; 日常脑瘫操作（ B - Planet Lapituletti 纯暴力就行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970struct fast_read&#123; template&lt;class name&gt; fast_read operator, (name &amp;x) &#123;scanner(x); return fast_read&#123;&#125;;&#125;&#125; fastRead;#define $$ fastRead,char trans[] = &#123;&#x27;0&#x27;, &#x27;1&#x27;, &#x27;5&#x27;, &#x27;-&#x27;, &#x27;-&#x27;, &#x27;2&#x27;, &#x27;-&#x27;, &#x27;-&#x27;, &#x27;8&#x27;, &#x27;-&#x27;&#125;;void mirror(const char *s, char *t)&#123; for (int i = 0; i &lt; 5; ++ i) if (s[i] == &#x27;:&#x27;) t[4 - i] = &#x27;:&#x27;; else t[4 - i] = trans[s[i] - &#x27;0&#x27;]; t[5] = 0;&#125;auto turn(const char *s)&#123; int H = (s[0] - &#x27;0&#x27;) * 10 + s[1] - &#x27;0&#x27;, M = (s[3] - &#x27;0&#x27;) * 10 + s[4] - &#x27;0&#x27;; return make_pair(H, M);&#125;void make(int H, int M, char *s)&#123; s[0] = H / 10 % 10 + &#x27;0&#x27;; s[1] = H % 10 + &#x27;0&#x27;; s[3] = M / 10 % 10 + &#x27;0&#x27;; s[4] = M % 10 + &#x27;0&#x27;; s[2] = &#x27;:&#x27;, s[5] = 0;&#125;signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int T = scanner.nextInt(), h, m; const auto validator = [&amp;](const char *s) &#123; for (int i = 0; i &lt; 5; ++ i) if (s[i] == &#x27;-&#x27;) return false; auto [H, M] = turn(s); return H &gt;= 0 &amp;&amp; H &lt; h &amp;&amp; M &gt;= 0 &amp;&amp; M &lt; m; &#125;; const auto tik = [&amp;](char *s) &#123; auto [H, M] = turn(s); ++ M; H = (H + M / m) % h; M %= m; make(H, M, s); &#125;; while (T --) &#123; char s[6], t[6]; $$ h, m, s; mirror(s, t); while (!validator(t)) tik(s), mirror(s, t); println(s); &#125; return 0;&#125; 但是代码有点花里胡哨 C - K-beautiful Strings 定义K-美丽的字符串：字符串中所有出现的字符的出现次数都是 k 的整数倍； 现在给 \\(n \\leq 10^5\\) 和 \\(k \\leq n\\)，问可以得到的字典序最小但是字典序大于等于原串的的K-美丽的字符串；如果这样的字符串不存在，输出 -1； 怎么说呢，首先需要明确以下几点： 只有字符串长度为 K 的倍数的字符串才有可能成为题目要求的字符串 因为满足要求的字符串字典序要比原串大，所以尽可能小的唯一方法是尽可能地保留前缀 同上，保留前缀后的第一位的字符一定要大于等于原串对应位置的字符 综上所述，我们可以得到一种优雅并且正确的写法： 如果原串已经是一个 K - 美丽的字符串了，就直接输出 倒序遍历可能维护的前缀长度，并维护前缀不同字符的出现次数 尝试将前缀后的第一个字符修改为任何大于原串的字符 判断除去该字符的后缀能否和前面的已确定字符组成 K - 美丽字符串 然后就可以写出这个题的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172struct fast_read&#123; template&lt;class name&gt; fast_read operator, (name &amp;x) &#123;scanner(x); return fast_read&#123;&#125;;&#125;&#125; fastRead;#define $$ fastRead,const int N = 1e5 + 5;int cnt[30];char s[N], app[N];signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int T = scanner.nextInt(), n, k, need; const auto stillNeed = [&amp;](int x) &#123;return (k - x % k) % k;&#125;; const auto alter = [&amp;](char ch, int delta) &#123; need -= stillNeed(cnt[ch - &#x27;a&#x27;]); cnt[ch - &#x27;a&#x27;] += delta; need += stillNeed(cnt[ch - &#x27;a&#x27;]); &#125;; while (T --) &#123; $$ n, k; if (n % k) &#123;println(-1); continue;&#125; memset(cnt, 0, sizeof cnt); $$ s; for (int i = 0; i &lt; n; ++ i) ++ cnt[s[i] - &#x27;a&#x27;]; for (int i = need = 0; i &lt; 26; ++ i) need += stillNeed(cnt[i]); if (!need) &#123;println(s); continue;&#125; for (int i = n - 1; i &gt;= 0; -- i) &#123; alter(s[i], -1); for (auto alt = s[i] + 1; alt &lt;= &#x27;z&#x27;; ++ alt) &#123; alter(alt, +1); if (i + need &lt; n) &#123; for (int j = 0; j &lt; i; ++ j) print(s[j]); print((char)alt); int cur = 0, res = n - i - 1; for (char ch = &#x27;a&#x27;; ch &lt;= &#x27;z&#x27;; ++ ch) &#123; int m = stillNeed(cnt[ch - &#x27;a&#x27;]); res -= m; while (m --) app[cur ++] = ch; &#125; while (res --) app[cur ++] = &#x27;a&#x27;; app[cur] = 0; sort(app, app + cur); println(app); goto complete; &#125; alter(alt, -1); &#125; &#125; complete: continue; &#125; return 0;&#125; 实际上也没有那么多需要注意的地方，关键就在于最开始写代码的思路是否正确）如果抓着修改字符来看的话，代码会难想而且难写许多，浪费比赛时间。 D - GCD of an Array 给一个长度为 \\(n \\leq 2 \\cdot 10^5\\) 的数组 \\(a\\)，满足 \\(a_i \\leq 2 \\cdot 10^5\\)； 然后对这个数组进行 \\(q \\leq 2 \\cdot 10^5\\) 次操作：单点修改为原来的 \\(x\\) 倍，且 \\(x \\leq 2 \\cdot 10^5\\)； 在每次操作后，要求输出现在数组的 gcd 对于 1e9 + 7 的模数。 STL 嗯做题：首先要意识到将所有的 \\(a_i\\) 分解成 \\(\\prod p_j^{k_i}\\) 的形式，那么 GCD 可以表示为 \\(\\prod p_j^{\\textrm{min}k_i}\\)；又因为修改只有单点倍增，GCD 只会有增无减；所以可以考虑用 STL 维护每个数组成员的分解结果，以及整个数组每个质因子的分解结果集合，需要支持查询最小值； 这样，每当进行单点修改时，我们就可以通过更新分解结果，然后更新数组质因子的维护结果，并借此更新答案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#define $$ fastRead,template &lt;int n&gt; auto &amp;EulerSieve()&#123; static vector&lt;int&gt; prime; static array&lt;int, n + 1&gt; vis; for (int i = 2; i &lt;= n; ++ i) &#123; if (!vis[i]) prime.push_back(i), vis[i] = i; for (auto &amp; pp : prime) &#123; if ((longs)i * pp &gt; n) break; vis[i * pp] = pp; if (i % pp == 0) break; &#125; &#125; return vis;&#125;const int N = 2e5 + 5;const int mod = 1e9 + 7;longs fastPow(longs a, ulongs b)&#123; longs ans = 1; while(b) &#123; if (b &amp; 1u) ans = (ans * a) % mod; a = (a * a) % mod; b &gt;&gt;= 1u; &#125; return ans % mod;&#125;signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int n, q, a; longs ans = 1; auto pp = EulerSieve&lt;N&gt;(); vector&lt;unordered_map&lt;int, int&gt;&gt; part; unordered_map&lt;int, multiset&lt;int&gt;&gt; maintain; const auto update = [&amp;](int div, int last) &#123; if (maintain[div].size() != n) return; int now = *maintain[div].begin(); ans = ans * fastPow(div, now - last) % mod; &#125;; const auto alter = [&amp;](int i, int x) &#123; while (1 != x) &#123; auto div = pp[x], cnt = 0; while (div == pp[x]) ++ cnt, x /= div; auto old = part[i][div]; part[i][div] += cnt; int last = 0; if (maintain[div].size() == n) last = *maintain[div].begin(); if (old) &#123; auto it = maintain[div].find(old); maintain[div].erase(it); &#125; maintain[div].insert(old + cnt); update(div, last); &#125; &#125;; $$ n, q, part.resize(n + 1); for (int i = 1; i &lt;= n; ++ i) $$ a, alter(i, a); int i, x; while (q --) $$ i, x, alter(i, x), println(ans); return 0;&#125; E - Enormous XOR 对于两个大整数 \\(l\\) 和 \\(r\\)（\\(l \\leq r\\)），定义函数： \\(G_{l, r} = \\bigoplus_{i=l}^ri\\)，\\(F _ {l, r} = \\mathrm{max} _ {l \\leq x \\leq y \\leq r} G _ {x, y}\\)； 现在给定 \\(l\\) 和 \\(r\\) 的二进制表示形式（\\(l \\leq r &lt; 2^{10^6}\\)）；要求求出 \\(F_{l, r}\\) 的值。 抖机灵题：令 \\(l\\) 和 \\(r\\) 的最高位分别为 \\(H_l\\)，\\(H_r\\)； 如果 \\(H_l \\ne H_r\\)，那么显然有 \\(F_{l, r} = 2^{H_r + 1} - 1\\)：因为 \\(2^{H_r},\\ 2^{H_r} - 1 \\in [l, r]\\) 显然成立，而 \\(2^{H_r} \\oplus (2^{H_r} - 1) = 2^{H_r + 1} - 1\\)；否则，答案至少有最大值 \\(r\\)；考虑选出答案的区间：为了保持可能存在的最高位存在，得到答案的区间 \\([x, y]\\) 的大小必定是奇数；且不难想到其中 \\(y = r\\)； 我们考虑 \\(r\\) 的奇偶性： 如果 \\(r\\) 为奇数，因此除了最大的一个数字之后，最大的数字是 \\(r - 1\\)——除了奇数位之外和 \\(r\\) 完全一致；不难发现区间中的数字是成对出现的，因此 \\(r\\) 能确定保留的位只有奇数位，不如 \\(r\\) 优； 如果 \\(r\\) 为偶数，同理，显然最低位（奇偶位）必然为 1，所以异或值为 \\(r + 1\\)，更优； 但是以上操作都要建立在区间 \\([l, r]\\) 允许的情况下；如果允许区间小于 3，则无法进行上述操作，答案为 \\(r\\)； 1234567891011121314151617181920212223242526272829303132333435363738394041#define $$ fastRead,const int N = 1e6 + 5;char l[N], r[N], ans[N], tmp[N];signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int n = scanner.nextInt(); $$ l, r; int hl = 0, hr = 0; while (l[hl] != &#x27;1&#x27;) ++ hl; while (r[hr] != &#x27;1&#x27;) ++ hr; if (hl != hr) &#123; for (int i = min(hl, hr); i &lt; n; ++ i) ans[i] = &#x27;1&#x27;; for (int i = 0; i &lt; min(hl, hr); ++ i) ans[i] = &#x27;0&#x27;; ans[n] = &#x27;\\0&#x27;; &#125; else if (r[n - 1] == &#x27;1&#x27;) memcpy(ans, r, sizeof ans); else &#123; memcpy(tmp, r, sizeof tmp); for (int i = n - 2; i &gt;= 0; -- i) if (tmp[i] == &#x27;1&#x27;) &#123;tmp[i] = &#x27;0&#x27;; break;&#125; else tmp[i] = &#x27;1&#x27;; memcpy(ans, r, sizeof ans); if (strcmp(tmp, l) &gt;= 0) ans[n - 1] = &#x27;1&#x27;; &#125; println(ans); return 0;&#125; F - Enchanted Matrix 这是一个交互题；有一个 \\(n \\times m\\) 的矩阵，求合法的 \\((x, y)\\) 的数对个数： 合法的 \\((x, y)\\) 数对的定义：可以将原矩阵完整的划分为一些 \\(x \\times y\\) 的子矩阵，这些子矩阵相等。 最多可以询问 \\(3 \\cdot \\lfloor \\textrm{log}_2(n + m) \\rfloor\\) 次两个不相交的子矩阵是否相等。 分析 首先可以意识到这个问题中行列是互相独立的问题：显然有 [x, y] === [x, m] &amp;&amp; [n, y] 然后再一个显然的就是要求出这个数对，必须要先求出行列方向上的最短循环节，再由循环节凑出其他的答案——这是一个很常见的套路：串的分多段全等的问题可以转化为找它的最短循环节。 如何在单维（也就是一个串）中寻找最短的循环节呢？我们首先利用筛预处理出范围内整数的质因数分解，然后以每一个质因数作为本次分段数，在上一次分割后的循环节上进行尝试；最后剩下的没有被除去的质因数的乘积就是最短循环节的长度。 那么如何判断分出的段在当前串中是否是循环节呢？ 首先，如果不考虑重叠的限制条件，对于任何串的候选循环节；我们先令该串包含了 \\(L\\) 个候选循环节，候选循环节的长度为 \\(x\\)：这样，我们只需要比较原串长度为 \\((L - 1)x\\) 的前缀和长度为 \\((L - 1)x\\) 的后缀是否相等即可；也就是前 \\(L - 1\\) 节和后 \\(L - 1\\) 节是否相等；这也是很容易证明的； 但是题目限制了不允许询问重叠的区间，所以上述做法在这并不可行；但是我们还是可以基于这种思路，采用迂回的办法来完成询问；因为我们每次都是对于一个串（原串或者已经被分割后的），使用它长度的质因数来作为划分段数；令划分的段数为 \\(L\\)，这里的段显然和上面说的候选循环节由相同的意义。 因为 \\(L\\) 是质因数，所以只有可能是两种情况： \\(L = 2\\)，此时直接询问两段是否相等即可； \\(L &gt; 2\\)，此时 \\(L\\) 必定是奇数；令 \\(l = \\lfloor \\frac{L}2 \\rfloor\\)； 我们选取前 \\(l\\) 段作为中转，那么还剩下连续的 \\(l + 1\\) 段 剩下的 \\(l + 1\\) 段也是奇数，可以使用最初说的方法进行判断 但是我们不直接比较重叠的两段，而是让它们分别于前面选出的中转段进行比较 这样就可以在 2 次询问之内判断一个候选循环节是否是串的循环节 综上所述，我们就可以在题目规定的询问次数之内完成最小循环节的求解了； 还需要特别注意的是，答案并不是最小循环节划分的段数的乘积；而是划分段数的因数个数的乘积。 代码 下面代码的欧拉筛以经过修改：可以使用代码中的办法从小到大地获取一个整数的质因数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const int N = 1005;int ask(int h, int w, int x1, int y1, int x2, int y2)&#123; cout &lt;&lt; &quot;? &quot; &lt;&lt; h &lt;&lt; &#x27; &#x27; &lt;&lt; w &lt;&lt; &#x27; &#x27; &lt;&lt; x1 &lt;&lt; &#x27; &#x27; &lt;&lt; y1 &lt;&lt; &#x27; &#x27; &lt;&lt; x2 &lt;&lt; &#x27; &#x27; &lt;&lt; y2 &lt;&lt; endl; int tmp; cin &gt;&gt; tmp; return tmp;&#125;template &lt;int n&gt; auto &amp;sieve()&#123; static vector&lt;int&gt; prime; static array&lt;int, n + 1&gt; vis; for (int i = 2; i &lt;= n; ++ i) &#123; if (!vis[i]) prime.push_back(i), vis[i] = i; for (auto &amp; pp : prime) &#123; if ((longs)i * pp &gt; n) break; vis[i * pp] = pp; if (i % pp == 0) break; &#125; &#125; return vis;&#125;signed main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);#if 0 freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);#endif int n, m; auto p = sieve&lt;N&gt;(); const auto askM = [&amp;](int len, int time) -&gt; bool &#123; const auto h = n, w = time / 2 * len; if (time == 2) return ask(h, w, 1, 1, 1, w + 1); else return ask(h, w, 1, 1, 1, w + 1) &amp;&amp; ask(h, w, 1, 1, 1, w + len + 1); &#125;; const auto askN = [&amp;](int len, int time) -&gt; bool &#123; const auto h = time / 2 * len, w = m; if (time == 2) return ask(h, w, h + 1, 1, 1, 1); else return ask(h, w, h + 1, 1, 1, 1) &amp;&amp; ask(h, w, h + len + 1, 1, 1, 1); &#125;; cin &gt;&gt; n &gt;&gt; m; auto [nn, mm] = make_pair(n, m); for (int i = nn; i &gt; 1; i /= p[i]) if (askN(nn / p[i], p[i])) nn /= p[i]; for (int i = mm; i &gt; 1; i /= p[i]) if (askM(mm / p[i], p[i])) mm /= p[i]; const auto nt = n / nn, mt = m / mm; longs np = 0, mp = 0; for (int i = 1; i &lt;= nt; ++ i) np += !(nt % i); for (int i = 1; i &lt;= mt; ++ i) mp += !(mt % i); cout &lt;&lt; &quot;! &quot; &lt;&lt; np * mp &lt;&lt; endl; return 0;&#125; 最后不能直接输出 nt * mt！ 后记 参考资料 https://www.cnblogs.com/zjjws/p/14500255.html https://codeforces.com/blog/entry/88422","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://shiraha.cn/tags/Codeforces/"}]},{"title":"使用又拍云联盟作为博客的图床","slug":"use-upyun-free-service-to-host-a-image-service","date":"2021-03-05T07:43:32.000Z","updated":"2021-03-05T07:43:32.000Z","comments":true,"path":"2021/use-upyun-free-service-to-host-a-image-service/","link":"","permalink":"https://shiraha.cn/2021/use-upyun-free-service-to-host-a-image-service/","excerpt":"","text":"当然，现在市面上已经有了一些既可以白嫖而且质量不错的免费图床，可以为我们的静态博客提供图片存储服务：比如 SM.MS 和 去不图床 和 Github；但是把图片放在别人的图床上总觉得不太安定，再加上又拍云长期有活动赠送 10 GB 存储空间和 15 GB 流量每月，所以考虑利用又拍云搭建一个个人图床。 申请又拍云联盟 首先前往又拍云注册账号，然后进入又拍云联盟的活动页面选择申请； 申请又拍云联盟唯二的要求是实名和将又拍云的 logo 置于一个你的网站的底部，大概就像这样： 本网站由 提供 CDN 加速/云存储服务 如果你是使用 Hexo 等静态网站生成器生成你的个人网站，可以在你使用的主题的文档中寻找修改配置文件来自定义网站 footer 的方法；或者将下面的 HTML 片段增加到对应的布局文件中去：对于 Hexo 的大多数主题，这个文件往往是位于主题的 layout 目录下的 layout.ejs 或者 footer.ejs 中。 1&lt;span&gt;本网站由 &lt;img src=&quot;https://cdn.jsdelivr.net/gh/YukiNoUta/cdn-static@main/blog/svg/upyun.svg&quot; width=&quot;53&quot; height=&quot;18&quot; style=&quot;fill: currentColor;&quot;/&gt; 提供 CDN 加速/云存储服务&lt;/span&gt; 这里使用的图片来源是我预置于 Github 上的；你也可以从官网下载它的 logo 并且至于一个可以访问的位置。 又拍云审核完了之后，你就应该会获得一张 67 元的代金券。 开启服务 前往又拍云的控制台，登录已经申请又拍云联盟的账号；在导航栏中的云产品下选择云存储服务；点击右上角的按钮创建新服务；为这个服务提供一个名字，就创建了一个存储桶。 YJX_P7PQF_FH_N_XM8YUA.png 创建完成之后，就可以在你的控制台页面中看到你创建的存储桶： SLVV_B5T@QHB_2_WQH_HN5A.png 然后进入刚创建的云存储服务，进行功能配置： 3BQS_O_1S0CZKJ_P_4F_CV7.png 配置操作员 有了存储桶之后，还需要一个对这个存储桶拥有读写权限的主体才可以进行操作；在又拍云中，这个主体就是操作员；在功能配置中选择存储管理子项，下拉页面找到操作员授权选项，点击右侧按钮“授权”。 默认新用户是没有操作员的，需要先新建一个操作员身份；创建之后需要将网页生成的操作员的密钥保存备用，然后将存储桶的读写权限赋予操作员即可。操作完成后大概长这样： O1R8UU_7S_5N___9BD_D_LU.png 防盗链设置 理论上现在已经可以使用刚创建的操作员身份上传图片了，但是还需要为我们的存储桶增加访问控制：云上服务的流量是有成本的，如果不做防盗链，我们的图片链接可能会被他人引用，从而产生不必要的流量。现在一般的云服务提供商的 OSS 服务都会提供防盗链的配置选项；又拍云的防盗链配置项在“访问控制”一栏中；找到并点击右侧的管理按钮进入配置： EG_ORH__6E__JC6JWVWO~F.png 需要注意的是：图中的通配符 *.shiraha.cn 和 @（也就是 shiraha.cn）并不等价；如果你和我一样直接使用 @，你需要额外增加一条允许的规则。 关于 Referer 的科普 Referer 是 HTTP 请求的 header 的一部分；当浏览器或者其他的软件要向 Web 服务器发起请求时，请求头中就包含了这一信息。它记录了当前页面的上一页面：打个比方，我从这个博客（https://shiraha.cn）点击了黄油画廊，那么浏览器发起的请求中就可以看到我这个博客的地址： E6YSUL_CFW1BW@_MH____LD.png 上面的这个画面可以在任何现代浏览器的开发者工具-&gt; 网络栏目中看到。 轶闻：其实 Referer 本是 Referrer 在 HTTP/1.0 协议中的错误拼写甚至现在还会被 Typora 和 Microsoft Editor 划线 Typo，只是因为矫正成本过大才一直将错就错；然而现在已经被收录作为一个正确的词汇了典型的鲁迅式将错就错 综上所述，一般情况下，我们可以使用 Referer 来判断我们的页面/链接是否被其他的网站所引用——或者说盗用了；在防盗链的时候，我们就可以拦截 Referer 不是我们想要的网址的请求，并且跳转到服务器想要跳转的页面去。 关于空 Referer 空 Referer 的定义：Referer === '' || Referer === null；通俗的说，就是请求头中的 Refer 字段为空串或者不包含 Referer 字段。 前面已经说过了，Referer 的含义就是当前页面的上一个页面（请求的地址）；如果这个请求地址是不存在的话，Referer 字段自然就为空。当然，使用某些工具也可以造成这样的结果。 在防盗链中，如果设置了允许 Referer 为空，就意味着你允许浏览器或者重定向通过直接 URL 访问你的资源；如果不允许，那么这些请求将被拦截。 一般来说我们通过白名单限制只有我们自有的域名来访问我们的存储桶；至于 localhost 则是取决于你是否希望在本地测试你的博客的时候访问你上传到图床的图片：如果不包含这条，你在本地运行你的静态博客的时候，这部分图片是无法加载的。Referer 的含义已经介绍了；但是就实际应用而言，不允许 Referer 为空会使得无法通过链接下载你的图片和 Typora 的预览。 P_Z0LYI9_C0A_938NR_17.png 配置完了选择应用大概就会便乘上面的那个样子。 绑定域名（可选） 因为又拍云对于存储桶提供的只是一个测试域名；我们虽然可以通过这个域名访问我们的存储桶数据，但是又拍云并不保证我们可以长期使用这个域名；所以，如果你拥有一个二级域名，可以考虑将一个子域名分配给这个 OSS 服务，并且启用 SSL。当然，因为又拍云的服务在大陆，所以你使用的这个域名需要先行备案。 在功能配置页面的“域名管理”一栏中找到加速域名项，点击右边的域名绑定，就可以将一个已经有过 ICP 备案的域名绑定到这个服务中。至于 ICP 备案，它要求你（主体）需要拥有一台有公网 IP 地址的云服务器，所以你可能需要去各大云服务提供商的网站上看看了。 成功绑定后，你就可以在功能配置页面的“HTTPS”一栏找到 HTTPS 配置选项；点击右侧管理，就可以设置你绑定的域名的 HTTPS 设置：你可以开启强制 HTTPS 访问，这样就可以避免在开启了 HTTPS 博客中引用 HTTP 链接的图片可能导致的各种各样的问题。 开启 HTTPS 之前，你需要为你绑定的子域名申请一个 SSL 证书：很多云服务商在出售域名或者提供 DNS 服务的时候会提供配套的申请免费 TrustAsia 或者 Let's Encrypt 的证书，如果没有的话，你也可以直接在又拍云上申请；而这只需要遵循又拍云的页面指导就可以轻松完成，而且还是秒批（ 使用 PicGo 客户端 和一般的公开图床不同，我们需要直接或者通过 API 访问我们的存储桶，而不是一个直观的网页；如果每次上传图片都需要打开又拍云控制台必然是非常的麻烦的；一种比较方便的方法就是使用开源工具 PicGo。 配置 PicGo 访问又拍云 从官方网站中下载 PicGo 并成功安装之后运行：在左侧栏中找到图床设置 -&gt; 又拍云图床，会看到下面的画面： 79_HOFOY9VPCWP6K9_4DDHY.png 其中前四项为必填项，分别要填入的内容是：又拍云服务名（存储桶名）、你授权的操作员名、网页生成的操作员密钥、又拍云提供的测试域名或你绑定的域名；为了方便管理，你也可以指定你通过 PicGo 上传的图片在存储桶的存储位置；“设定网址后缀”是又拍云提供的功能，可以自行探索（ 填入信息并保存后，就可以将又拍云设置为默认图床，并上传图片进行测试了。 连接 Typora 较新版本的 Typora 支持插入图片式自动通过 PicGo 上传，所以在开始本步骤之前需要先确保你使用的 Typora 是新版本：否则请先前往官网下载最新版本。 首先先配置 PicGo：在左侧的 PicGo 设置中找到“设置Server”项；PicGo 理论上是默认设置了这一项的，但是仍然要确保它已经开启；如果你需要进行图片的版本控制，也可以开启在“设置Server”下面的一些重命名的选项；开启的界面如下： _M__2_6_YS2JX@AU__P@N0.png 然后打开新版的 Typora，在偏好设置-&gt;图像中设置插入图片时上传图片；并在上传服务设定中指定使用PicGo (app)，并指定 PicGo 的安装路径；最后点击验证图片的上传选项按钮测试。 U0W_~@_ZRT3_PAK6DOGT_TO.png 设置完成后，当你在使用 Typora 进行 Markdown 写作时，就可以简单地将图片拖进 Typora 中，它将自动使用 PicGo 上传图片到指定的默认云服务中。 上传图片测试 下面是一张来自于刚部署的图床的图片： test 因为我开启了空 Referer 防盗链，并在白名单中加入了 localhost，因此它在开发模式下（localhost）可以访问；但是如果复制链接直接在浏览器窗口中或者使用 Typora 打开它的源文件，都无法预览。 如果出现了错误，还可以在 PicGo 设置中查看它的日志文件。","categories":[{"name":"折腾记录","slug":"折腾记录","permalink":"https://shiraha.cn/categories/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://shiraha.cn/tags/hexo/"},{"name":"云服务","slug":"云服务","permalink":"https://shiraha.cn/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/"}]},{"title":"2019 CCPC 秦皇岛区域赛 回顾","slug":"2019-ccpc-qinhuangdao","date":"2020-09-18T10:57:43.000Z","updated":"2020-09-18T10:57:43.000Z","comments":true,"path":"2020/2019-ccpc-qinhuangdao/","link":"","permalink":"https://shiraha.cn/2020/2019-ccpc-qinhuangdao/","excerpt":"","text":"写在前面 已经有相当一段时间没有写过博客了；也许是因为牛客多校某次讲评时老师说的：如果为了写博客而写博客，那么写博客对于个人而言又有多少除了心理满足之外的意义呢？这句话一时间使我陷入了迷惘—— 应当警惕隐藏在其中的形式主义（ 但是在漫长的补题不写博客的日子后，我渐渐发现博客的优点也确实存在：比如客观上可以加深对于题目的印象；外加如今 8 个月的寒假已经结束，是时候重新启用这个博客记录题解了。 废话少说，那么从今往后（包括那些今天之后修改的博文）的博文，如果是题解，就尽量控制废话数量：不再包含题目的详细的翻译什么的（但根据情况可能会有一句话的大意描述），也不会按照顺序一个题一个题的创建标题了——完全根据补题情况——也就是说补了几个写几个；虽然少了很多东西，但是会包括必须的资源下载的链接；至于每一个具体的题目，简单的讲解思路就直接贴代码了。 团队链接：https://vjudge.net/contest/395445/ 比赛链接：https://codeforces.com/gym/102361/ 没有找到官方的题解幻灯片 / PDF D - Decimal 老签到题了，大胆猜测只有 2 和 5 的数字满足要求，就过了（ 但是考场却 WA 了一发，还搞了半天，离谱儿 代码 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;using longs = long long;using uint = unsigned;inline int nextInt()&#123; int x = 0, f = 0, ch = getchar(); while (!isdigit(ch)) ch == &#x27;-&#x27; &amp;&amp; (f = !f), ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;&#125;int main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int t = nextInt(); while (t --) &#123; int n = nextInt(); while (n % 2 == 0) n /= 2; while (n % 5 == 0) n /= 5; printf(n == 1 ? &quot;No\\n&quot; : &quot;Yes\\n&quot;); &#125; return 0;&#125; F - Forest Program 也是个简单的题目；给一个包含一些树和仙人掌树的“森林”，你可以删除一些边以破坏掉全部的仙人掌树，使得得到的森林仅包含树；求模意义下达到目标的方案数； 仙人掌树，指的是那些不包含自环和重边，每一条边可能且最多只属于一个简单环的连通图。 思路 如果一个图是树，又或者是森林，那么随便怎么删边，它都一定满足题目要求，那么假设这个森林里有 m 个边，方案数量就是 \\(2^m\\) 种； 如果一个连通图是仙人掌，且假设它一共有 m 条边，含有一个边长为 c (m &gt; c) 的环，那么： 不属于环的部分：和上面一般树/森林一样，可以随意删除 属于环的部分：环内可以随意删除，但是至少要删去 1 条边 那么可以通过简单的 DFS 找到所有的环，然后根据上面的结论，将非环部分和每一个环分别处理，然后结果乘起来就得到的了答案； 代码 需要注意输入的图可能包含多个连通块，需要进行处理后才能计算答案 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;functional&gt;#include &lt;bitset&gt;#include &lt;vector&gt;using namespace std;using longs = long long;using uint = unsigned;inline int nextInt()&#123; int x = 0, f = 0, ch = getchar(); while (!isdigit(ch)) ch == &#x27;-&#x27; &amp;&amp; (f = !f), ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;&#125;struct edge&#123; int u, v, w, next; edge() = default; edge(int u, int v, int w, int next) : u(u), v(v), w(w), next(next) &#123;&#125;&#125;;const int N = 3e5 + 5, M = 5e5 + 5;const int inf = 0x3f3f3f3f;const longs mod = 998244353;longs fastPow(longs a, longs b)&#123; longs ans = 1; while (b) &#123; if (b &amp; 1) ans = (ans * a) % mod; a = (a * a) % mod; b &gt;&gt;= 1; &#125; return ans % mod;&#125;namespace FWS&#123; int head[N]; int tot; edge ee[M * 2]; void init(int n = N - 1) &#123; memset(head, -1, sizeof(int) * (n + 1)); tot = 0; &#125; void addEdge(int u, int v, int w) &#123; ee[tot] = edge(u, v, w, head[u]); head[u] = tot ++; &#125; inline void forEach(int st, const function&lt;void(edge&amp;)&gt;&amp; func) &#123; for (int c = head[st]; ~c; c = ee[c].next) func(ee[c]); &#125;&#125;vector&lt;int&gt; ring;bitset&lt;N&gt; vis;int dfn[N];void dfs(int u, int p)&#123; dfn[u] = dfn[p] + 1; vis[u] = true; FWS::forEach(u, [&amp;](edge &amp;e) &#123; if (e.v == p) return; if (dfn[e.v]) if (dfn[u] &gt; dfn[e.v]) ring.push_back(dfn[u] - dfn[e.v] + 1); else; else dfs(e.v, u); &#125;);&#125;int main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); auto n = nextInt(), m = nextInt(); FWS::init(n); auto cnt = m; while (m --) &#123; int u = nextInt(), v = nextInt(); FWS::addEdge(u, v, 0); FWS::addEdge(v, u, 0); &#125; dfn[0] = 0, dfs(1, 0); for (int i = 1; i &lt;= n; ++ i) if (!vis[i]) dfs(i, 0); for (auto ii : ring) cnt -= ii; auto ans = fastPow(2, cnt); for (auto ii : ring) &#123; auto t = fastPow(2, ii); t = (t - 1 + mod) % mod; ans = ans * t % mod; &#125; printf(&quot;%lld\\n&quot;, ans); return 0;&#125; 不要看到树上有环就满脑子 tarjan 啊 kora，好好地区别 SCC 和环啊草！ I - Invoker 简单的 DP；虽然看起来吓死人，但是三个字母长的序列翻来覆去也就六种情况，直接暴力转移完全大丈夫 于是就有了下面这种在考场上写的丑陋代码 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;array&gt;#include &lt;unordered_map&gt;#define VAR(var) &quot;&quot;#var&quot; = &quot; &lt;&lt; varusing namespace std;using longs = long long;using uint = unsigned;inline int nextInt()&#123; int x = 0, f = 0, ch = getchar(); while (!isdigit(ch)) ch == &#x27;-&#x27; &amp;&amp; (f = 1), ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;&#125;const int N = 1e5 + 5;longs dp[N][6];unordered_map&lt;char, string&gt; mm[6];string s;inline void mov(int x)&#123; int a = x - 1, b = x; char aa = s[a - 1], bb = s[b - 1]; if (aa == bb) &#123; for (int i = 0; i &lt; 6; ++ i) dp[b][i] = dp[a][i]; return; &#125; for (int j = 0; j &lt; 6; ++ j) &#123; dp[x][j] = 0x3f3f3f3f3f3f3f3f; for (int i = 0; i &lt; 6; ++ i) &#123; auto add = 0; if (mm[i][aa][1] == mm[j][bb][0] &amp;&amp; mm[i][aa][2] == mm[j][bb][1]) add = + 1; else if (mm[i][aa][2] == mm[j][bb][0]) add = + 2; else add = + 3; dp[x][j] = min(dp[x][j], dp[x - 1][i] + add); &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); auto &amp;m = mm[0]; m[&#x27;Y&#x27;] = &quot;QQQ&quot;, m[&#x27;V&#x27;] = &quot;QQW&quot;, m[&#x27;G&#x27;] = &quot;QQE&quot;, m[&#x27;C&#x27;] = &quot;WWW&quot;, m[&#x27;X&#x27;] = &quot;QWW&quot;; m[&#x27;Z&#x27;] = &quot;WWE&quot;, m[&#x27;T&#x27;] = &quot;EEE&quot;, m[&#x27;F&#x27;] = &quot;QEE&quot;, m[&#x27;D&#x27;] = &quot;WEE&quot;, m[&#x27;B&#x27;] = &quot;QWE&quot;; for (auto &amp;ii : m) &#123; for (int i = 1; i &lt; 6; ++ i) mm[i][ii.first] = m[ii.first]; swap(mm[1][ii.first][1], mm[1][ii.first][2]); swap(mm[2][ii.first][0], mm[2][ii.first][1]); mm[3][ii.first] = mm[2][ii.first]; swap(mm[3][ii.first][1], mm[3][ii.first][2]); mm[4][ii.first] = mm[1][ii.first]; swap(mm[4][ii.first][0], mm[4][ii.first][1]); mm[5][ii.first] = mm[4][ii.first]; swap(mm[5][ii.first][1], mm[5][ii.first][2]); &#125; cin &gt;&gt; s; for (int i = 0; i &lt; 6; ++ i) dp[1][i] = 3; auto siz = s.length(); for (int i = 1; i &lt; siz; ++ i) mov(i + 1); longs ans = dp[siz][0]; for (int i = 1; i &lt; 6; ++ i) ans = min(dp[siz][i], ans); cout &lt;&lt; ans + siz &lt;&lt; endl; return 0;&#125; J - MUV LUV EXTRA 给定参数 a 和 b，记截断小数的小数部分的循环节长度为 l，出现的循环节循环部分长度为 p，要求计算 \\[ a \\times p - b \\times l \\] 的最大值；a 和 b 均为正整数； 思路 本来还以为要考虑 a 和 b 的大小关系，考虑什么单调性什么什么的，结果连怎么找到循环节都没想出来，经济基础都没建立还满脑子上层建筑，跟个脑瘫似的（笑）一直听着隔壁队伍大声吵吵 KMP，也没做出这个题== 但是它确实是脑瘫 KMP 题； 一般 KMP 找到的是什么？模式串所有前缀的 border —— 也就是最长的公共真前后缀；这样当模式串在后缀的后面匹配失败的时候，就可以直接原地起飞回到前缀的后面，省去了前缀部分的匹配。 这个题目要关注的是被截断的小数部分，可以看成字符串；因为要求的循环节是从后面延申的，所以求所有前缀的 border 并无卵用，应该求后缀的 border；因此我们 KMP 之前需要翻转小数部分 那么我们可以发现，原本 KMP 中的 border 的前缀部分现在变成后缀，后缀变成了前缀；现在的后缀和前缀依然是相等的；这样就符合了循环小数的定义：我们可以把字符串后缀除了 border 后缀部分的部分看作是循环节，后缀 border 看作是循环节的延申，就可以对于每一个后缀求出 p 和 l 了； 这里本来有张图，但是画错了…… 需要注意的是这并没有覆盖全部的情况：比如字符串 ...ABCABCA，它只考虑了 l = 3, p = 4 和 l = 3, p = 7 的情况，没有考虑到 l = 6 和 p = 7 的情况，但是因为 a 和 b 都是正整数，所以显然 l 较小的时候比较占优势；因为 border 是最大的真公共子串，所以它一定会包含所有可以包含的部分，所以它总是会包含最优的 l； 如果不是这样的话这就变得有点麻烦了（ 代码 注意：因为字符串的下标从 0 开始，所以 p = 0 （即第一位失配）的值是无意义的，不应该考虑； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;cassert&gt;using namespace std;using longs = long long;using uint = unsigned;inline int nextInt()&#123; int x = 0, f = 0, ch = getchar(); while (!isdigit(ch)) ch == &#x27;-&#x27; &amp;&amp; (f = !f), ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;&#125;const int N = 1e7 + 5;template &lt;class T&gt;void buildKMP(const T *arr, vector&lt;int&gt; &amp;kmp, int length)&#123; kmp.resize(length + 1); int i = 0, j = kmp[0] = -1; while(i &lt; length) if(-1 == j || arr[i] == arr[j]) &#123; ++ i, ++ j; if (i == length || arr[i] != arr[j]) kmp[i] = j; else kmp[i] = kmp[j]; &#125; else j = kmp[j];&#125;int main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); string s; longs a, b; cin &gt;&gt; a &gt;&gt; b; getline(cin, s, &#x27;.&#x27;); getline(cin, s, &#x27;\\n&#x27;); reverse(s.begin(), s.end()); vector&lt;int&gt; kmp; buildKMP(s.c_str(), kmp, s.size()); const auto siz = s.size(); longs ans = -0x3f3f3f3f3f3f3f3f; for (int p = 1; p &lt;= siz; ++ p) &#123; int l = p - kmp[p]; ans = max(ans, a * p - b * l); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 此外还有需要注意的是：上面代码的优化后的 KMP 求出的并不是严格的 border，虽然就算不管这个还是可以过掉这道题就是了，但是也许可以进行更深层次的讨论； E - Escape 一个 n * m 的矩阵，有的位置有墙，其他的可以通行；在第一行的上面有 a 个机器人，在最后一行下面有 b 个出口；机器人只能走直线，但是你可以加入转向器（两个方向对换，但是阻止另外两个方向）改变机器人前进的方向；问 a 个机器人是否都能够到达出口； 思路 有的人看到只有 100 的数据范围就想到了网络流，有的人看到了 a 进 b 出想到网络流，还有的人纠结了转向器的含义纠结了半个小时 首先给出结论：若可以到达终点，任何两个机器人的行动路线之间一定不会有长度大于 0 的公共部分；或者说，不会有两个机器人通过同一个转向器；解释如下： 若没有障碍，没有转向器：一个入口格子上只能有一个机器人；他们直走，互相平行； 若它们经过了同一个转向器转向：那么转向前它们的方向相同，但这样的机器人对在起点就不存在； 若他们被不同的转向器转到同一方向：在前面的转向器一定会阻挡后面的机器人； 因此，可以得到推论：每一个格子只可以被横着通过一次，竖着通过一次；若转向，会同时占用横竖； 综上所述，可以建立网络流：在空格子之间建立双向边，在“横格子”和“竖格子”之间建立双向边，跑最大流即可；若最大流等于机器人总数，则满足题目要求。 代码 网络流最大流的图中可以出现重边！不用担心，嗯流就完事了（ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;functional&gt;#include &lt;queue&gt;#define USE_DINICusing namespace std;using longs = long long;using uint = unsigned;inline int nextInt()&#123; int x = 0, f = 0, ch = getchar(); while (!isdigit(ch)) ch == &#x27;-&#x27; &amp;&amp; (f = !f), ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;&#125;const int X = 110;char g[X][X];int p[X], e[X];int n, m, t, a, b;int h[X][X], v[X][X];using number = int; // 设置流量数据类型const int N = X * X * 3, M = N * 10;struct edge&#123; int u, v, next; number w; edge() = default; edge(int u, int v, number w, int next) : u(u), v(v), w(w), next(next) &#123;&#125;&#125;;namespace FWS&#123; int head[N]; int tot; edge ee[M * 2]; using method = function&lt;void(const edge &amp;e)&gt;; void init(int n = N - 1) &#123; memset(head, -1, sizeof(int) * (n + 1)); tot = 0; &#125; int addEdge(int u, int v, number w) &#123; ee[tot] = &#123;u, v, w, head[u]&#125;; return head[u] = tot ++; // 返回加入的边的编号，方便处理重边 &#125; void forEach(int u, const method &amp;iter) &#123; for (auto ii = head[u]; ii != -1; ii = ee[ii].next) iter(ee[ii]); &#125;&#125;namespace FN&#123; constexpr int inf = 0x3f3f3f3f; // 严格匹配 number，不要自动转型！ int S, T, total = 0; // 重新建图之后的节点数 int addEdge(int u, int v, number w) &#123; auto pos = FWS::addEdge(u, v, w); FWS::addEdge(v, u, 0); return pos; &#125;#ifdef USE_DINIC /** * Dinic 算法 * O (n²m) * * - 在残量网络上使用 BFS 构造分层图 * - 在分层图上 DFS 寻找增广路，并更新边权 * - 当前弧优化：避免寻找不可能增广的边 */ namespace Dinic &#123; number dis[N]; int cur[N]; // 当前弧优化 // 先创建分层图 bool bfs() &#123; using namespace FWS; static queue&lt;int&gt; q; memset(dis, 0x3f, sizeof(number) * (total + 1)); q.push(S); dis[S] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int cc = head[u]; cc != -1; cc = ee[cc].next) &#123; edge&amp; e = ee[cc]; int v = e.v; auto w = e.w; cur[u] = head[u]; if (!w || dis[v] &lt;= dis[u] + 1) continue; dis[v] = dis[u] + 1; q.push(v); &#125; &#125; return dis[T] != inf; &#125; number dfs(int u, number inflow) &#123; using namespace FWS; if (u == T) return inflow; number outflow = 0, rest = inflow; for (int &amp;cc = cur[u]; cc != -1; cc = ee[cc].next) // 当前弧优化 &#123; edge &amp;e = ee[cc], &amp;r = ee[uint(cc) ^ 1u]; int v = e.v; auto w = e.w; if (!w || dis[v] != dis[u] + 1) continue; int t = dfs(v, min(w, rest)); outflow += t; e.w -= t; r.w += t; rest -= t; if (!rest) break; &#125; if (!outflow) dis[u] = 0; return outflow; &#125; number go() &#123; number maxFlow = 0; while (bfs()) maxFlow += dfs(S, inf); return maxFlow; &#125; &#125;#elif defined USE_ISAP /** * Improved Shortest Augumenting Path * O (n²m)，比起 Dinic 算法只需要一次 BFS * * - 反向 BFS 并标记节点深度 * - 正向 DFS，用尽节点的出流时回溯加深深度 * - gap 优化：当某一深度不再包含节点时停止搜索 * - 当 S 的深度达到 n 时，搜索一定结束 * * 和 Dinic 类似，本算法也可以进行当前弧优化 */ namespace ISAP &#123; int dep[N], gap[N]; // 节点的深度 &amp; 特定深度节点的数量 number maxFlow = 0; int cur[N]; // 当前弧优化 void bfs() &#123; memset(dep, -1, sizeof dep); memset(gap, 0, sizeof gap); dep[T] = 0, gap[0] = 1; queue&lt;int&gt; q; q.push(T); using namespace FWS; while (!q.empty()) &#123; auto u = q.front(); q.pop(); for (int cc = head[u]; cc != -1; cc = ee[cc].next) &#123; edge&amp; e = ee[cc]; int v = e.v; if (dep[v] != -1) continue; q.push(v); ++ gap[dep[v] = dep[u] + 1]; &#125; &#125; &#125; number dfs(int u, number flow) &#123; if (u == T) return maxFlow += flow, flow; number used = 0; using namespace FWS; for (int cc = head[u]; cc != -1; cc = ee[cc].next) &#123; edge&amp; e = ee[cc], &amp;r = ee[uint(cc) ^ 1u]; int v = e.v; auto w = e.w; if (!w || dep[v] + 1 != dep[u]) continue; auto t = dfs(v, min(w, flow - used)); if (t) e.w -= t, r.w += t, used += t; if (used == flow) return used; &#125; if (-- gap[dep[u]] == 0) dep[S] = total + 1; ++ gap[++ dep[u]]; return used; &#125; number go() &#123; maxFlow = 0; bfs(); while (dep[S] &lt; total) memcpy(cur, FWS::head, sizeof(int) * (total + 1)), // 当前弧优化 dfs(S, inf); return maxFlow; &#125; &#125;#endif void setInfo(int s, int t, int cnt) &#123;FN::S = s, FN::T = t, FN::total = cnt;&#125;&#125;bool in(int r, int c)&#123;return r &gt; 0 &amp;&amp; r &lt;= n &amp;&amp; c &gt; 0 &amp;&amp; c &lt;= m;&#125;// TODO: 思考这样处理的合理性？// 直接加两条边或者加重边没有区别void addEdgeX(int u, int v)&#123; FWS::addEdge(u, v, 1); FWS::addEdge(v, u, 1);&#125;void buildGraph()&#123; using namespace FN; S = T = total = 0; FWS::init(2 + n * m * 2); for (int i = 1; i &lt;= n; ++ i) memset(h[i], 0, sizeof(int) * (m + 1)), memset(v[i], 0, sizeof(int) * (m + 1)); S = ++ total, T = ++ total; for (int r = 1; r &lt;= n; ++ r) for (int c = 1; c &lt;= m; ++ c) &#123; h[r][c] = ++ total, v[r][c] = ++ total; if (g[r][c] == &#x27;0&#x27;) &#123; if (in(r - 1, c) &amp;&amp; g[r - 1][c] == &#x27;0&#x27;) addEdgeX(v[r - 1][c], v[r][c]); if (in(r, c - 1) &amp;&amp; g[r][c - 1] == &#x27;0&#x27;) addEdgeX(h[r][c - 1], h[r][c]); addEdgeX(h[r][c], v[r][c]); &#125; &#125; for (int i = 1; i &lt;= a; ++ i) addEdge(S, v[1][p[i]], 1); for (int i = 1; i &lt;= b; ++ i) addEdge(v[n][e[i]], T, 1);&#125;int main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); cin &gt;&gt; t; while (t --) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; (g[i] + 1); for (int i = 1; i &lt;= a; ++ i) cin &gt;&gt; p[i]; for (int i = 1; i &lt;= b; ++ i) cin &gt;&gt; e[i]; buildGraph(); auto res = FN::Dinic::go(); cout &lt;&lt; (res == a ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; endl; &#125; return 0;&#125; 再度验证了我全新版本网络流板子的正确性建图的时候请务必记得分配源点和汇点 K - MUV LUV UNLIMITED 是有趣的新游戏 有一棵树，先手和后手轮流操作，每次可以拿掉若干叶子结点（但不能不拿），拿到根结点的人获胜。问先手是否必胜。 思路 有很多种思考的模型：从简单考虑到复杂情况和状态转化的推导；下面进行示例 首先考虑在一棵树的某个非叶结点下面加上一个叶子结点： 原树是必败态，那么先手第一次只取新叶子后就留下了必败态，所以新树是必胜态 原树是必胜态，那么先手第一次取下新叶子和原树必胜态中第一步应该取下的叶子，所以新树还是必胜态 所以说，当不管原树怎么样，只要有一个叶子节点的父亲度数大于等于 2，那么它就是必胜态 当然，显然这不是充要条件：比如原树是一个链的时候，并不存在这样的叶子节点，但是依然可以根据链的长度的奇偶性来判断当前是必胜态还是必败态。显然，这也不是一个充要条件； 但是链最终可以转化成上面说的那种必胜态的树型，只是先手后手必须一片叶子一片叶子的拿才可以；那么我们假设某长度为 x 的链的末端的叶子节点有一个度数大于等于 2 的祖先，设这个祖先的子节点是 a，那么问题就变成了怎么样删除节点让 a 节点成为叶子节点时玩家先手。形式化的说：假设当前树有 k 条链，链上当前的叶子节点和上述 a 节点的距离为 xi；每次可以选择部分 xi 使得它们减一，将其中一个减小到 0 的人输掉游戏。 因为树只会有上面两种构造，所以上述两种情况包括了全部的可能性；对于任何一棵树，我们只需要分析它的所有叶子节点距离第一个父亲节点度数大于 2 的节点的距离，也就是转化成上面的形式，从而可以进行胜败态的分析。 当 xi 中出现了偶数的时候，先手可以选择所有长度为偶数的链减一；这样就转化为了所有链长为奇数的状态；当最短链长为 1 的时候，当前玩家必败；当链长为其他奇数的时候，当前先手所作的任何行为产生的偶数长的链都可以被后手抵消，所以全部链长为奇数是必败态，出现了偶数的链长是必胜态。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;using longs = long long;using uint = unsigned;inline int nextInt()&#123; int x = 0, f = 0, ch = getchar(); while (!isdigit(ch)) ch == &#x27;-&#x27; &amp;&amp; (f = !f), ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar(); return f ? -x : x;&#125;const int N = 1e6 + 5;int deg[N], p[N];int main()&#123; ios::sync_with_stdio(false); int t = nextInt(); while (t --) &#123; int n = nextInt(); memset(deg, 0, sizeof(int) * (n + 1)); for (int i = 2; i &lt;= n; ++ i) ++ deg[p[i] = nextInt()]; bool ok = true; for (int i = 1; i &lt;= n; ++ i) if (!deg[i]) &#123; auto x = i, len = 0; while (x &amp;&amp; deg[p[x]] == 1) x = p[x], ++ len; ok &amp;= bool(len % 2); &#125; printf(!ok ? &quot;Takeru\\n&quot; : &quot;Meiya\\n&quot;); &#125; return 0;&#125; A - Angle Beats 一个平面里有 n 个点，现在每次询问给一个新点 P，你需要从 n 个点中选出两个点和 P 构成直角三角形；一共询问 q 次，求对于每次询问，可以构成直角三角形的不同方案数量； C - Sakurada Reset 给定数列 A 和 B，将数列中的每个子序列都看作一个 1000 进制数，问有多少对 (x,y)满足 x 是 A 的某个子序列，y 是 B 的某个子序列，并且 x &gt; y；相同的子序列需要去重。 思路 有句古话说：所有的计数问题都可以直接或间接地使用动态规划来解 后记 这个出题人老二次元了而且还是个重度 MUV-LUV 厨 因为这次主要的时间花在了博弈论上，所以深有感触；对于树的两种状态的分析都有，但是却没有将它们结合起来考虑，导致这个题花了很多时间。 我们队竟然没有人会平面几何（悲），这不太行；该努力学习提升自己的塑料平面几何水平了（ 参考链接 https://www.cnblogs.com/LMCC1108/p/11577614.html https://blunt-axe.gitee.io/2019/10/11/20191011-CCPC2019-Tutorial/","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://shiraha.cn/tags/Codeforces/"},{"name":"Gym","slug":"Gym","permalink":"https://shiraha.cn/tags/Gym/"}]},{"title":"在服务器上部署 SYZOJ","slug":"deploy-syzoj-on-a-server","date":"2020-07-31T03:08:30.000Z","updated":"2020-07-31T03:08:30.000Z","comments":true,"path":"2020/deploy-syzoj-on-a-server/","link":"","permalink":"https://shiraha.cn/2020/deploy-syzoj-on-a-server/","excerpt":"","text":"什么是syzoj？什么是OJ 虽说理论上既然自己搭 OJ 就应该仿真一点，搭个 DomJudge 之类的官方用品；但是对于博主而言，好看就是生产力，所以就选择了界面相对更加美观，且由中国人开发的 SYZOJ 了；毕竟搭建 OJ 本身也没啥意义，我也不会出题，比赛的话使用现成的 vjudge 不知道高到哪里去了（ 硬要说意义的话…… 只能说是熟悉一下服务器部署？或者说给一成不变的生活去找一些乐子？大概也就这样吧 == 因为官方已经有详尽的部署指南，所以已经有的东西就不再重复说明了，只重点介绍本人踩坑。 事前准备 因为是回忆性质的文章，很多东西也不会讲的很详细很有条理；我尽力： Vultr 超低级服务器 *1（1 vCore &amp; 1 GB RAM &amp; 25 GB SSD &amp; 1Mbps &amp; Ubuntu 18.04） Xshell 6（学生可以白嫖阉割版，但是已经够用了） 机场为你提供的纸飞机（不推荐了，推荐了你站就没了==） 一个域名，增加 A 记录解析到你的服务器（如果是国内域名还需备案） 其他的服务器，用来搞分布式评测提升效率和使用体验（有钱我也想） 有了这些，我们就可以一边参考官方的部署指南来配置了； 在 Vultr 上购买了服务器并且成功启动之后，可以将得到的 IPv4 地址在这个网站上过一遍，确保在国内的服务是正常的；毕竟在某一个时期似乎很流行购买 Vultr 服务器去搭建 SSR，再加上 Vultr 的 IP 地址更换非常容易，导致它很多的 IP 都已经被大陆 GFW 给 ban 了；如果你还希望在国内可以访问这个服务器，建议一直更换到上面的检测通过反正就一毛钱； 配置 SSH 代理 就算上面的服务器可以通过测试，也不代表着你可以舒服的使用它：因为墙的存在总会或多或少的阻挠你，而且服务器远在国外，本身连接的速度就相对比较慢还可能有高的无法忍受的延迟；所以要做些什么才行—— 国内服务器？确实配置更高，对于带学生的价格也更加优惠；但是你想要忍受国内那离谱的备案程序吗？ 在正式开始之前先说一下 VPN 和 sock5 代理的区别： VPN &amp; sock5 一般来说，像纸飞机这样的代理程序和 VPN 是不一样的：VPN 是你计算机网络的唯一出口，甚至你还会获得 VPN 分配的虚拟 IP；VPN 会接管所有的流量，等同于你处在另一个网络中；而 sock5 代理则是启动一个基于较低层次的网络协议的服务，sock5 协议只负责发送数据包，而不在意顶层应用层的协议因而速度较快；客户端（比如纸飞机）会在计算机上启动一个端口，并监听发送到该端口的所有数据，通过远程的服务器进行转发从而实现科学上网； 所谓的纸飞机全局代理模式，是利用 Windows 10 提供的代理功能，将电脑上所有的流量转发到它所在的服务端口；由它进行转发从而实现所谓的“代理全局流量”；事实上当开启了全局模式的 Shadowsock 不正确退出时，因为没有回收 Windows 10 中的代理配置，从而导致无法上网。 Windows 10 的这项功能在 设置 &gt; 网络和 Internet &gt; 代理 中；有一项是全局代理；这里已经体现了 代理 ≠ VPN 的概念。 SSH Proxy 在 Linux 中，终端不走代理是默认设置，而在 Windows 中却比较少见——但并不是不存在；我原本使用 Fluent Terminal 自带的 SSH 客户端，但是因为实在无法忍受其速度，外加上不可配置最终切换了 Xshell； 和 ping 不同，我原以为 SSH 连接也是低层网络，但是 Juice SSH 客户端是可以使用 SSR 加速的；所以 PC 端也可以通过代理来提升连接质量：在 Xshell 的会话属性中，可以指定代理服务器；我们将它设置为 http://127.0.0.1:1080/ —— IP 地址是 localhost 的默认值，而 1080 是 ShadowsocksR 运行的默认本地端口，就可以让 ssh 的连接通过代理访问远程服务器。 安装 Yarn Yarn 在我还在搞前端开发搬砖的时候已经使用过很多次了；Windows 的安装十分方便：去官网下载 msi 安装包，使用 Windows 的包管理器 Chocolatey / Scoop 安装，或者直接使用 Node.js 的 npm 来安装都可以；但是在 Linux 中似乎却没有这么容易： 如果你使用 sudo apt install yarn，你只会获得一个 0.32 的阴间版本的 yarn；在任何一个有 yarn.lock，你认为可以执行脚本的情况下它都会报错“缺少 scenario”；正确的安装方法是需要先增加 yarn 的仓库： 12curl -sS https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -echo &quot;deb https://dl.yarnpkg.com/debian/ stable main&quot; | sudo tee /etc/apt/sources.list.d/yarn.list 注意，在运行在 WSL 1 上的 Ubuntu 20.04 上执行代码会出现 gpg 的错误；参考 stackoverflow 得知这是由于 Ubuntu 20.04 不再支持 WSL 1 导致；当在 Debian 10 WSL 上执行这些命令的时候是可以正常工作的（当然可能会出现因为下载 GPG 公钥失败导致的错误） 增加仓库之后再执行 apt 的安装命令就可以安装正常可用的 yarn 了： 1sudo apt-get update &amp;&amp; sudo apt-get install yarn 当然也可以使用 npm install -g yarn 来安装 yarn：可是当你已经安装了来自 apt 的低版本 yarn 后，这样可能不会成功； 评测端的沙箱 Wiki 中给定的从 Github 下载的镜像只能在国外的云服务器上正常下载；如果你需要在国内的服务器上下载沙箱文件，可以使用开发者 HeRaNO 的seafile镜像处下载； 此外，下载的 .tar.xz 文件中已经包含了 rootfs 目录；如果按照教程上的做法新建文件夹，可能会导致这个文件夹被嵌套两次（HeRaNO 的知乎文章）；所以可以将该部分命令替换成如下内容： 1234567# 源地址：https://github.com/syzoj/sandbox-rootfs/releases/download/181202/sandbox-rootfs-181202.tar.gzwget -O /sandbox-rootfs.tar.xz https://seafile.t123yh.xyz:2/f/124a91be48ad41b98668/?dl=1md5sum /sandbox-rootfs.tar.xz# 预计计算结果为 09fe4fc407e4580e9ae4de8e2af5918e sandbox-rootfs.tar.xzmkdir -p /opt/syzoj/sandboxcd /opt/syzoj/sandbox/tar xvf /sandbox-rootfs.tar.xz 下载完成后可以计算 MD5 值来确定文件在下载过程中没有损坏； 安装 redis 虽然上面安装 yarn 已经搞得我对 apt 非常害怕，但是 redis 还是可以通过 apt 来安装的： 1sudo apt install -y redis-server 但是需要注意的是安装之后的服务名既不是 redis.service 也不是 redisd.service； 安装 Node.js 10 默认 Ubuntu 18.04 的 apt 安装的 node 是 8.1.0 版本的，这比启动 SYZOJ 评测端所要求的最低版本 10.0 要低；参考上面说到的 yarn 的安装方法，我们需要在使用 apt 安装 node 之前更新存储库： 1234curl -sL https://deb.nodesource.com/setup_10.x | sudo bashsudo apt updatesudo apt -y install gcc g++ makesudo apt -y install nodejs 更新存储库后就可以安装新版本的 Node.js 了；同样，安装 yarn 包管理器也需要增加对应存储库： 123curl -sL https://dl.yarnpkg.com/debian/pubkey.gpg | sudo apt-key add -echo &quot;deb https://dl.yarnpkg.com/debian/ stable main&quot; | sudo tee /etc/apt/sources.list.d/yarn.listsudo apt-get update &amp;&amp; sudo apt-get install yarn 之后才可以通过 apt 安装正常版本的 yarn。 systemd 守护进程 首先需要在 /usr/lib/systemd/system/ 目录下创建自己的守护进程的服务文件 *.service","categories":[{"name":"折腾记录","slug":"折腾记录","permalink":"https://shiraha.cn/categories/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"syzoj","slug":"syzoj","permalink":"https://shiraha.cn/tags/syzoj/"},{"name":"nginx","slug":"nginx","permalink":"https://shiraha.cn/tags/nginx/"},{"name":"Linux","slug":"Linux","permalink":"https://shiraha.cn/tags/Linux/"}]},{"title":"Nowcoder 2020 暑期多校训练 （4）","slug":"nowcoder-2020-summer-multi-4","date":"2020-07-20T08:40:44.000Z","updated":"2020-07-20T08:40:44.000Z","comments":true,"path":"2020/nowcoder-2020-summer-multi-4/","link":"","permalink":"https://shiraha.cn/2020/nowcoder-2020-summer-multi-4/","excerpt":"","text":"A - Ancient Distance B - Basic Gcd Problem C - Count New String 给长度为 n 的字符串 S，定义函数 f(S, x, y) 的值是 长度为 y - x + 1 的字符串，它的第 k 个字符是 \\(max_{i=x...x+k-1} S_i\\)； 现定义集合 A = {$$} D - Dividing Strings E - Eliminate++ F - Finding the Order G - Geometry Challenge H - Harder Gcd Problem I - Investigating Legions J - Jumping on the Graph 后记","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"https://shiraha.cn/tags/Nowcoder/"}]},{"title":"Nowcoder 2020 暑期多校训练 （3）","slug":"nowcoder-2020-summer-multi-3","date":"2020-07-19T02:01:14.000Z","updated":"2020-07-19T02:01:14.000Z","comments":true,"path":"2020/nowcoder-2020-summer-multi-3/","link":"","permalink":"https://shiraha.cn/2020/nowcoder-2020-summer-multi-3/","excerpt":"","text":"这一轮比赛的题目明显比起之前要友好许多——至少在最后一刻都能让队友满载做题，甚至还能感觉到一丝时间不够用……这比起之前的比赛可以说是天大的进步了，不过这也都是因为题目友好；而且简单的能做的题目就要尽快做出来这一愿望在这次比赛砸的荡然无存（签到题 +5 我来给大家表演一个队友消失术 89K5SF2PF2J7JT8QD.gif 虽然题目数量变多了，但是这一次的题目应该会比之前的要好补； 因为接下来比赛还有好多，所以接下来的题目若无必要就都不放题目翻译了…… 毕竟像我这种萌新写翻译还是挺花时间的，补题才是要紧之事（ A - Clam and Fish 简单题，队友 A 的 B - Classical String Problem C - Operation Love 平面几何，给手形，可能翻转放大缩小，判断是左手还是右手；因为点是根据时针方向给的（这点省了很多事，有一说一我并不知道不按照顺序给我要怎么办），只需要一个叉积判断顺逆时针就完事；观察图形，最长边只有一个，所以可以利用最长边定位；确定方向之后，最长边前后长度就可以用作左右手的判据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;using namespace std;using longs = long long;using uint = unsigned;inline int nextInt()&#123; int x = 0, f = 1, ch = getchar(); while (!isdigit(ch)) if (ch == &#x27;-&#x27;) f = -1, ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar(); return x * f;&#125;namespace Geo&#123; using number = long double; const number eps = 1e-8; int compareTo(number x) &#123;return x &lt; -eps ? -1 : x &gt; eps;&#125; int compareTo(number a, number b) &#123;return compareTo(a-b);&#125; struct point &#123; number x, y; point() = default; point(number x, number y) : x(x), y(y) &#123;&#125; point operator +(const point &amp;rhs) const &#123;return &#123;x + rhs.x, y + rhs.y&#125;;&#125; point operator -(const point &amp;rhs) const &#123;return &#123;x - rhs.x, y - rhs.y&#125;;&#125; number operator *(const point &amp;rhs) const &#123;return x * rhs.x + y * rhs.y;&#125; point operator *(const number rhs) const &#123;return &#123;rhs * x, rhs * y&#125;;&#125; point operator /(const number rhs) const &#123;return &#123;x / rhs, y / rhs&#125;;&#125; point &amp;operator +=(const point&amp; rhs) &#123;x += rhs.x; y += rhs.y; return *this;&#125; point &amp;operator -=(const point&amp; rhs) &#123;x -= rhs.x; y -= rhs.y; return *this;&#125; point &amp;operator *=(const number rhs) &#123;x *= rhs; y *= rhs; return *this;&#125; point &amp;operator /=(const number rhs) &#123;x /= rhs; y /= rhs; return *this;&#125; bool operator ==(const point &amp;rhs) const &#123;return x == rhs.x &amp;&amp; y == rhs.y;&#125; bool operator !=(const point &amp;rhs) const &#123;return !(rhs == *this);&#125; number dot(const point &amp;rhs) const &#123;return x * rhs.x + y * rhs.y;&#125; number cross(const point &amp;rhs) const &#123;return rhs.y * x - rhs.x * y;&#125; auto length() const &#123;return sqrt(dot(*this));&#125; auto distance(const point &amp;b) const &#123;return (*this - b).length();&#125; auto distance(const point &amp;ls, const point &amp;rs) const &#123;return fabs((ls - *this).cross(rs - *this)) / ls.distance(rs);&#125; point normal() const &#123;return (x || y) ? *this / length() : point(0, 0);&#125; auto angle() const &#123;return atan2(y, x);&#125; point rotate(number a) const &#123;number c = cos(a), s = sin(a); return &#123;c * x - s * y, s * x + c * y&#125;;&#125; point perpendicular() const &#123;return &#123;-y, x&#125;;&#125; point symmetry() const &#123;return &#123;-x, -y&#125;;&#125; number square() const &#123; return x * x + y * y; &#125; &#125;; struct line &#123; point s, t; line() = default; line(number a, number b, number x, number y) : s(a, b), t(x, y) &#123;&#125; line(const point &amp;s, const point &amp;t) : s(s), t(t) &#123;&#125; &#125;; int onLeft(point p, line l) &#123; number xx = (l.t - l.s).cross(p - l.s); return compareTo(xx); &#125;&#125;using point = Geo::point;using number = Geo::number;using Geo::compareTo;point p[25];number d[25];int main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int t; cin &gt;&gt; t; while (t --) &#123; for (int i = 0; i &lt; 20; ++ i) cin &gt;&gt; p[i].x &gt;&gt; p[i].y; d[0] = p[0].distance(p[19]); for (int i = 1; i &lt; 20; ++ i) d[i] = p[i].distance(p[i - 1]); int xp = 0; number xx = 0; for (int i = 0; i &lt; 20; ++ i) if (compareTo(d[i], xx) &gt; 0) xx = d[i], xp = i; auto hand = Geo::line(p[xp], p[(xp + 19) % 20]); auto &amp;ff = p[(xp + 18) % 20], &amp;bb = p[(xp + 1) % 20]; if (Geo::onLeft(ff, hand) &gt; 0) // counterclockwise if (compareTo(d[(xp + 1) % 20], d[(xp + 19) % 20]) &gt; 0) cout &lt;&lt; &quot;left&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;right&quot; &lt;&lt; endl; else // clockwise if (compareTo(d[(xp + 1) % 20], d[(xp + 19) % 20]) &gt; 0) cout &lt;&lt; &quot;right&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;left&quot; &lt;&lt; endl; &#125; return 0;&#125; 这题最开始我还把左右手弄反了，神秘 D - Points Construction Problem E - Two Matchings F - Fraction Construction Problem G - Operating on a Graph H - Sort the Strings Revision I - Sorting the Array J - Operating on the Tree K - Eleven Game L - Problem L is the Only Lovely Problem 真 · 签到题； 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;using namespace std;using longs = long long;using uint = unsigned;const int N = 2e5 + 5;char s[N];int main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); cin &gt;&gt; s; for (int i = 0; i &lt; 6; ++ i) s[i] = tolower(s[i]); auto ss = string(s); if (ss.length() &gt;= 6 &amp;&amp; ss.substr(0, 6) == &quot;lovely&quot;) cout &lt;&lt; &quot;lovely&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;ugly&quot; &lt;&lt; endl; return 0;&#125; 比赛场上写的代码属实不好看，可以动作更快一些的（ 后记 赛后复盘，觉得能力范围应该在七题以上，部分简单题的实现速度可以更快；但是这些题目中有不少题目都是那个大一队友想出来的，这果然还是不太行；","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"https://shiraha.cn/tags/Nowcoder/"}]},{"title":"组会分享：TypeScript & React 简单入门","slug":"Dian-hawkeye-introducing-of-typescript-and-react","date":"2020-07-14T07:13:17.000Z","updated":"2020-07-14T07:13:17.000Z","comments":true,"path":"2020/Dian-hawkeye-introducing-of-typescript-and-react/","link":"","permalink":"https://shiraha.cn/2020/Dian-hawkeye-introducing-of-typescript-and-react/","excerpt":"","text":"在目前主流的三大前端框架中，React 应该是和 TypeScript 联系最为紧密的；TypeScript 已经可以完美的融入到 React 的工具链中，所以若需要开发现代的、整洁的 React 应用， TypeScript 不可或缺； 此外，在 React 工具链中，React-Router 和 React-Redux 是重要的部分，它们也对 TypeScript 有很好的支持；这篇文章将结合刚过去不久的工程实训，谈谈我在使用 TypeScript + React 工具链的一些想法和实践； TypeScript 入门 有道：学习一门语言的最好方法是看它的官方文档； 下面仅简单的介绍一些可以用的到的东西： 建立项目 考虑到你组项目常用 React + antd 组合，所以可以通过执行下面命令创建： 123yarn create react-app antd-demo-ts --template typescript# ↑ yarn || npm ↓npx create-react-app antd-demo-ts --typescript 均使用 CRA 创建样板项目，具体的配置被隐藏，一般需要 eject 后才可以修改； 虽然理论上需要使用 tsc 将 TypeScript 代码编译成 js 代码，但是这些事情都已经被脚手架集成了，所以在 React 项目中不用考虑这些事情。 需要注意的是，很多 node 模块默认是不包含 TypeScript 支持的；当你需要向一个 TypeScript 工程中引入某个模块时，不仅需要安装这个模块，还需要安装它的类型声明文件，就像这样： 123yarn add react-router-dom @types/react-router-dom# ↑ yarn || npm ↓npm install react-router-dom @types/react-router-dom 否则，IDE 将会因为找不到类型声明文件而报错，或提示你没有安装对应的包。 类型标识 TypeScript 和 JavaScript 的核心区别；即使 React.js 可以通过 jsdoc 或者 proptype 进行类型检查和 IDE 指导，但是均没有 TypeScript 原生的类型检查来的优雅自然： jsDoc：受有限的支持，在部分 IDE 中甚至不会有语法高亮；仅能在有限的环境中提供 IDE 建议，而不是强制的语法保证；毕竟本质上只是注释。 propType：是运行时的类型检查，并不能在编译期间提供任何指引。 类型标识的格式：变量名 / 参数名 / 类域名 : 类型标识符，这些声明和 JavaScript 所在位置一样。 类型标识符包括 JavaScript Object 类型和由库定义的类型；浏览器，网页对象模型中的类型已经在 React 中定义好，也可以直接使用： 组别 标识符 JSON number, string, object, any, null, undefined, boolean, &lt;class&gt;[], void TypeScript 特有 never：表示的是永不存在的值的类型any：表示任何类型，TypeScript 将放弃类型检查 函数 (param: any) =&gt; void：括号中是参数类型，需要指定参数名，但只对比参数类型 用户定义的类型 使用 interface 关键字定义的类型和 type 关键字定义的类型 React 常见类型 React.Component&lt;P,S&gt;：组件类，P 是 props 类型，S 是 state 类型JSX.Element：JSX 标签类型，可以作为组件的返回值React.CSSProperties：描述了 style 的对象，连字符被更换成了驼峰命名法React.&lt;...&gt;Event：代表各种 HTML 事件的类型，如 change 和 keyboard 等 在 TypeScript 中，声明变量的类型如果不能由上下文自动推导，将提示错误：即你需要在任何不能推断类型的地方使用类型标识规定类型才能使得代码通过编译； 类型运算 比起其他强类型语言类型的麻烦，TypeScript 提供了灵活的类型运算；我们称其结果为类型谓词： 关键字 含义 typeof 获得其后跟随的变量类型，具体如下：- 跟随普通变量将获得变量的类型- 跟随字符串将获得字符串字面量的类型- 跟随对象将获得包含对象中所有属性的类型- 跟随箭头函数将获得该函数的类型签名这个表达式运行的结果是类型谓词。 interface 类似 C 中的结构体（下文简称），声明包含特定属性的对象的类型谓词； type 用来声明类型（谓词）或者类型别名；它可以接受：- 一个类型谓词的赋值，形如 typeof xxx- 使用 | 或 &amp; 运算符组合的类型，形如 string | number- 接受字符串/数字字面量类型，形如 'big' | 'small'格式为 type MyType = &lt;类型谓词&gt;，接下来你可以使用 MyType 了； Partial&lt;T&gt; T 为结构体，得到 T 所有域均为可选的类型谓词 Required&lt;T&gt; T 为结构体，得到 T 所有域均为必须的类型谓词 Nullable&lt;T&gt; T 为结构体，得到 T 所有域均为可空的类型谓词 ↑↑ 后三个这种“类型”还有很多，出现在 typescript/lib/lib.es5.d.ts 的 1440 行左右，可以去看（ 声明 interface 时，可以对成员变量标志后增加 ? 来表明它是可选的，也可以在标志前增加 readonly 来表明它是只读的；比如你可以这样声明一个 “结构体”： 12345interface User &#123; username: string; avatar: string | number | null; readonly password?: string;&#125; 当你只需要一个 interface 中的部分属性的时候（比如后端通信），就可以使用 Partial&lt;User&gt; 来获得这样的类型； 在 React 中使用 React 现在有两种写法：一种是比较经典的 class 写法，还有一种是比较新的 React Hook 写法；它们均能和 TypeScript 较好的联动，增加代码的整洁程度： class 写法 首先，我们继承的 React.Component 的定义是 React.Component&lt;P, S&gt;；两个泛型参数分别制定了 props 类型和 state 类型，因此我们在创建一个组件时，需要先定义该组件的 props 和 state 的类型谓词；因为它们都是一个对象，所以我们使用 interface 定义它们的类型；一般遵循如下格式： 12345678910111213141516171819202122232425262728import React, &#123;Component, CSSProperties&#125; from &quot;react&quot;;interface IProps &#123; style?: Partial&lt;CSSProperties&gt;; className?: string; children?: JSX.Element | null;&#125;interface IState &#123; data: object;&#125;class App extends Component&lt;IProps, IState&gt; &#123; constructor(props: IProps) &#123; super(props); this.state = &#123; data: &#123;&#125; &#125; &#125; render(): JSX.Element &#123; const &#123;className, style&#125; = this.props; return &lt;div className=&#123;className&#125; style=&#123;style ?? &#123;&#125;&#125;&gt; &#123;this.props.children&#125; &lt;/div&gt; &#125;&#125; 大体和 JavaScript 一致，只是增加了类型标识；需注意非箭头方法仍然需要 this 绑定； React Hook 写法 其实只是函数式组件的写法，和 Hook 相关的内容暂时扯不上太多关系： 12345678910111213141516import React, &#123;CSSProperties, FC, memo, useState&#125; from &quot;react&quot;;interface IProps &#123; style?: Partial&lt;CSSProperties&gt;; className?: string; children?: JSX.Element | null;&#125;const App: FC&lt;IProps&gt; = memo(props =&gt; &#123; const [data, setData] = useState(&#123;&#125;); return &lt;div className=&#123;className&#125; style=&#123;style ?? &#123;&#125;&#125;&gt; &#123;this.props.children&#125; &lt;/div&gt;&#125;) 只是当组件需要持有状态时，采用 useState 钩子创建即可；下面列出了一些常用 Hook： Hook 来源 作用 useState React 为当前的函数组件增加一个状态；返回一个包含状态和修改函数的数组； useContext React 在 Provider 下使用，获取其提供的共享 Context 对象； useEffect React 用于取代 class 型组件的生命周期方法：它接受两个参数：一个回调函数（异步）和一个包含依赖项的数组；当依赖项发生变化时，它会调用回调函数；省略第二个参数：每次重新渲染时调用回调函数；第二个参数为空：仅第一次渲染时调用回调函数 useReducer React 和 useState 类似；接受 Reducer 函数和初始状态作为参数； useHistory React-Router 在路由组件下使用，获得该路由依据的 History 对象，可用于跳转页面； 但是 TypeScript 的强大之处并没有体现出来，当和 Redux 一起使用，组件的类型不能够明晰的分辨出时，TypeScript 所提供的类型提示的作用才可以真正反映出来； Redux 入门 Redux 是前端的一个中心化数据管理的框架；它将一些组件中需要重复使用的数据提取出来，存储到一个统一的位置供组件拿取；并通过统一的预定义的行为对存储的数据进行修改，从而达成了数据流可控；在 React 中，Redux 通过 React 组件的上下文来实现； 本部分进行简单的 Redux 概念介绍，并结合 React Hook 和 TypeScript 构建代码： 概念介绍 首先先介绍专有名词： Store：即存储，中心化状态管理体系中数据存储的地方；对于 React 等现代前端框架而言，每个 SPA 仅持有 1 个；它是一个树状结构，可以用对象的形式表示； Action：即行为，用来修改 store 中存储的状态；一般来说，它是一个对象，包含这个 Action 是什么以及执行这个行为所需要的数据； Reducer：用来处理 Action，是一个函数；它接受 store 的上一个状态和 Action，返回新的 store 状态；它是一个纯函数，且定义了 store 的结构； Action Creator：即行为创造器，它可以接受必须的信息，用来生成一个符合要求的 Action 对象，是一个函数； 实际上，Redux 的工作流程可以概括为下图： 流程图 由 Action Creator 创造的 Action 对象可以通过 store.dispatch() 方法分发给 Store，Store 根据 Action 的类型（即这是什么行为）将它交给对应的 Reducer 计算出新的状态进行更新； 和 Store 的树形结构一样，Reducer 也是树形结构——可包含多个子 Reducer，和 Store 一一对应；Store 的树形结构来自 JavaScript 对象的嵌套，Reducer 的树形结构来自于多个子 Reducer 的合并；一般写法如下： 123456789101112131415161718192021222324interface StoreState &#123; user: UserStore; homepage: HomepageStore; component: ComponentStore; category: CategoryStore;&#125;;const reducers = combineReducers(&#123; user: userReducer, homepage: homepageReducer, component: componentReducer, category: categoryReducer,&#125;);const enhancer = composeWithDevTools(AsyncMiddleware);const store = createStore(reducers, enhancer);const App: FC = memo(() =&gt; &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;/&gt; &lt;/Provider&gt; );&#125;); 上面代码中的 XxxStore 和 xxxReducer 分别是子 Store 和子 reducer，唯一的根 Store 即由合并得到的根 Reducer 生成的 store；enhancer 是增强件，可以用来强化 Redux 的功能；上图的 ”Async Middleware“ 就是其中一种，这里先不细说；创建的 Store 需要使用 Provider 提供给虚拟 DOM 某节点下所有的节点，这里通过 React 的上下文来实现； composeWithDevTools 来自 node 模块 redux-devtools-extension；它可以和 Chrome 同名插件配合使用，输出 Action 对 Redux Store 的更改轨迹，并随时查看 Store 中存储的值；它也属于 enhancer 的一种，建议使用； 关于 React-Redux 可以看到，Redux 这种设计模式适用于任何根据数据渲染组件的前端框架，这当然包括 React；React-Redux 的出现代替了上面提到的“订阅/通知”，而采用一种更加自然的方式帮助我们完成了这项工作。 在说这个之前先说一种在 React 中非常常见的设计模式： ##### 有状态组件和无状态组件 顾名思义，状态指 React 中的 state；有状态组件不仅需要参与页面渲染，还需要包含逻辑来维护它自身所持有的状态；而无状态组件仅根据父组件传进来的 props 渲染视图； 软件设计中有一个原则，叫做“责任分离”：即让一个模块的责任尽量少；当模块负责的内容过多，应当将模块进行拆分，以使得每一个模块尽可能专注一个事务，以方便后续维护。 显然，渲染视图和维护状态的逻辑并不是一项功能，特别是当逻辑复杂时，会导致很大的组件——这对于后期项目维护来说是致命的；一种显然的解决措施就是将维护状态逻辑和渲染视图分离，即将一个“传统组件”拆分成有状态组件（即“容器”）和无状态组件（即“视图”）； 首先，渲染视图和逻辑并不沾边，这样的分割是合理的；其次，这样做可以方便的更换数据管理的方式：比如有状态组件从 Redux 获取数据；也可以方便的更换数据的展示方式，这样做均只需要修改对应的组件即可，避免了对代码的大规模改动。 如果我们要在项目中使用 Redux，显然视图组件的数据来源是 Redux，我们应当使用这种设计模式；但是这方面的工作 React-Redux 已经帮我们做好了，我们只需要专注视图组件的展示即可；React-Redux 提供了方便的 API 实现 Store 中数据和视图状态的双向绑定： mapStateToProps：将 Store 中储存的状态双向绑定到组件的 Props，从而组件可以通过 Props 获得渲染视图所需要的状态；它的类型声明是 (state: Store) =&gt; object； mapDispatchToProps：将 Store 接受的 Action 的 Creator 通过 Props 传递给组件；Action 是改变 Store 状态唯一的途径，组件可以通过这些方法产生需要的 Action 并且自动分发到 Store； connect：接受上面的两个用户定义的方法和视图组件，自动生成一个该视图组件的容器组件；这个容器组件可以读取 Store 中特定的数据并交给视图组件渲染，并在必要时触发 Action； 简单的说，就是用户提供用于渲染视图的无状态组件，以及该组件需要进行的 Action，也就是逻辑，由 React-Redux 负责生成对应组件的容器；用户无需进行具体的组件状态管理，只需要定义 Action 和编写视图组件；在所有需要使用到该组件的场合使用 React-Redux 自动生成的组件即可； 使用 Redux 使用 React 的好处不言而喻；状态的更改有迹可循，组件并不需要维持很多状态就可以渲染视图，整个项目的逻辑更加的清晰自然；但是缺点也是显而易见的——将所有的操作定义为 Action 将产生大量的”无用代码“，增加了项目的代码量和复杂程度；React 自身也有优秀的状态管理，如果完全使用 Redux 作为状态管理，也是对 React 的功能的一种浪费；因此要做到有的放矢，才是最佳实践： 被多个 React 组件共享的状态需要放进 Redux 组件重新装载，仍然需要持有之前的状态时需要放进 Redux 否则，这个状态就放在 React 组件中好了 通过上面的方法可以判断一个状态是否要放进 Redux 中；对于放进 Redux 状态，我们仍然需要遵循一些”公理“，来使得代码的逻辑更加的合理： Redux 中的数据应当是范式化的 ”Raw Data“ 通过 selector 将处理后的数据传送给组件 只有少量的关键组件 connect 了 Redux Store Selector 相当于 Vue 中的计算属性 computed：它以 Store 中存储的一些数据为基础，记忆化的存储计算结果，且仅在这些数据源发生改变时才重新计算；比起 React 每次使用数据都进行重复计算要更加高效；Selector 本质上只是接受状态的函数，包含计算出容器所需要的数据的逻辑；它可复用，且一般在 mapStateToProps 中使用； 处理异步事件 如果仅使用前面提到的 Redux，我们需要为一个异步事件确定三个 Action：它们分别在异步事件开始时、异步事件 Fulfilled 和 Rejected 的情况下被触发；对应 Promise 的 resolve 和 reject；如果这些操作都在需要执行异步请求的组件中手动调用，将造成大量的重复代码，不可取；但是 Redux 的设计要求 Action 只能是同步的，我们并不能想当然的将一个异步事件做成一个 Action；此时就需要异步中间件了。 异步中间件仍然需要定义多个 Action，但是它将根据异步请求的结果自动地调用后续 Action，减少了代码重复；同时，异步 Action 遵循了 Redux 的标准，它对状态的修改也是可追溯的；常用的异步中间件如下： Redux-thunk：简单易上手，但功能有限；它会在第一个 Action 发出之后，自动地发出第二个 Action 用异步获取的数据来更新状态； Redux-observable：基于 RxJS 的 observer 实现，功能强大，可以处理复杂的事件流，但是学习门槛较高； Redux-Saga：基于 JavaScript Generator 语法，介于上述两者之间；下文将着重介绍它的使用； 异步中间件属于对于 Redux 的拓展，在创建 store 时需要将需要的中间件放在上文代码 enhancer 的位置； 中间件原理 分析 Redux 的工作流程，Reducer 和 Action 是纯函数和纯对象，并不能进行改动；再参考上面说的没有中间件的情况下异步 Action 的方法，考虑到我们需要在 Action 分发的过程中增加中间件来自动完成一些工作； 中间件相当于一个改造过的 store.dispatch；dispatch 方法可以拿到行为和前状态，并且有和可以改变状态的 Reducer 通信的能力；如果我们需要做什么包含副作用的行为，在 dispatch 函数内最合适不过了；所谓中间件，就是按照 Redux 的标准对 dispatch 方法进行了一些改造，增强了它的功能； 比如 redux-logger 中间件，他会在收到前状态和行为时打印前状态，并且在和 Reducer 通信后打印新状态；又比如上面提到的 redux-thunk 中间件要求 Action Creator 返回一个异步请求执行前和执行后都会发起同步 Action 的函数；这种特别的 Action Craetor 产生的 Action 本不能被 dispatch 函数处理，但是中间件增强了它的功能，使得这种 Action 被中间件处理成可以自动发起第二个 Action 的效果；从而达到了异步通信的目的； 使用 Redux-Saga Redux-Saga 采用了 JavaScript 的生成器语法；它接管部分 Action，在收到 Action 时产生一个生成器对象，并且逐步执行其中的语句——这个过程保证了其内部语句执行的顺序；这个过程中可以发起新的 Action，由中间件自动完成；为了和普通的 Action 区分开来，我们将这部分被接管的 Action 称为 Saga； 生成器语法 首先先介绍大家都很熟悉的 yield 关键字：它在 C# 和 Python 中都存在也即将出现在 C++ 2a，在各领域（如 Unity 游戏编程）的协程中发挥作用；JavaScript / TypeScript 的 yield 和其它语言类似，如果理解的话就不用看下面了； 生成器函数使用 function* 声明，调用它将返回一个迭代器；每次调用迭代器都将执行到 yield 语句所在位置，并将该语句的值作为阶段性返回值返回，直到该函数中所有的语句都已经执行完毕；简单的说，yield 语句将会确保严格按照其顺序执行； 在 Redux-Saga 中，我们并不需要手动的去调用迭代器的 next 方法，中间件将会替我们完成； Saga 的组成 和定义 Action 类似，定义 Saga 依然需要包含四个部分；但是它们被 dispatch 后的处理方式不同： 一般的 Action 需要被 Reducer 接受并且利用 switch 语句计算新状态，而 Saga 需要被已注册的监视函数监听后，根据定义的并行策略调用生成器函数，并自动迭代；异步 Action 需要发起的其他 Action 均可以作为该生成器函数中可迭代的一步； 因此，对于一个 Saga，我们还需要额外定义它的监视函数（仅包含一个语句，决定了这个异步行为的策略）和它的生成器函数（包含了这个行为需要进行的异步操作逻辑），代码范例见下文代码范式； 使用 Saga 和普通的 Action 一样，将 Saga 的 Action Creator 通过 React-Redux 的 mapDispatchToProps 方法传递给组件即可；创造出的 Saga 会被注册的监听函数捕捉，并自动迭代生成器函数； 代码范式 对于上一部分提到的一些名词，这里展示一些使用 TypeScript 编写的范式代码供参考： Action &amp; Action Creator 定义一个 Action 至少需要下面四个声明： 1234567891011export const LOGIN = &#x27;LOGIN&#x27;;export type LOGIN = typeof LOGIN; // 取字符串字面量作为此 Action 的类型标识export interface Login &#123; type: LOGIN; // Action 的类型声明，必须包含 type 域 token: string;&#125;export function login(token: string): Login &#123; return &#123; type: LOGIN, token&#125;; // Action Creator 制造一个 Action 对象&#125; Action 标识字符串，Action 表示类型谓词，Action 对象的类型谓词和 Action Creator 函数；一般分别采用大写 + 下划线、大写 + 下划线、Pascal 命名法、驼峰命名法来命名； Reducer 一个 Reducer 也许要包含下面四个部分：接受的 Action 类型，由它更新的子 store 的类型声明，这个子 store 的初始值以及 Reducer 函数； 1234567891011121314151617181920212223242526type Action = actions.Login | actions.Logout;export interface UserStore &#123; token: string; info: User; isLoading: boolean;&#125;export const init: UserStore = &#123; token: localStorage.getItem(&#x27;token&#x27;) ?? &#x27;&#x27;, info: &#123;&#125; as User, isLoading: false,&#125;;export function userReducer(state = init, action: Action): UserStore &#123; switch (action.type) &#123; case actions.LOGIN: const &#123;token&#125; = action; localStorage.setItem(&#x27;token&#x27;, token); return &#123;...state, token&#125;; case actions.LOGOUT: localStorage.removeItem(&#x27;token&#x27;); return &#123;...userInit, token: &#x27;&#x27;&#125;; default: return state; &#125;&#125; 从外部导入已经定义好的 Action 对象类型谓词，并将该 Reducer 需要处理的 Action 类型通过类型运算符 | 合并起来，就是这个 Reducer 需要接受的 Action 类型的类型谓词； Reducer 函数需要接受上一个 Store 的状态和要进行的 Action 对象，通过 switch 语句匹配 Action 标识类型并且进行对应的操作，计算出新对象返回；当上一个 Store 状态不存在时，填入初始值； React-Redux 下面的代码为视图组件 AppBar 创造了一个容器类： 12345678910111213141516171819import &#123;connect&#125; from &quot;react-redux&quot;;import &#123;bindActionCreators, Dispatch&#125; from &#x27;redux&#x27;;import AppBar from &#x27;../components/AppBar&#x27;;const mapStateToProps = (state: StoreState) =&gt; (&#123; loggedIn: (state) =&gt; !!state.user.token, // 一个简单的 selector userInfo: state.user,&#125;);const mapDispatchToProps = (dispatch: Dispatch) =&gt; bindActionCreators(&#123; updateToken: actions.login, logout: actions.logout,&#125;, dispatch)type StateProps = ReturnType&lt;typeof mapStateToProps&gt;;type DispatchProps = ReturnType&lt;typeof mapDispatchToProps&gt;;export type AppBarProps = StateProps &amp; DispatchProps; // 作为 AppBar 视图组件的 IPropsexport default connect(mapStateToProps, mapDispatchToProps)(AppBar); 上述代码中提到的 connect 其实需要接受四个类型参数：&lt;TStateProps = &#123;&#125;, TDispatchProps = &#123;&#125;, TOwnProps = &#123;&#125;, State = DefaultRootState&gt;；但是因为可以类型推导以及默认值，所以这里没有写明： TStateProps：由 mapStateToProps 带来的 props，上述代码中已经赋值给了 StateProps； TDispatchProps：由 mapDispatchToProps 带来的 props，上述代码中已经赋值给了 DispatchProps； TOwnProps：除了这些之外该组件需要的 props；比如需要传入路由参数时，该值应当为 RouteComponentProps； State：即原始 Store 的类型，已经通过默认值自动赋值了，一般不需要修改； 当你要将路由参数传入容器时，不仅需要显式地传入类型参数 RouteComponentProps，还需要将组件使用 withRouter 方法处理；即：export default withRouter(connect&lt;StateProps, DispatchProps, RouteComponentProps, StoreState&gt;(mapStateToProps, mapDispatchToProps)(AppBar));； Redux-Saga 和其他异步中间件一样，Redux-Saga 接管了部分 Action 的处理，我们称这些 Action 为 Saga；下面是定义一个 Saga 并且将它应用到 store 的代码样例： 12345678910111213141516171819202122232425262728293031323334import &#123;put, takeLatest, call, all&#125; from &#x27;redux-saga/effects&#x27;;import createSagaMiddleware from &#x27;redux-saga&#x27;;function* worker(action: $actions.FetchInfoStart) &#123; try &#123; yield put(actions.processStarted()); // 发起异步操作开始的 Action const res = yield axios.get(api.me); // 调用异步 API const body = res.data; if (body.code &gt;= 0) &#123; yield put(actions.InfoFetched(action.uid, body.data)); // 发起更新数据的 Action &#125; else yield console.log(body.msg); &#125; catch (e) &#123; yield message.error(e.toString()); // 可以发起 Reject 的第二个 Action $history.push(url.$404); &#125; finally &#123; yield put(actions.processHandled()); // 发起 Fulfill 的第二个 Action &#125;&#125;function* watcher() &#123; yield takeLatest($actions.FETCH_USER_INFO_START, worker); // 另有 takeEvery 代表允许并行&#125;const sagas = [watcher]; // 用来存放不同 saga 的 watcherexport function* Sagas() &#123; // 注册所有的 saga yield all(sagas.map(saga =&gt; call(saga)));&#125;;const saga = createSagaMiddleware();const AsyncMiddleware = applyMiddleware([saga]);const enhancer = composeWithDevTools(AsyncMiddleware); // 组合 enhancer，引入 devtoolconst store = createStore(reducers, enhancer); // 创建 storesaga.run(Sagas); // 启动 Redux-Saga 代码中的 takeLatest 表示不允许并行，仅监听并执行最新的异步 Action； React-Router 5.x 官方文档还停留在 3.0 版本，可是这玩意从 4.x 开始就已经和之前截然不同了；本部分的内容也无法解释很多，仅从个人使用的过程中总结一下经验和踩过的坑； 安装 123yarn add react-router react-router-dom @types/react-router @types/react-router-dom# ↑ yarn || npm ↓npm install react-router react-router-dom @types/react-router @types/react-router-dom 组件 常用的组件包括三种： 根组件（路由组件）：使用 history 模式的 BrowserRouter 和使用 hash 模式的 HashRouter 路径匹配组件：可嵌套的路径组件 Route 和非嵌套的 Switch 组件； 导航跳转：Link 组件和 NavLink 组件、Redirect 组件等； 除非在静态服务器上部署使用 hash 路由，否则强烈建议使用基于 History 的 BrowswerRouter； Route 组件接受的参数主要包括下面的内容： props 含义 path: string 路由的路径；在没有 exact 标志时只匹配前缀，且按照从上到下的顺序匹配 exact: boolean 精准匹配标志；当包含此标志时，路径匹配将要求完全一致，但忽略末尾的 '/' component 渲染组件；当路径匹配成功时需要渲染的组件 render 渲染函数；当路径匹配成功时将调用此函数渲染视图，可用于 SPA 的懒加载 children 可以是其他路由组件以组成嵌套路由；也可以只是一般的 JSX 因为 React-Router 导航的 Web 应用本质是单页应用（SPA）；当应用包含过多信息时，第一次载入将会十分耗时；我们可以将一些暂时不需要渲染的页面（组件）延迟加载，从而缩短第一次加载所需要的时间，提升用户体验： 12345678910111213141516171819202122232425const Homepage = lazy(() =&gt; import(&quot;../containers/pages/homepage&quot;));const User = lazy(() =&gt; import(&quot;../containers/pages/user&quot;));const Index: FC = memo(() =&gt; &#123; useEffect(() =&gt; window.scrollTo(0, 0)); const load = (Component: JSX.Element) =&gt; (props: RouteComponentProps) =&gt; ( &lt;Container &#123;...props&#125;&gt; &lt;Suspense fallback=&#123;&lt;Loading /&gt;&#125;&gt; &#123;Component&#125; &lt;/Suspense&gt; &lt;/Container&gt; ); return ( &lt;Switch&gt; &lt;Route path=&#123;url.login&#125; exact component=&#123;Login&#125; /&gt; &lt;Route path=&#123;url.register&#125; exact component=&#123;Register&#125; /&gt; &lt;Route path=&#123;url.root&#125; exact render=&#123;load(&lt;Homepage /&gt;)&#125; /&gt; &lt;Route path=&#123;url.user&#125; exact render=&#123;load(&lt;User /&gt;)&#125; /&gt; &lt;Redirect to=&#123;url.$404&#125;/&gt; &lt;/Switch&gt; );&#125;) 在 load 方法中还可以自定义当按需加载的组件还在加载中时需要显示的内容：比如一个 Loading 的动画、一个进度条或者是骨架屏，显著提升用户体验； 路由传参 在 TypeScript 中，路由传递的参数的类型谓词是 RouteComponentProps；如果你需要在一个组件中使用路由参数，你需要在导出该组件时使用 withRouter 方法将它包裹，并修改显式声明的 IProps； 传入 Route 参数之后，就可以通过 match 来获得匹配信息：比如通过 match.params 来获得路由参数； 路由跳转 有两种方法：经典的做法就是通过上面组件中的 Link 等导航组件进行跳转；当你使用 BrowserRouter 作为根路由组件时，你也可以在其子组件中通过 useHistory 钩子获得 History 对象，然后通过 history.push 方法进行路由跳转；需要注意的是 useHistory 是钩子，仅能在函数式 React 组件中使用；且当该组件渲染在跟路由组件外时，通过该钩子会得到 undefined 并且报错； 当然，上述做法都是需要在视图之内的地方才可以使用路由跳转的；如果你想要在视图之外的地方（比如异步逻辑层）进行路由跳转…… 人不能，至少不应该。建议停下来思考有没有更好的实现方法；当然方法还是有的：比如在逻辑层使用 ReactDOM.render 在某个不可见的地方渲染一个 Link 组件，又或者让根组件使用外部的 history 对象；但是这样写出来一定是烂代码所以这里就不细说了。 后记 &amp; 总结 不是多少有技术含量的东西，但是属于读了一些还算整洁的 React 源代码的一些收获；按照这样的实践方法写出的代码确实要来的更加整洁；但是任何事情都没有绝对的最优实践：即使完全按照上面说到的这些写法来构筑代码，如果缺乏一个合理的设计，盲目追求“最佳实践”，最终只会适得其反。 虽然 Redux 提供了可追踪的状态管理，但是根据上面的代码范式也很容易知道，这是建立在大量繁杂的代码基础上的； 本质上 Redux 通过增加了额外的 Action 和 Reducer 代码来增强项目的可维护性，但是增加的代码是不是必要的 参考资料 http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html https://www.tslang.cn/docs/home.html https://juejin.im/book/5ba42844f265da0a8a6aa5e9/section/5ba4840f5188255c791b0008 http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html https://www.cnblogs.com/samve/p/12435908.html https://redux-saga-in-chinese.js.org/ https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators","categories":[{"name":"Web","slug":"Web","permalink":"https://shiraha.cn/categories/Web/"},{"name":"前端","slug":"Web/前端","permalink":"https://shiraha.cn/categories/Web/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"课内作业","slug":"课内作业","permalink":"https://shiraha.cn/tags/%E8%AF%BE%E5%86%85%E4%BD%9C%E4%B8%9A/"},{"name":"Web","slug":"Web","permalink":"https://shiraha.cn/tags/Web/"},{"name":"Dian","slug":"Dian","permalink":"https://shiraha.cn/tags/Dian/"},{"name":"React","slug":"React","permalink":"https://shiraha.cn/tags/React/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://shiraha.cn/tags/TypeScript/"}]},{"title":"Nowcoder 2020 暑期多校训练 （2）","slug":"nowcoder-2020-summer-multi-2","date":"2020-07-13T08:49:41.000Z","updated":"2020-07-13T08:49:41.000Z","comments":true,"path":"2020/nowcoder-2020-summer-multi-2/","link":"","permalink":"https://shiraha.cn/2020/nowcoder-2020-summer-multi-2/","excerpt":"","text":"比完看到群里一群 hack 老哥和暴躁老哥，萌新不敢说话（ 3FUEYCMFGCVMO_XE2OY.png 看着带佬们讨论，发现争议的 hack，卡常数，栈空间等问题都和我们没有关系…… 那没事了（ A - All with Pairs 给定 n 个字符串，定义 f(s, t) 的值为满足 s 的前缀和 t 的后缀相等的最长长度，且不存在时为 0； 现要求计算出 \\(\\sum_{i=1}^n \\sum_{j=1}^n f^2(s_i, s_j)\\ mod\\ 998244353\\)；也就是说求给定的 n 个字符串中任意两个字符串的“公共前后缀”长度之在模意义下的和； 数据范围：n ≤ 1e5，Σ|s| ≤ 1e6； 和上一次多校的第一题一样，是我不喜欢的字符串题目，所以直接对着题解说好了：要求求出所有的两个字符串排列的最大公共顶针字串的长度在模意义下的和；因为字符串总长并不大，所以可以用 O(Σ|s|) 的时间预处理所有字符串的前/后缀哈希，利用哈希进行子串匹配； 接下来再遍历所有字符串的后/前缀，和已经预处理的哈希进行匹配即可；但是因为我们只计算最大公共子串长度的和，不必要的子串需要减掉，所以可以考虑使用 KMP 构建出 next 数组，然后利用这个 next 数组主动地去重； 仿造标程写的代码↓↓，并且重构了一下相关的板子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;using namespace std;using longs = long long;using ulongs = unsigned long long;using uint = unsigned;inline int nextInt()&#123; int x = 0, f = 1, ch = getchar(); while (!isdigit(ch)) if (ch == &#x27;-&#x27;) f = -1, ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar(); return x * f;&#125;const uint N = 1e6 + 5;const uint M = 1e5 + 5;const uint mod = 998244353;namespace StringHash&#123; using hashArray = vector&lt;ulongs&gt;; struct hashMachine &#123; int base, offset; hashArray pow; static int idx(const char ch)&#123;return ch - &#x27;a&#x27;;&#125; explicit hashMachine(int n, int b = 233, int k = 5): base(b), offset(k) &#123; pow.resize(n); pow[0] = 1; for (int i = 1; i &lt; n; ++ i) pow[i] = pow[i - 1] * base; &#125; void make(const char *s, hashArray &amp;var) const &#123; int n = strlen(s); for (int i = 1; i &lt;= n; ++ i) var[i] = var[i - 1] * base + idx(s[i - 1]) + offset; &#125; ulongs get(hashArray &amp;var, int l, int r) const &#123; if (!l) return var[r]; auto len = r - l; return var[r] - var[l] * pow[len]; &#125; &#125;;&#125;void buildKMP(const string &amp;s, vector&lt;int&gt; &amp;kmp)&#123; kmp[0] = -1; int i = 0, j = -1; int length = s.length(); while(i &lt; length) &#123; if(-1 == j || s[i] == s[j]) kmp[++ i] = ++ j; else j = kmp[j]; &#125;&#125;char s[N];unordered_map&lt;ulongs, uint&gt; $map;vector&lt;int&gt; $next[M];vector&lt;ulongs&gt; $hash[M];ulongs cnt[N], ans = 0;int main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); auto hm = StringHash::hashMachine(N, 6151); auto handleHash = [&amp;](int ii) &#123; auto len = strlen(s); $next[ii].resize(len + 1); $hash[ii].resize(len + 1); buildKMP(s, $next[ii]); hm.make(s, $hash[ii]); for (uint i = 0; i &lt; len; ++ i) ++ $map[hm.get($hash[ii], i, len)]; &#125;; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++ i) cin &gt;&gt; s, handleHash(i); for (int i = 0; i &lt; n; ++ i) &#123; auto length = $hash[i].size() - 1; auto &amp;kmp = $next[i]; for (uint j = 1; j &lt;= length; ++ j) &#123; cnt[j] = $map[hm.get($hash[i], 0, j)]; if (kmp[j] != -1) cnt[kmp[j]] -= cnt[j]; &#125; for (uint j = 1; j &lt;= length; ++ j) ans = (ans + cnt[j] * j % mod * j) % mod; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 吐槽：翻了一遍你科和武大的榜，竟然没有人做这个题，草（ 再吐槽：牛客的 g++14 编译这个抛出了难以置信的 Assembler Error ↓↓，最后是 clang++ 编译过的（ 8W_0LU94U_I7GH9.png 啊这…… ICE？这太怪了（ B - Boundary 平面上给定 n 个点的坐标，找一个圆，有如下要求： 原点（0，0）在该圆的边界上 除原点外有尽可能多的点在此圆边界上 问该圆的边界上除了原点之外的点的数量。 数据范围：n ≤ 2000； 直接想到四点共圆，遍历两个点确定一个三角形——也就是圆，再遍历第三个点判断是否在这个圆上就行了，时间复杂度 O(n³)；可这就是个大暴力做法，就算跑不满也会被 2000 的数据卡掉可是我 WA 了，神秘； 于是思考复杂度较低的做法：若点共圆，那么它们确定的圆心相等，可以去遍历所有三角形确定的圆心然后找到聚集点……还是算了吧；除了圆心之外，同一个圆弧对应的圆周角是相等的，比起二维的坐标，一维的圆周角的众数显然更加好找，那么就可以这么做了； 但是圆弧对应的圆周角可能不在同一个圆上，还有可能出现在镜像中，所以还需要叉乘判断方向；这也许也是我上面暴力的方法出错的原因吧（只考虑互补 / 相等，直接比较 |cos| 怕不是什么样的点都算进去了）； 补充：听完讲题，还真有人通过中垂线找圆心做；这…… 使用分数类？有点想看这样通过的代码，找找看吧…… 啊这不用找了，eps 设为 0 才能 A，设为 1e-8 反而 A 不了，那没事了…… 首先是按照标准做法，计算角度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;using longs = long long;using uint = unsigned;inline int nextInt()&#123; int x = 0, f = 1, ch = getchar(); while (!isdigit(ch)) if (ch == &#x27;-&#x27;) f = -1, ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar(); return x * f;&#125;template &lt;class T&gt; struct fraction&#123; T num, den;#ifdef WIN32 using _t = __int64;#else using _t = __int128;#endif fraction() = default; fraction(T u, T v): num(u), den(v) &#123; if (!v) num = 1; else if (v &lt; 0) num = -u, den = -v; &#125; constexpr static const long double $eps = 0; static int sgn(long double x) &#123;return x &lt; -$eps ? -1 : x &gt; $eps;&#125; static T gcd(T a, T b) &#123;return a &lt; b ? gcd(b, a) : (!b ? a : gcd(b, a % b));&#125; auto toNumber() const &#123; return (long double) num / den; &#125; int compareTo(const fraction &amp;rhs) const &#123;return sgn(this-&gt;toNumber() - rhs.toNumber());&#125; bool equals(const fraction &amp;rhs) const &#123;return den == 0 || rhs.den == 0 ? den == rhs.den : !compareTo(rhs);&#125; fraction &amp;reduce() &#123; auto x = gcd(num, den); num /= x, den /= x; return *this;&#125; auto atan2() const &#123;return std::atan2(num, den);&#125; fraction reciprocal() const &#123;return &#123;den, num&#125;;&#125; bool operator ==(const fraction &amp;rhs) const &#123; return num * rhs.den == den * rhs.num;&#125; bool operator &lt;(const fraction &amp;rhs) const &#123;return den &amp;&amp; (!rhs.den || (_t)num * rhs.den &lt; (_t)den * rhs.num);&#125; fraction operator -() const &#123;return &#123;-num, den&#125;;&#125; friend ostream &amp;operator &lt;&lt;(ostream &amp;os, const fraction &amp;frac) &#123;if (frac.den) os &lt;&lt; frac.num &lt;&lt; &quot;/&quot; &lt;&lt; frac.den; else os &lt;&lt; &quot;NaN&quot;; return os;&#125;&#125;;namespace Geo&#123; using number = longs; const long double eps = fraction&lt;longs&gt;::$eps; int compareTo(number x) &#123;return x &lt; -eps ? -1 : x &gt; eps;&#125; int compareTo(number a, number b) &#123;return compareTo(a-b);&#125; struct point &#123; number x, y; point() = default; point(number x, number y) : x(x), y(y) &#123;&#125; point operator +(const point &amp;rhs) const &#123;return &#123;x + rhs.x, y + rhs.y&#125;;&#125; point operator -(const point &amp;rhs) const &#123;return &#123;x - rhs.x, y - rhs.y&#125;;&#125; number operator *(const point &amp;rhs) const &#123;return x * rhs.x + y * rhs.y;&#125; point operator *(const number rhs) const &#123;return &#123;rhs * x, rhs * y&#125;;&#125; point operator /(const number rhs) const &#123;return &#123;x / rhs, y / rhs&#125;;&#125; point &amp;operator +=(const point&amp; rhs) &#123;x += rhs.x; y += rhs.y; return *this;&#125; point &amp;operator -=(const point&amp; rhs) &#123;x -= rhs.x; y -= rhs.y; return *this;&#125; point &amp;operator *=(const number rhs) &#123;x *= rhs; y *= rhs; return *this;&#125; point &amp;operator /=(const number rhs) &#123;x /= rhs; y /= rhs; return *this;&#125; bool operator ==(const point &amp;rhs) const &#123;return x == rhs.x &amp;&amp; y == rhs.y;&#125; bool operator !=(const point &amp;rhs) const &#123;return !(rhs == *this);&#125; number dot(const point &amp;rhs) const &#123;return x * rhs.x + y * rhs.y;&#125; number cross(const point &amp;rhs) const &#123;return rhs.y * x - rhs.x * y;&#125; auto length() const &#123;return sqrt(dot(*this));&#125; auto distance(const point &amp;b) const &#123;return (*this - b).length();&#125; auto distance(const point &amp;ls, const point &amp;rs) const &#123;return fabs((ls - *this).cross(rs - *this)) / ls.distance(rs);&#125; point normal() const &#123;return (x || y) ? *this / length() : point(0, 0);&#125; auto angle() const &#123;return atan2(y, x);&#125; point rotate(number a) const &#123;number c = cos(a), s = sin(a); return &#123;c * x - s * y, s * x + c * y&#125;;&#125; point perpendicular() const &#123;return &#123;-y, x&#125;;&#125; point symmetry() const &#123;return &#123;-x, -y&#125;;&#125; number square() const &#123; return x * x + y * y; &#125; &#125;;&#125;template &lt;class T&gt; int sgn(T t) &#123;return t ? (t &lt; 0 ? -1 : 1) : t;&#125;using point = Geo::point;using frac = fraction&lt;longs&gt;;const int N = 2060;point a[N];vector&lt;frac&gt; li;frac cosLemmaSquare(const point &amp;p1, const point &amp;p2)&#123; auto aa = p1.square(), bb = (p2 - p1).square(), cc = p2.square(); longs x = bb + cc - aa, f = sgn(x); return &#123;f * x * x, 4ll * bb * cc&#125;;&#125;int main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); longs n, ans = 1; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) cin &gt;&gt; a[i].x &gt;&gt; a[i].y; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++ j) if (a[i].cross(a[j]) &gt; 0) li.push_back(cosLemmaSquare(a[i], a[j])); sort(li.begin(), li.end(), [](frac &amp;a, frac &amp;b)&#123;return a.compareTo(b) &lt; 0;&#125;); longs len = li.size(), l = 0; while (l &lt; len) &#123; auto r = l; while (r &lt; len &amp;&amp; li[r] == li[l]) ++ r; ans = max(ans, r - l + 1); l = r; &#125; li.clear(); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 需要注意的是，如果使用精准比较（“&lt;” 和 “==” 运算符），中间结果可能会爆 long long，所以如果在 Windows 环境下则可以考虑在合适的误差下使用浮点比较（equals 和 compareTo 方法）； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;using longs = long long;using uint = unsigned;inline int nextInt()&#123; int x = 0, f = 1, ch = getchar(); while (!isdigit(ch)) if (ch == &#x27;-&#x27;) f = -1, ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar(); return x * f;&#125;template &lt;class T&gt; struct fraction&#123; T num, den; fraction() = default; fraction(T u, T v): num(u), den(v) &#123; if (!v) num = 1; else if (v &lt; 0) num = -u, den = -v; &#125; constexpr static const long double $eps = 0; static int sgn(long double x) &#123;return x &lt; -$eps ? -1 : x &gt; $eps;&#125; static T gcd(T a, T b) &#123;return a &lt; b ? gcd(b, a) : (!b ? a : gcd(b, a % b));&#125; auto toNumber() const &#123; return (long double) num / den; &#125; int compareTo(const fraction &amp;rhs) const &#123;return sgn(this-&gt;toNumber() - rhs.toNumber());&#125; bool equals(const fraction &amp;rhs) const &#123;return den == 0 || rhs.den == 0 ? den == rhs.den : !compareTo(rhs);&#125; fraction &amp;reduce() &#123; auto x = gcd(num, den); num /= x, den /= x; return *this;&#125; bool operator ==(const fraction &amp;rhs) const &#123; return num * rhs.den == den * rhs.num;&#125; bool operator &lt;(const fraction &amp;rhs) const &#123;return den &amp;&amp; (!rhs.den || compareTo(rhs) &lt; 0);&#125; fraction operator -() const &#123;return &#123;-num, den&#125;;&#125;&#125;;namespace Geo&#123; using number = longs; const number eps = fraction&lt;longs&gt;::$eps; int compareTo(number x) &#123;return x &lt; -eps ? -1 : x &gt; eps;&#125; int compareTo(number a, number b) &#123;return compareTo(a-b);&#125; struct point &#123; number x, y; point() = default; point(number x, number y) : x(x), y(y) &#123;&#125; point operator +(const point &amp;rhs) const &#123;return &#123;x + rhs.x, y + rhs.y&#125;;&#125; point operator -(const point &amp;rhs) const &#123;return &#123;x - rhs.x, y - rhs.y&#125;;&#125; number operator *(const point &amp;rhs) const &#123;return x * rhs.x + y * rhs.y;&#125; point operator *(const number rhs) const &#123;return &#123;rhs * x, rhs * y&#125;;&#125; point operator /(const number rhs) const &#123;return &#123;x / rhs, y / rhs&#125;;&#125; point &amp;operator +=(const point&amp; rhs) &#123;x += rhs.x; y += rhs.y; return *this;&#125; point &amp;operator -=(const point&amp; rhs) &#123;x -= rhs.x; y -= rhs.y; return *this;&#125; point &amp;operator *=(const number rhs) &#123;x *= rhs; y *= rhs; return *this;&#125; point &amp;operator /=(const number rhs) &#123;x /= rhs; y /= rhs; return *this;&#125; bool operator ==(const point &amp;rhs) const &#123;return x == rhs.x &amp;&amp; y == rhs.y;&#125; bool operator !=(const point &amp;rhs) const &#123;return !(rhs == *this);&#125; number dot(const point &amp;rhs) const &#123;return x * rhs.x + y * rhs.y;&#125; number cross(const point &amp;rhs) const &#123;return rhs.y * x - rhs.x * y;&#125; number length() const &#123;return sqrt(dot(*this));&#125; number distance(const point &amp;b) const &#123;return (*this - b).length();&#125; number distance(const point &amp;ls, const point &amp;rs) const &#123;return fabs((ls - *this).cross(rs - *this)) / ls.distance(rs);&#125; point normal() const &#123;return (x || y) ? *this / length() : point(0, 0);&#125; number angle() const &#123;return atan2(y, x);&#125; point rotate(number a) const &#123;number c = cos(a), s = sin(a); return &#123;c * x - s * y, s * x + c * y&#125;;&#125; point perpendicular() const &#123;return &#123;-y, x&#125;;&#125; point symmetry() const &#123;return &#123;-x, -y&#125;;&#125; number square() const &#123; return x * x + y * y; &#125; &#125;;&#125;using point = Geo::point;using frac = fraction&lt;longs&gt;;const int N = 2060;point a[N];vector&lt;frac&gt; li;frac getSlope(const point &amp;ll, const point &amp;rr = &#123;0, 0&#125;)&#123; auto ld = ll.square(), rd = rr.square(); if (!ld) ld = 1; if (!rd) rd = 1; return &#123;rr.y * ld - ll.y * rd, rr.x * ld - ll.x * rd&#125;;&#125;int main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); longs n, ans = 1; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++ i) cin &gt;&gt; a[i].x &gt;&gt; a[i].y; for (int i = 0; i &lt; n; ++ i) &#123; frac tmp = getSlope(a[i]); for (int j = i + 1; j &lt; n; ++ j) &#123; frac ff = getSlope(a[i], a[j]); if (ff.equals(tmp)) continue; li.push_back(ff); &#125; sort(li.begin(), li.end()); auto len = li.size(); for (int l = 0, r = 0; l &lt; len;) &#123; r = l; while (r &lt; len &amp;&amp; li[r].equals(li[l])) ++ r; ans = max(ans, r - l + 1ll); l = r; &#125; li.clear(); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 新嫖的分数类板子↑↑；这是武大仓鼠队使用圆的反演的做法，比较神奇的是这个题必须在允许误差为 0 时才可以 A。至于圆的反演，那是平面几何中的，有点像复变里的共形映射，之后应该会开篇文章专门学吧（ C - Cover the Tree 给一颗 n 个节点的无根树，你需要给出多条链使得该树所有树边被覆盖，且链的数量尽可能少； 数据范围：n ≤ 2e5； D - Duration 签到题，直接读入计算即可但是队友白给两发草 1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;cctype&gt;using namespace std;inline int nextInt()&#123; int x = 0, f = 1, ch = getchar(); while (!isdigit(ch)) if (ch == &#x27;-&#x27;) f = -1, ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar(); return x * f;&#125;int main()&#123; auto h1 = nextInt(), m1 = nextInt(), s1 = nextInt(); auto h2 = nextInt(), m2 = nextInt(), s2 = nextInt(); auto $1 = h1 * 3600 + m1 * 60 + s1; auto $2 = h2 * 3600 + m2 * 60 + s2; cout &lt;&lt; abs($1 - $2); return 0;&#125; E - Exclusive OR 给长为 n 的数组 A，现要求你在数组中可重复的选出 i 个数字，使得这 i 个数字的异或和最大；要求你对於一组数据，输出 i ∈ [1, n] 时的答案； 数据范围：n ≤ 2e5，A ≤ 2e18； F - Fake Maxpooling 给定 n × m 的矩阵，找到其中所有 k × k 矩阵的最大值并求和； 数据范围：k ≤ n, m ≤ 5000 一看是个二维最值，自信满满的敲了个二维 ST 表的板子然后 T 了…… 用 gprof 分析显示 gcd 用时 33%，ST 表构造用时 30%，花掉了大量的时间；二维 ST 表是 O(n²log²n) 的，求出 gcd 也是 O(nmlogn) 的，难怪过不了…… NF0Q2_TXK0U5ESOA0XH.png 后来一看洛谷那个二维 ST 表的板子题数据规模是 100…… 但是转念一项我那个板子与其说是二维 ST 表不如说是倍增 DP，复杂度应该只有一个 log ——生成表的那个；因为正方形大小是确定的，所以不需要保留多维数据，可以直接滚动，所以也不存在空间方面的问题…… 那果然就是 33% gcd 的错了！因为空间只有 256 MB 比较紧巴，所以 gcd 的记忆化直接在 mat 数组里做了，之后再遍历一波手动求 lcm 就行（ 然后就过了，めでたしめでたし（虽然比赛时是队友写的滑动窗口就是了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;using longs = long long;using uint = unsigned;inline int nextInt()&#123; int x = 0, f = 1, ch = getchar(); while (!isdigit(ch)) if (ch == &#x27;-&#x27;) f = -1, ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar(); return x * f;&#125;const int N = 5005;int mat[N][N];inline longs gcd(longs a, longs b)&#123; if (a &lt; b) gcd(b, a); if (mat[a][b]) return mat[a][b]; if (!b) return mat[a][b] = a; else return mat[a][b] = gcd(b, a % b);&#125;namespace STtable2D_simple&#123; int log[N], high[N][N]; uint _log; int row, col, sq, _max; template &lt;class T&gt; T max4(T t1, T t2, T t3, T t4) &#123; return max(max(t1, t2), max(t3, t4)); &#125; auto import = [] &#123; for (int i = 1; i &lt;= row; ++ i) for (int j = 1; j &lt;= col; ++ j) high[i][j] = mat[i][j]; _log = log[sq]; &#125;; void init(uint k) &#123; log[0] = -1; for (uint i = 1; i &lt;= k; ++ i) log[i] = log[i &gt;&gt; 1u] + 1; memset(high, 0x80, sizeof(high)); import(); &#125; void make(uint a, uint b) &#123; for (uint p = 0; p &lt; _log; ++ p) for (int i = 1; i + (1u &lt;&lt; p) &lt;= a; ++ i) for (int j = 1; j + (1u &lt;&lt; p) &lt;= b; ++ j) high[i][j] = max4&lt;int&gt;( high[i][j], high[i + (1u &lt;&lt; p)][j + (1u &lt;&lt; p)], high[i + (1u &lt;&lt; p)][j], high[i][j + (1u &lt;&lt; p)] ); &#125; void query(int x, int y) &#123; _max = max4&lt;int&gt;( high[x][y], high[x + sq - (1u &lt;&lt; _log)][y + sq - (1u &lt;&lt; _log)], high[x][y + sq - (1u &lt;&lt; _log)], high[x + sq - (1u &lt;&lt; _log)][y] ); &#125; auto solve(int n, int m, int k) &#123; row = n, col = m, sq = k; init(k); make(n, m); longs ans = 0; const int $row = n - k + 1, $col = m - k + 1; for (int i = 1; i &lt;= $row; ++ i) for (int j = 1; j &lt;= $col; ++ j) query(i, j), ans += _max; return ans; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for (int i = 1; i &lt;= n; ++ i) for (int j = 1; j &lt;= m; ++ j) gcd(i, j); for (int i = 1; i &lt;= n; ++ i) for (int j = 1; j &lt;= m; ++ j) mat[i][j] = i * j / mat[i][j]; auto xx = STtable2D_simple::solve(n, m, k); cout &lt;&lt; xx &lt;&lt; endl; return 0;&#125; 然后发现这个题目似乎并不需要“二维单调队列”，只需要一维单调队列横纵两次就可以了== 毕竟 ST 表都可以偷懒到这种程度，所以可以过也是可以过吧（ 除了稳健的记忆化，将求出矩阵的 gcd 的时间变成了 O(nm) 之外，还可以使用出题人的申必方法： 1234for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) if (!Gcd[i][j]) for (int k = 1; k * i &lt;= n &amp;&amp; k * j &lt;= m; k ++) Gcd[k * i][k * j] = k, A[k * i][k * j] = i * j * k; 这也是某种筛法，只是出题人也忘记它叫什么名字了== 但是还是看起来就很稳健的记忆化搜索比较好写（ 值得一提的是，在比赛的时候有不少人都是“猜测”最大值出现在左下角/右下角 10 步位置内的，也都成功 AC 了。 G - Greater and Greater 给定长度为 n 的数组 A 以及长度为 m 的数组 B；在 A 中找到长度为 m 的子区间 S，使得对于 \\(\\forall i \\in [1, m]\\) 都有 \\(S_i &gt; B_i\\)；要求求出这样的 S 的数目； 数据范围：n ≤ 150000，m ≤ min(n, 40000)； H - Happy Triangle q 次操作，可重集合中插入删除数据，在线询问对于一个数，判断集合中是否存在两个数，使得以它们为边长的线段可以组成一个非退化三角形； 数据范围：q ≤ 2e5； 这个可重集合用 multiset 都可以，关键问题在于怎么样快速判断是否存在可以凑成三角形的两个数；首先我们考虑只看大小相邻的两个边长 a, b； I - Interval J - Just Shuffle 给定一个长度为 n 的 1~n 的排列，要求你构造出一个置换 P，在恰好 k 次置换后将 1~n 变换为目标排列； 数据范围：n ≤ 1e5，1e8 ≤ k ≤ 1e9； K - Keyboard Free 给定三个半径不同的同心圆的半径，每个圆的边界上有一个动点，并且组成一个三角形；求该三角形面积的数学期望； 数据范围：r ≤ 100； 后记 听完了题解，这个小哥哥讲题就比昨天那位好多了 == 虽然也没有讲很长时间但是和昨天那进行对比高下立判（ 虽然最后摆一句没看懂私聊，结果他本人不在我在的那个群里倒也有些麻烦== 不过参考之前竞赛培训加了好友那也多半是吹水吹逼而不会去讨论正经的学术问题吧可能只有我是这样的（ 最后我心心念念的二维 ST 表也过了，非常的好== 可是听完直播课之后回顾一遍题目，真正会做的又只有几个题呢？道阻且长啊（","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"https://shiraha.cn/tags/Nowcoder/"}]},{"title":"Nowcoder 2020 暑期多校训练 （1）","slug":"nowcoder-2020-summer-multi-1","date":"2020-07-12T05:19:58.000Z","updated":"2020-07-12T05:19:58.000Z","comments":true,"path":"2020/nowcoder-2020-summer-multi-1/","link":"","permalink":"https://shiraha.cn/2020/nowcoder-2020-summer-multi-1/","excerpt":"","text":"一共 10 个题目，能做的有几个？ 听完叉姐（？）讲题目最速传说快于洛谷，好多题目都是论文的结论题…… 队内群友对此以及讲题纷纷发表各自的高见，可大佬的关注点总是和咱菜鸡不太一样…… 咱也不知道，咱也不敢问（ 5KVYKS6_FJQEAQJGGX5.jpg ↑ 要被大一队友嫌弃力，乌乌 ↑ 多亏这次是校队全队参加比赛，hls 已经开始撰写队内题解了，这是好的，不然我属实补不了题了（ A : B-Suffix Array 对于字符串 \\(t_1t_2...t_k\\)，有函数 \\(B(t_1t_2...t_k) = b_1b_2...b_k\\) 定义如下： 若存在下标 j &lt; i 使得 \\(t_j = t_i\\)，那 \\(b_i = min_{1 \\leq j \\lt i, t_j = t_i} i - j\\)； 否则，\\(b_i = 0\\)； 对于给定长为 n 字符串 s 的 n 个后缀，根据 B 函数的值进行字典序排序；字符串 s 仅由 a 和 b 构成； 数据范围：n ≤ 1e5，Σn ≤ 1e6； B : Infinite Tree 令 \\(mindiv(n)\\) 为 n 大于 1 的最小因数；现对于全体正整数，在 n - \\(\\frac n{mindiv(n)}\\) 之间连边构成树；令 \\(\\delta (u,v)\\) 为节点 u v 之间的边数，给定 \\(w_1...w_n\\)，求 \\(min_u\\sum^m_{i=1} w_i\\delta(u,i!)\\)。 数据范围：1 ≤ m ≤ 1e5，0 ≤ wi ≤ 1e4，Σm ≤ 1e6； C : Domino 有两个 n × m 的矩阵，由 1 × 2 的砖块和 2 × 1 的砖块密铺；你可以将 2 × 2 范围内的两块相同的砖块调转方向（换成两块另一种砖块），问你需要操作多少次才能使得两个矩阵中的砖块排布一致； 数据范围：n, m ≤ 1e3，n × m ≤ 2e6； D : Quadratic Form 太麻烦了…… E : Counting Spanning Trees 二分图包含 X（n个节点）和 Y（m个节点）两个部分；每一个 \\(x_i\\) 连接到了 Y 的前 \\(a_i\\) 个节点；给定 n, m, a 和 mod，求在模 mod 意义下生成树的数量； 数据范围：1 ≤ n,m ≤ 1e5，1 ≤ mod ≤ 1e9，1 ≤ a ≤ m，Σn ≤ 1e6； F : Infinite String Comparision s 为字符串，定义 \\(s^\\infty\\) 为字符串 s 的无穷循环；现给定字符串 a, b，要求比较 \\(a^\\infty, b^\\infty\\)； 数据范围：1 ≤ |a|, |b| ≤ 1e5，Σs ≤ 1e6； 签到题，稍微优雅的暴力（直接比较）就可以过但是我白给两发；但是其实也是有正经做法的，原题解中说到： 通过 Periodicity Lemma，仅比较前 a + b - gcd(a, b) 个字符即可判断字符串大小； 所以，这个代码暴力的极限不是 LCM，而是定理中的 Periodicity Lemma； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;using longs = long long;using uint = unsigned;inline int nextInt()&#123; int x = 0, f = 1, ch = getchar(); while (!isdigit(ch)) if (ch == &#x27;-&#x27;) f = -1, ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar(); return x * f;&#125;inline longs gcd(longs a, longs b)&#123; if (a &lt; b) swap(a, b); if (!b) return a; else return gcd(b, a % b);&#125;string a, b;int main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); while (cin &gt;&gt; a &gt;&gt; b) if (a.length() == b.length()) &#123; if (a == b) cout &lt;&lt; &#x27;=&#x27; &lt;&lt; endl; else if (a &lt; b) cout &lt;&lt; &#x27;&lt;&#x27; &lt;&lt; endl; else cout &lt;&lt; &#x27;&gt;&#x27; &lt;&lt; endl; &#125; else &#123; longs _a = a.length(), _b = b.length(); longs ca = 0, cb = 0, cnt = 0; longs lim = _a + _b - gcd(_a, _b); while (cnt &lt; lim) &#123; if (a[ca] != b[cb]) break; ca = (ca + 1) % _a; cb = (cb + 1) % _b; ++ cnt; &#125; if (cnt == lim) cout &lt;&lt; &#x27;=&#x27; &lt;&lt; endl; else if (a[ca] &lt; b[cb]) cout &lt;&lt; &#x27;&lt;&#x27; &lt;&lt; endl; else cout &lt;&lt; &#x27;&gt;&#x27; &lt;&lt; endl; &#125; return 0;&#125; 那么什么是 Periodicity Lemma 呢？ 关于 Periodicity Lemma 周期引理：字符串 S 有循环节 p 和 q 并满足 p + q ≤ |S| + gcd(p, q)，那么 gcd(p, q) 也是一个循环节； 在这一题里的用法？ 显然，a 和 b 是待比较字符串（现设为 A 和 B，长度为 ∞）的循环节；我们先假设 A = B = S，那么 a 和 b 都是 S 的循环节；因为 |S| = ∞，所以 a + b - gcd(a, b) ≤ |S| 可以使用周期引理：gcd(a, b) 是 S 的循环节；因为串 gcd(a, b) 较短，它成为了循环节，则整个串显然相同； 如果 A，B 的前 a + b - gcd(a, b) 位不相同，则不能被看作是一个字符串，上述假设就失效了；这时也可以判定字符串的字典序大小，直接输出即可； 简单的说，若两个字符串相等的假设成立，那么就一定可以证明 gcd(a, b) 长度的字串是循环节，这个串的长度小于 a 和 b，且再使用引理的过程中已经判等了，所以两个串相等，假说也成立； 引理证明？ 组内大佬证明了，我学会了再发上来； F-Lemma-hjl.png 先贴另一个组内大佬的证法 ↑ G : BaXianGuoHai, GeXianShenTong 太长了不翻译了…… H : Minimum-cost Flow 有一个网络，包括 n 个节点和 m 个弧边，每条边有费用 c； 进行 q 次询问，每个询问当所有边的容量为 u/v 时，将单位流量从节点 1 到节点 n 所需要的最小费用； 可行时，输出最小费用，否则输出 NaN； 数据范围：2 ≤ n ≤ 50，1 ≤ m ≤ 100，c, q ≤ 1e5，u, v ≤ 1e9；Σm ≤ 1e4，Σq ≤ 1e6； I : 1 or 2 一张图，有 n 个点，给定 m 条边；问可不可以选出一些边，使得第 i 个点恰好连接了 \\(d_i\\) 条边；只需要判断是否可行，而无需输出具体选择方案。 数据规模：不超过 100 组测试数据；n ≤ 50，m ≤ 100，\\(d_i \\in\\) {1, 2}； J : Easy Integration 求 \\(\\int_0^1 (x - x^2)^n dx\\) 在 998244353 下的模，n ≤ 1e6；不超过 1e5 组数据。 一个计算题，因为大一队友光速推出公式所以我就直接码代码了；没想到还是有点麻烦的…… 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;using longs = long long;using uint = unsigned;inline int nextInt()&#123; int x = 0, f = 1, ch = getchar(); while (!isdigit(ch)) if (ch == &#x27;-&#x27;) f = -1, ch = getchar(); while (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar(); return x * f;&#125;const longs mod = 998244353;const longs p = mod - 2;int fracMod(longs a, longs b) // 费马小定理法&#123; auto n = p; longs ans = 1; while (n) &#123; if (n &amp; 1) ans = (ans * b) % mod; b = (b * b) % mod; n &gt;&gt;= 1; &#125; ans = (ans * a) % mod; return (int) ans;&#125;const int N = 1e6 + 5;longs ans[N];auto init = []&#123; longs a = 1, b = 1; for (longs i = 1; i &lt; N; ++ i) &#123; a = (a * i) % mod; b = (2 * b * (2 * i + 1)) % mod; ans[i] = fracMod(a, b); &#125;&#125;;int main()&#123; ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); init(); longs n; while (cin &gt;&gt; n) cout &lt;&lt; ans[n] &lt;&lt; endl; return 0;&#125; 后记","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"https://shiraha.cn/tags/Nowcoder/"}]},{"title":"在 Windows 10 中使用 zsh 作为默认终端","slug":"use-zsh-in-windows-10-with-wtd-and-vscode","date":"2020-07-05T05:44:05.000Z","updated":"2021-06-22T08:47:15.000Z","comments":true,"path":"2020/use-zsh-in-windows-10-with-wtd-and-vscode/","link":"","permalink":"https://shiraha.cn/2020/use-zsh-in-windows-10-with-wtd-and-vscode/","excerpt":"","text":"不能再不更新博客了，可是这段时间因为各种考试大作业课设然后人又比较摸所以就没有什么文章更新；这篇文章也是开了好久才慢慢的补全的== 废话不多说，既然是花里胡哨的东西那就尽快的说完== Windows 10 终端美化还是有不少事情可以搞的：比如通过 WSL 使用美妙的 Linux 终端，比如使用美丽的 UWP 终端软件替换掉愚蠢的 Windows 自带的 conhost.exe，还比如使用某些模拟环境的终端；下面一点点讲： 终端客户端 推荐两个，一个是 Windows Terminal，微软开源的美丽的 UWP 终端，另有预览版下载；非预览版可以使用 wt 命令直接打开，预览版没试过，似乎不行；如果是自行构建的版本可以用 wtd 命令直接打开；然后就是 Fluent Terminal，也是开源的，现在上了 Microsoft Store；个人觉得这个比上一个好看，但是现在用的还是前者居多； 从上面的两个终端中选择一个下载安装即可，都是 UWP 应用；因为现在微软官方的终端的使用体验已经很好了，所以建议直接下载 Windows Terminal，后面的教程也全部基于这个； 补充说明：虽然不能方便的使用命令行唤起 Windows Terminal Preview，但是可以通过增加到右键菜单来方便的使用它：在 C:\\Users\\&lt;username&gt;\\AppData\\Local\\Microsoft\\WindowsApps 目录下有很多 UWP App 命令行启动的程序，Windows Terminal Preview 的启动程序也在其中：它还叫 wt.exe，但是并不在根目录下，很容易就可以找到；然后将注册表文件中对应的项目换成 Preview 的接口就可以了： 12345678Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wt]@&#x3D;&quot;Open Windows Terminal Here&quot;&quot;Icon&quot;&#x3D;&quot;C:\\\\Env\\\\wtp.ico&quot;[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wt\\command]@&#x3D;&quot;C:\\\\Users\\\\Shiroha\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps\\\\wt.exe&quot; 在我的电脑上，Windows Terminal Preview 的位置是 C:\\Users\\shiroha\\AppData\\Local\\Microsoft\\WindowsApps\\Microsoft.WindowsTerminalPreview_8wekyb3d8bbwe\\wt.exe 加上转义符号进行替换即可；图标的话也做好了，直接下载普通版或者预览版的图标，放在特定位置之后修改上面的图标路径就可以了； 此外，为了保证终端可以在我们唤起菜单的目录下启动，我们需要将对应（默认）配置文件的启动目录（\"startingDirectory\"）换成 null； PowerShell 美化 这是微软的 shell 程序，比 cmd 先进，内置在 Windows 10 内的版本是 5.0，但是现在已经有全新的 PowerShell Core 7.0 可供下载安装了，个人建议下载一个，毕竟后面那个跨平台（）但是不下也可以，不妨碍后面的教程： 因为苹果 zsh 的终端有各种花里胡哨的东西，所以 PowerShell 也想变漂亮；在 zsh 中有一个比较厉害的插件叫做 oh-my-zsh，所以到 PowerShell 这里来就整了一个差不多的 oh-my-posh，也可以美化 PowerShell； 因为 Windows Terminal + PowerShell Core + oh my posh 已经被微软官方认定为最佳组合了，所以官方也整了一个教程教你怎么使用这个玩意了，所以可以直接去看（ 安装 Powerline 字体 微软官方的 PowerLine 字体 Cascadia Code / Cascadia Mono，可以直接下载安装； 个人比较喜欢的 Menlo 字体，可以从它的发布页下载； 这里还有一个整合包：Github 仓库地址，包含了绝大多数比较好看的 PL 字体，并且有安装脚本； 当然，Jetbrains 家的 Jetbrains Mono，Mozilla 家的 Fira 等等有名字体都是有 PL 版本的，可以百度自行下载； PowerLine 字体为一些特殊形状提供支持（比如箭头啊，Git 标志啊，苹果/Ubuntu 标志啊之类的），要想在控制台上显示这些图标，必须要有 PowerLine 字体支持； 但是标准 PowerLine 字体包含的特殊图标并不多，如果需要使用包含更多图标的终端，可能需要一些 Nerd 字体（下面有讲），比如Hack Nerd Font； 安装 oh my posh 首先，你得安装 Git for Windows； 然后，在管理员状态下的 PowerShell (Core) 中运行下面的命令安装 oh my posh 及相关组件： 12Install-Module posh-git -Scope CurrentUserInstall-Module oh-my-posh -Scope CurrentUser 中途遇到询问全部选是。这可能会自动在电脑上安装包管理器 NuGet；Posh-Git 提供了 Git 状态信息的提示，并为 Git 命令、参数、远程和分支名称等添加 tab 自动补全； Oh-My-Posh 为 PowerShell 提供主题了功能。 如果是 PowerShell Core，您还需要安装 PSReadline： 1Install-Module -Name PSReadLine -Scope CurrentUser -Force -SkipPublisherCheck 它允许在 PowerShell 中自定义命令行编辑环境； 之后使用下面的命令打开/新建一个 PowerShell 配置文件，它的作用和 Linux 中的 ~/.bashrc 相似； 12if (!(Test-Path -Path $PROFILE )) &#123; New-Item -Type File -Path $PROFILE -Force &#125;notepad $PROFILE 不使用路径检测，直接输入 notepad $PROFILE 也会直接创建一个新文件，只是会弹出对话框询问而已； 之后会用 notepad 打开这个配置文件，在其中加上下面的内容： 123Import-Module posh-gitImport-Module oh-my-poshSet-Theme Paradox 可以自行选择主题样式，oh my posh 自带十个经典主题；官方文档中使用的是 Paradox，这个主题的单行版本是 Agnoster；显示的比较详尽的主题有 Honukai，oh-my-zsh 经典主题是 robbyrussell；还有几个比较特别的是 PowerLine 和 Darkblood；即使你没有使用 PowerLine 字体，使用经典主题 robbyrussell 也不会出现方块问题，这是好的。 设置终端样式 我们必然要通过 Windows Terminal 来使用全新的 PowerShell；打开 Windows Terminal 的配置文件页面，增加/修改对应的配置文件： 1234567891011121314&#123; &quot;theme&quot;: &quot;dark&quot;, &quot;profiles&quot;: [ &#123; &quot;name&quot; : &quot;Powershell&quot;, &quot;source&quot; : &quot;Windows.Terminal.PowershellCore&quot;, &quot;acrylicOpacity&quot; : 0.7, &quot;colorScheme&quot; : &quot;Campbell&quot;, &quot;cursorColor&quot; : &quot;#FFFFFD&quot;, &quot;fontFace&quot; : &quot;Cascadia Code PL&quot;, &quot;useAcrylic&quot; : true &#125; ]&#125; 或者： 12345678910111213141516171819202122232425262728293031323334353637&#123; &quot;theme&quot;: &quot;light&quot;, &quot;profiles&quot;: [ &#123; &quot;name&quot; : &quot;PowerShell&quot;, &quot;source&quot; : &quot;Windows.Terminal.PowershellCore&quot;, &quot;acrylicOpacity&quot;: 0.7, &quot;colorScheme&quot; : &quot;Frost&quot;, &quot;cursorColor&quot; : &quot;#000000&quot;, &quot;fontFace&quot; : &quot;Cascadia Code PL&quot;, &quot;useAcrylic&quot;: true &#125; ], &quot;schemes&quot;: [ &#123; &quot;name&quot; : &quot;Frost&quot;, &quot;background&quot; : &quot;#FFFFFF&quot;, &quot;black&quot; : &quot;#3C5712&quot;, &quot;blue&quot; : &quot;#17b2ff&quot;, &quot;brightBlack&quot; : &quot;#749B36&quot;, &quot;brightBlue&quot; : &quot;#27B2F6&quot;, &quot;brightCyan&quot; : &quot;#13A8C0&quot;, &quot;brightGreen&quot; : &quot;#89AF50&quot;, &quot;brightPurple&quot; : &quot;#F2A20A&quot;, &quot;brightRed&quot; : &quot;#F49B36&quot;, &quot;brightWhite&quot; : &quot;#741274&quot;, &quot;brightYellow&quot; : &quot;#991070&quot;, &quot;cyan&quot; : &quot;#3C96A6&quot;, &quot;foreground&quot; : &quot;#000000&quot;, &quot;green&quot; : &quot;#6AAE08&quot;, &quot;purple&quot; : &quot;#991070&quot;, &quot;red&quot; : &quot;#8D0C0C&quot;, &quot;white&quot; : &quot;#6E386E&quot;, &quot;yellow&quot; : &quot;#991070&quot; &#125; ] &#125; 上面的是官方提供的明暗两种配色方式，只需要保证在对应的配置文件中选择了 PL 字体就可以了； 又及：我的两台电脑的 PowerShell 中 ls 命令均自动指向 dir 命令，而我的小伙伴的电脑却没有，需要手动设置或者安装 Gow 来实现（个人不太喜欢 Gow）；我不知道这是什么原因，可能某些软件安装时会自动帮你设置这些吧；此外，其他教程中有提到安装 Chocolatey，这是一个 Windows 包管理器，和 homebrew 很像，但是因为没有必要所以这里没有提； 原生 zsh 但是比起主题受限的 PowerShell，我想可能还是 zsh 更加有吸引力；虽然 zsh 是 Linux 上的玩意，但是我想大家都用过 Git Bash —— 一个基于 MinGW64 环境的仿 Linux 环境的终端；虽然它已经很 Linux 了，但是很多功能还是被删减了；但是我们可以使用未删减的 Git SDK 来使用 zsh； Git SDK 全称 Git for Windows SDK，是基于 MSYS2（MinGW64 + Cygwin 合体增强）的仿 Linux 环境；安装后大约会占用 4~5 GB 的磁盘空间，但是包含了完整的仿 Linux 环境：包括常用工具，完整的 GNU Complier 链以及包管理器 pacman；基本上是一套完整的集成开发环境，所以是 SDK == 此外，虽然 Git SDK 是基于 MSYS2 的，是 Git 的超集…… 但是你仍然需要安装 Git（可能可以通过适当的配置解决），因为很多软件只认识 Git；建议安装 Git SDK 而不是 MSYS2，因为前者比后者好用（原因不明）。 安装 Git SDK 你可以去 Git for Windows 官网，拉到最下面可以看到 Git SDK 的下载；这样下载的是一个安装器，会自动从一个仓库克隆这个程序所需要的全部文件但是下载速度感人，即使你科学上网也不能保证一个满意的下载速度；所以个人建议直接去 Github 仓库下载 main 分支下的文件；注意的是后者解包后文件总大小小于前者，笔者安装过程中也意外发现只有后者可以在我的电脑上正常运行，所以建议直接拉取 Github 仓库； 将解压后的文件放在某个位置，并且将其目录下的 usr/bin 文件夹加入系统变量——因为这样用起来比较舒服，一些程序（比如 zsh）在全局变量空间中也能找到 MSYS2 的工具包，但是这可能会和其他类似工具比如 Gow 产生冲突，所以一般加在靠后的位置，这样就会优先使用 Windows 中的工具； 安装 zsh 以及 oh my zsh 这一部分的教程好像挺多的，不再重复说明了…… 算了还是说一下吧： 修改 pacman 软件包源 在 /etc/pacman.d/ 目录下有三个文件：mirrorlist.msys、mirrorlist.mingw64 和 mirrorlist.mingw32；我们可以直接在 Windows 中使用文本编辑器修改它们为国内源： 1234567891011121314151617181920212223242526272829303132333435#### MSYS2 repository mirrorlist#### Primary## msys2.orgServer &#x3D; http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;msys2&#x2F;msys&#x2F;$arch&#x2F;Server &#x3D; http:&#x2F;&#x2F;repo.msys2.org&#x2F;msys&#x2F;$archServer &#x3D; http:&#x2F;&#x2F;downloads.sourceforge.net&#x2F;project&#x2F;msys2&#x2F;REPOS&#x2F;MSYS2&#x2F;$archServer &#x3D; http:&#x2F;&#x2F;www2.futureware.at&#x2F;~nickoe&#x2F;msys2-mirror&#x2F;msys&#x2F;$arch&#x2F;Server &#x3D; https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;msys2&#x2F;msys&#x2F;$arch&#x2F;#### 64-bit Mingw-w64 repository mirrorlist#### Primary## msys2.orgServer &#x3D; http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;msys2&#x2F;mingw&#x2F;x86_64&#x2F;Server &#x3D; http:&#x2F;&#x2F;repo.msys2.org&#x2F;mingw&#x2F;x86_64Server &#x3D; http:&#x2F;&#x2F;downloads.sourceforge.net&#x2F;project&#x2F;msys2&#x2F;REPOS&#x2F;MINGW&#x2F;x86_64Server &#x3D; http:&#x2F;&#x2F;www2.futureware.at&#x2F;~nickoe&#x2F;msys2-mirror&#x2F;x86_64&#x2F;Server &#x3D; https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;msys2&#x2F;mingw&#x2F;x86_64&#x2F;#### 32-bit Mingw-w64 repository mirrorlist#### Primary## msys2.orgServer &#x3D; http:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;msys2&#x2F;mingw&#x2F;i686&#x2F;Server &#x3D; http:&#x2F;&#x2F;repo.msys2.org&#x2F;mingw&#x2F;i686Server &#x3D; http:&#x2F;&#x2F;downloads.sourceforge.net&#x2F;project&#x2F;msys2&#x2F;REPOS&#x2F;MINGW&#x2F;i686Server &#x3D; http:&#x2F;&#x2F;www2.futureware.at&#x2F;~nickoe&#x2F;msys2-mirror&#x2F;i686&#x2F;Server &#x3D; https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;msys2&#x2F;mingw&#x2F;i686&#x2F; 注意服务器的顺序，将国内服务器放在优先的位置才能保证 pacman 优先使用它； 调整之后执行 pacman -Syu 和 pacman -Su 更新源信息，首次更新可能需要重启； 安装相关软件包 首先，我们要有 zsh： 1pacman -S zsh 然后，我们要有 oh-my-zsh： 123sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;# ↑ 通过 curl 或者 通过 wget ↓sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 当然，修改 host 文件，设置终端代理过于麻烦；我们可以科学上网后直接访问上述命令中的地址，获得脚本的内容后放到某个文件夹下，再使用 zsh 去执行脚本即可； 安装后脚本会在 ~ 目录下创建 .oh-my-zsh 目录，和 ~/.zshrc 在同一个目录中；这个 ~ 目录对应的就是 Windows 的用户文件夹，注意不要删掉它们；如果觉得碍眼可以把它们设为系统文件 + 隐藏文件（cmd 中的 attrib +s+h 或者 PowerShell 中的 $file.Attributes += 'hidden, system'），就不会在资源管理器中看到它们了； 关闭自动更新 此外，oh-my-zsh 会定期的运行更新检查来从 Github 下载最新的更新；但是由于国内网络环境的因素，这个过程并不能流利地进行，这样就会导致在更新的时候卡在初始化终端，造成不好的体验；关闭自动更新也需要编辑 ~/.zshrc 文件，找到 DISABLE_AUTO_UPDATE 项目，并取消其默认的注释： 12- # DISABLE_AUTO_UPDATE=&quot;true&quot;+ DISABLE_AUTO_UPDATE=&quot;true&quot; 这样就关闭了 oh-my-zsh 定期的自动更新；如果需要手动更新，可以运行 upgrade_oh_my_zsh。 设置主题 打开 ~/.zshrc 文件，可以命令行用 vim 打开，也可以直接在资源管理器中打开，编辑其中的 ZSH_THEME 字段就可以更换它的主题，编辑 plugins=(git zsh-autosuggestions) 在括号中增加内容来启用插件；因为 zsh 还是借助 Windows 的 conhost 或者其他终端软件运行，所以并不需要在这个文件中修改字体； 因为 MSYS2 pacman 中的 zsh 似乎没有包含一部分插件，所以若部分插件找不到，可以在这里下载，之后复制到 ~/.oh-my-zsh 文件夹的对应位置中即可； 有一个美妙的 zsh 主题叫做 powerlevel10k：它比较的美观，并且使用了某些方法解决了在 Windows Terminal 这种半透明终端中 PL 展示效果不佳的问题，还提供了比较人性化的解决方案，所以建议使用它： 1git clone https://github.com/romkatv/powerlevel10k.git $ZSH_CUSTOM/themes/powerlevel10k 当然也可以手动克隆之后复制到 ~/.oh-my-zsh/theme 中；安装完成后修改 ~/.zshrc 文件来使用这个主题： 1ZSH_THEME&#x3D;&quot;powerlevel10k&#x2F;powerlevel10k&quot; 之所以要加上路径，是因为 oh my zsh 通过找到 .zsh 文件来找到安装的主题和插件；第一次使用该主题，会自动跳转到对于这个主题的配置页面：会有一个向导根据你终端对于 PowerLine 和图标的支持帮助你选择合理的不会出现乱码的主题，并且配置向导可以快速的通过 p10k configure 唤起，非常方便。 字体问题（补充 上面说到了只有安装 PowerLine 字体才可以显示一些美妙的图标；但是如果你跑了一遍 p10k 的配置之后就会发现，上面提到的好一部分 PL 字体并不支持显示 fontawesome 上的图标，比如那个锁就会显示成一个方块，这不太行；前几天再网上瞎jb翻的时候看到了一种字体叫做 Nerd Fonts，有一种 Hack Nerd Font 似乎可以很棒的兼容这些图标，所以在这里推荐一手（ 实际上，除了 oh my posh，其他的终端美化都是使用打包了 Fontawesome 的 Hack 字体作为更丰富的图标支持的；如果你需要使用包含多个图标的字体，比起一般的 PowerLine 字体，还是建议来一个 Hack 字体== 配置文件 安装完成之后，我们就要将调教好的 zsh 终端增加到工作场景中集成了： 首先不建议将任何 Powerline 终端集成到 Jetbrains 的任何 IDE 中；因为 Windows 上的 Jetbrains IDE 的终端渲染比较的奇特：主要就是行间距太大，导致显示的图标会非常不好看。 集成到 Windows Terminal 默认的继承方式是通过 MSYS2 终端的启动脚本来运行 zsh：这个脚本在启动 shell 前会做许多事情，比如创建临时的系统变量空间，加载 rc 文件等，所以即使你没有将 MSYS2 的二进制文件目录加入到系统变量，shell 也能找到它们： 1234567891011121314&#123; &quot;profiles&quot;: [ &#123; &quot;guid&quot;: &quot;&#123;e7c16a4b-3d29-4785-bf68-ab883e837f1d&#125;&quot;, &quot;name&quot;: &quot;zsh&quot;, &quot;commandline&quot;: &quot;C:/git-sdk-64-main/msys2_shell.cmd -defterm -mingw64 -no-start -here -lic \\&quot;exec zsh\\&quot;&quot;, &quot;fontFace&quot; : &quot;Cascadia Code PL&quot;, &quot;fontSize&quot; : 10, &quot;icon&quot; : &quot;C:/Env/DefaultIcons/WebIcon/GitBash.png&quot;, &quot;startingDirectory&quot; : &quot;%USERPROFILE%&quot;, &#125; ]&#125; 这样没什么坏处，但是在博主的电脑上可能是因为系统环境变量错乱，在该脚本初始化过程中会因为大量系统变量地址映射失败而报错，并且产生巨量输出（包括使用 MinTTY 也会产生这些输出），非常的不美观；而且这些初始化工作还包括了在桌面上创建不需要的快捷方式，非常的不好；所以我们也可以将 usr/bin 增加到系统变量，然后配置文件设置命令行直接启动 usr/bin/zsh.exe，可以产生相同的效果： 1234567891011121314&#123; &quot;profiles&quot;: [ &#123; &quot;guid&quot;: &quot;&#123;e7416a4b-3d29-4745-be68-ab883e837f1a&#125;&quot;, &quot;name&quot;: &quot;zsh&quot;, &quot;commandline&quot;: &quot;C:/git-sdk-64-main/usr/bin/zsh.exe&quot;, &quot;fontFace&quot; : &quot;Cascadia Code PL&quot;, &quot;fontSize&quot; : 10, &quot;icon&quot; : &quot;C:/Env/DefaultIcons/WebIcon/GitBash.png&quot;, &quot;startingDirectory&quot; : &quot;%USERPROFILE%&quot; &#125; ]&#125; 第一次启动依然会初始化最基本的环境，但是不会再产生大量输出了，非常完美；也避免了从 msys2_shell.cmd 启动可能出现的退格闪屏问题； 集成到 VS Code 和上面一样，可以通过 msys2_shell.cmd 启动，也可以直接运行 zsh.exe 启动： 从工具栏中选择 文件 -&gt; 首选项 -&gt; 设置，打开设置页；在 功能 / 终端 中找到任何一个 在 settings.json 中编辑 按钮来打开 vscode 的配置文件；并且加上下面内容： 12345&#123; &quot;terminal.integrated.shell.windows&quot;: &quot;C:\\\\git-sdk-64-main\\\\msys2_shell.cmd&quot;, &quot;terminal.integrated.shellArgs.windows&quot;: [&quot;-defterm&quot;, &quot;-mingw64&quot;, &quot;-no-start&quot;, &quot;-here&quot;, &quot;-lic&quot;, &quot;cd $PWD; exec zsh&quot;], &quot;terminal.integrated.fontFamily&quot;: &quot;DejaVu Sans Mono for Powerline&quot;&#125; 上面的配置指定了命令行、参数以及终端字体（可以和文本编辑器使用不同的字体）；命令参数中的 cd $PWD 是切换到当前目录，如果报错也可以不加（似乎还是会跳转到当前目录）；在 VS Code 中也有相当数量的 PL 字体存在行间距过大的问题，似乎也可以通过调整解决；但是 DejaVu Sans Mono for Powerline 这款字体不存在上述问题，所以为了方便我就直接使用这款字体了； 当然，你也可以将 MSYS2 工具链增加到系统变量后直接运行 zsh.exe，配置文件就像下面这样： 12345&#123; &quot;terminal.integrated.shell.windows&quot;: &quot;C:\\\\git-sdk-64-main\\\\usr\\\\bin\\\\zsh.exe&quot;, &quot;terminal.integrated.shellArgs.windows&quot;: [], &quot;terminal.integrated.fontFamily&quot;: &quot;DejaVu Sans Mono for Powerline&quot;&#125; 启动后也会直接跳转到你的项目目录下，但是如果没有事先将 C:\\git-sdk-64-main\\usr\\bin\\ 增加到系统变量中，输入部分 Linux 命令可能会提示命令未找到错误； WSL 终端美化 依然是安装 zsh &amp; oh my zsh，网上教程也挺多的，和在 Linux 系统中的操作一样（甚至和上述在 MSYS2 中安装的过程高度相似）所以这里就不再多说了；但是需要注意的是更改了 raw.githubusercontent.com 的 host 之后下载 oh my zsh 脚本时可能会因为证书不匹配而报错，这时可以使用 wget 的 --no-check-certificate 选项来忽略检查；curl 则没有找到解决方案； 另：在 Ubuntu WSL 中安装 powerlevel10k 主题时出现了无法加载 gitstatusd 的问题，在 Debian WSL 中却没有出现，原因不明，有些神秘（ 一些补充 WSL 上使用 ls 命令查看文件目录似乎会出现绿色背景的问题，这个 WSL 文件映射机制有关：这里有一篇文章讲的很好，有兴趣可以去看看，了解一波；然后这里还有一篇博文是说 WSL 和 Fluent Terminal 配置的，感觉有点意思，有兴趣的朋友可以去看看。 我的配置文件 这里也没啥特别的内容，主要是博主个人的配置文件的备份： Windows Terminal Preview Upd. 2020-7-22 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&#123; &quot;$schema&quot;: &quot;https://aka.ms/terminal-profiles-schema&quot;, &quot;defaultProfile&quot;: &quot;zsh&quot;, &quot;theme&quot;: &quot;dark&quot;, &quot;profiles&quot;: [ &#123; &quot;guid&quot;: &quot;&#123;e7416a4b-3d29-4745-be68-ab883e837f1a&#125;&quot;, &quot;hidden&quot;: false, &quot;name&quot;: &quot;zsh&quot;, &quot;commandline&quot;: &quot;C:/git-sdk-64-main/usr/bin/zsh.exe&quot;, &quot;useAcrylic&quot; : true, &quot;fontFace&quot; : &quot;Hack Nerd Font Mono&quot;, &quot;fontSize&quot; : 11, &quot;foreground&quot; : &quot;#FCFCFC&quot;, &quot;acrylicOpacity&quot; : 0.5, &quot;icon&quot; : &quot;C:/Env/DefaultIcons/WebIcon/GitBash.png&quot;, &quot;colorScheme&quot; : &quot;New Campbell Plus&quot;, &quot;background&quot;: &quot;#000000&quot;, &quot;startingDirectory&quot; : null &#125;, &#123; &quot;acrylicOpacity&quot; : 0.5, &quot;guid&quot;: &quot;&#123;574e775e-4f2a-5b96-ac1e-a2962a402336&#125;&quot;, &quot;hidden&quot;: false, &quot;name&quot;: &quot;PowerShell Core&quot;, &quot;source&quot;: &quot;Windows.Terminal.PowershellCore&quot;, &quot;colorScheme&quot; : &quot;One Half Dark&quot;, &quot;useAcrylic&quot; : true, &quot;fontFace&quot; : &quot;Hack Nerd Font Mono&quot;, &quot;fontSize&quot; : 11, &quot;startingDirectory&quot; : &quot;%USERPROFILE%&quot; &#125;, &#123; &quot;guid&quot;: &quot;&#123;58ad8b0c-3ef8-5f4d-bc6f-13e4c00f2530&#125;&quot;, &quot;hidden&quot;: false, &quot;name&quot;: &quot;Debian&quot;, &quot;snapOnInput&quot; : true, &quot;acrylicOpacity&quot; : 0.5, &quot;closeOnExit&quot; : true, &quot;useAcrylic&quot; : true, &quot;colorScheme&quot;: &quot;Raspberry&quot;, &quot;fontFace&quot; : &quot;Hack Nerd Font Mono&quot;, &quot;fontSize&quot; : 11, &quot;icon&quot; : &quot;C:/Env/DefaultIcons/WebIcon/debian.png&quot;, &quot;source&quot;: &quot;Windows.Terminal.Wsl&quot;, &quot;startingDirectory&quot; : &quot;%USERPROFILE%&quot; &#125; // 已经省略自动生成的配置文件 ], &quot;schemes&quot; : [ &#123; &quot;name&quot; : &quot;New Campbell Plus&quot;, &quot;background&quot; : &quot;#0C0C0C&quot;, &quot;black&quot; : &quot;#0C0C0C&quot;, &quot;blue&quot; : &quot;#519DFF&quot;, &quot;brightBlack&quot; : &quot;#767676&quot;, &quot;brightBlue&quot; : &quot;#8CC4FF&quot;, &quot;brightCyan&quot; :&quot;#34E3E3&quot;, &quot;brightGreen&quot; : &quot;#8BE334&quot;, &quot;brightPurple&quot; : &quot;#FFBBF8&quot;, &quot;brightRed&quot; : &quot;#E74856&quot;, &quot;brightWhite&quot; : &quot;#FFFFFF&quot;, &quot;brightYellow&quot; : &quot;#FFEC50&quot;, &quot;cyan&quot; : &quot;#0AFCFF&quot;, &quot;foreground&quot; : &quot;#CCCCCC&quot;, &quot;green&quot; : &quot;#81FF0A&quot;, &quot;purple&quot; : &quot;#F3A6FF&quot;, &quot;red&quot; : &quot;#FF0000&quot;, &quot;white&quot; : &quot;#FAFAFA&quot;, &quot;yellow&quot; : &quot;#FFD000&quot; &#125;, &#123; &quot;name&quot; : &quot;One Half Dark&quot;, &quot;background&quot; : &quot;#282C34&quot;, &quot;black&quot; : &quot;#282C34&quot;, &quot;blue&quot; : &quot;#61AFEF&quot;, &quot;brightBlack&quot; : &quot;#5A6374&quot;, &quot;brightBlue&quot; : &quot;#61AFEF&quot;, &quot;brightCyan&quot; : &quot;#56B6C2&quot;, &quot;brightGreen&quot; : &quot;#98C379&quot;, &quot;brightPurple&quot; : &quot;#C678DD&quot;, &quot;brightRed&quot; : &quot;#E06C75&quot;, &quot;brightWhite&quot; : &quot;#DCDFE4&quot;, &quot;brightYellow&quot; : &quot;#E5C07B&quot;, &quot;cyan&quot; : &quot;#56B6C2&quot;, &quot;foreground&quot; : &quot;#DCDFE4&quot;, &quot;green&quot; : &quot;#98C379&quot;, &quot;purple&quot; : &quot;#C678DD&quot;, &quot;red&quot; : &quot;#E06C75&quot;, &quot;white&quot; : &quot;#DCDFE4&quot;, &quot;yellow&quot; : &quot;#E5C07B&quot; &#125;, &#123; &quot;name&quot; : &quot;Raspberry&quot;, &quot;background&quot; : &quot;#3C0315&quot;, &quot;black&quot; : &quot;#282A2E&quot;, &quot;blue&quot; : &quot;#0170C5&quot;, &quot;brightBlack&quot; : &quot;#676E7A&quot;, &quot;brightBlue&quot; : &quot;#80c8ff&quot;, &quot;brightCyan&quot; : &quot;#8ABEB7&quot;, &quot;brightGreen&quot; : &quot;#B5D680&quot;, &quot;brightPurple&quot; : &quot;#AC79BB&quot;, &quot;brightRed&quot; : &quot;#BD6D85&quot;, &quot;brightWhite&quot; : &quot;#FFFFFD&quot;, &quot;brightYellow&quot; : &quot;#FFFD76&quot;, &quot;cyan&quot; : &quot;#3F8D83&quot;, &quot;foreground&quot; : &quot;#FFFFFD&quot;, &quot;green&quot; : &quot;#76AB23&quot;, &quot;purple&quot; : &quot;#7D498F&quot;, &quot;red&quot; : &quot;#BD0940&quot;, &quot;white&quot; : &quot;#FFFFFD&quot;, &quot;yellow&quot; : &quot;#E0DE48&quot; &#125; ]&#125; 常用终端：PowerShell Core、zsh、Debian WSL； wt 右键菜单 将下方内容复制到文本文件中，修改后缀为 .reg 并且双击打开安装即可： 123456789101112131415Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wt]@&#x3D;&quot;Open Windows Terminal&quot;&quot;Icon&quot;&#x3D;&quot;C:\\\\Env\\\\DefaultIcons\\\\wt.ico&quot;[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wt\\command]@&#x3D;&quot;C:\\\\Users\\\\Shiroha\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps\\\\wt.exe&quot;[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wtp]@&#x3D;&quot;Open Windows Terminal Preview&quot;&quot;Icon&quot;&#x3D;&quot;C:\\\\Env\\\\DefaultIcons\\\\wtp.ico&quot;[HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\wtp\\command]@&#x3D;&quot;C:\\\\Users\\\\Shiroha\\\\AppData\\\\Local\\\\Microsoft\\\\WindowsApps\\\\Microsoft.WindowsTerminalPreview_8wekyb3d8bbwe\\\\wt.exe&quot; 如果你希望提示文字是中文，请特别注意文件的编码方式，以避免乱码。 文章更新记录 日期 更新内容 2020-07-12 补全文章主体内容（草 2020-07-21 更新了一些字体和外链 2020-07-22 更新了配置文件和脚本 2021-06-22 更新了关闭自动更新的方法 参考资料 https://www.cnblogs.com/wswind/p/10650126.html https://tmc0210.github.io/Mac%E7%9A%84%E7%BB%88%E7%AB%AF%E7%BE%8E%E5%8C%96/#more https://www.jianshu.com/p/67df4d3aa22d","categories":[{"name":"折腾记录","slug":"折腾记录","permalink":"https://shiraha.cn/categories/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"}],"tags":[{"name":"Windows 10","slug":"Windows-10","permalink":"https://shiraha.cn/tags/Windows-10/"},{"name":"Microsoft","slug":"Microsoft","permalink":"https://shiraha.cn/tags/Microsoft/"},{"name":"msys2","slug":"msys2","permalink":"https://shiraha.cn/tags/msys2/"},{"name":"美化","slug":"美化","permalink":"https://shiraha.cn/tags/%E7%BE%8E%E5%8C%96/"}]},{"title":"Codeforces Good Bye 2019 回顾","slug":"codeforces-good-bye-2019","date":"2020-06-15T06:48:53.000Z","updated":"2020-06-15T06:48:53.000Z","comments":true,"path":"2020/codeforces-good-bye-2019/","link":"","permalink":"https://shiraha.cn/2020/codeforces-good-bye-2019/","excerpt":"","text":"这场比赛的编号是 1270，可以去洛谷上搜索 CF1270X 或者去官网补题。 题目质量还是不错的，明明长着一副 div2 的样子却把我搞得要死== 我属实不太行（ HIQBB15UOYE1IUQ6B.jpg 其实这应该算不上是什么题解，充其量就算是做题记录吧（ A - Card Game 签到题 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, k1, k2, t, a; cin &gt;&gt; t; while (t --) &#123; cin &gt;&gt; n &gt;&gt; k1 &gt;&gt; k2; bool firstWin = false; while (k1 --) &#123; cin &gt;&gt; a; if (a == n) firstWin = true; &#125; while (k2 --) cin &gt;&gt; a; cout &lt;&lt; (firstWin ? &quot;YES&quot; : &quot;NO&quot;) &lt;&lt; endl; &#125; return 0;&#125; B - Interesting Subarray 简单的在草稿纸上推一下，就会知道这不会存在越位的问题：对于数列 [A, B, C] ：如果 A-B 不行，那么 A-C 也必然不行；从另一个角度来看，也就是说，所有的可行的 (l, r) 最后一定可以转化为 (x, x+1)；所以我们可以扫一遍数组，如果元组 (i, i+1) 可以满足要求，就记录答案，最后输出即可； 现在有一种一般性的思维来考虑：设 max(a) = i，min(a) = j，那么 max(a) - min(a) ≥ k 就可以转化为 |a[i] - a[j]| ≥ |i-j|；假设一下顺序，就可以移项转化成 a[i] + i &lt; a[j] + j 或者 a[i] - i &gt; a[j] - j；这样的话就可以遍历数组求 f(x) = a[x] + x 以及 g[x] = a[x] - x；统计它们的最值，如果符合要求就输出即可； 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;const int N = 2e5 + 5;int a[N];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t, n; cin &gt;&gt; t; while (t --) &#123; cin &gt;&gt; n &gt;&gt; a[0]; int ll = -1, rr = -1; for (int i = 1; i &lt; n; ++ i) &#123; cin &gt;&gt; a[i]; if (abs(a[i] - a[i - 1]) &gt; 1) ll = i, rr = i + 1; else continue; &#125; if (ll == -1 &amp;&amp; rr == -1) cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;YES\\n&quot; &lt;&lt; ll &lt;&lt; &#x27; &#x27; &lt;&lt; rr &lt;&lt; endl; &#125; return 0;&#125; C - Make Good 给你一个数列，它的和是 a，环和是 b；现在你要给这个序列再加上不超过 3 个数，使得新的 a' = 2b'； 数列不重要，遍历数列知道了 a 和 b 就可以了；题目允许我们加三个数字，那么这个题目有一种很巧妙的构造方法；加法的性质我们都很熟悉，在说这个之前先简单回顾一下环加（异或）的性质：a ⊕ a = 0，a ⊕ 0 = a；也就是说我们可以通过把环和置零，将环和置为任何一个数字；所以这个题目可以这么做： 先加上 b：此时，a' = a + b，b' = b ⊕ b = 0； 再加上 a + b：此时，a' = 2(a + b)，b' = 0 ⊕ (a + b) = a + b； 这样就在三个数字之内实现了题目的要求： 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;using namespace std;typedef unsigned long long ulongs;const int N = 1e5 + 5;ulongs a[N], sum, x_sum;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int t, n; cin &gt;&gt; t; while (t --) &#123; cin &gt;&gt; n; sum = x_sum = 0; for (int i = 1; i &lt;= n; ++ i) &#123; cin &gt;&gt; a[i]; sum += a[i]; x_sum ^= a[i]; &#125; if ((x_sum &lt;&lt; 1u) == sum) cout &lt;&lt; 0 &lt;&lt; endl &lt;&lt; endl; else cout &lt;&lt; 2 &lt;&lt; endl &lt;&lt; x_sum &lt;&lt; &#x27; &#x27; &lt;&lt; (x_sum + sum) &lt;&lt; endl; &#125; return 0;&#125; 但是，如果我们只允许在序列末尾增加一个数字呢？可以实现题目的要求吗？ 虽然不知道应该怎么数学证明，但是这是可以的。 D - Strange Device 交互机器有一个长度为 n 数列，每个元素互不相同；对于这个数列，你可以进行询问： ? x1 x2 …… xk ：询问包含 k 个数字的单调递增数列，xi 是原数列的下标； 交互机器返回 pos val ：pos 是询问序列中第 m 大的元素的下标，val 是它的值； 现要求你在不超过 n 次询问中求出 m 的值，满足 m ≤ k &lt; n； 虽然说交互机器持有了一个不为我们所知的 n 元数组，但是注意到我们求的东西和数组的值或者某个下标的值实际上没有任何关系，所以可能是闪光弹== 每次询问可以获得长度为 k 的元素互不相同的数组中的第 m 大的元素，为了确定这个 m 的值，一种很容易想到的策略如下： 取 k + 1 数字（互不相同），对于从中取出 k 个数字的每种组合进行询问 因为互不相同，所以元素之间的关系非常单纯：只有大于和小于的区别 这样应该只会得到两种应答：一种是因为被丢弃的数字比第 m 个小，一种是因为大 可以根据这两种应答数字的相对大小来确定它们的来源，从而确定 m 这样的做法要求询问 k + 1 次，数组中至少要包括 k + 1 个元素；但是题目已经贴心的安排了 k &lt; n，所以这种方法必然可以采用；事实上题目的样例输入输出就是采用的这种方法进行判定，只是 k + 1 = n 混淆视听罢了。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;#define ask cout &lt;&lt; &quot;? &quot;#define chk cout &lt;&lt; &quot;! &quot;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, k, pos, val; cin &gt;&gt; n &gt;&gt; k; unordered_map&lt;int, int&gt; x; const int lim = k + 1; int m_pos = -1, m_val = -1; for (int i = 1; i &lt;= lim; ++ i) &#123; ask; for (int j = 1; j &lt;= lim; ++ j) if (j == i) continue; else cout &lt;&lt; j &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl; cin &gt;&gt; pos &gt;&gt; val; if (val &gt; m_val) m_pos = pos, m_val = val; ++ x[pos]; &#125; chk &lt;&lt; x[m_pos] &lt;&lt; endl; return 0;&#125; E - Divide Points 给你 n ≥ 2 个整数坐标，要求你将它分成两组，并且满足下面的需求： 所有的点对之间连边；将两个点在同一组的边称为 A 类边，否则称为 B 类边； 不存在长度相等的 A 类边和 B 类边；即长度相等的边必须同类； 确保对于所有的输入数据，存在这样的分组方法；保证输入的每个点独一无二； 看到分组，还是和图论相关的分成两组，难以不想到二分图，并查集乌拉乌拉…… 然而遗憾的是这个题和它们没有半点关系；1e6 的数据范围和 1s 的时限让它最多只能接受 O(n√n) 的算法，所以它是个思维题（ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;typedef unsigned int uint;const int N = 1050;pair&lt;uint, uint&gt; p[N];int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); vector&lt;uint&gt; ans; uint cnt[2][2], &amp;p00 = cnt[0][0], &amp;p11 = cnt[1][1], &amp;p01 = cnt[0][1], &amp;p10 = cnt[1][0]; uint n, x, y, msk = 1; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++ i) &#123; cin &gt;&gt; x &gt;&gt; y; p[i] = make_pair(x, y); &#125; while (true) &#123; memset(cnt, 0, sizeof cnt); for (int i = 1; i &lt;= n; ++ i) ++ cnt[bool(p[i].first &amp; msk)][bool(p[i].second &amp; msk)]; if (p01 + p10 &amp;&amp; p00 + p11) &#123; for (int i = 1; i &lt;= n; ++ i) if ((p[i].first &amp; msk) ^ (p[i].second &amp; msk)) ans.push_back(i); break; &#125; else if (p00 + p01 &amp;&amp; p10 + p11) &#123; for (int i = 1; i &lt;= n; ++ i) if (p[i].first &amp; msk) ans.push_back(i); break; &#125; else msk &lt;&lt;= 1u; &#125; cout &lt;&lt; ans.size() &lt;&lt; endl; for (auto &amp;ii : ans) cout &lt;&lt; ii &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl; return 0;&#125; 刚刚发现坐标原来可以是负数，我还拿了个 uint 来存…… 虽然说负数坐标映射不改变其奇偶性，导致上述代码仍然可以 AC，但是无论怎么说这还是太不小心了，好歹读进来整体平移啊（ F - Awesome Substrings 给一个长度为 n 的 01 字符串；现在需要求出满足条件的区间 [l, r] 的数目：区间 [l, r] 满足 r - l + 1 是区间内值为 1 的位数的倍数； 数据范围：n ≤ 2e5； 1 G - Subset with Zero Sum 给你一个长度为 n 的整数数组 a，下标为 1 ~ n；对于 a 中的元素有 i - n ≤ a[i] ≤ i - 1；现在要求你找出这个数组中元素集合的子集 S，集合内的元素的和为 0；可以证明对于满足这个条件的数组 a，这样的子集必然存在。 数据规模：n 不超过 1e6； 这个题目看起来比较的奇怪：说是数组，要找的自己和却是一个和数组下标顺序没有任何关系的东西；看起来求和为 0 的子集无从保证，但是随便写几组数据发现确实存在；就……感觉这题目做不得了（ 从看起来最奇怪的约束不等式入手：两个边界都有 +i 存在，可以考虑移项，得到：1 ≤ i - a[i] ≤ n；似乎和下标的范围完全一致，所以就可以建图了别问我我也不知道题解怎么想的：建立一个 n 个点的有向图，连边 i → i - a[i]，就得到了一个基环内向森林——每一个节点的出度为 1 的图； 这样的图有一个特性，即一定存在环；先说结论，对于这个图中的任何一个环，环上的所有节点构成的集合一定满足题目要求：即集合内点的和为 0；证明如下： 由我们的建图方式可以知道，对于该图的任何一条边；起点为 i，终点为 i - a[i]； 如果形成了一个环，那么这个环上所有边的起点集和终点集完全一致，等于处于这个环上的点集； 那么，对于起点集求和一定和终点集求和相等；因为这两个集合相等；令环上点集为 S； 上述关系写成式子就是 \\(\\sum_{i \\in S} i = \\sum_{i \\in S} (i - a_i)\\)，移项整理可得 \\(\\sum_{i \\in S} a_i = 0\\)； 综上所述，对于按照 i → i - a[i] 建立的图，图上任意一个环上的所有点构成的集合就满足题目要求；且这样构成的图中一定存在环。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;inline int nextInt()&#123; int x = 0, f = 1; char ch = getchar(); while (!isdigit(ch)) &#123;if (ch == &#x27;-&#x27;) f = -1; ch = getchar();&#125; while (isdigit(ch)) &#123;x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + ch - 48; ch = getchar();&#125; return x * f;&#125;const int N = 1e6 + 5;int to[N], vis[N];int main()&#123; int t = nextInt(), n; while (t --) &#123; n = nextInt(); for (int i = 1; i &lt;= n; ++ i) to[i] = i - nextInt(), vis[i] = 0; int now = 1, st; while (!vis[now]) vis[now] = 1, now = to[now]; vector&lt;int&gt; ans; st = now, now = to[now]; while (now != st) ans.push_back(now), now = to[now]; ans.push_back(st); printf(&quot;%d\\n&quot;, (int)ans.size()); for (auto &amp;ii : ans) printf(&quot;%d &quot;, ii); puts(&quot;&quot;); &#125; return 0;&#125; 这个题目似乎卡了IO，同样逻辑的代码如果使用 C++ IO 的话会在第八个点几乎一定会 TLE；这种题目姑且还算是个组合题，值和下标在同一个范围内，和经典问题“没有指针的链表”的思想很像== 害也就那么回事吧（ H - Number of Components 一个长度为 n 的元素互不相同的数组 a，映射为一张包含 n 个节点的无向图 G；映射关系为：当 i &lt; j 和 a[i] &lt; a[j] 同时成立时，认为节点 i 和 j 之间存在连边；现在将会修改数组 a 某位置的值，要求动态地维护图 G 中连通块的数目；修改次数为 q，保证修改后数组元素依然互不相同； 数据范围：n, q ≤ 5e5；1 ≤ a[i] ≤ 1e6；i ≠ j ⇔ a[i] ≠ a[j]； 1 I - Xor on Figures 有一个 \\(2^k × 2^k\\) 的矩阵 A，行列从 0 开始标号；给定长度为 t 的数列 x，y；现在你可以进行操作，操作的定义如下： 操作接受三个参数：p，q，w；记 \\(X = (x_i+p)\\ mod\\ 2^k\\)，\\(Y = (y_i+q)\\ mod\\ 2^k\\)； 对于 \\(\\forall a \\in X, \\ b \\in Y\\)，将使得矩阵的 \\(A_{a,b} = A_{a,b} \\oplus w\\)； 现要求仅使用上述操作将矩阵 A 变为零矩阵，求最小的操作次数； 数据范围：k ≤ 9，t ≤ 99 且为奇数； 1 后记 个人认为这套题目的质量应该是非常之高的吧。题目代码量也不是很大，很多题目都是看起来麻烦但实际上是很棒的思维题，只要想到了那个点，问题就可以迎刃而解可我没有数学思维真是抱歉呜呜呜呜； 6CJWD08019QS4D1H33.jpg 还是得加大练习量，多遇见一些这样的有趣的题目才好啊…… 希望人没事，六月底能留下来就好了。","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://shiraha.cn/tags/Codeforces/"}]},{"title":"软件工程：第 3 次上机实验","slug":"class-software-engineering-experiment-3","date":"2020-06-11T12:15:09.000Z","updated":"2020-06-11T12:15:09.000Z","comments":true,"path":"2020/class-software-engineering-experiment-3/","link":"","permalink":"https://shiraha.cn/2020/class-software-engineering-experiment-3/","excerpt":"","text":"下面是这一次的实验要求： ##### 软件工程综合实验 一、实验名称：软件工程综合实验 二、实验目的 掌握软件分析、设计、测试和实现基本方法 综合运用测试驱动开发和重构 三、实验内容和要求 开发一个机器可读的英汉词典，能获得给定英文词条的多方面信息（读音、词性、每个词义、例句等，能提供的信息越多越好），并在其他软件系统（桌面或在线词典、机器翻译系统、其他自然语言处理系统等）中使用 根据常见纸质英汉词典（如牛津高阶英汉词典等）的内容和结构，给出详细的机器可读英汉词典的功能需求 设计机器可读英汉词典的存储结构（词典需要存储在磁盘中和内存中） 设计机器可读英汉词典的接口 采用熟悉的语言（OOP优先）进行实现 采用测试驱动的开发方法进行开发 采用重构完善设计和实现 四、实验时间 2次上机时间 实验过程 设计一个使用 TDD 方法的机器可读的词典。 需求分析 从实验要求入手，对于实验要求的部分进行合理解释； 词典 通过传入的字符串，在内建的数据库中搜索对应或者相关的词条；也可以对于某个特定的单词在数据库中查找它全部的相关信息（包括释义、例句以及词性）； 机器可读 按照约定的规则向其他应用程序返回格式化的数据；比如作为一个库提供 API 给其他的程序调用，或者作为一个服务端，向对它发起请求的客户端返回合适的数据；在本次实验中，我将词典核心部分打包成 C++ 共享库，可以方便的在其他的 C++ 程序/工程中使用； 存储 SQLite3 是一个轻量级的数据库，它支持全部的 SQL 特性，且数据库作为一个文件存储在本地的文件系统中；对于一个离线的字典工具，使用 SQLite3 作为数据库显然是非常的合适的。 测试驱动 因为涉及到数据库的操作需要验证准确性，且 C++ 没有现成的较好的 ORM 框架，所以在构筑上层程序之前，首先需要先编写和 SQLite3 API 通信的框架；每当完成一部分的时候，都应该对这个框架的方法进行测试； 实现 实现的平台是： Windows 10 + CLion + MinGW + CMake，使用了 SQLite3 作为底层数据库； 简介 项目分为三个部分：控制台Shell，C++ 共享库，共享库测试demo；您可以点击这些链接来访问它们的仓库；是基于 CMake 的项目，可以跨平台编译并且运行；项目提供了 API 打开 SQLite3 词典数据库（这里，以 Kelinsi 电子词典的数据库设计作为标准），然后提供封装后的 API 来查询单词，或者获得某个确定单词的相关信息； 机器可读和测试 用户可以在自己的 C++ 工程中引入本项目生成的库文件，在本文档或头文件的引导下使用 API 打开词典数据库，并且查阅单词，对于返回的数据，项目也提供了必要的 Demo 和 API 来获得用户想要查询的信息；Shell 项目和 Demo 项目已经测试了全部的 API，保证它们可以在测试数据集中正常运行； 关于测试框架：使用 Boost.Test 对比接口查询的数据和 SQL Shell 查询的数据，但是 Git 的时候弄丢了，所以无了。现在仅剩下 Demo 项目和 Shell 项目下的 Test 文件夹下的测试用代码； 此外，编译生成的库中的 hello 函数，也是用来测试项目是否正确的连接到你的工程的，请多加注意； 数据库设计 这是 Kelinsi 电子词典数据库的表结构： Kelinsi.svg 一个单词可能有多个释义，不同的释义可能有很多条的信息（比如例句），它们通过保存彼此的主键作为自己的外键来关联到一起，是典型的关系型数据库； API 设计 本项目基于 SQLite3 本地数据库，基于该数据库系统的特点设计 API；以下仅列出关键的 API 的声明，如果您需要完整的 API，可以阅读项目工程中提供的 eDict_library.h 文件中的声明； 1234567891011#define OPEN_DICTIONARY(path) // 打开字符串 path 规定的数据库文件，一个作用域内只能执行一次#define CLOSE_DICTIONARY() // 关闭已经打开的数据库文件，必须要先打开数据库才可以关闭#define QUERY_BY_KEYWORD(key) // 查找单词字符串前缀（忽略大小写）的所有单词，并且查询这些单词的编号#define QUERY_BY_WORD_ID(wid) // 利用单词的编号查找一个具体单词的全部相关信息（包括全部释义）#define GET_WORD_ID(obj) // 从 QUERY_BY_KEYWORD 返回的数组中的具体元素中获得单词 ID#define GET_WORD_EN(obj) // 从 QUERY_BY_KEYWORD 返回的数组中的具体元素中获得单词的英文编写#define GET_WORD_STAR(obj) // 从 QUERY_BY_KEYWORD 返回的数组中的具体元素中获得单词的评级字符串#define GET_SENTENCE_CN(st) // 从 QUERY_BY_WORD_ID 返回数据的例句字段中提取具体例句的中文#define GET_SENTENCE_EN(st) // 从 QUERY_BY_WORD_ID 返回数据的例句字段中提取具体例句的英文#define DICTIONARY_IS_CONNECT // 类型是 bool : 用来验证词典文件是否已经顺利打开#define DICTIONARY_ERR_MSG // 获得电子词典上一次非致命行为异常的错误信息的 C-字符串 (const) 正常的工作流程是，在开始查询之前运行 OPEN_DICTIONARY(path) ，并且通过 DICTIONARY_IS_CONNECT 确认字典数据库是否已经连接；若连接，再使用查询相关的 API 查询单词；当程序结束时，建议手动调用 CLOSE_DICTIONARY() 断开连接。 如果您还想使用这些代码进行更高级的操作，您可能需要了解关于这个项目的结构设计： orm.h ：可以和 SQLite3 数据库通信，执行 SQL 语句，并且将返回的结果作为一个 OBJECT 对象返回；这个对象的本质上是 STL 实现的哈希表，且当前的版本不能很好地实现 BLOB 格式的数据的读取； edict.h ：是 ORM 的子类；将执行 SQL 的接口进行进一步的封装，暴露传入回调函数的接口；此外将上文 API 中规定的查询行为特化，返回基于 Kelinsi 电子词典设计的数据结构； 工作开始时，可以实例化一个 edict 对象，你可以发现这个对象持有上述简易 API 宏所涉及的所有相关的函数；此外，你可以通过暴露的 execSQL 方法执行任何复杂的查询，并通过设计类型为 CALLBACK 的回调函数，将返回的 Meta 数据处理成为任何你想要的数据结构。切记，在工作结束后使用 close 方法结束对于数据库文件的占用。 1234567891011121314151617181920212223242526272829303132333435363738394041class database &#123; sqlite3 *db; bool opened;protected: const sqlite3 *getDB(); int _exec_sql(const char *sql, sqlite3_callback cb, void *data, char **err_msg);public: database(); explicit database(const char *fileName); explicit database(const std::string &amp;fileName); bool bind(const char *fileName); bool bind(const std::string &amp;fileName); bool close(); bool isOpened() const; META_RESULT execSQL(const char *sql); META_RESULT execSQL(const TEXT &amp;sql); ~database();&#125;;class edict : public database &#123; TEXT last_err_msg; ITEM fillItem(ITEM &amp;item);public: explicit edict(const char *db_name); using database::execSQL; bool execSQL(const char *sql, CALLBACK cb, void *param); bool execSQL(const TEXT &amp;sql, CALLBACK cb, void *param); const char *getLastErrorMsg(); ARRAY search(TEXT prefix); DETAIL getDetail(unsigned word_id);&#125;; ↑ 上述两个类的声明（位于 eDict_library.h 中） ↑ 重构 虽然在 Shell 工程中将代码分成多个文件存放是好的，但是当要制作一个库的时候，将太多高度耦合的文件分开存放并不是一件好事，会增大用户使用的复杂度；所以打包成成品库之后，我将很多高度耦合的头文件的代码进行了融合，作为一个新的工程与原来的 Executable 工程分开； 此外，在我的代码中，一些常用的功能已经被提取成纯函数，作为单独的模块而存在； 使用 关于库文件的 API，已经在上面讲过了；想要知道更多请去阅读相关头文件； Excutable 项目 从代码仓库中获得代码后，使用 CMake 加载这个项目，编译可以得到可执行文件；将可执行文件和电子词典数据库文件放在相同的目录下，关闭杀毒软件即可查询； Library 项目 从代码仓库获取代码之后，使用 CMake 生成 .dll 文件；将这个文件以及项目目录下的 sqlite3.h 和 edict_library.h 文件放在你要使用的项目里，并且加入 Include Path（也可以忽略此步，但是这样大多数 IDE 将不能为这里的代码提供自动补全或者只智能纠错）；在编译时使用 -l libedict_library.dll 命令，或者（你使用 CMake 管理你的项目）在你自己的项目的 CMakeList.txt 中加入以下内容： 123include_directories(./) # 用来存放 dll 的位置add_executable(main $&#123;SRC_FILES&#125;) # 你的 build targettarget_link_libraries(main libeDict_library.dll) 如果你使用 Visual Studio 管理你的项目，你需要在解决方案的配置页面，在 C/C++ &gt; 链接器 的页面中加入这个 dll 文件。 这样，你就可以使用上述的 API 来查询符合 Kelinsi 词典表规范的电子词典数据库了；实际上，Demo 项目已经实现了这个功能，但是在使用之前，您仍然需要将电子词典数据库文件放在生成的可执行文件相同的目录下，并且修改文件名； Win32 + CMake 你可以下载已经编译过的DLL文件和头文件来在 CMake 项目中使用这个程序；当然，这里也提供 kelins 电子词典的 SQLite3 数据库文件，可以配合上述文件以及介绍快速地在您的项目中使用。 后记 通过本次的软件工程实验，我学会了使用 SQLite3 数据库框架，熟练了 CMake 对于项目管理的流程；实际操作了在现代 IDE 中的项目管理流程，一定程度上熟悉了 TDD 开发以及 C++ 测试框架，并且对于库文件开发的理解更进一步。 关于源代码 展示的源代码是 Library 项目的源代码，它的文件结构如下图所示： FQ1M0QMYAKNXD07Q77Y.png 其中 cmake-build-debug 是 CMake 生成的临时文件，可以忽略；但是作为生成的可执行文件的所在位置，如果你要运行其他两个 C++ Executable 项目的话，需要将数据库文件放在该目录下； build 目录是手动生成的输出位置，如果生成静态库就会得到 .a 文件，生成共享库文件就会得到 .dll 文件；其中的 libedict_library.h 文件就是前面可以直接下载的头文件，它包含了 SQLite3 的头文件； CMakeList.txt 文件记录了项目的配置信息；如果不是直接从仓库拉取项目，这个文件的内容可能需要重新配置； sqlite3.c 和 sqlite3.h 文件是 SQLite3 官方 API 的一部分，您可以从它的官方网站上下载，并且将它们包含在这个项目的目录中；注意，如果您下载的文件版本和仓库中的版本不一致，可能会导致运行结果和预想不一致甚至是无法编译的问题，请根据实际情况进行酌情调整； library.h 和 library.c 包含了对于底层 SQLite3 API 的封装以及面向用户的宏的声明和实现；编译后可以将这里的头文件和上面的 SQLite3 的头文件一起加入到新项目中以使用代码智能提醒；","categories":[{"name":"课业","slug":"课业","permalink":"https://shiraha.cn/categories/%E8%AF%BE%E4%B8%9A/"}],"tags":[{"name":"课内作业","slug":"课内作业","permalink":"https://shiraha.cn/tags/%E8%AF%BE%E5%86%85%E4%BD%9C%E4%B8%9A/"},{"name":"实验报告","slug":"实验报告","permalink":"https://shiraha.cn/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"软件工程","slug":"软件工程","permalink":"https://shiraha.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"2019 NWRRC 回顾","slug":"2019-nwrrc","date":"2020-05-30T14:24:31.000Z","updated":"2020-05-30T14:24:31.000Z","comments":true,"path":"2020/2019-nwrrc/","link":"","permalink":"https://shiraha.cn/2020/2019-nwrrc/","excerpt":"","text":"虽然找到了官方网站，但是并没有找到题解文档或者是 Slide——准确的说是没有找到英文版本的，俄文版本倒是有的，甚至还有标题是英文内容是俄文的…… 下载到的标程也存疑，因为形态比较诡异，也就没有参考； 找到了就会贴出来的找不到的，最后还是依靠校队组织的讲题完成了这篇题解，官方的俄文题解我是不指望了（ 下面就是这次的 13 个题目，我也没有做出来几个，没做出来的就先占个坑好了： A. Accurate Movement 槽里面有一个长条，一个短条，起始位置都在一侧；一次只能移动一个，要保证短条始终在长条内部，问最少需要多少次才能够将两个条都移动到槽的另一端。 签到题。 1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int a, b, n; cin &gt;&gt; a &gt;&gt; b &gt;&gt; n; auto xx = n - a; auto tt = xx / (b - a) + bool(xx % (b - a)); cout &lt;&lt; tt * 2 - 1 &lt;&lt; endl; return 0;&#125; B. Bad Treap Treap，树堆，即笛卡尔树；每一个节点包含两个值 (K, V)，K 值满足二叉搜索树的性质（左二子 &lt; 树根 &lt; 右儿子），而 V 值满足堆的性质（根 &gt; 所有儿子）； 现在要构造一颗树堆，它的每个节点定义是 (x, y = sin x)；现在你希望它包含 n 个节点，且平衡性是所有 n-树堆 中最差的；你要构造出这 n 个节点的 x 值，且 x 的类型是 __int32。 数据范围：1 ≤ n ≤ 50000，-2³¹ ≤ x ≤ 2³¹ - 1； 首先，”最不平衡“指的是左右子树的高度差最大；显然，一颗 n 个节点构成的 Treap 能达到的最大的高度差是 n-1：即当整棵树退化成一条链的时候；那么在什么样的情况下，这棵树会退化成一条链呢？一种很简单的情况，就是当 K 和 V 值都是单调的时候，堆的性质一定会满足，所有节点都是其父节点的左二子或是右儿子； 观察节点的函数 (K: x, V: y = sin x)：假设我们想要一个 V 随着 K 增大而增大的区间，那么这个区间可以是 x ∈ [-π/2, π/2]；但是题目要求了键 K 是 __int32 类型，不然我们直接将这个区间平均分配就可以了；但是另注意到，sin x 是一个周期函数，所以对于同一个 V 值，可以对应多个差距为 2kπ 的 K 值，只要这些 K 值递增且为整数，就可以构造出一个整数数列；那么现在我们想要构造一组 K = -π/2 + 2πi / T + 2kπ，使得他们都是整数且数列递增；显然，增量 δ = 2π / T + εkπ； 当然，我们可以使用暴力的方法先行求出这个 ε 的值，进而得到这个增量 δ 的值，使用下面的简单易懂的代码就可以轻松的求出在不同整数精度的情况下的增量值： 1234567891011121314151617181920212223template &lt;typename number&gt;class comparable : binary_function&lt;number, number, bool&gt;&#123; number eps = 1e-8; int compareTo(number x) const &#123;return x &lt; -eps ? -1 : x &gt; eps;&#125;public: explicit comparable(number eps) : eps(eps) &#123;&#125; int compareTo(number a, number b) const &#123;return compareTo(a-b);&#125; int operator()(number a, number b) const &#123;return compareTo(a-b);&#125;&#125;;long double calcDelta(long double precision, unsigned count)&#123; static const long double pi = 3.1415926535897932384626; static const long double dpi = 2.0 * pi; comparable&lt;long double&gt; cmp(precision); const long double delta = pi / count; cerr &lt;&lt; fixed &lt;&lt; setprecision(10) &lt;&lt; &quot;delta: &quot; &lt;&lt; delta &lt;&lt; endl; long double xx = delta, ans = xx; int cnt = 0; while (cmp(ans, ceil(ans))) ++ cnt, ans = xx + cnt * dpi; // unsequenced modification and access to &quot;ans&quot; return cerr &lt;&lt; &quot;found: &quot; &lt;&lt; ans &lt;&lt; endl, ans;&#125; 因为题目的要求是 50000 数据范围，如果调用上述的 calcDelta(1e-5, 50000) 得到的是 1420，交上去会挂掉；因为 C++ 浮点数有着大家都知道的误差，所以一般来说 T 应该更大的数，比如 60000，求出的增量 710，就可以过了；此外按照 hjl 巨佬的 ppt 上的推法也可以得到相同的结果；最后代码就像下面这样： 12345678910111213#include &lt;iostream&gt;using namespace std;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++ i) cout &lt;&lt; 710 * (i - 25000) &lt;&lt; endl; return 0;&#125; C. Cross-Stitch Cross-Stitch [n] 十字绣给你一个 h 行 w 列的十字绣图案，要求使用一根线将它绣出来，并且消耗线的长度最少；输出这种绣法包含的针数（孔数），并且按照先后顺序输出线经过的点的坐标。 数据规模：1 ≤ w, h ≤ 100； 首先，一根线绣出的意思，就是说存在一条欧拉回路连接这所有的绣边；要消耗线的长度最小，不论怎样的绣边的长度都只能是 1 或者是 √2；最短的消耗，一定是每个十字绣网格，由两条长度为 √2 的表线，和两条长度为 1 的里线组成，且包含起点和终点的网格可以节约一条里线； 因为给的十字绣图案只是表面的走线，里面的走线是可以按照一定的标准来自行连接的，经过草稿纸上的推导其实是我懒得在电脑上画图了，就可以知道起点和终点是可以在同一个方格里的十字上的；这样，当我们连接起点和终点作为里边的时候（这样的连接是合法的），就可以将欧拉路变成欧拉环； 严格按照 表-里-表-里 的方法绣十字绣，当所有的方格的构型是相同（两条里边上下/左右相对）时，一定存在这样的欧拉回路，将所有的绣点连接起来；所以我们可以按照这种思路建图，然后限定 表-里 交错的方法 DFS，就可以找到一个绣十字绣的顺序，它可以确保绣出这个图案并且花费线材最少；特别注意第一针必须绣表线，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;const int N = 105, M = N * N * 4;char map[N][N];int id[N][N], cnt = 0, vis[M];vector&lt;int&gt; ans;struct edge&#123; int u, v, w, next; edge() = default; edge(int u, int v, int w, int next) : u(u), v(v), w(w), next(next) &#123;&#125;&#125;;namespace FWS&#123; int head[N * N]; int tot; edge ee[M * 2]; void init(int n) &#123; memset(head, -1, sizeof(int)*(n+1)); tot = 0; &#125; void addEdge(int u, int v, int w) &#123; ee[tot] = edge(u,v,w,head[u]); head[u] = tot ++; &#125;&#125;void init(int n, int m)&#123; ans.clear(); cnt = 0; for (int i = 0; i &lt;= n; ++ i) for (int j = 0; j &lt;= m; ++ j) id[i][j] = cnt ++; FWS::init(cnt + 5);&#125;void addEdge(int u, int v, int color)&#123; FWS::addEdge(u, v, color); FWS::addEdge(v, u, color);&#125;void dfs(int u, int last_color)&#123; using namespace FWS; for (auto cc = head[u]; cc + 1; cc = ee[cc].next) &#123; if (vis[cc / 2] || ee[cc].w == last_color) continue; vis[cc / 2] = true; dfs(ee[cc].v, ee[cc].w); ans.push_back(ee[cc].v); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); int m, n; cin &gt;&gt; m &gt;&gt; n; init(n, m); int sp, div = m + 1; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; (map[i] + 1); for (int i = 1; i &lt;= n; ++ i) for (int j = 1; j &lt;= m; ++ j) if (map[i][j] == &#x27;X&#x27;) sp = id[i][j], addEdge(id[i - 1][j - 1], id[i][j], 1), addEdge(id[i - 1][j], id[i][j - 1], 1), addEdge(id[i - 1][j], id[i][j], 0), addEdge(id[i - 1][j - 1], id[i][j - 1], 0); dfs(sp, 1); cout &lt;&lt; (ans.size() - 1) &lt;&lt; endl; for (auto &amp; ii : ans) cout &lt;&lt; ii % div &lt;&lt; &#x27; &#x27; &lt;&lt; ii / div &lt;&lt; endl; return 0;&#125; D. Double Palindrome 定义双回文串：一个字符串是双回文串，当且仅当它是一个回文串或两个回文串的组合；现在询问长度不超过 n 的，由大小为 k 的字符集排列组合构成的所有字符串中回文串的数量，输出答案取模。 数据规模：1 ≤ k ≤ 26 并且 1 ≤ n ≤ 1e5。 占坑 E. Equidistant 有 n 个城市连成一棵树，每两个相邻的城市连接的边的长为 1；现在这些城市中的一部分（或者全部）都有人要参加区域赛，问比赛场地设置在哪座城市，才可以保证所有城市的参赛者到达比赛场所需要走的路径长度一致，不存在这样的城市时输出 Impossible。 没有什么特别优秀的做法，考虑暴力，但是并不是直接就暴力了——n²给卡到死；仔细思考一波，发现最多只要扫描所有的节点就一定可以找到这个点，那么就可以考虑多起点 BFS：每当一个节点到达一个节点的时候，如果深度和当前深度一致就增加一次访问次数，这样最终只需要遍历所有节点，找到是否存在被访问了 n 次的节点存在就可以了。 思路比较清晰，接下来就是实现细节的问题了； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int N = 2e5 + 5, M = N;int n, m, c[N];struct edge&#123; int u, v, w, next; edge() = default; edge(int u, int v, int w, int next) : u(u), v(v), w(w), next(next) &#123;&#125;&#125;;namespace FWS&#123; int head[N]; int tot; edge ee[M * 2]; void init(int n = N-1) &#123; memset(head, -1, sizeof(int)*(n+1)); tot = 0; &#125; void addEdge(int u, int v, int w) &#123; ee[tot] = edge(u,v,w,head[u]); head[u] = tot ++; ee[tot] = edge(v,u,w,head[v]); head[v] = tot ++; &#125;&#125;int BFS()&#123; if (n == 1) return 1; queue&lt;int&gt; q; int visit[N] &#123;0&#125;, depth[N] &#123;0&#125;; bool used[N] &#123;false&#125;; for (int i = 1; i &lt;= m; ++ i) &#123; q.push(c[i]); visit[c[i]] = 1; depth[c[i]] = 1; used[c[i]] = true; &#125; int found = -1; using namespace FWS; while (!q.empty()) &#123; auto top = q.front(); q.pop(); for (auto ii = head[top]; ~ii; ii = ee[ii].next) &#123; auto &amp;e = ee[ii]; if (!depth[e.v] || depth[e.v] == depth[e.u] + e.w) &#123; visit[e.v] += visit[e.u]; depth[e.v] = depth[e.u] + e.w; if (visit[e.v] == m) &#123;found = e.v; break;&#125; if (!used[e.v]) &#123; q.push(e.v); used[e.v] = true; &#125; &#125; &#125; if (found &gt; 0) break; &#125; return found;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; n &gt;&gt; m; int u, v; FWS::init(n); for (int i = 1; i &lt; n; ++ i) &#123; cin &gt;&gt; u &gt;&gt; v; FWS::addEdge(u, v, 1); &#125; for (int i = 1; i &lt;= m; ++ i) cin &gt;&gt; c[i]; int found = BFS(); if (found &lt; 0) cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl &lt;&lt; found &lt;&lt; endl; return 0;&#125; 但是这个题目，ECNU 的带佬们有他们独特的想法：首先对于两个“相邻”的特殊点使用倍增 LCA 求中点，且没有终点，一定无解；之后按照 DFS 标号后，就将子树问题转化为了区间问题；虽然到头来，他也没有提供这么做的代码，但是想必也是很有趣的思路吧。 F. Foreach PHP 的 foreach 模拟器因为题目太长所以下面直接说意思： 有一个 PHP 数组 $a，你可以使用 foreach 遍历所有的变量，并且使用 break 中断循环；为了简单起见，你只能操作变量 $x：你可以使用两种 foreach 语句进行操作： 带引用版本：将变量设置为数组中某元素的引用，你只可以使用如下的形式获得元素的引用 1foreach ($a as &amp;$x) if ($x == &lt;some integer value&gt;) break; 值版本：将变量（引用的元素）设置为一个数组元素的值；同样只能使用如下形式 1foreach ($a as $x) if ($x == &lt;some integer value&gt;) break; 接下来题目会给你一个长度为 n 的数组 $a，并且指定目标状态；要求你生成将原数组转化为目标状态的代码（仅由上述两个语句构成），并在第一行输出代码行数；如果不可能生成这样的代码。输出 -1； 数据规模：数组长度 1 ≤ n ≤ 50，元素（包括原始状态和目标状态）的值 1 ≤ si, ti ≤ 100； 使用谷歌生草机来学习共产主义唯一指定语言——俄语 G. Golf Time 有一个宽为 w，高为 h 的球场，定义坐标系：+x 向右，+y 向上；球场内有一个 n 边形池塘，如果球到达了池塘位置就会立即下沉，输入将按照顺时针方向描述池塘边缘所有的格点；球总是朝东北方向发出，并保持匀速直线运动 (1, 1)；当球撞到了边缘，球会被无能量损失的反弹（仅改变运动方向）；现在告诉你 t 个发球点，问这个球是否可以永远的运动下去，或在落水之前运动的时间以及落水时的准确位置。 数据规模：4 ≤ w, h ≤ 5e8，4 ≤ n ≤ 1000，1 ≤ t ≤ 100； 占坑 H. High Load Database 有一个数据库，里面有 n 块数据，每一块数据的大小是 ai；接下来尝试将这个大数据库分库成多个单个存储了不超过 t 数据的数据库：要求数据块的顺序保持和原数据库一致，且每一块数据一定要放在一个数据库中；进行 q 次询问，每次询问 ti，要求求出分成的数据库的数量，或者不能够实现目标。 数据规模：1 ≤ n ≤ 2e6，1 ≤ Σai ≤ 1e6，1 ≤ q ≤ 1e6，1 ≤ t ≤ Σai； 不能分库的情况很显然，就是存在单块数据大于这个要求的数据库最大容量 t，做一下特殊处理就好了；接下来对于单次询问 t，也很容易有这样的思路：从第一块数据开始贪心的向右边数，当空间超过 t 的时候就取出最后一块数据，并且统计次数自增即可；这样对于单次询问是 O(n) 的。 但是问题是这题询问次数很多，这样复杂度就是 O(nq) 的，就会炸了；所以需要想方设法进行一些优化：注意到了询问从左向右的过程是再不断累加求和，这个过程显然可以使用前缀和优化掉；接下来得到的前缀和序列就是一个递增序列：我们每一次寻找到的当前分库存储的数据量 x' 也可以表示为 Σx + x' 的前缀和形式，这样就可以使用二分查找了； 还是应当注意一些实现细节；整体复杂度是 O(qlogn)。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;using namespace std;const int N = 2e5 + 5;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, a[N], q, t, inm = 0, sum[N] &#123;0&#125;; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i], inm = max(inm, a[i]), sum[i] = sum[i - 1] + a[i]; unordered_map&lt;int, int&gt; mem; const auto end = sum + n + 1; cin &gt;&gt; q; while (q --) &#123; cin &gt;&gt; t; if (t &lt; inm) cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; endl; else if (mem.count(t)) cout &lt;&lt; mem[t] &lt;&lt; endl; else &#123; int ans = 0; for (int cur = 0; cur &lt; n; -- cur) &#123; ++ ans; cur = upper_bound(sum + cur, end, sum[cur] + t) - sum; &#125; cout &lt;&lt; (mem[t] = ans) &lt;&lt; endl; &#125; &#125; return 0;&#125; 虽然这样前缀和二分就已经可以做出这个题目了：但是听了校队的 sac 巨佬的讲解之后，了解到了这种情况下还可以使用倍增来搜索前缀和数组，以快速找到下一个合理的位置；先上代码： 123456789while (++ cnt) &#123; int tol = 0, bin = 1; while (bin) if (l + tol + bin &gt; n || a[l + tol + bin] - a[l] &gt; t) bin &gt;&gt;= 1; else tol += bin, bin &lt;&lt;= 1; if (l + tol == n) break; l += tol;&#125; 简单的说就是固定左侧端点，然后使用倍增的方法（其实也就是变相的二分）来枚举段的大小；理论上的时间复杂度仍然和二分方法一样，是 O(log n) 的，但是执行起来的实际效率远高于一般二分；下面是使用这种方法构筑的本题的通过代码甚至用上了六月全新的代码答题卡模板。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#define USING_STDIO 0#if USING_STDIO#include &lt;cstdio&gt;#include &lt;cctype&gt;inline int nextInt()&#123; int x=0,f=1;char ch=getchar(); while (!isdigit(ch))&#123;if (ch==&#x27;-&#x27;) f=-1;ch=getchar();&#125; while (isdigit(ch))&#123;x=(x&lt;&lt;1)+(x&lt;&lt;3)+ch-48;ch=getchar();&#125; return x*f;&#125;#else#include &lt;iostream&gt;#include &lt;iomanip&gt;#endif#include &lt;unordered_map&gt;using namespace std;constexpr long double eps = 1e-8;template &lt;typename number&gt;int compareTo(number x) &#123;return x &lt; -eps ? -1 : x &gt; eps;&#125;template &lt;typename number&gt;int compareTo(number a, number b) &#123;return compareTo(a-b);&#125;const int N = 2e5 + 5;int n, a[N], q, t;long long sum[N];int main()&#123;#if !USING_STDIO ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);#endif cin &gt;&gt; n; int top = sum[0] = 0; sum[n + 1] = 0x7fffffffffffffff; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i], top = max(top, a[i]), sum[i] = sum[i - 1] + a[i]; unordered_map&lt;int, int&gt; memo; cin &gt;&gt; q; while (q --) &#123; cin &gt;&gt; t; if (t &lt; top) cout &lt;&lt; &quot;Impossible&quot; &lt;&lt; endl; else if (memo[t]) cout &lt;&lt; memo[t] &lt;&lt; endl; else &#123; int cnt = 0, l = 0, r; while (++ cnt) &#123; int off = 0, bin = 1; while (bin) if ((r = l + off + bin) &gt; n || sum[r] - sum[l] &gt; t) bin &gt;&gt;= 1; else off += bin, bin &lt;&lt;= 1; if (l + off == n) break; l += off; &#125; cout &lt;&lt; (memo[t] = cnt) &lt;&lt; endl; &#125; &#125; return 0;&#125; 虽然不知道在其他的二分题目里面这有没有什么应用，但是在这里他就这么用上了。 I. Ideal Pyramid 二维坐标系中有 n 个柱子，使用 (x, y, h) 来描述它们：xy 即平面坐标系中代表位置的坐标，h 代表这些柱子的高度；现在法老想要修金字塔：金字塔是一个四棱方锥，四个三角面和坐标系平面的夹角是 45°；法老希望这个金字塔覆盖了所有的柱子，同时尽可能的小，并且金字塔尖一定要是整数坐标的；要求输出 (x, y, h) 描述这个金字塔：xy 是金字塔尖的位置坐标，h 是这个金字塔的高度。 一开始看还以为是平面二分，甚至搬出了我那丑陋的平面几何板子== 最后发现这彻头彻尾是一个超有趣的思维题（也不算吧，主要还是自己太蠢了）：我们假设在每一个柱子处建造小型金字塔，那么符合题意的金字塔一定会把这些金字塔都包含在其中，这样的话金字塔投影的正方形一定会把这些小金字塔的正方形包含在其中——大正方形包含小正方形还是很好计算的；所以我们只要把柱子转化成金字塔投影方形，然后求可以覆盖这些投影的最小正方形，然后求出这个正方形的中心坐标并且计算高度就可以了（草 特别提示：这个金字塔的投影就是边都在网格上的正方形，而不是格点菱形；就算是格点菱形依然是这个思路，只不过求包覆的大菱形的难度变大了== 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;struct triple&#123; int x, y, h; triple(int x, int y, int h) : x(x), y(y), h(h) &#123;&#125;&#125;;vector&lt;triple&gt; p;int n;triple solution()&#123; int uu = p[0].y - p[0].h, dd = p[0].y + p[0].h, ll = p[0].x - p[0].h, rr = p[0].x + p[0].h; for (auto &amp;ii : p) &#123; int uuu = ii.y - ii.h, ddd = ii.y + ii.h, lll = ii.x - ii.h, rrr = ii.x + ii.h; uu = min(uu, uuu); dd = max(dd, ddd); ll = min(ll, lll); rr = max(rr, rrr); &#125; auto xx = rr - ll, yy = dd - uu; unsigned length = max(xx, yy); if (length &amp; 1u) ++ length; int height = length &gt;&gt; 1u; return &#123;ll + height, uu + height, height&#125;;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; n; int x, y, h; for (int i = 0; i &lt; n; ++ i) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; h; p.emplace_back(x, y, h); &#125; auto ans = n == 1 ? p.front() : solution(); cout &lt;&lt; ans.x &lt;&lt; &#x27; &#x27; &lt;&lt; ans.y &lt;&lt; &#x27; &#x27; &lt;&lt; ans.h &lt;&lt; endl; return 0;&#125; J. Just the Last Digit 现在有一个 n 个节点的图，它的每个节点的高度都是唯一的，且是 [1, n] 中的一个整数：数字越大高度越低；现在你只能从高的点到达低的点，你最开始站在最高点处；接下来给你的数据包括一组数据：记载了从每一个点（高度）到达其他点的方法数的最后一位，要求你根据这些数据还原出这个图的可达信息。 数据范围：2 ≤ n ≤ 500. 输入数据看起来有点像入度，但其实不是；只给最后一位的数字也非常的吓人，啊这那我不会做了== 仔细观察样例一定可以发现：对于 \\(a_{i,j}\\) ，就是从 i 点出发到达 j 点的方式数字，当 i ≤ j 的时候的数字必然是 0：这很好理解，因为我比不可能到达比我当前位置高的地方；那我们对于第 i 组数据，只需要从第 i+1 个位置开始考虑就可以了：首先就是 i+1 位置，它只可能是两个值——1 表示该点和当前点是直接连接的，0 则表示没有直接通路；因为这两个点高度差距之间不允许出现间接到达的可能，所以就可以直接得出准确信息； 接下来考虑 [i+2, n] 位置的值：根本没有办法考虑，你能得到的信息就是它定义说的那样；但是从定义出发，就这样：当我们确认 i - i+1 的路径是存在的，那么对于 x ∈ [i+2, n]，一定会有 cnt(i, x) ≥ cnt(i+1, x) ——因为 i 一定可以通过 i+1 到达这些位置，这是确定的间接到达，可以从现在的第 i 组数据中减去； 我们继续向右扫描，如果还能遇到没有被消除的，存在的 j ∈ [i+2, n]，那么它一定是 1，并且代表它和 i 是直接连接的：因为间接连接的可能性都在前面的扫描中被排除了；我们可以再如法炮制，将通过 j 间接到达的可能性全部排除；这样循环就可以填完整个数组，求出所有可能建立直接连接的边，也就是还原了图。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;const int N = 550;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int n, map[N][N], ans[N][N]; char ch; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++ i) for (int j = 1; j &lt;= n; ++ j) &#123; cin &gt;&gt; ch; map[i][j] = ch - &#x27;0&#x27;; &#125; for (int i = 1; i &lt; n; ++ i) for (int j = i + 1; j &lt;= n; ++ j) &#123; ans[i][j] = map[i][j]; if (map[i][j]) for (int k = 1; k &lt;= n; ++ k) &#123; map[i][k] -= map[j][k]; while (map[i][k] &lt; 0) map[i][k] += 10; &#125; &#125; for (int i = 1; i &lt;= n; ++ i) &#123; for (int j = 1; j &lt;= n; ++ j) cout &lt;&lt; ans[i][j]; cout &lt;&lt; endl; &#125; return 0;&#125; K. King’s Children 国王有一个 n × m 矩阵的地图，每一个方格是地盘的最小单位；王有不超过 26 个儿子，用字母表示；每一个儿子有一个城堡，位于地图中的某个方格上：这个方格使用这个字母的大写形式标识，其他方格用 . 表示；现在国王要将地盘分给儿子们，分给儿子们的地盘用字母的小写形式表示；分地图有要求：所有领土必须全部分给儿子，且每个儿子得到的领土是严格的网格矩阵；此外，国王希望 A 儿子分到的领土尽可能的大；现在要求你将分割后的矩阵计算出来并输出。 数据范围：1 ≤ n, m ≤ 1000 好麻烦的 DSU 题目…… 直接翻译题意就可以知道，首先我们要求出整个矩阵中 A 可以拓展的最大子矩阵，然后再拓展其他的字母，将整个矩阵填满；填充最大子矩阵可以使用很多种方法：比如悬线法，或者是单调数据结构等等，求出了 A 的最大子矩阵之后，就将矩阵剩余部分划分成了四个部分；因为其他的字母只需要扩充后填满整个矩形即可，所以不再需要跑一遍最大子矩阵了，随便使用什么乱搞的方法将矩阵填满就可以了。 这里填充其他矩阵的方法，就是对于任何一个字母，先尝试上下拓展，将整列占满，之后再尝试横向拓展；就算这一步暴力也问题不大，之后得到的结果一定是有效的。 先复习关于最大 0, 1 子矩阵的问题：当障碍点比较密集的时候可以使用悬线法，就是开三个数组，记录向上、向左、向右可以到达的最远的距离，之后再遍历整个矩阵的所有点，找到最大的值并记录即可；当然，只开一个数组更新左侧可到达的最远距离，再向上/向下探测求的原理也是一样的，只是因为少了预处理，效率变差了；至于单调栈方法，则是从上而下枚举每一行，维护该行每个位置可以向上探明的最高高度；之后对于每一行，以这个高度作为标准按照一个顺序进行一次单增栈，每次弹栈的时候更新最大面积，就像这里说的那样；甚至还有神奇的并查集做法，自己去看洛谷题解了。 如果你想知道更多关于这个问题的一些信息，你可以去阅读这篇论文：传送门&gt;&gt; 但是和上面所说的那种最大子矩形问题不同的是，这个问题所要求的只是以确定点为重心发散的最大子矩形，暴力的话就可以了（所以这个题目只是单纯的麻烦罢了，但是没问题，我写不出来 ==）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;const int N = 1050;char map[N][N], ans[N][N];int n, m, pos[N][N];struct node&#123; int x, y; char ch; node(int x, int y, char ch) : x(x), y(y), ch(ch) &#123;&#125;&#125;;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); int Ax, Ay; vector&lt;node&gt; vec; pair&lt;int, int&gt; seg[N]; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; (map[i] + 1); memset(pos, 0, sizeof pos); for (int i = 1; i &lt;= n; ++ i) for (int j = 1; j &lt;= m; ++ j) if (map[i][j] == &#x27;A&#x27;) pos[i][j] = map[i][j] - &#x27;A&#x27; + 1, Ax = i, Ay = j; else if (map[i][j] != &#x27;.&#x27;) pos[i][j] = map[i][j] - &#x27;A&#x27; + 1, vec.emplace_back(i, j, pos[i][j] - 1 + &#x27;a&#x27;); for (int j = 1; j &lt;= m; ++ j) &#123; int uu = Ax, dd = Ax; if (pos[Ax][j] &amp;&amp; j != Ay) &#123; seg[j] = make_pair(uu, dd - 1); continue; &#125; while (uu &gt; 1 &amp;&amp; !pos[uu - 1][j]) -- uu; while (dd + 1 &lt;= n &amp;&amp; !pos[dd + 1][j]) ++ dd; seg[j] = make_pair(uu, dd); &#125; pair&lt;int, int&gt; outer = seg[Ay], sav; int al = Ay, ar = Ay, aa = 0; for (int ll = Ay; ll &gt;= 1; -- ll) &#123; auto inner = outer; for (int rr = Ay; rr &lt;= m; ++ rr) &#123; int area = (rr - ll + 1) * (inner.second - inner.first + 1); if (area &gt; aa) &#123; aa = area, al = ll, ar = rr; sav = inner; &#125; inner.first = max(inner.first, seg[rr + 1].first); inner.second = min(inner.second, seg[rr + 1].second); &#125; outer.first = max(outer.first, seg[ll - 1].first); outer.second = min(outer.second, seg[ll - 1].second); &#125; for (int i = 1; i &lt;= n; ++ i) for (int j = 1; j &lt;= m; ++ j) ans[i][j] = &#x27;.&#x27;; for (int j = al; j &lt;= ar; ++ j) for (int i = sav.first; i &lt;= sav.second; ++ i) ans[i][j] = &#x27;a&#x27;; ans[Ax][Ay] = &#x27;A&#x27;; for (auto &amp;ii : vec) ans[ii.x][ii.y] = ii.ch - &#x27;a&#x27; + &#x27;A&#x27;; for (auto &amp;ii : vec) &#123; int xx = ii.x, yy = ii.y; char now = ii.ch; if (xx &lt;= sav.second &amp;&amp; xx &gt;= sav.first) &#123; int ll, rr; while (yy &lt; m &amp;&amp; (yy &gt; al || yy + 1 &lt; al) &amp;&amp; ans[xx][yy + 1] == &#x27;.&#x27;) ans[xx][++ yy] = now; rr = yy, yy = ii.y; while (yy &gt; 1 &amp;&amp; (yy &lt; ar || yy - 1 &gt; ar) &amp;&amp; ans[xx][yy - 1] == &#x27;.&#x27;) ans[xx][-- yy] = now; ll = yy; while (true) &#123; ++ xx; if (xx &gt; n || xx &gt; sav.second) break; bool flag = true; for (int j = ll; j &lt;= rr; ++ j) flag &amp;= ans[xx][j] == &#x27;.&#x27;; if (flag) for (int j = ll; j &lt;= rr; ++ j) ans[xx][j] = now; else break; &#125; xx = ii.x; while (true) &#123; -- xx; if (xx &lt; 1 || xx &lt; sav.first) break; bool flag = true; for (int j = ll; j &lt;= rr; ++ j) flag &amp;= ans[xx][j] == &#x27;.&#x27;; if (flag) for (int j = ll; j &lt;= rr; ++ j) ans[xx][j] = now; else break; &#125; &#125; else &#123; int uu, dd; while (xx &lt; n &amp;&amp; (xx &gt; sav.second || xx + 1 &lt; sav.first) &amp;&amp; ans[xx + 1][yy] == &#x27;.&#x27;) ans[++ xx][yy] = now; dd = xx, xx = ii.x; while (xx &gt; 1 &amp;&amp; (xx &lt; sav.first || xx - 1 &gt; sav.second) &amp;&amp; ans[xx - 1][yy] == &#x27;.&#x27;) ans[-- xx][yy] = now; uu = xx; while (true) &#123; ++ yy; if (yy &gt; m) break; bool flag = true; for (int i = uu; i &lt;= dd; ++ i) flag &amp;= ans[i][yy] == &#x27;.&#x27;; if (flag) for (int i = uu; i &lt;= dd; ++ i) ans[i][yy] = now; else break; &#125; yy = ii.y; while (true) &#123; -- yy; if (yy &lt; 1) break; bool flag = true; for (int i = uu; i &lt;= dd; ++ i) flag &amp;= ans[i][yy] == &#x27;.&#x27;; if (flag) for (int i = uu; i &lt;= dd; ++ i) ans[i][yy] = now; else break; &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++ i) cout &lt;&lt; (ans[i] + 1) &lt;&lt; endl; return 0;&#125; 因为基本上就是嗯暴力，所以代码也算不上整洁优雅== L. Lengths and Periods 求字符串的临界指数：字符串 w 的子串 t，是由 t 的某个前缀 p 循环 α 次得到：这里的 α 未必是整数；字符串 w 的临界指数就是最大的 α； 数据范围：|w| ≤ 2e5 参考了一篇博客的介绍，它提到了这个题目不能用HDU6661 Acesrc and String Theory的做法来做；有时间研究研究 M. Managing Difficulties 给一个长度为 n 的数组 a；要求求出这个数组中，满足 i ≤ j ≤ k 并且 \\(a_k - a_j = a_j - a_i\\) 的不同的三元组 (i, j, k) 的数量；有不超过 10 组的测试数据； 数据范围：3 ≤ n ≤ 2000，1 ≤ \\(a_i\\) ≤ 1e9 另一个签到题：一个第一题一个最后一题…… 好小子，真会照顾人（ 直接暴力是 n³ 的直接暴毙，所以需要优化；这就是常用的套路：暴力两个下标，寻找满足第三个下标的值是否存在，或者存在几个，然后计算个数就可以了；至于记录下标值的数量，显然可以使用稀疏数组 unordered_map： 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;typedef long long longs;const int N = 2060;int n, t, a[N];unordered_map&lt;int, int&gt; mmp;int main()&#123; ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); cin &gt;&gt; t; while (t --) &#123; cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i]; auto n1 = n - 1; longs ans = 0; for (int i = 1; i &lt;= n; ++ i) ++ mmp[a[i]]; for (int i = 1; i &lt;= n; ++ i) &#123; -- mmp[a[i]]; for (int j = 1; j &lt; i; ++ j) &#123; auto pos = 2 * a[i] - a[j]; ans += mmp[pos]; &#125; &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; return 0;&#125; 当然，你也可以使用其他的思路进行暴力；大抵复杂度都是平方等级的。 后记 菜的扣脚…… 不会做题就算了，甚至还不会补题 == 我爬我爬（ 3dfecf7637dcd426.jpg 你已经是一个成熟的题目了，应该学会自动 AC 了 ==","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://shiraha.cn/tags/Codeforces/"},{"name":"Gym","slug":"Gym","permalink":"https://shiraha.cn/tags/Gym/"}]},{"title":"校队训练：个人训练 - 第 1 周","slug":"icpc-team-personal-training-1","date":"2020-05-26T07:59:20.000Z","updated":"2020-05-26T07:59:20.000Z","comments":true,"path":"2020/icpc-team-personal-training-1/","link":"","permalink":"https://shiraha.cn/2020/icpc-team-personal-training-1/","excerpt":"","text":"因为摸鱼的原因，搞到现在才整理好总结…… 至少现在，尽量地把每次训练内容和成果进行总结吧。之后的个人训练就采取先随机题部分题解，后专题板子的顺序来讲解内容好了；希望人没事，希望一个月后我还活在校队里（ 随机练习 随机练习题是 Codeforces 往届的一些比赛题目，都是 div2 的；用群内巨佬神犇的话说就是没有算法的算法题。 CF1236E Alice and the Unfair Game 1 个小球，n 个盒子，m 次操作；每次操作询问 a[i] 盒子里有没有小球，若有则输；为了赢，你在每一次操作之前可以将小球从当前位置移到相邻的盒子中，在所有询问结束后还可以移动一次； 现在规定小球开始位置为 x，结束位置为 y，不同的 (x, y) 为不同的状态；问所有可能使得你胜利的状态数。 数据范围：n, m ≤ 1e5 分析 显然，从某个点出发可以到达的终点构成了一个连续的区间；所以，问题转化成从起点出发最远可达的左右端点；显然找到某一个方向的端点应该尽可能的向该方向移动，但是当向某方向前进时，会因为当前位置冲突（将要移动的目标位置将会被询问）而停止一格； 这样停留之后，相当于它反方向一格的那个格子移动过来但是没有停，所以可以直接转移过来：统计 X[i] 表示向某方向行走的时候，因障碍止步的次数；这样转移方程就可以写成 X[i] = X[i±1] + 1； 实际的统计方法：可以倒过来统计；设我们现在要求从起点 i 开始向右到达的最远距离，向右走会因为障碍中断 X[i] 次，那么最远可以到达的距离就是 i + (1 + m) - X[i]；因为是倒过来统计，所有的障碍数组的初值是 0：当遇到了 a[i] 阻碍的时候，显然，我们要为 XR[ a[i] - i ] 增加一个障碍；根据上面的讨论，这个转移关系始终成立，所以只要按照上面的转移方程进行转移就可以了。 实现上有一些策略：可以开三倍数组考虑偏移，这样不仅解决了边界问题，且因为统计的时候并不会访问这些实际不存在的盒子，所以不会对答案造成什么影响。因为是逆推，所以也不需要考虑开始的障碍：等到考虑它们的时候，它们也会使用转移方程对于相关位置进行更新。 在统计的时候，因为数组使用了偏移，需要保证边界不超过实际存在的边界。 代码 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;using longs = long long;const int N = 1e5 + 5;const int off = 1e5;int a[N], lb[3 * N], rb[3 * N];int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; ++ i) cin &gt;&gt; a[i]; if (n &lt;= 1) cout &lt;&lt; 0 &lt;&lt; endl; else &#123; for (int i = m; i &gt;= 1; -- i) &#123; rb[off + a[i] - i] = rb[off + a[i] - i - 1] + 1; lb[off + a[i] + i] = lb[off + a[i] + i + 1] + 1; &#125; longs cnt = 0; for (int i = 1; i &lt;= n; ++ i) cnt += min(n, i + (m + 1) - rb[off + i]) - max(1, i - (m + 1) + lb[off + i]) + 1; cout &lt;&lt; cnt &lt;&lt; endl; &#125; return 0;&#125; 附录 这个题目如果在 Google 中查的话，还可以找到一种申必的权值线段树的做法。 CF1355F Guess Divisors Count 这是一个交互题：有一个正整数 X，你可以询问 Q，交互机器返回 gcd(Q, X)；要求在不超过 22 次询问之内，求出 X 的约数个数；只要你的猜测 a' 和实际答案满足下面两个关系的任一个就算正确： \\(|a - a&#39;| \\leq 7\\) \\(\\frac 1 2 \\leq \\frac a {a&#39;} \\leq 2\\) 数字 X 不大于 1e9，你询问的数字 Q 不大于 1e18； 分析 首先，任何一个数可以按照下面的形式被唯一分解： \\[ x = p_1^{a_1}p_2^{a_2}...p_n^{a_n} \\] 公式中，n 是这个数字的质因数数目，\\(p_i\\) 表示质因数，\\(a_i\\) 表示质因数的幂次，是一个正整数。显然，这样的一个数的约数数目可以表示为： \\[ \\sigma_0(x) = Π_{i=1}^n (1 + a_i) \\] 这也很容易证明，这样我们就可以想到询问的思路： 第一层：每次询问 \\(Π p_i^{a_i} \\leq 10^{18}\\)，且 \\(p_i^{a_i+1} \\geq 10^9\\) 这样的好处是一定可以询问出准确的约数个数——根据唯一分解定理；但是缺点就是不可能在22次之内询问结束；也就是说，仅仅凭借22次询问是不可能得到约数的准确值的。 第二层：考虑容错机制，压缩询问次数 既然不能做到准确的询问，那么就想办法减少询问的次数，省去不必要的询问（比如上面方法会导致大量的 1）。减少询问的思路显然是压缩对于每一个质数的幂次，让更多的素数可以压缩再一次询问中。 然后，显而易见地，我们可以找到的答案 out 一定会比真实的答案小：因为答案的误差只会来自于对部分情况的未考虑；所以，为了保证最优的状况，输出答案时可以按照 2out 输出，可以覆盖的真实答案的范围就扩展到了 [out, 4out]，更有利。 接下来，观察唯一分解定理，上面得到的 4 倍误差可以被表示为真实答案的唯一分解式中的 (1 + 1)(1 + 1) 或者 (1 + 3)；也就是说，允许两个幂次为 1 的质数没有被考虑，或者是 1 个幂次不超过 3 的质数没有被考虑；前者一定处于 \\([\\sqrt{10^9}, 10^9]\\) 的范围之内，且最多出现一个；后者一定出现在 \\([ \\sqrt[3]{10^9}, \\sqrt{10^9} ]\\) 区间内，且最多出现一个； 还有没有什么可以优化的地方呢？假设我们从 2 开始尝试质数，尝试到了第 n 个质数，已经确定的约数乘积为 w 的时候：当满足 \\(wp_{n+1}p_{n+2}p_{n+3} \\geq 10^9\\) 时，就已经满足了容错规定的情况了；此外，当找到的答案比较小，或者确定答案不会很大的时候（比如没有小因数），可以直接输出 8，当实际答案在 [1, 15] 范围内都可通过。 第三层：实现 虽然讲踢人提供了这些思路，但是也没说一个具体的实现过程；所以最后我就直接去看的题解了。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define ask cout&lt;&lt;&quot;? &quot;#define chk cout&lt;&lt;&quot;! &quot;using namespace std;using longs = long long;template &lt;int n&gt; const int *EulerSieve()&#123; static int prime[n + 5]; bool vis[n + 5] &#123;false&#125;; int &amp;cnt = prime[0] = 0; for (int i = 2; i &lt;= n; ++ i) &#123; if (!vis[i]) prime[++ cnt] = i; for (int j = 1; j &lt;= cnt &amp;&amp; (longs)i * prime[j] &lt;= n; ++ j) &#123; vis[i * prime[j]] = true; if (i % prime[j] == 0) break; &#125; &#125; return prime;&#125;struct triple&#123; int p, a; longs v; triple(int p, int a, longs v) : p(p), a(a), v(v) &#123;&#125; bool operator&lt;(const triple &amp;rhs) const &#123; if (a == rhs.a) return v &gt; rhs.v; else return a &lt; rhs.a; &#125;&#125;;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int t; longs response, ans; auto p = EulerSieve&lt;31623&gt;(); auto cnt = p[0]; cin &gt;&gt; t; while (t --) &#123; priority_queue&lt;triple&gt; pq; for (int i = 1; i &lt;= cnt; ++ i) pq.push(&#123;p[i], 1, p[i]&#125;); vector&lt;triple&gt; used; ans = 1; for (int i = 0; i &lt; 22; ++ i) &#123; used.clear(); longs query = 1; while (!pq.empty()) &#123; auto &amp;front = pq.top(); if ((double)query * front.v &gt; 1e18) break; used.push_back(front); query *= front.v; pq.pop(); &#125; ask &lt;&lt; query &lt;&lt; endl; cin &gt;&gt; response; for (auto &amp;ii : used) if (response % ii.v == 0) &#123; ans = (ans / ii.a) * ++ ii.a; ii.v *= ii.p; pq.push(ii); &#125; &#125; chk &lt;&lt; ans * 2 &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"校队","slug":"校队","permalink":"https://shiraha.cn/tags/%E6%A0%A1%E9%98%9F/"}]},{"title":"校队总结：树上分治","slug":"icpc-team-tree-divisor-and-conquer","date":"2020-05-24T16:27:23.000Z","updated":"2020-05-24T16:27:23.000Z","comments":true,"path":"2020/icpc-team-tree-divisor-and-conquer/","link":"","permalink":"https://shiraha.cn/2020/icpc-team-tree-divisor-and-conquer/","excerpt":"","text":"树上分治主要是针对于树上路径问题的，一种使用分治思想解决的方法。主要分为树分治（树上点分治、边分治）以及动态树分治两个部分。 点分治 适合处理大规模的树上路径信息问题。 例题 ##### luogu P3806【模板】点分治 1 给定一颗 n 个点的带点权树，m 次询问，每次询问给出 k，询问树上距离为 k 的点对是否存在。 n ≤ 1e5，m ≤ 100，k ≤ 1e9 先随意选择一个节点作为根节点 rt：这样，所有完全位于其子树中的路径可以分为两种—— 一种是经过当前根节点的路径，一种是不经过当前根节点的路径；对于经过当前根节点的路径，又可以分为两种，一种是以根节点为一个端点的路径，另一种是两个端点都不为根节点的路径；而后者又可以由两条属于前者链合并得到。 因此，对于枚举的根节点 rt ：我们可以先计算在其子树中且经过该节点的路径对答案的贡献，再递归其子树对不经过该节点的路径进行求解。 对于这个题目，对于经过根节点 rt 的路径，我们先枚举其所有子节点 ch ，以 ch 为根计算 ch 子树中所有节点到 rt 的距离。记节点 i 到当前根节点 rt 的距离为 \\(d_i\\) ， \\(tf_d\\) 表示之前处理过的子树中是否存在一个节点 v 使得 \\(d_i\\) = d 。若一个询问的 k 满足 \\(tf_{k-d_i}\\) = true ，则存在一条长度为 k 的路径。在计算完 ch 子树中所连的边能否成为答案后，我们将这些新的距离加入 tf 数组中。 一般来说，清空 tf 数组不应使用 memset，这会导致 TLE；正确的做法是将之前使用过的位置加入一个数组中，清空的时候使用这个数里的记录值清空，才可以保证时间复杂度。 点分治过程中，每一层的所有递归过程合计对每个点处理一次，假设共递归 h 层，则总时间复杂度为 O(nh)。但是若我们每次选择子树的重心作为根节点，可以保证递归层数最少，时间复杂度为 O(nlogn)。每一次在确定根节点之前统计子树大小，并且找到一个根，使得最大子树大小最小，就找到了重心。 请注意在重新选择根节点之后一定要重新计算子树的大小，否则一点看似微小的改动就可能会使时间复杂度错误或正确性难以保证。 例题的代码（来自 OI Wiki）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int maxn = 20010;const int inf = 2e9;int n, m, a, b, c, q[maxn], rt, siz[maxn], maxx[maxn], dist[maxn];int cur, h[maxn], nxt[maxn], p[maxn], w[maxn];bool tf[10000010], ret[maxn], vis[maxn];void add_edge(int x, int y, int z) &#123; cur++; nxt[cur] = h[x]; h[x] = cur; p[cur] = y; w[cur] = z;&#125;int sum;void calcsiz(int x, int fa) &#123; siz[x] = 1; maxx[x] = 0; for (int j = h[x]; j; j = nxt[j]) if (p[j] != fa &amp;&amp; !vis[p[j]]) &#123; calcsiz(p[j], x); maxx[x] = max(maxx[x], siz[p[j]]); siz[x] += siz[p[j]]; &#125; maxx[x] = max(maxx[x], sum - siz[x]); if (maxx[x] &lt; maxx[rt]) rt = x;&#125;int dd[maxn], cnt;void calcdist(int x, int fa) &#123; dd[++cnt] = dist[x]; for (int j = h[x]; j; j = nxt[j]) if (p[j] != fa &amp;&amp; !vis[p[j]]) dist[p[j]] = dist[x] + w[j], calcdist(p[j], x);&#125;queue&lt;int&gt; tag;void dfz(int x, int fa) &#123; tf[0] = true; tag.push(0); vis[x] = true; for (int j = h[x]; j; j = nxt[j]) if (p[j] != fa &amp;&amp; !vis[p[j]]) &#123; dist[p[j]] = w[j]; calcdist(p[j], x); for (int k = 1; k &lt;= cnt; k++) for (int i = 1; i &lt;= m; i++) if (q[i] &gt;= dd[k]) ret[i] |= tf[q[i] - dd[k]]; for (int k = 1; k &lt;= cnt; k++) tag.push(dd[k]), tf[dd[k]] = true; cnt = 0; &#125; while (!tag.empty()) tf[tag.front()] = false, tag.pop(); for (int j = h[x]; j; j = nxt[j]) if (p[j] != fa &amp;&amp; !vis[p[j]]) &#123; sum = siz[p[j]]; rt = 0; maxx[rt] = inf; calcsiz(p[j], x); calcsiz(rt, -1); dfz(rt, x); &#125;&#125;int main() &#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt; n; i++) scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c), add_edge(a, b, c), add_edge(b, a, c); for (int i = 1; i &lt;= m; i++) scanf(&quot;%d&quot;, q + i); rt = 0; maxx[rt] = inf; sum = n; calcsiz(1, -1); calcsiz(rt, -1); dfz(rt, -1); for (int i = 1; i &lt;= m; i++) if (ret[i]) printf(&quot;AYE\\n&quot;); else printf(&quot;NAY\\n&quot;); return 0;&#125; 点分治的经典例题还有这个题目：luogu P4178 Tree 找重心 可以看到，找到正确的重心是保障算法复杂度的关键；首先下定义：一棵树的最大子树最小的点有一个名称，叫做重心；它有一个特点是以它为根的每一个子树的大小都不超过 n/2，这可以使用反证法来证明；正因为重心有这样的特点，所以每一次都选取重心进行递归，可以保障复杂度是 O(nlogn)。 找到子树也是依靠了这个特性：每次 DFS 整棵树，并且统计最大子树，就可以确定树的重心： 123456789101112void findrt(int u,int fa)&#123; sz[u]=1,son[u]=0; // sz表示子树的大小，son表示点的最大子树的大小 for(int i=head[u];i;i=Next[i])&#123; int v=ver[i]; if(vis[v]||v==fa) continue; findrt(v,u); sz[u]+=sz[v]; son[u]=max(son[u],sz[v]); &#125; son[u]=max(son[u],size-sz[u]); if(son[u]&lt;mx) mx=son[u],rt=u;&#125; 这个过程的复杂度是 O(n) 的。 分治过程 不同的题目可能具体实现不同，但是大概结构如下： 123456789101112void divide(int u)&#123; ans+=solve(u,0); //把当前节点的答案加上去 vis[u]=1; //把节点标记，防止陷入死循环 for(int i=head[u];i;i=Next[i])&#123; //分别处理每一棵子树 int v=ver[i]; if(vis[v]) continue; ans-=solve(v,edge[i]); mx=inf,rt=0,size=sz[v]; //把所有信息更新，递归进子树找重心，并继续分治 findrt(v,0); divide(rt); &#125;&#125; 有一个要提的地方是：在对于子树的 findrt 之前的传递全树大小的位置，直接传递了 sx[v]；实际上这个地方应该传递的是 size=sz[v]&gt;sz[u]?totsz-sz[u]:sz[v]，但是这个错误的写法在这里并不会影响算法的正确性或者复杂度。数学证明可以看这里：传送门 动态点分治 上面的点分治只可以处理静态的问题，如果问题是动态的，也就是要求待修改状态的话，上面的方法就不能直接使用了；对于动态点分治问题来说，修改的只有点权值，整棵树的结构是不变的——这意味着我们每一次进行点分时选到的重心也是不变的；又因为遍历连通块是 O(n) 的，点分治的复杂度仅和上述的递归深度相关。 “树上的动态点分治相当于序列上的线段树” 点分树 简单的说，把上面说的点分治里每一层找到的重心之间连边，就构成了一颗高度为 logn 树，也就是点分树。 官方的说，就是通过更改原树形态使树的层数变为稳定 logn 的一种重构树；是点分治过程中选择的分治中心点构成的树形结构；常用于解决与树原形态无关的带修改问题，也就是上面说的那种动态问题。 得到点分树，就可以通过点分治每次找重心的方式来对原树进行重构：将每次找到的重心与上一层的重心缔结父子关系，这样就可以形成一棵 logn 层的树。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;typedef vector&lt;int&gt;::iterator IT;struct Edge &#123; int to, nxt, val; Edge() &#123;&#125; Edge(int to, int nxt, int val) : to(to), nxt(nxt), val(val) &#123;&#125;&#125; e[300010];int head[150010], cnt;void addedge(int u, int v, int val) &#123; e[++cnt] = Edge(v, head[u], val); head[u] = cnt;&#125;int siz[150010], son[150010];bool vis[150010];int tot, lasttot;int maxp, root;void getG(int now, int fa) &#123; siz[now] = 1; son[now] = 0; for (int i = head[now]; i; i = e[i].nxt) &#123; int vs = e[i].to; if (vs == fa || vis[vs]) continue; getG(vs, now); siz[now] += siz[vs]; son[now] = max(son[now], siz[vs]); &#125; son[now] = max(son[now], tot - siz[now]); if (son[now] &lt; maxp) &#123; maxp = son[now]; root = now; &#125;&#125;struct Node &#123; int fa; vector&lt;int&gt; anc; vector&lt;int&gt; child;&#125; nd[150010];int build(int now, int ntot) &#123; tot = ntot; maxp = 0x7f7f7f7f; getG(now, 0); int g = root; vis[g] = 1; for (int i = head[g]; i; i = e[i].nxt) &#123; int vs = e[i].to; if (vis[vs]) continue; int tmp = build(vs, ntot - son[vs]); nd[tmp].fa = now; nd[now].child.push_back(tmp); &#125; return g;&#125;int virtroot;int main() &#123; int n; cin &gt;&gt; n; for (int i = 1; i &lt; n; i++) &#123; int u, v, val; cin &gt;&gt; u &gt;&gt; v &gt;&gt; val; addedge(u, v, val); addedge(v, u, val); &#125; virtroot = build(1, n);&#125; 这里有一个技巧：每次用递归上一层的总大小 tot 减去上一层的点的重儿子大小，得到的就是这一层的总大小。这样求重心就只需一次 DFS 了； 实现修改 在查询和修改的时候，我们在点分树上暴力跳父亲修改；由于点分树的深度最多是 O(nlogn) 的，这样做复杂度能得到保证。 在动态点分治的过程中，需要一个结点到其点分树上的祖先的距离等其他信息，由于一个点最多有 logn 个祖先，我们可以在计算点分树时额外计算深度或使用 LCA，预处理出这些距离或实现实时查询；因为一个结点到其点分树上的祖先的距离不一定递增，所以不能累加；除此之外，一个结点在其点分树上的祖先结点的信息中可能会被重复计算：此时我们需要消去重复部分的影响。一般的方法是对于一个连通块用两种方式记录：一个是其到分治中心的距离信息，另一个是其到点分树上分治中心父亲的距离信息。 例题 ##### 「ZJOI2007」捉迷藏 给定一棵有 n 个结点的树，初始时所有结点都是黑色的。你需要实现以下两种操作： 反转一个结点的颜色（白变黑，黑变白）； 询问树上两个最远的黑点的距离； 数据范围：n ≤ 1e5，m ≤ 5e5 求出点分树，对于每个结点 维护两个可删堆1。 dist[x] 存储结点 x 代表的连通块中的所有黑点到 x 的距离信息， ch[x] 表示结点 x 在点分树上的所有儿子和它自己中的黑点到 x 的距离信息；由于本题贪心的求答案方法，且两个来自于同一子树的路径不能成为一条完成的路径，我们只在这个堆中插入其自己的值和其每个子树中的最大值；我们发现， ch[x] 中最大的两个值（如果没有两个就是所有值）的和就是分治时分支中心为 x 时经过结点 x 的最长黑端点路径。我们可以用可删堆 ans 存储所有结点的答案，这个堆中的最大值就是我们所求的答案。 我们可以根据上面的定义维护 dist[], ch[], ans 这三个可删堆：当 dist[x] 中的值发生变化时，我们也可以在 O(logn) 的时间复杂度内维护 ch[x] 和 ans。 现在我们来看一下，当我们反转一个点的颜色时， dist[x] 值会发生怎样的改变：当结点原来是黑色时，我们要进行的是删除操作；当结点原来是白色时，我们要进行的是插入操作；假如我们要反转结点 x 的颜色。对于其所有祖先 u，我们在 dist[u] 中插入或删除 dist(x, u)，并同时维护 ch[x] 和 ans 的值；特别的，我们要在 ch[x] 中插入或删除值 0。 分治树深度 logn，堆操作时间复杂度是l O(logn)，总时间复杂度是 O(nlog²n)； 例题的代码（来自 OI Wiki）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;const int maxn = 100010;const int inf = 2e9;int n, a, b, m, x, col[maxn];// 0 off 1 onchar op;int cur, h[maxn * 2], nxt[maxn * 2], p[maxn * 2];void add_edge(int x, int y) &#123; cur++; nxt[cur] = h[x]; h[x] = cur; p[cur] = y;&#125;bool vis[maxn];int rt, sum, siz[maxn], maxx[maxn], fa[maxn], dep[maxn];void calcsiz(int x, int f) &#123; siz[x] = 1; maxx[x] = 0; for (int j = h[x]; j; j = nxt[j]) if (p[j] != f &amp;&amp; !vis[p[j]]) &#123; calcsiz(p[j], x); siz[x] += siz[p[j]]; maxx[x] = max(maxx[x], siz[p[j]]); &#125; maxx[x] = max(maxx[x], sum - siz[x]); if (maxx[x] &lt; maxx[rt]) rt = x;&#125;struct heap &#123; priority_queue&lt;int&gt; A, B; // heap=A-B void insert(int x) &#123; A.push(x); &#125; void erase(int x) &#123; B.push(x); &#125; int top() &#123; while (!B.empty() &amp;&amp; A.top() == B.top()) A.pop(), B.pop(); return A.top(); &#125; void pop() &#123; while (!B.empty() &amp;&amp; A.top() == B.top()) A.pop(), B.pop(); A.pop(); &#125; int top2() &#123; int t = top(), ret; pop(); ret = top(); A.push(t); return ret; &#125; int size() &#123; return A.size() - B.size(); &#125;&#125; dist[maxn], ch[maxn], ans;void dfs(int x, int f, int d, heap&amp; y) &#123; y.insert(d); for (int j = h[x]; j; j = nxt[j]) if (p[j] != f &amp;&amp; !vis[p[j]]) dfs(p[j], x, d + 1, y);&#125;void pre(int x) &#123; vis[x] = true; for (int j = h[x]; j; j = nxt[j]) if (!vis[p[j]]) &#123; rt = 0; maxx[rt] = inf; sum = siz[p[j]]; calcsiz(p[j], -1); calcsiz(rt, -1); fa[rt] = x; dfs(p[j], -1, 1, dist[rt]); ch[x].insert(dist[rt].top()); dep[rt] = dep[x] + 1; pre(rt); &#125; ch[x].insert(0); if (ch[x].size() &gt;= 2) ans.insert(ch[x].top() + ch[x].top2()); else if (ch[x].size()) ans.insert(ch[x].top());&#125;struct LCA &#123; int dep[maxn], lg[maxn], fa[maxn][20]; void dfs(int x, int f) &#123; for (int j = h[x]; j; j = nxt[j]) if (p[j] != f) dep[p[j]] = dep[x] + 1, fa[p[j]][0] = x, dfs(p[j], x); &#125; void init() &#123; dfs(1, -1); for (int i = 2; i &lt;= n; i++) lg[i] = lg[i / 2] + 1; for (int j = 1; j &lt;= lg[n]; j++) for (int i = 1; i &lt;= n; i++) fa[i][j] = fa[fa[i][j - 1]][j - 1]; &#125; int query(int x, int y) &#123; if (dep[x] &gt; dep[y]) swap(x, y); int k = dep[y] - dep[x]; for (int i = 0; k; k = k / 2, i++) if (k &amp; 1) y = fa[y][i]; if (x == y) return x; k = dep[x]; for (int i = lg[k]; i &gt;= 0; i--) if (fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i]; return fa[x][0]; &#125; int dist(int x, int y) &#123; return dep[x] + dep[y] - 2 * dep[query(x, y)]; &#125;&#125; lca;int d[maxn][20];int main() &#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt; n; i++) scanf(&quot;%d%d&quot;, &amp;a, &amp;b), add_edge(a, b), add_edge(b, a); lca.init(); rt = 0; maxx[rt] = inf; sum = n; calcsiz(1, -1); calcsiz(rt, -1); pre(rt); // for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,fa[i]);printf(&quot;\\n&quot;); for (int i = 1; i &lt;= n; i++) for (int j = i; j; j = fa[j]) d[i][dep[i] - dep[j]] = lca.dist(i, j); scanf(&quot;%d&quot;, &amp;m); while (m--) &#123; scanf(&quot; %c&quot;, &amp;op); if (op == &#x27;G&#x27;) &#123; if (ans.size()) printf(&quot;%d\\n&quot;, ans.top()); else printf(&quot;-1\\n&quot;); &#125; else &#123; scanf(&quot;%d&quot;, &amp;x); if (!col[x]) &#123; if (ch[x].size() &gt;= 2) ans.erase(ch[x].top() + ch[x].top2()); ch[x].erase(0); if (ch[x].size() &gt;= 2) ans.insert(ch[x].top() + ch[x].top2()); for (int i = x; fa[i]; i = fa[i]) &#123; if (ch[fa[i]].size() &gt;= 2) ans.erase(ch[fa[i]].top() + ch[fa[i]].top2()); ch[fa[i]].erase(dist[i].top()); dist[i].erase(d[x][dep[x] - dep[fa[i]]]); if (dist[i].size()) ch[fa[i]].insert(dist[i].top()); if (ch[fa[i]].size() &gt;= 2) ans.insert(ch[fa[i]].top() + ch[fa[i]].top2()); &#125; &#125; else &#123; if (ch[x].size() &gt;= 2) ans.erase(ch[x].top() + ch[x].top2()); ch[x].insert(0); if (ch[x].size() &gt;= 2) ans.insert(ch[x].top() + ch[x].top2()); for (int i = x; fa[i]; i = fa[i]) &#123; if (ch[fa[i]].size() &gt;= 2) ans.erase(ch[fa[i]].top() + ch[fa[i]].top2()); if (dist[i].size()) ch[fa[i]].erase(dist[i].top()); dist[i].insert(d[x][dep[x] - dep[fa[i]]]); ch[fa[i]].insert(dist[i].top()); if (ch[fa[i]].size() &gt;= 2) ans.insert(ch[fa[i]].top() + ch[fa[i]].top2()); &#125; &#125; col[x] ^= 1; &#125; &#125; return 0;&#125; 还有一个经典的例题：洛谷 P6329 【模板】点分树 | 震波 边分治 边分治和点分治一样属于树分治的一部分，和点分治也有足够的相似之处：选取一条边，将树尽量均匀地分为两个部分；但是相比于点分治，边分治对于与度数相关的问题有着很大的优势，同时边分治也是解决树上最优化问题的一种重要的算法。 但是这样存在一个问题：当一棵树是有多个大小相近的子树的时候比如菊花图，复杂度就会变差： tree-divide1.png ↑ 菊花图 ↑ 在这种情况下，无论怎么划分复杂度都会变成 O(n²)；考虑到如果根节点的孩子减少的话，就可以缓解这种压力，最优的树型就是二叉树；所以可以重构这颗树，利用插入虚点的方法将一颗多叉树转化为二叉树从而保证分治的复杂度 O(nlogn) ；但是因为插入了 O(n) 个虚点，最多会引入两倍的常数。 这种重构树的建树方法和线段树的建树很像；新插入的虚点维护的数据可以根据题目要求来确定——比如当统计路径长度时，将原边边权赋为 1, 将新建的边边权赋为 0 即可；几乎所有的点分治的题边分都能做，但是常数上有差距。 至于分治的过程，和点分治依然是相似的：每次分治时找到一条分治中心边，使这条边两端的两个联通块中较大的一个尽量小；在以分治中心边为界限分开而得到的两个连通块中，统计路径经过分治中心边的答案；然后将分治中心边断开，递归分治中心边两端的两个联通块。 找中心边 和点分治非常相似：通过统计一条边的两侧的子树的大小，找到较大的一侧子树大小最小的边；在递归的时候应当将当前的中心边打上删除标记，以避免统计错误。 1234567891011121314inline void findct(int u, int fa) &#123; siz[u] = 1; for(int i = head[u]; ~i; i = gra[i].nxt) &#123; int v = gra[i].to; if(del[i &gt;&gt; 1] || v == fa) continue; findct(v, u); siz[u] += siz[v]; int vsiz = std::max(siz[v], sum - siz[v]); if(vsiz &lt; ctsiz) &#123; ct = i; ctsiz = vsiz; &#125; &#125;&#125; 代码中的 sum 是调用该函数时设置的当前连通块的大小。 树重构 重构树的递归过程是：先重构子树，再将重构完成的子树们二分连接到虚点上，效果大概如下图所示： tree-divide2.png 下面是一种参考的树重构的实现方法： 1234567891011121314151617181920inline void rebuild(int u, int fa) &#123; int ff = 0; for(int i = heado[u]; ~i; i = grao[i].nxt) &#123; int v = grao[i].to, w = grao[i].w; if(v == fa) continue; if(!ff) &#123; addedge(u, v, w); addedge(v, u, w); ff = u; &#125; else &#123; int k = ++n; addedge(ff, k, 0); addedge(k, ff, 0); addedge(k, v, w); addedge(v, k, w); ff = k; &#125; rebuild(v, u); &#125;&#125; 但是上面的实现并不是边分治中重构树的唯一选择；大可采用其他的实现来完成这项工作。 例题 ##### SP2666 QTREE4 - Query on a tree IV 给定一棵 n 个点的带边权的树，点从 1 到 n 编号；每个点可能有两种颜色：黑或白；一开始所有的点都是白色的；定义 dist(a, b) 为 a-b 路径上的权值之和；可以进行操作： C a：反转 a 点的颜色； A：查询 dist(a, b) 的最大值，a b 都是白色，且可相同； 查询时若树上无白色点，输出 They have disappeared.；N, Q ≤ 1e5，边权c ∈ [-1e3, 1e3]。 当然，这个题目也可以使用点分治来做；但是这里使用边分治的方法来解决：在中心边位置维护两个堆，分别表示左右子树的各个白点距离；单独维护每个分治结构的答案，就可以在一个统计最大值的时候顺带把子分治结构的最大值也计算进来，这样询问的时候只需要询问根分支结构的答案即可； 在加点的的过程中，记录下这个点会影响到的堆的数据：变白要把这个点放进堆里，变黑只需要打标记；在每一次更新答案的时候，从堆顶把黑点全部删除；如果用数组或者 vector 来存的话，这个更新要根据倒序，因为倒序才是分治结构从底向根的顺序。 参考代码（Code by KSkun, 2018/3）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;typedef long long LL;inline char fgc() &#123; static char buf[100000], *p1 = buf, *p2 = buf; return p1 == p2 &amp;&amp; (p2 = (p1 = buf) + fread(buf, 1, 100000, stdin), p1 == p2) ? EOF : *p1++;&#125;inline LL readint() &#123; register LL res = 0, neg = 1; register char c = fgc(); while(c &lt; &#x27;0&#x27; || c &gt; &#x27;9&#x27;) &#123; if(c == &#x27;-&#x27;) neg = -1; c = fgc(); &#125; while(c &gt;= &#x27;0&#x27; &amp;&amp; c &lt;= &#x27;9&#x27;) &#123; res = res * 10 + c - &#x27;0&#x27;; c = fgc(); &#125; return res * neg;&#125;inline bool isop(char c) &#123; return c == &#x27;A&#x27; || c == &#x27;C&#x27;;&#125;inline char readop() &#123; char c; while(!isop(c = fgc())); return c;&#125;const int MAXN = 200005, INF = 2e9;int n, q, col[MAXN], ans;struct Edge &#123; int to, w, nxt;&#125; gra[MAXN &lt;&lt; 1], grao[MAXN &lt;&lt; 1];int head[MAXN], heado[MAXN], ecnt, ecnto;inline void addedge(int u, int v, int w) &#123; gra[ecnt] = Edge &#123;v, w, head[u]&#125;; head[u] = ecnt++;&#125;inline void addedgeo(int u, int v, int w) &#123; grao[ecnto] = Edge &#123;v, w, heado[u]&#125;; heado[u] = ecnto++;&#125;inline void rebuild(int u, int fa) &#123; int ff = 0; for(int i = heado[u]; ~i; i = grao[i].nxt) &#123; int v = grao[i].to, w = grao[i].w; if(v == fa) continue; if(!ff) &#123; addedge(u, v, w); addedge(v, u, w); ff = u; &#125; else &#123; int k = ++n; col[k] = 1; addedge(ff, k, 0); addedge(k, ff, 0); addedge(k, v, w); addedge(v, k, w); ff = k; &#125; rebuild(v, u); &#125;&#125;bool del[MAXN &lt;&lt; 1];int ct, ctsiz, sum;int siz[MAXN], msz[MAXN];inline void calsiz(int u, int fa) &#123; siz[u] = 1; for(int i = head[u]; ~i; i = gra[i].nxt) &#123; int v = gra[i].to; if(del[i &gt;&gt; 1] || v == fa) continue; calsiz(v, u); siz[u] += siz[v]; &#125;&#125;inline void findct(int u, int fa) &#123; for(int i = head[u]; ~i; i = gra[i].nxt) &#123; int v = gra[i].to; if(del[i &gt;&gt; 1] || v == fa) continue; findct(v, u); int vsiz = std::max(siz[v], sum - siz[v]); if(vsiz &lt; ctsiz) &#123; ct = i; ctsiz = vsiz; &#125; &#125;&#125;struct DisData &#123; int u, d; inline bool operator&lt;(const DisData &amp;rhs) const &#123; return d &lt; rhs.d; &#125;&#125;;std::priority_queue&lt;DisData&gt; s[MAXN][2];int cnt;struct NodeData &#123; int bel, side, dis;&#125;;std::vector&lt;NodeData&gt; ndata[MAXN];inline void caldis(int u, int fa, int d, int t, int l) &#123; if(!col[u]) &#123; s[t][l].push(DisData &#123;u, d&#125;); ndata[u].push_back(NodeData &#123;t, l, d&#125;); &#125; for(int i = head[u]; ~i; i = gra[i].nxt) &#123; int v = gra[i].to, w = gra[i].w; if(del[i &gt;&gt; 1] || v == fa) continue; caldis(v, u, d + w, t, l); &#125;&#125;int mx[MAXN], lch[MAXN], rch[MAXN], ctw[MAXN];inline void update(int p) &#123; while(!s[p][0].empty() &amp;&amp; col[s[p][0].top().u]) s[p][0].pop(); while(!s[p][1].empty() &amp;&amp; col[s[p][1].top().u]) s[p][1].pop(); if(s[p][0].empty() || s[p][1].empty()) mx[p] = 0; else mx[p] = s[p][0].top().d + ctw[p] + s[p][1].top().d; if(lch[p]) mx[p] = std::max(mx[p], mx[lch[p]]); if(rch[p]) mx[p] = std::max(mx[p], mx[rch[p]]);&#125;inline int divide(int u) &#123; calsiz(u, 0); ct = -1; ctsiz = INF; sum = siz[u]; findct(u, 0); if(ct == -1) return 0; int x = gra[ct].to, y = gra[ct ^ 1].to; del[ct &gt;&gt; 1] = true; int t = ++cnt; ctw[t] = gra[ct].w; caldis(x, 0, 0, t, 0); caldis(y, 0, 0, t, 1); lch[t] = divide(x); rch[t] = divide(y); update(t); return t;&#125;inline void setwhite(int u) &#123; for(int i = ndata[u].size() - 1; i &gt;= 0; i--) &#123; NodeData d = ndata[u][i]; s[d.bel][d.side].push(DisData &#123;u, d.dis&#125;); update(d.bel); &#125;&#125;inline void setblack(int u) &#123; for(int i = ndata[u].size() - 1; i &gt;= 0; i--) &#123; NodeData d = ndata[u][i]; update(d.bel); &#125;&#125;int ut, vt, wt;char op;int main() &#123; memset(head, -1, sizeof(head)); memset(heado, -1, sizeof(heado)); n = readint(); int white = n; for(int i = 1; i &lt; n; i++) &#123; ut = readint(); vt = readint(); wt = readint(); addedgeo(ut, vt, wt); addedgeo(vt, ut, wt); &#125; rebuild(1, 0); divide(1); q = readint(); while(q--) &#123; op = readop(); if(op == &#x27;A&#x27;) &#123; if(!white) &#123; puts(&quot;They have disappeared.&quot;); &#125; else if(white == 1) &#123; puts(&quot;0&quot;); &#125; else &#123; printf(&quot;%d\\n&quot;, mx[1]); &#125; &#125; else &#123; ut = readint(); col[ut] ^= 1; if(col[ut]) &#123; setblack(ut); white--; &#125; else &#123; setwhite(ut); white++; &#125; &#125; &#125; return 0;&#125; 不只是这个题目，很多的点分治的问题都可以使用边分治解决，这里就不贴其他题了。 推荐题目 除了文章中出现的讲解了的和没讲解的例题之外，还可以做一做下面这些题目： 洛谷 P2664 树上游戏 洛谷 P3345 [ZJOI2015]幻想乡战略游戏 洛谷 P3241 [HNOI2015]开店 推荐的题目参考了网络上的资料。 参考资料 因为这篇文章参考了大量其他巨佬神犇的博客和资料，所以基本上没有什么原创性可言；借物表如下： https://oi-wiki.org/graph/tree-divide/ https://www.cnblogs.com/bztMinamoto/p/9489473.html https://oi-wiki.org/graph/dynamic-tree-divide/ https://www.cnblogs.com/HocRiser/p/8505627.html https://www.cnblogs.com/Khada-Jhin/p/10154994.html https://ksmeow.moe/edge_based_divide_and_conquer/ 都是因为 DDL，理解万岁，理解万岁（ 比起朴素堆只能删除堆顶元素，还可以删除其他元素；一般是使用一个临时堆存储暂时不在堆顶但是需要删除的元素，当这些元素到达堆顶的时候再一并弹出。↩︎","categories":[{"name":"校队讲义","slug":"校队讲义","permalink":"https://shiraha.cn/categories/%E6%A0%A1%E9%98%9F%E8%AE%B2%E4%B9%89/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"校队","slug":"校队","permalink":"https://shiraha.cn/tags/%E6%A0%A1%E9%98%9F/"}]},{"title":"软件工程：第 2 次上机实验","slug":"class-software-engineering-experiment-2","date":"2020-05-24T15:20:08.000Z","updated":"2020-05-24T15:20:08.000Z","comments":true,"path":"2020/class-software-engineering-experiment-2/","link":"","permalink":"https://shiraha.cn/2020/class-software-engineering-experiment-2/","excerpt":"","text":"下面是这一次的实验要求： ##### 系统建模实验 一、实验名称：系统建模实验 二、实验目的 理解多视角系统建模思想和技术 掌握常见UML建模图形。 三、实验内容和要求 对你使用和熟悉的一个系统进行上下文、结构、行为和交互建模 建模不需要是整个系统，重点是建模角度 为了方便理解建模结果，给出必要的背景或上下文描述 使用用例图+脚本、顺序图、活动图、类图或包图、状态图 实验过程 系统建模是一个开发系统抽象模型的过程，每个模型表示系统的不同方面或角度，其意味着用某种图形符号表示系 统，常见的图形符号基于 UML 。 UML 建模最主要的五个图是用例图、静态结构、序列图、状态机图和活动图。当然也包含了一些其他的例如数据库表示图，只是使用没有前面五种图常见；下面的内容根据 Java 大作业 todo-list 工程绘制： 活动图（上下文建模） 对于一个任务清单程序，它的基本功能就如下所示： 活动图.png 将这些功能使用 UML 的方法绘制成流程图，那就是活动图了。 静态结构模型（类图） 设计好了功能之后，就要根据设计的功能设计模型了；将程序中的关键概念抽象成类，并梳理之间的关系，就得到了静态结构模型： 静态结构.png 将一些概念进行泛化聚合，就可以得到上图。 行为模型 描述行为模型主要有两种图： 数据驱动建模（数据流图） UML不支持数据流图。原因是DFD关注的是系统功能而不识别系统对象。然而，因为数据驱动系统在业务中太常用了，所有 UML2.0引入了与数据流图类似的活动图。在UML中也用时序图表示系统处理序列。 事件驱动建模（状态图） 状态图表示系统状态和引起状态改变的事件。状态图不表示系统中的数据流，但可能包括在每一状态在每一状态中所执行运 算的附加信息。 对于 todo-list 程序，总结得到的状态机图可以根据展示的页面的逻辑来划分： 状态图.png 页面分为编辑页面和显示页面，再加上其后的存储进程，就成了这个工程的三个状态。 交互模型（时序图） 交互即用户交互，与用户输入输出有关；有可能是正在开发的系统与其他系统之间的或是系统各部分之间的交互。为用户交互建模主要是因为它有助于我们识别用户需求。为系统间的交互建模应将重点放在可能产生的交流问题上。为系统各部分之 间的交互建模有助于我们分析所提出的系统结构能否实现系统所需的功能及其可靠性。 交互模型在 UML 体系中主要使用两种图来表示： 用例建模：该方法主要用来为系统与外部参与者（用户或其他系统）之间的交互建模。 用例图.png 上面的就是用例图。 时序图：该方法用来为系统各部分之间的交互建模；尽管也包括一些外部因素。 顺序图.png 实验总结 通过这次实验，我理解了多视角系统建模思想和技术，掌握了基本常见的UML建模图形；通过对一个之前工程系统进行上下文、结构、行为和交互建模，更一步加深了对建模的理解。","categories":[{"name":"课业","slug":"课业","permalink":"https://shiraha.cn/categories/%E8%AF%BE%E4%B8%9A/"}],"tags":[{"name":"课内作业","slug":"课内作业","permalink":"https://shiraha.cn/tags/%E8%AF%BE%E5%86%85%E4%BD%9C%E4%B8%9A/"},{"name":"实验报告","slug":"实验报告","permalink":"https://shiraha.cn/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"软件工程","slug":"软件工程","permalink":"https://shiraha.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"UML","slug":"UML","permalink":"https://shiraha.cn/tags/UML/"}]},{"title":"华东师范大学“游族杯”全国高校程序设计网络挑战赛（2020.5）","slug":"ECNU-yoozoo-cup-2020","date":"2020-05-23T06:50:44.000Z","updated":"2020-05-23T06:50:44.000Z","comments":true,"path":"2020/ECNU-yoozoo-cup-2020/","link":"","permalink":"https://shiraha.cn/2020/ECNU-yoozoo-cup-2020/","excerpt":"","text":"——爬就爬，我自己能爬的，我最会爬了 开始之前先挂上比赛链接，题目下载链接和可能会有的官方题解的链接： 比赛链接：https://acm.ecnu.edu.cn/contest/273/ 问题集（PDF）：官方下载 或者 备份下载 官方题解：官方下载 或者 备份下载 就不说结果了，说了实在是太丢人了 GW_UNHLLRG6_JNOP_T8I7.jpg 傻逼就傻逼，下面是这次的题目： Amateur Chess Players 前面哔哔了一堆国际象棋但是结果和国际象棋没有任何关系（ 8×8的棋盘上，摆着 n 个白子，m 个黑子；白子先动：操作可以消除一条直线上的所有的子，这个直线可以不是横平竖直对角线；问谁的子先销完。 签到题。 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;using longs = long long;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n, m; string s; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++ i) cin &gt;&gt; s; cin &gt;&gt; m; for (int i = 0; i &lt; m; ++ i) cin &gt;&gt; s; if (n &lt;= m) cout &lt;&lt; &quot;Quber CC&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;Cuber QQ&quot; &lt;&lt; endl; return 0;&#125; 读错题目属实害人，第一题必然不可能是计算几何。 Binary String 这是一个交互题，给人一种既视感感觉在某年区域赛见过差不多的题目： 程序构造了一个长度 n 的二进制字符串，您可以向交互机器发起 1024 次请求，格式如下： ? &lt;binary string shorter than n&gt; ：询问这个字符串是不是程序构造的字符串的子序列，是返回 1，否返回 0；如果询问格式不正确将返回 -1 并且 WA。 ! &lt;binary string with n bits&gt; ：询问这个字符串是否是程序构造的字符串，交互机器将立刻退出并且返回评测结果。 交互程序会先输入字符串的长度 n，随后您可以进行询问，并且获得验证：切记您需要预留 1 次请求的机会用来提交答案，也就是询问最多 1023 次。n 小于 1000； 比较有趣，但是题目也不像上次那个交互题那样猜测次数提供了一个指示。 看了题解才发现原来这是所有的题目里官方难度评价最高的一个题目吗（ 首先，因为是询问子串，使用二分的方法询问 0 或者是 1 的数量是很容易想到的，因为这两个数量是零和的，所以只需要询问其中一种就可以了；之后就是二进制字符串的一种惯用的猜测方法：向一种数字种插入另一种数字；因为子序列还是遵循了原序列的顺序的，所以可以一直向一个指定的数字的左侧插入另一个数字：这个过程也可以二分的；最后总复杂度是 O(nlogn)； 具体的说，我们假设有 n 个 0，m 个 1；我们向 0 中插入 1，需要使用这种方法来测试： 首先，我们将 n 个 0 摆放在一起，这一定是一个正确的子序列； 然后，我们从左向右遍历 0：在第 1 个 0 的左侧插入 1，这个插入的 1 的数量可以在 [0, m] 中二分； 找到插入数量 x 之后，尝试在第 1-2 个 0 之间插入 1，在 [0, m-x] 的范围内二分数量； 直到处理到 m - Σx = 0 或者处理完所有的 0 之后，将剩余的未使用 1 全部补在字符串的末尾； 这样就可以写出代码了。又是一个读错了题目然后xjb做的题目 1代码 RE 了，正在调试中 事实证明这题目哪里有那么麻烦嘛== 都是读错了题目的锅（ Coronavirus Battle 一个图论题目。 有一个三维空间，其中有 n 个白细胞；病毒总会从 (-x, -y, -z) 的方向进攻：一个白细胞 (x, y, z) 可以存活，只有当存在一个白细胞 (x₀, y₀, z₀)，满足 x₀ ≤ x &amp;&amp; y₀ ≤ y &amp;&amp; z₀ ≤ z 且 x₀ &lt; x || y₀ &lt; y || z₀ &lt; z 成立的时候；如果存在这样的细胞，那么这个细胞去世，其他细胞存活；否则，所有没有保护的细胞都将去世； 如果所有的白细胞都死了，那么游戏结束；你需要输出在游戏结束前病毒攻击的轮数，并输出一个数列 a：其中 ai 表示第 i 个白细胞存活的轮数。 输入的数据是白细胞个数 n ≤ 1e5，以及种子 k1，k2：可以用给定的随机数生成器生成这些白细胞的坐标，种子和生成的白细胞位置坐标的范围是 unsigned long long 的。 Decay of Signals 给一颗 n 个节点的无向树，每一个节点上有一个权值 ai，每一条边的长度为 1；假设从节点 u 到节点 v 的最短路，这样定义一条最短路径的“值”： \\[ s = \\frac {Π_{i=1}^m a_{p_i}} {m} \\] m 是这条最短路经过的边数，\\(p_i\\)表示这些边；\\(a_{p_i}\\)表示这些边在这条路径中的终点的权值，即\\(a_u\\)没有被包含在其中；现在要求求出全树中这个 s 值最小的最短路，并且分数形式输出这个 s 值。 Even Degree Find / -type f -or -type d 所以说为什么要多此一举呢（ 给定 n 个字符串，描述了 n 个绝对路径；问在这个文件系统中存在的 *.eoj 文件的数量； 数据规模：n ≤ 1e5，绝对路径字符串的总长度不会超过 1e6 Geralt of Rivia Heat Pipes 现在有一些温室和热管，热管的作用是保证它所连接的两个温室的温差等于 1 度；现在告诉你温室和热管的布局，要求你设计一种温度设定方法，让这些温室的温度可以覆盖一个区间内所有的温度（整数）。 一共有 t 组测试数据：每一组包含温室数量 n，热管数量 m，温度区间 [a, b]，以及用来描述热管情况的 m 行，每行包括两个整数，指明热管连接的两个温室。 数据规模：N ≤ 2000，M ≤ 50000，a ≤ b ≤ n；N, M 指的是所有测试用例的 n, m 的和 Idiotic Suffix Array 首先你需要了解后缀数组——当然不了解也不是做不了： 给了一个后缀数组的代码，可以用来生成后缀数组 SA；然后告诉你一个长度 n，告诉你一个数组 k，要求构造一个长度为 n 的仅由小写字母构成的字符串，根据它构造出的后缀数组满足 SA[k - 1] == 0；此外这个字符串的所有后缀中，第 k 个后缀的字典序排列最小。 后记","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"EOJ","slug":"EOJ","permalink":"https://shiraha.cn/tags/EOJ/"}]},{"title":"厦门大学程序设计大赛月赛（5月，同步赛）","slug":"XMU-icpc-month-2020-5","date":"2020-05-17T13:16:35.000Z","updated":"2020-05-17T13:16:35.000Z","comments":true,"path":"2020/XMU-icpc-month-2020-5/","link":"","permalink":"https://shiraha.cn/2020/XMU-icpc-month-2020-5/","excerpt":"","text":"按照之前做题目的惯例，在开始之前先摆个链接： 比赛链接： https://ac.nowcoder.com/acm/contest/5759#description 官方题解： https://ac.nowcoder.com/discuss/428597?type=101&amp;order=0&amp;pos=4&amp;page=1&amp;channel=-1&amp;source_id=1_101 至于官方题解，因为不算是公开比赛，所以还没有找到；如果找到了会挂在这里的。已经找到了 啊这啊这，半个月不做算法题目了，真就什么都不会了呗== 再过几天校队还要再次排位刷人，啊这…… Z94XW8MDFSI4NBN_H9H.jpg 希望人没事== 得赶紧地把空窗期补回来了。 这次比赛一共有五个题目，但是比赛时长五个小时；从同步赛的榜单来看，除了第一的 AK 爷之外，其他的过题数量都小于 3；这至少证明了这场比赛具有一定的难度不适合萌新从空窗期恢复的性质。 补完了题感觉就没有那么难了…… 啊这，还是自己太鸡儿菜了；每个思路基本都是有道理的，只不过是真的不会写代码== 吐了吐了，希望能好起来吧（ 环鸽的CHONG 定义“好序列”指的是这个序列存在至少一个元素与这个序列的其他任何元素都不同； 给定一个长度小于 2e5 的序列，要求判断它的所有子串是否都是“好序列”。 *原题说是唯一一个元素，但是仔细思考应该还是至少一个元素。 这题整第一个直接把我给读傻了，而且作为第一题有着极高的尝试数== 所以没做出来我人就傻了（ 但是也不能说是毫无思路：一个数字一旦不能使它所在的序列的好序列，那一定是因为它在这个序列中还有一个一样的数字；所以显然需要预处理一个数字左右两端最近的相同数字的位置；接下来考虑这个左右位置的区间 [L, R]：假设这个数字的位置是 M，那么可以确定的是 [L, M] - [M, R] 一定都是好序列。 这样就可以进行分治：找到了唯一的 M，就可以确保一个端点来自 M 两侧的区间是“好序列”；接下来只需要考虑两个端点都在一侧的区间的情况：此时问题已经被 M 划分成了子问题，可以重复上述方法，直到子串长度为 1； 两种情况可以特判：若全序列不存在一个唯一的 M，又或者序列中存在连续的区间，那么这个序列一定不是符合要求的序列。这可以在扫描过程中直接判断出来。 此外，如果从两头出发向中间寻找，最坏情况就是在序列中间找到唯一值，可以证明复杂度是 O(nlogn)。 这样我们就可以写出 DFS 的分治搜索的代码了。 我的代码 根据上面的分析：首先特判，如果发现两个连续的数字直接俯冲；随后标记位置，使用 map 是 O(nlogn) 的，将每一个在区间内无重复的点作为分治点，将区间分为两个区间继续处理，直到区间大小缩为 2； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;using longs = long long;using longd = long double;using ulongs = unsigned long long;const int N = 2e5 + 5;int n, a[N], pre[N], nex[N];bool cannot = false;bool dcDFS(int ll, int rr)&#123; if (ll &gt;= rr) return true; auto ii = ll; while (ii &lt;= rr) &#123; if (pre[ii] &lt; ll &amp;&amp; nex[ii] &gt; rr) return dcDFS(ll, ii - 1) &amp;&amp; dcDFS(ii + 1, rr); ++ ii; &#125; return false;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n; map&lt;int, int&gt; mp; a[0] = 0; const int tail = n + 1; for (int i = 1; i &lt;= n; ++ i) &#123; cin &gt;&gt; a[i]; if (a[i] == a[i - 1]) cannot = true; if (mp[a[i]]) &#123; pre[i] = mp[a[i]]; nex[mp[a[i]]] = i; &#125; else pre[i] = 0; mp[a[i]] = i; nex[i] = tail; &#125; if (cannot) cout &lt;&lt; &quot;fuchong&quot; &lt;&lt; endl; else &#123; cannot = !dcDFS(1, n); cout &lt;&lt; (cannot ? &quot;fuchong&quot; : &quot;chong&quot;) &lt;&lt; endl; &#125; return 0;&#125; 虽然数字可以很大，但是总数有限，所以还是可以使用 map 日常当作稀疏数组使用 环鸽的数列 有一个长度为 n 的数列 a，以及一个无限长的递推数列 F；对于 F &gt; 2，它满足 \\(F_n = 3F_{n-1} + 2F_{n-2}\\)，此外，有\\(F_1 = 1,\\ F_3 = 3\\)；对于数列 a，要求实现下列区间操作： 对于有效区间 [l, r]，对于任意 l ≤ i ≤ r，\\(a_i\\) 加上 \\(F_{i-l+1}\\)； 对于有效区间 [l, r]，对于任意 l ≤ i ≤ r，对 \\(a_i\\) 求和并且取模； 要求对于给定的请求序列，输出所有上述第二种请求的结果。 首先，看到是区间操作，大脑第一反应是想到线段树；线段树如果加上了懒惰标记，做乘法或者修改其值，想必也是可以的吧；但是问题是这个题目加上的不是一般值，是一个数列；所以使得这个题目变得麻烦了起来，也就是所谓的“代码量多”；但是虽然这样，本质上还是一个带懒惰标记的线段树上的区间修改。 啊这，但是为什么这题公开赛下 A 的数量最少啊……虽然我也写代码写了好久，那没事了（ 首先从递推公式下手：既然是递推公式，肯定有办法写成矩阵方式；首先从给定值的两种情况入手，可以推导出 F₀ = 0；然后经过简单的推导，可以得到下面的两种矩阵表达形式： \\[ \\begin {bmatrix} F_{n+1} &amp; 2F_n \\\\\\\\ F_n &amp; 2F_{n-1} \\\\\\\\ \\end {bmatrix} = \\begin {bmatrix} F_n &amp; 2F_{n-1} \\\\\\\\ F_{n-1} &amp; 2F_{n-2} \\\\\\\\ \\end{bmatrix} \\cdot \\begin {bmatrix} 3 &amp; 2\\\\\\\\ 1 &amp; 0 \\end {bmatrix} \\] 代码里采用的是这一种形式，当然也可以采用下面这种： \\[ \\begin {bmatrix} F_{n+1} &amp; F_n \\\\\\\\ 0 &amp; 0 \\\\\\\\ \\end {bmatrix} = \\begin {bmatrix} F_n &amp; F_{n-1} \\\\\\\\ 0 &amp; 0 \\\\\\\\ \\end{bmatrix} \\cdot \\begin {bmatrix} 3 &amp; 1\\\\\\\\ 2 &amp; 0 \\end {bmatrix} \\] 啊这，这矩阵又不能正常显示，我吐了我吐了== 又得找时间修（这转义就有些离谱== 最后的代码采用的是上述第一种表达式，原因请看下面的分析——第二种也可以用只是会麻烦许多（ 啊等等，别介，这样一来，这个题目是不是不用矩阵乘法也可以？矩阵乘法的意义何在？ 1BWR9RSVN472XJIE03LP.jpg ↑ 椿姐的凝视 ↑ 啊这，这…… 这不太行——笔者写代码的时候为数不多的已提交代码都是使用了矩阵乘法，所以一定是哪里出现了一些误会；先放着不管我们继续说（ 然后首先预处理一下数列在范围内的值和前缀和，就可以开始构筑线段树部分了；懒惰标记在这里的使用方式是这样子的：首先，线段树建立两个，一个就是标准意义上的线段树，统计了每个区间节点的和，并且叶子节点是具体的数组成员；另外建立一个空的 lazy 树，用来存放一些标记。 当读取到指令需要加上一个数列的时候（假设需要加上数列的区间是 [l, r]），可以确定的是这个区间的总和会增加 \\(\\sum_{i=1}^{r-l+1} F_i\\)，每一个真正的节点加上的值可以通过和 l 的相对定位求出来；为了省事，我们直接这样操作：加上值的时候，在懒惰树上操作，当节点区间被待处理区间完整覆盖的时候，就直接在这个区间上加上这段数列的和（因为已经预处理过，所以可以快速得出），并且在懒惰节点中记录这个节点的首值； 众所周知，一般的懒惰标记的线段树的区间修改是所有区间加上同一个值——总之是进行同一个操作，然后当需要使用子节点的时候，再将这个操作应用到子节点上；但是因为本次加上的是一个数列，所以这样的操作大概是不可行的（当然，你的懒惰节点也可以是一个数组，记录每一次修改的首值下标，这样也是可以的）；但是现在就体现使用矩阵的优势了：首先，上述矩阵表达式 1 的开始的情况是矩阵 I₂（有的书上将单位矩阵记作 E）；所有的矩阵都是通过乘一个相同的变换矩阵得到的，记变换矩阵为 B，则整个矩阵序列可以看成是 {~, I₂, B, B², B³, ...}，这样即使懒惰标记节点只是记录了这个区间多次修改的矩阵和，使用一个可以容易的计算出的位置偏移（下标做差）得到 B^n，由于矩阵乘法的性质，相乘就可以得到位移过的矩阵的和； 那么如何修改子节点的值呢？因为矩阵乘法性质，懒惰节点记录的本质是偏移；再加上子区间的大小非常的好求，求出子区间的大小之后乘以偏移就可以得到目标区间的修改值； 我的代码 使用上述矩阵表达式一，写出的代码是下面这样：可能有一些问题，因为理论上更加亲民的 GNU g++ 14 在线跑出了和本地 CLion C++ 14 不一样的结果，但是一般来说不太行的 clang++ 11 却AC了； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;using longs = long long;using longd = long double;using ulongs = unsigned long long;const int inf = 0x3f3f3f3f;const longs INF = 0x3f3f3f3f3f3f3f3f;const double eps = 1e-8;const longs mod = 998244353;const int N = 1e5 + 5;template &lt;int n&gt; struct matrix&#123; longs m[n][n]; matrix() = default; longs &amp;operator()(unsigned i, unsigned j) &#123; return m[i][j]; &#125; matrix operator+(const matrix&lt;n&gt; &amp;rhs) const &#123; matrix&lt;n&gt; res; for (int i = 0; i &lt; n; ++ i) for (int j = 0; j &lt; n; ++ j) res.m[i][j] = (m[i][j] + rhs.m[i][j]) % mod; return res; &#125; matrix &amp;operator+=(const matrix&lt;n&gt; &amp;rhs) &#123; for (int i = 0; i &lt; n; ++ i) for (int j = 0; j &lt; n; ++ j) m[i][j] = (m[i][j] + rhs.m[i][j]) % mod; return *this; &#125; matrix operator-(const matrix&lt;n&gt; &amp;rhs) const &#123; matrix&lt;n&gt; res; for (int i = 0; i &lt; n; ++ i) for (int j = 0; j &lt; n; ++ j) res.m[i][j] = (m[i][j] - rhs.m[i][j] + mod) % mod; return res; &#125; matrix operator-=(const matrix&lt;n&gt; &amp;rhs) &#123; for (int i = 0; i &lt; n; ++ i) for (int j = 0; j &lt; n; ++ j) m[i][j] = (m[i][j] - rhs.m[i][j] + mod) % mod; return *this; &#125; matrix operator*(const matrix&lt;n&gt; &amp;rhs) const &#123; matrix&lt;n&gt; res; for (int i = 0; i &lt; n; ++ i) for (int j = 0; j &lt; n; ++ j) res.m[i][j] = 0; for (int i = 0; i &lt; n; ++ i) for (int j = 0; j &lt; n; ++ j) for (int k = 0; k &lt; n; ++ k) res.m[i][j] = (res.m[i][j] + m[i][k] * rhs.m[k][j] % mod) % mod; return res; &#125;&#125;;using mat = matrix&lt;2&gt;;longs a[N];mat sum[N], p[N];void preProcess()&#123; p[1](0, 0) = p[1](1, 1) = 1; p[1](0, 1) = p[1](1, 0) = 0; sum[1] = p[1]; mat xx; xx(0, 0) = 3, xx(0, 1) = 2, xx(1, 0) = 1, xx(1, 1) = 0; for (int i = 2; i &lt;= N; ++ i) &#123; p[i] = p[i - 1] * xx; sum[i] = sum[i - 1] + p[i]; &#125;&#125;namespace segTree&#123; mat tree[N &lt;&lt; 2], lazy[N &lt;&lt; 2]; void upMerge(unsigned root) &#123; tree[root] = tree[root &lt;&lt; 1u] + tree[root &lt;&lt; 1u ^ 1u]; &#125; void downSplit(unsigned root, unsigned l, unsigned r) &#123; auto mid = (l + r) &gt;&gt; 1u; lazy[root &lt;&lt; 1u] += lazy[root]; lazy[root &lt;&lt; 1u ^ 1u] += lazy[root] * p[mid + 2 - l]; tree[root &lt;&lt; 1u] += sum[mid - l + 1] * lazy[root]; tree[root &lt;&lt; 1u ^ 1u] += (sum[r - l + 1] - sum[mid - l + 1]) * lazy[root]; memset(lazy[root].m, 0, sizeof(lazy[root].m)); &#125; void build(unsigned root, unsigned l, unsigned r) &#123; memset(lazy[root].m, 0, sizeof(lazy[root].m)); tree[root] = lazy[root]; if (l == r) tree[root](0, 0) = a[l]; else &#123; auto mid = (l + r) &gt;&gt; 1u; build(root &lt;&lt; 1u, l, mid); build(root &lt;&lt; 1u ^ 1u, mid + 1, r); upMerge(root); &#125; &#125; void update(unsigned root, unsigned l, unsigned r, unsigned ll, unsigned rr) &#123; if (ll &lt;= l &amp;&amp; r &lt;= rr) &#123; lazy[root] += p[l - ll + 1]; tree[root] += sum[r - ll + 1] - sum[l - ll]; &#125; else &#123; downSplit(root, l, r); auto mid = (l + r) &gt;&gt; 1u; if (mid &gt;= ll) update(root &lt;&lt; 1u, l, mid, ll, rr); if (mid &lt; rr) update(root &lt;&lt; 1u ^ 1u, mid + 1, r, ll, rr); upMerge(root); &#125; &#125; longs query(unsigned root, unsigned l, unsigned r, unsigned ll, unsigned rr) &#123; if (ll &lt;= l &amp;&amp; r &lt;= rr) return tree[root](0, 0); downSplit(root, l, r); auto mid = (l + r) &gt;&gt; 1u; longs ans = 0; if (mid &gt;= ll) ans = (ans + query(root &lt;&lt; 1u, l, mid, ll, rr)) % mod; if (mid &lt; rr) ans = (ans + query(root &lt;&lt; 1u ^ 1u, mid + 1, r, ll, rr)) % mod; return (ans % mod + mod) % mod; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); preProcess(); int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; a[i]; segTree::build(1, 1, n); while (m --) &#123; int op, ll, rr; cin &gt;&gt; op &gt;&gt; ll &gt;&gt; rr; if (ll &gt; rr) swap(ll, rr); if (op == 1) segTree::update(1, 1, n, ll, rr); else cout &lt;&lt; segTree::query(1, 1, n, ll, rr) &lt;&lt; endl; &#125; return 0;&#125; 啊这，线代白给不可取== 果然数学题还是数学一点的好啊；我们来欣赏一下标准答案的说法： 由特征方程 \\(\\alpha^2 = 3\\alpha + 2\\) 解出特征根 $= {2} $； 使用待定系数法得到通项公式：$ F_n = {} (( {2})^n + ( {2})^n) $； 暴力测试得到 17 的二次剩余 473844410，处理两个模意义下的特征根； 所以可以用两颗线段树维护区间加等比数列、区间求和的操作；懒标记记录首项，应用到区间的时候直接更新为等比数列求和；标记的合并可以直接相加，但是要预处理两个特征根的 1~n 次方。 所以说矩阵还是不是必须的== 啊这就这（ 环鸽不会X点 本轮的签到题；下面是题面： 问一个数 n 能不能和 k 个正偶数和 k 个正奇数的和相等； 最小的正奇数是 1；最小的正偶数是 2；也就是说 k 个正奇数和 k 个正偶数的和一定大于 3k；此外，对任何一个整数加上一个偶数不会改变这个数的奇偶性，所以 n - 3k 必然应当是一个偶数，且大于等于 0； 我的代码 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;using longs = long long;using longd = long double;using ulongs = unsigned long long;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int t, n, k; cin &gt;&gt; t; while (t --) &#123; cin &gt;&gt; n &gt;&gt; k; n -= k; cout &lt;&lt; ((n &gt;= 2 * k &amp;&amp; n % 2 == 0) ? &quot;Yes&quot; : &quot;No&quot;) &lt;&lt; endl; &#125; return 0;&#125; 虽然实现的和上面分析中所说的不太一致，但是基本就是这么一回事。 小C的棋王之路 这竟然是一个板子题== 首先，有一个大小为 n 的整数数组，记每一个元素为 A[i]；你可以对这个数组进行下面的区间操作： 将 [l, r] 区间里的数字每一个都加上 k； 将 [l, r] 区间里的数字每一个都乘以 k； 将 [l, r] 区间里的数字修改为 k； 在数组的最后增加一个数字，值为 k； 除了进行这些操作，还需要在任何时候在线查询一个区间内所有数字的和；此外所有运算在模 p 意义下。 如果使用线段树，那就需要动态开点线段树了；这我不太会 == 但是这个题还可以用另一种简单粗暴的数据结构来解决，也就是这个题目的板子：珂朵莉树（老司机树，ODT）； 这显然是一个自创的数据结构，但是有点非常的显著：仅仅使用 STL 和简单的代码实现就可以达到一个不错的平均复杂度；但是缺点是这些修改必须是随机的，如果不是随机的话这个数据结构将会退化的很惨；不过参考其他博客的带佬们的说法，似乎一般出题人并不会卡掉这种做法，但是还是有可能所以需要注意； ODT，使用 STL set 实现，可以达到复杂度 O(nlog²n)，对于区间修改是一种取巧的数据结构；它使用 set 将每一个节点（区间节点）以及它们的值存储起来：当需要修改一些值的时候，就将已经有的区间拆开，修改后重新插入 set 中；如果需要修改一个区间的值的时候，也只需要将这些区间的节点取出，合并成一个区间并置相同的值，再作为新节点插入到 set 中；查找节点全程使用 lower_bound / upper_bound，所以实现起来基本就和上面的描述那样顺畅所以我超喜欢珂朵莉。 当然，听了上面的描述，你应该也很容易发现这珂朵莉树其实根本算不上是一棵树：它其实只有一层父子关系，找到对应区间的子节点使用的方法是二分查找；所以想要在这个节点后面加一个新节点也是非常轻松，只需要在 set 的尾部加入新节点就可以了。 至于初始化 ODT，只需要把所有的数字作为一个单个区间插入 set 就可以了，复杂度 O(nlogn)；啊这完全就是乱搞嘛 == 这要是没有大量的区间设置操作合并区间的话，简直就是直接暴毙的节奏啊（ 我的代码 使用 split 函数拆分节点区间，使用 assign 合并区间节点；仅有区间设置 k 的操作使用了 assign； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;using longs = long long;using longd = long double;using ulongs = unsigned long long;int n, m, p;namespace ODT&#123; template &lt;class T&gt; struct node &#123; int l, r; mutable T val; node(int l, int r, const T &amp;v) : l(l), r(r), val(v) &#123;&#125; node(int l, int r, const T &amp;&amp;v) : l(l), r(r), val(v) &#123;&#125; bool operator&lt;(const node&lt;T&gt; &amp;rhs) const &#123;return l &lt; rhs.l;&#125; &#125;; using number = longs; using iter = set&lt;node&lt;number&gt;&gt;::iterator; using func = void (*) (iter &amp;, void *); set&lt;node&lt;number&gt;&gt; odt; iter split(int x) &#123; auto it = odt.lower_bound(node&lt;number&gt;(x, 0, 0)); if (it != odt.end() &amp;&amp; it -&gt; l == x) return it; const number v = (-- it) -&gt; val; const int l = it -&gt; l, r = it -&gt; r; odt.erase(it); odt.insert(node&lt;number&gt;(l, x - 1, v)); return odt.insert(node&lt;number&gt;(x, r, v)).first; &#125; void assign(int l, int r, number v) &#123; auto rr = split(r + 1); auto ll = split(l); odt.erase(ll, rr); odt.insert(node&lt;number&gt;(l, r, v)); &#125; void run(int l, int r, func todo, void *param) &#123; auto rr = split(r + 1); auto ll = split(l); for (; ll != rr; ++ ll) todo(ll, param); &#125; func add = [](iter &amp;it, void *para) &#123; const number value = *(number*)para; it-&gt;val = (it-&gt;val + value) % p; &#125;; func mul = [](iter &amp;it, void *para) &#123; const number value = *(number*)para; it-&gt;val = (it-&gt;val * value) % p; &#125;; longs _sum = 0; func sum = [](iter &amp;it, void *para) &#123; _sum = (_sum + it-&gt;val * (it-&gt;r - it-&gt;l + 1)) % p; &#125;;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; m &gt;&gt; p; longs x, tail = n + 1; for (int i = 1; i &lt;= n; ++ i) &#123; cin &gt;&gt; x; ODT::odt.insert(ODT::node&lt;longs&gt;(i, i, x)); &#125; auto last = ODT::node&lt;longs&gt;(tail, -1, -1); ODT::odt.insert(last); while (m --) &#123; int op, l, r; longs k; cin &gt;&gt; op; switch (op) &#123; case 1: cin &gt;&gt; l &gt;&gt; r &gt;&gt; k; ODT::run(l, r, ODT::add, &amp;k); break; case 2: cin &gt;&gt; l &gt;&gt; r &gt;&gt; k; ODT::run(l, r, ODT::mul, &amp;k); break; case 3: cin &gt;&gt; l &gt;&gt; r &gt;&gt; k; ODT::assign(l, r, k); break; case 4: &#123; cin &gt;&gt; k; auto it = ODT::odt.lower_bound(last); ODT::odt.erase(it); ODT::odt.insert(ODT::node&lt;longs&gt;(tail, tail, k)); last = ODT::node&lt;longs&gt;(++ tail, -1, -1); ODT::odt.insert(last); break; &#125; case 5: cin &gt;&gt; l &gt;&gt; r; ODT::_sum = 0; ODT::run(l, r, ODT::sum, &amp;k); cout &lt;&lt; ODT::_sum &lt;&lt; endl; break; default: break; &#125; &#125; return 0;&#125; 特别注意：当switch语句中需要新建变量或者特别长的时候，要使用花括号包覆； 兰德索尔的瞭望塔 一个计算几何的题目。 给定了一个二维坐标系，已知原点和 x 坐标轴上的一个确定点；此外，还给了第一象限中的 n 个点； 现要求你从 n 个点中选出一些点，这些点中的每一个点和 原点 - 确定点 构成三角形，要求形成的三角形是严格的互相嵌套——每个三角形和其他三角形除了 原点 - 确定点 共有之外没有其他任何的公共边或者交点；问最多可以在给定的点集中选出多少点。 保证给出的第一象限的点不重复（ 在这之前：这个题目和之前做过的“汉诺塔拼盘”，“看星星”（只记得大概的题目名字了）很像——包含关系的成立取决于两个维度，需要同时满足才可以包含，寻找包含关系的最大值。 这种题目满嘴跑火车还是不可取，所以要有图；把题面里给的样例的一张图搬过来： 999991351_1589784561169_30097379256A480B09E6D5A8DF2B6B26.png 因为是共有边 OA，所以如果 △OCA 包含了 △OBA，那么一定有 ∠BOA &lt; ∠COA 和 ∠BAO &lt; ∠CAO 同时成立；如果用斜率来表示，那就是 |k(OC)| &gt; |k(OB)| 和 |k(AC)| &gt; |k(AB)| 同时成立。这两个三角形就在图中可以轻松的看出来，对于一般的两个这样的三角形也一定是这样吧。 一种最简单的方法就是：因为斜率具有上述的关系，所以可以对于所有在第一象限内的点 X，分别按照 k(OX) 和 k(AX) 进行排序，并对排序得到的两个序列寻找最长公共子序列——显然，这个子序列的长度就是答案；当然，实现的时候也可以只排序一次，并再增长这个序列的时候判定另一个斜率是否符合标准。 当然，你也可以像标准答案那样，使用权值线段树来维护以满足要求；具体做法如下： 所有点按照到原点的极角排序，将另一个角的值排序后离散化 建立维护最大值的权值线段树，每一个节点维护一个区间内的节点的最大答案 更新答案时：查找区间节点中的最大值并且单点修改 需要注意极角相同时的情况；因为感觉太过麻烦这一回就不写这种做法的代码了，请参考官方题解。 我的代码 根据斜率寻找最长公共子序列：按照 OX 斜率排序后的向量，如果 AX 的斜率更加有优势就更新；直到所有的向量都扫描完之后，整个序列的大小就是答案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;using longs = long long;using longd = long double;using ulongs = unsigned long long;namespace Geo&#123; using number = int; struct point &#123; number x, y; point() = default; point(number x, number y) : x(x), y(y) &#123;&#125; point operator+(const point &amp;rhs) const &#123; return &#123;x + rhs.x, y + rhs.y&#125;; &#125; point operator-(const point &amp;rhs) const &#123; return &#123;x - rhs.x, y - rhs.y&#125;; &#125; number operator*(const point &amp;rhs) const &#123; return x * rhs.x + y * rhs.y; &#125; point operator*(const number rhs) const &#123; return &#123;rhs * x, rhs * y&#125;; &#125; point operator/(const number rhs) const &#123; return &#123;x / rhs, y / rhs&#125;; &#125; point &amp;operator+=(const point &amp;rhs) &#123; x += rhs.x; y += rhs.y; return *this; &#125; point &amp;operator-=(const point &amp;rhs) &#123; x -= rhs.x; y -= rhs.y; return *this; &#125; point &amp;operator*=(const number rhs) &#123; x *= rhs; y *= rhs; return *this; &#125; point &amp;operator/=(const number rhs) &#123; x /= rhs; y /= rhs; return *this; &#125; bool operator==(const point &amp;rhs) const &#123; return x == rhs.x &amp;&amp; y == rhs.y; &#125; bool operator!=(const point &amp;rhs) const &#123; return !(rhs == *this); &#125; number dot(const point &amp;rhs) const &#123; return x * rhs.x + y * rhs.y; &#125; number cross(const point &amp;rhs) const &#123; return rhs.y * x - rhs.x * y; &#125; number length() const &#123; return sqrt(dot(*this)); &#125; number distance(const point &amp;b) const &#123; return (*this - b).length(); &#125; number distance(const point &amp;ls, const point &amp;rs) const &#123; return fabs((ls - *this).cross(rs - *this)) / ls.distance(rs); &#125; point normal() const &#123; return (x || y) ? *this / length() : point(0, 0); &#125; number angle() const &#123; return atan2(y, x); &#125; point rotate(number a) const &#123; number c = cos(a), s = sin(a); return &#123;c * x - s * y, s * x + c * y&#125;; &#125; point perpendicular() const &#123; return &#123;-y, x&#125;; &#125; point symmetry() const &#123; return &#123;-x, -y&#125;; &#125; bool operator&lt;(const point &amp;rhs) const &#123; auto ll = 1ll * y * rhs.x; auto rr = 1ll * x * rhs.y; return ll &lt; rr; &#125; bool operator&gt;(const point &amp;rhs) const &#123; auto ll = 1ll * y * rhs.x; auto rr = 1ll * x * rhs.y; return ll &gt; rr; &#125; &#125;;&#125;const int N = 1e5 + 5;int n, m, upto, dp[N];Geo::point p[N], v[N];int binary(const Geo::point &amp;now)&#123; int ll = 1, rr = upto, res = 0; auto ii = Geo::point(m - now.x, -now.y); while (ll &lt;= rr) &#123; int mid = ll + rr &gt;&gt; 1; if (v[mid] &lt; ii) res = mid, ll = mid + 1; else rr = mid - 1; &#125; return res;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); while (cin &gt;&gt; n &gt;&gt; m) &#123; auto pp = Geo::point(m, 0); for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; p[i].x &gt;&gt; p[i].y; sort(p + 1, p + 1 + n, greater&lt;Geo::point&gt;()); upto = 0; for (int i = 1; i &lt;= n; ++ i) &#123; dp[i] = binary(p[i]) + 1; v[dp[i]] = pp - p[i]; upto = max(upto, dp[i]); &#125; cout &lt;&lt; upto &lt;&lt; endl; &#125; return 0;&#125; binary 函数用来找到斜率可以更新的位置；但是最终 dp 数组内的向量未必可以指示实际选出的点，这点还请多加注意。 后记 虽然做的时候很痛苦，但是补题的时候却没有什么没学过的知识点…… 这不太行== 我已经不会做题力（ 还有一大堆没有做的题目等着我去补，呜呼！","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"https://shiraha.cn/tags/Nowcoder/"}]},{"title":"软件工程：第 1 次上机实验","slug":"class-software-engineering-experiment-1","date":"2020-05-17T06:40:30.000Z","updated":"2020-05-17T06:40:30.000Z","comments":true,"path":"2020/class-software-engineering-experiment-1/","link":"","permalink":"https://shiraha.cn/2020/class-software-engineering-experiment-1/","excerpt":"","text":"本次实验的要求如下： 实验名称： 重构实验 实验目的： 理解重构在软件开发中的作用 熟悉常见的代码环味道和重构方法 实验内容和要求： 阅读：Martin Fowler 《重构-改善既有代码的设计》 掌握你认为最常见的8种代码坏味道及其重构方法 从你过去写过的代码或 Github 等开源代码库上寻找这8种坏味道，并对代码进行重构 简单的说就是总结出 8 中“坏味道”，并且给出样例； 重复代码 它可能出现在下面的三种情况中；每种情况有对应的改正方法： 同一个类的两个函数含有相同的表达式 建立一个新方法，将重复的代码提取出来，再在重复代码的地方调用这个新方法； 同一个互为兄弟的子类内出现 建立一个新方法提取重复代码，并且将这个新方法放到这两个类的超类中；如果代码只是相似而不完全相同，可以提取成方法，并构建成模板供调用；如果代码完成了相同的功能，但是实现方法不同，则选出较优的那个提取成方法，以供调用。 两个毫不相关的类 创建一个新类，以保存两者共有的代码提取出的方法； 下面的样例说明了在同一个类中的重复代码的重构情况 实例 下面，在某类中有两个需要随机数的地方，需要使用 C++ 随机数生成器得到随机数： 123456789101112131415161718192021void methodA() &#123; // ... uniform_real_distribution&lt;double&gt; dm (1, 65536); random_device rd; default_random_engine rm(rd()); auto seed = dm(rm); // ...&#125;void methodB() &#123; // ... uniform_real_distribution&lt;double&gt; dm (0, 255); random_device rd; default_random_engine rm(rd()); auto r = dm(rm); auto g = dm(rm); auto b = dm(rm); // ...&#125; C++ 随机数生成器初始化是一个非常麻烦的工作，但是却是一个确定的事情；可以将这些代码提取到一个公共的随机数生成器生成器函数中，用函数生成符合要求的随机数生成器，使得代码更加清晰； 1234567891011121314151617181920212223242526auto createRandomMachine(int lb, int rb)&#123; if (lb &gt; rb) swap(lb, rb); uniform_real_distribution&lt;double&gt; dm (lb, rb); random_device rd; default_random_engine rm(rd()); return [=]()mutable&#123;return dm(rm);&#125;;&#125;void methodA() &#123; // ... auto random = createRandomMachine(1, 65536); auto seed = random(); // ...&#125;void methodB() &#123; // ... auto random = createRandomMachine(0, 255); auto r = random(); auto g = random(); auto b = random(); // ...&#125; 这样就完成了重构；代码更加的简洁，而且random()的调用方式也符合 C 语言的使用习惯。 超长函数 每当需要使用注释说明函数每一步在干什么时，就将需要说明的步骤写进独立函数中，并以其用途命名；根据不同情况，可能需要做到下面的不同的程度： 一般来说，只需要将代码按照步骤提取成方法就可以了； 如果有大量参数和临时变量，考虑使用查询替换临时变量；查询时，构造参数对象或保留整个对象可以简化查询函数的参数列表； 若临时变量/参数仍然很多，可以使用方法对象来代替方法——将方法构成一个新类，保有计算需要的信息，提供一个方法接口来完成函数的工作（比如operator()）； 对于存在条件表达式和循环的情况，可以分解条件表达式：将循环体、或者时不同的分支提取成为不同的函数；主函数只控制分支流向，每个分支的具体工作交给独立函数完成。 实例 比如一个需要创建子进程的函数，使用fork函数的返回值来判断当前所处进程： 1234567891011121314151617int forkNewProcess()&#123; // ...pre-process pid_t son = fork(); if (son) &#123; auto ppid = getppid(); cout &lt;&lt; &quot;父親進程： pid = &quot; &lt;&lt; getpid() &lt;&lt; &quot; ppid = &quot; &lt;&lt; ppid &lt;&lt; endl; cout &lt;&lt; &quot;父親的兒子： pid = &quot; &lt;&lt; son &lt;&lt; endl; &#125; else &#123; auto ppid = getppid(); cout &lt;&lt; &quot;兒子進程： pid = &quot; &lt;&lt; getpid() &lt;&lt; &quot; ppid = &quot; &lt;&lt; ppid &lt;&lt; endl; cout &lt;&lt; &quot;兒子的父親： pid = &quot; &lt;&lt; ppid &lt;&lt; endl; &#125; // ...post-process&#125; 虽然分支不长，但是当不同进程需要做的事情明显不同，且包括很多行代码的时候，这样写就会非常的不优雅；根据上面提到的分解表达式方法，我们可以对上述的代码做出如下重构： 123456789101112131415161718192021void fatherProcess()&#123; auto ppid = getppid(); cout &lt;&lt; &quot;父親進程： pid = &quot; &lt;&lt; getpid() &lt;&lt; &quot; ppid = &quot; &lt;&lt; ppid &lt;&lt; endl; cout &lt;&lt; &quot;父親的兒子： pid = &quot; &lt;&lt; son &lt;&lt; endl;&#125;void sonProcess()&#123; auto ppid = getppid(); cout &lt;&lt; &quot;兒子進程： pid = &quot; &lt;&lt; getpid() &lt;&lt; &quot; ppid = &quot; &lt;&lt; ppid &lt;&lt; endl; cout &lt;&lt; &quot;兒子的父親： pid = &quot; &lt;&lt; ppid &lt;&lt; endl;&#125;int forkNewProcess()&#123; // ...pre-process pid_t son = fork(); son ? fatherProcess() : sonProcess(); // ...post-process&#125; 这样，当父子进程的工作更多，更复杂的时候，也能保证一定程度的可读性。 过大的类 若类中的实例变量过多，一般可以通过提取新类（组件）或创建子类解决；若代码较多，也可以提取共用“接口”，将类对于这些方法的使用具体到接口中； 特别地，如果这是一个 GUI 类（组件），可能要将业务数据和需要这些数据的方法放到一个处理业务的类中，从视图类中分离；视图类对于业务类实现观察者模式，仅保留视图必需的数据，并且和业务对象保持同步； 实例 在前端框架 React 的实际使用过程中，上述对于 GUI 类的描述则是一种比较常见的设计模式：即聪明组件和傻瓜组件的设计模式； 比如一个 React 组件，它的工作是从后台的 API 请求一个笑话，并且将它显示在用户的主页上；它可以这么写： 123456789101112131415161718192021222324export default class JokeTeller extends React.Component &#123; state &#x3D; &#123; joke: null &#125; render() &#123; return ( &lt;div&gt; &lt;img src&#x3D;&#123;SmileFace&#125; &#x2F;&gt; &#123;joke || &#39;loading...&#39; &#125; &lt;&#x2F;div&gt; ) &#125; componentDidMount() &#123; fetch(&#39;https:&#x2F;&#x2F;icanhazdadjoke.com&#x2F;&#39;, &#123;headers: &#123;&#39;Accept&#39;: &#39;application&#x2F;json&#39;&#125;&#125; ).then(response &#x3D;&gt; &#123; return response.json(); &#125;).then(json &#x3D;&gt; &#123; this.setState(&#123;joke: json.joke&#125;); &#125;); &#125;&#125; 因为只是将一个笑话显示在页面上，所以就算这么写也并没有什么；但是当这个组件需要显示的内容非常的复杂（即render函数很大很长），并且需要从后端获得大量数据的时候，就会得到一个长的离谱的类；但是，我们可以使用上述的重构思想对这个类进行重构： 12345678910111213141516171819202122232425262728const JokeShower &#x3D; (&#123;value&#125;) &#x3D;&gt; &#123; return ( &lt;div&gt; &lt;img src&#x3D;&#123;SmileFace&#125; &#x2F;&gt; &#123;value || &#39;loading...&#39; &#125; &lt;&#x2F;div&gt; );&#125;export default class JokerGetter extends React.Component &#123; state &#x3D; &#123; joke: null &#125; render() &#123; return &lt;JokeShower value&#x3D;&#123;this.state.joke&#125; &#x2F;&gt; &#125; componentDidMount() &#123; fetch(&#39;https:&#x2F;&#x2F;icanhazdadjoke.com&#x2F;&#39;, &#123;headers: &#123;&#39;Accept&#39;: &#39;application&#x2F;json&#39;&#125;&#125; ).then(response &#x3D;&gt; &#123; return response.json(); &#125;).then(json &#x3D;&gt; &#123; this.setState(&#123;joke: json.joke&#125;); &#125;); &#125;&#125; 这样，就将 React 组件类中的一个很长的部分——也就是渲染函数直接单立出去，避免了类既包含太多的渲染结构，也包含了大量的业务逻辑；至于观察者模式，React 框架已经帮我们做好了一切。 引入空对象 当代码中的多项操作需要检查一个对象是不是空对象（如果是空对象，则使用默认配置）的时候，可以为该类创建一个空对象的子类，或者创建一个包含默认设置的静态空对象； 使用一个具体的对象代替空对象，可以使得代码运行的更安全，避免意外情况的出现； 实例 比如下面这个函数，它接受一个可以是空的对象，并对它进行操作： 12345678910const request = () =&gt; &#123; // ... return res;&#125;const handle = (res) =&gt; &#123; res ??= &#123;&#125;; let data = res.data ?? &#123;err : &#x27;system.1001&#x27;&#125;; // ...&#125; 我们可以预先定义空对象，保证操作对象的函数永远获得的是一个存在的对象——当然这个对象可能实际上是一个没有意义的空对象； 123456789101112131415const nullObject = &#123; data : &#123; err : &#x27;system.1001&#x27; &#125;&#125;const request = () =&gt; &#123; // ... return res ?? nullObject;&#125;const handle = (res) =&gt; &#123; let data = res.data; // ...&#125; 这样可以使得代码运行更加的安全，并且也避免了大量的判空工作。 狎昵关系 当两个类过分的关注彼此的私有域，可以进行如下重构： 可以移动方法、私有域来划清界限 可以就共同部分提取成一个新的公共类 可以使用隐藏委托来传递这些信息 使用以委托取代继承的方法来回避类的继承带来的问题 下面的实例使用了移动私有域的方法回避了两个类过于亲近的关系。 实例 下面是一个 C++ 图的类型，它使用了一个边的类型： 123456789101112131415161718192021222324252627282930313233343536struct edge&#123; int u, v, w, next; edge() = default; edge(int u, int v, int w, int next) : u(u), v(v), w(w), next(next) &#123;&#125;&#125;;template &lt;int N, int M&gt; class FWS&#123; int head[N]; int tot; edge ee[M*2]; public: FWS(int n = N-1) &#123; memset(head, -1, sizeof(int)*(n+1)); tot = 0; &#125; void addedge(int u, int v, int w) &#123; ee[tot] = edge(u,v,w,head[u]); head[u] = tot ++; ee[tot] = edge(v,u,w,head[v]); head[v] = tot ++; &#125; void foreach(int st, const function&lt;bool(edge&amp;)&gt;&amp; func) &#123; for (int c = head[st]; ~c; c = ee[c].next) if (!func(ee[c])) break; &#125;&#125; edge 类的 next 域完全就是为了图 FWS 类进行遍历，不应当放在 edge 类中；所以可以对于上述的代码做出如下的重构： 123456789101112131415161718192021222324252627282930313233343536struct edge&#123; int u, v, w; edge() = default; edge(int u, int v, int w) : u(u), v(v), w(w) &#123;&#125;&#125;;template &lt;int N, int M&gt; class FWS&#123; int head[N]; int tot; edge ee[M*2]; int next[M*2]; public: FWS(int n = N-1) &#123; memset(head, -1, sizeof(int)*(n+1)); tot = 0; &#125; void addedge(int u, int v, int w) &#123; ee[tot] = edge(u,v,w,head[u]); head[u] = tot ++; ee[tot] = edge(v,u,w,head[v]); head[v] = tot ++; &#125; void foreach(int st, const function&lt;bool(edge&amp;)&gt;&amp; func) &#123; for (int c = head[st]; ~c; c = next[c]) if (!func(ee[c])) break; &#125;&#125; 这样就避免了方法FWS::foreach频繁的访问 edge 类的私有成员变量 next； 基本类型偏执 很多时候，在小任务上使用小对象是一件好事；但是这经常被人们忽视。具体的做法如下： 可以将原本单独存在的数据值替换为对象 如果想要替换的数据值是类型码而它不影响行为，可以使用类来替换类型码 如果有与类型码相关的条件表达式，可以替换为子类或状态 如果多个字段经常共同存在，则可以提取出新公共类 如果参数列表中出现了基本类型数据，尝试替换成对象 如果从数组中挑选数据，可以使用对象来替换数组 下面的实例介绍了一种常见的数据结构的重构过程； 实例 并查集是一个很常见的数据结构；最简单的并查集可以使用一个数组和简单的递归函数实现： 123456int p[N];int getFather(int x, int* p)&#123; return p[x] == x ? x : p[x] = getFather(p[x]);&#125; 如果需要使用多个并查集，这样就显得非常乱：毕竟在getFather之外的函数看来，p只不过是一个一般的数组。尽管getFather只是做了一些微小的工作，但是这并不妨碍我们将它重构成一个类： 12345678910111213141516template &lt;int N&gt; ufs&#123; int p[N]; public: ufs() &#123; for (int i = 0; i &lt; N; ++ i) p[i] = i; &#125; int getFather(int x, int* p) &#123; return p[x] == x ? x : p[x] = getFather(p[x]); &#125;&#125; 每当使用并查集的时候，只需要构建一个这个的对象，也避免了大量的未知数组创建； 参数列过长 有的函数可能会带着一个长长的参数列表，以至于调用的时候甚至还需要换行；对于这种情况，可以对这个函数进行重构；具体的重构方法包括： 如果向已有的对象发出一条请求就可以取代一个参数，那应该使用方法替代参数 可以将来自于同一个对象的参数用所属的对象进行替换 如果某些数据缺乏合理的对象归属，可以为它们创建一个参数对象 但是特殊情况下，比如明显不希望这些参数之间产生某些联系，也可以将这些数据按照单独的参数处理。 实例 比如下面的代码，它是一个函数的声明；该函数接受很多的参数，来生成一个符合参数要求的注册表文件： 123456789int createClsidRegFileDefault( const char* file_path, const char* app_name, const char* clsid_main, const char* default_icon, const char* inproc_server, const char* clasid_instance = nullptr, const char* exec_options = nullptr); 我们将它的参数列表提取成一个文件对象，那么这个函数的工作仅仅是将这个对象“文件化”，可以作为对象的成员函数（方法）；重构之后如下： 12345678910111213141516class clsidFile&#123; char* default_icon; char* app_name; char* clsid_main; char* inproc_server; char* clasid_instance; char* exec_option; public: // ...constructor // ...getter &amp; setter int createRegFile(const char* file_path);&#125; 因为文件路径并不是一个 CLSID 注册表项的固有成员，可以在调用的时候指定；故予以保留。 数据泥团 当在很多地方看到相同的三四项数据，例如两个类中相同的字段或是许多函数签名中相同的参数的时候，可以找出数据以字段形式出现的地方，将它们提取到公共类中；再缩减参数列表。 当删掉众多数据中的一项，如果有数据失去类意义，那么这意味着需要产生新对象（类）。 实例 比如下面的一些排序函数的声明： 12345678910void basketSort(int* array, unsigned length);void binaryInsertSort(int* array, unsigned length);void bubbleSort(int* array, unsigned length);void countSort(int* array, unsigned length);void heapSort(int* array, unsigned length);void insertSort(int* array, unsigned length);void mergeSort(int* array, unsigned length);void quickSort(int* array, unsigned length);void radixSort(int* array, unsigned length);void randomQuickSort(int* array, unsigned length); 因为所有的排序方法都是对于一个数组而言的；如果需要对一个数组使用不同的方法排序，可以将这些相同的参数提取到一个类中，并且将这些方法移动成为方法；具体重构方法如下： 1234567891011121314151617181920212223class Sorter&#123; int* array; unsigned length; public: // ...constructor // ...getter &amp; setter Sorter&amp; bind(int* array, unsigned length); void basketSort(); void binaryInsertSort(); void bubbleSort(); void countSort(); void heapSort(); void insertSort(); void mergeSort(); void quickSort(); void radixSort(); void randomQuickSort();&#125; 这样就可以将一个数组作为任务对象化，之后对这个任务对象使用不同的排序方法；最后使用 getter 获得排序的结果（当然，这里是直接在绑定的数组上进行操作）。 体会 很多代码都可以采用更好的设计模式、重构策略进行重构；但是策略也不是万金油：很多时候采用较长/较短的类，使用参数列表还是参数对象，更多是取决于项目属性，数据意义，而不是所谓的策略；","categories":[{"name":"课业","slug":"课业","permalink":"https://shiraha.cn/categories/%E8%AF%BE%E4%B8%9A/"}],"tags":[{"name":"课内作业","slug":"课内作业","permalink":"https://shiraha.cn/tags/%E8%AF%BE%E5%86%85%E4%BD%9C%E4%B8%9A/"},{"name":"实验报告","slug":"实验报告","permalink":"https://shiraha.cn/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"软件工程","slug":"软件工程","permalink":"https://shiraha.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"操作系统原理：第 1 次上机实验报告","slug":"class-FoDOS-experiment-1","date":"2020-05-12T16:46:07.000Z","updated":"2020-05-12T16:46:07.000Z","comments":true,"path":"2020/class-FoDOS-experiment-1/","link":"","permalink":"https://shiraha.cn/2020/class-FoDOS-experiment-1/","excerpt":"","text":"操作系统原理的上机实验的报告一共有四个，其他的报告的地址是： 第一次：https://shiraha.cn/2020/class-FoDOS-experiment-1/ 第二次：https://shiraha.cn/2020/class-FoDOS-experiment-2/ 第三次：https://shiraha.cn/2020/class-FoDOS-experiment-3/ 第四次：https://shiraha.cn/2020/class-FoDOS-experiment-4/ Front-matter 本次实验的所有源代码可以在https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job?path=%2Fosnmb%2Fexp 查看到。 实验要求 本次上机实验的实验要求如下： ##### 《操作系统原理》第一次上机实验 一、实验目的 理解操作系统生成的概念和过程； 理解操作系统两类用户界面（操作界面，系统调用）概念； 二、实验内容 在 Ubuntu 或其他 Linux 平台环境下裁剪和编译 Linux 内核，并启用新的内核。 在 Ubuntu 或其他 Linux 平台为 Linux 内核增加 1-3 个新 的系统调用，并启用新的内核，编写一个应用程序测试新增加的系 统调用是否能正确工作。 在 Windows 环境下，编写一个批处理程序（算命大 师.bat），程序运行后，输入：出生年月日（例如 2000-07-31）。系 统输出相应的属相和星座，例如：你属兔， 狮子座。要求：输入进 行合法性检查，能循环接收用户的输入，直到输入 q 或 Q 就退出。 要求一、二在上机前自己做过了，本次实验报告只简述实验过程和贴图。要求三完成了简单的 Bat 版本和 Powershell 的复杂版本。 实验内容 在 Ubuntu 或其他 Linux 平台环境下裁剪和编译 Linux 内核，并启用新的内核。 在 Ubuntu 或其他 Linux 平台为 Linux 内核增加 1-3 个新 的系统调用，并启用新的内核，编写一个应用程序测试新增加的系 统调用是否能正确工作。 在 Windows 环境下，编写一个批处理程序（算命大 师.bat），程序运行后，输入：出生年月日（例如 2000-07-31）。系 统输出相应的属相和星座，例如：你属兔， 狮子座。要求：输入进 行合法性检查，能循环接收用户的输入，直到输入 q 或 Q 就退出。 第一、第二个实验的内容原文来自本博客：https://shiraha.cn/2019/Linux-FoDOS-experiment-dian/，选择的 Linux 平台是 Arch Linux。 第三个实验的内容原文来自本博客：https://shiraha.cn/2020/class-FoDOS-experiment-bat-programming/，这篇文章只包括了 Powershell 的脚本的实验过程。 实验过程 下面是对于每一个任务的原理和过程的简述：为了遵循实际实验的最佳顺序，讲述顺序为实验二、实验一、实验三（实验二的完成本身需要实验一的工作 增加系统调用 总的来说，增加最简单的系统调用主要分为 增加新函数 -&gt; 增加新声明 -&gt; 将新调用增加到系统调用注册表 三个步骤。复制一份下载的纯净内核文件，修改其中的include/uapi/asm-generic/unistd.h和include/linux/syscalls.h两个头文件来增加系统调用的函数。 进入系统调用注册表的目录arch/x86/entry/syscalls，根据要安装的操作系统位数修改其下的tbl文件，注册增加的系统调用。特别注意不应该与已经存在的系统调用的编号冲突，这点在后面增加宏的时候再次重复。 使用vim打开系统调用的实现的源文件kernel/sys.c来增加刚才增加的函数的实现。如果要增加的是在内核缓冲区打印消息这种最简单的系统调用，则它可以是下面这样： 123456asmlinkage void sys_shirohashow(void)&#123; printk(&quot;Shiroha do your best!&quot;); printk(&quot;\\n@Edit by Shiroha on 2019-11-15.&quot;); return 0;&#125; 这样，我们就增加了一个系统调用函数sys_shirohashow的实现。完成之后还要在include/uapi/asm-generic/unistd.h增加宏。这个系统调用的含义是在内核缓冲区（用户程序不可以实现的功能）打印一条消息，需要使用dmesg -c命令清除所有缓冲区日志来查看。 dmesg命令主要有下面三个用途： 列出所有检测到的硬件 输出指定行数的日志 清空dmesg缓冲区日志 这里主要就是使用了第三个功能，用来检查printk的输出结果。 此外，上述函数体的修饰符asmlinkage宏确保了这个函数使用堆栈传递参数；所有的系统调用函数都应该使用这个进行修饰。 添加完实现之后还需要在unistd.h文件中增加这个函数的声明。这个文件在 Arch 中的位置是include/uapi/asm-generic/unistd.h；我们使用 Vim 打开它并在末尾增加： 12#define __NR_shirohashow 765__SYSCALL(__NR_shirohashow,sys_shirohashow) 765 是这个系统调用的编号，选取它的原因是因为 346/283 被其他系统调用占用了而它没有。需要确认一个系统调用编号是否已经被占用，可以打开系统调用注册表进行确认（比如syscall_64.tbl，可以使用find指令找到这个文件所在目录）。 还有一处需要增加声明的地方是include/linux/syscalls.h；打开这个文件并且增加标准的 C 函数声明： 1asmlinkage void sys_shirohashow(void); 这个文件应该有注释表明了这个函数实现所在的位置，建议遵循规则增加到注释kernel/sys.c的区域。 将修改过的内核和纯净内核使用diff -Naur生成差异补丁，再使用patch命令应用到纯净内核上。使用make -j6进行多线程编译。当然你也可以直接在修改的内核上直接编译，patch 一次纯属娱乐，没太多实际意义。当然也可以作为对于patch指令的熟悉。 编译成功后执行安装，并将必要的文件复制到特定的地方之后更新grub的引导信息，就完成了内核的应用。应用新内核将会在下一个任务的实验过程中较为详细的介绍。 应用新内核之后，在运行新内核的操作系统上写C程序，调用增加的系统调用，就可以看到我们在内核中编写的程序可以成功运行了。随后通过一些方法（对于printk，就是使用dmesg -c查看内核缓冲区）验证实验结果。对于上述步骤增加的系统调用，提供一个示例 C 程序用于测试： 123456789101112#include &lt;stdio.h&gt;#include &lt;sys/reg.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/user.h&gt;#include &lt;sys/types.h&gt;int main()&#123; syscall(765); return 0;&#125; 编译后执行，应该就可以在内核缓冲区中看到输出的鼓励话语了。 编译内核 实验背景：使用 Hyper-V （第二代） 虚拟机平台，安装 Arch Linux。已经下载好了对应版本的 Linux 官方的纯净内核源代码文件。 从官网上下载的内核已经提供了编译的配置文件，甚至还提供了一个比较图形化的menuconfig页面，提供了较为可视化的 .config 文件的生成方法。因为我们只是在一般的 PC 上安装新 Linux 内核，所以不需要进行特别的裁剪和配置，使用缺省配置就好： 1zcat /proc/config.gz &gt; .config 复制得到 .config 文件之后还建议修改文件中的CONFIG_LOCALVERSION的值，避免将要编译的内核文件覆盖当前内核文件。生成了 config 文件之后就可以使用make -jx开始多线程编译了。建议 x 取值和计算机所持有的物理核心数相同以获得最大编译速度。 安装新编译生成的新内核的步骤可以简单归纳为：安装内核模块 -&gt; 复制内核文件 -&gt; 制作initramfs镜像 -&gt; 复制System.map -&gt; 生成新的启动引导。 安装内核模块可以使用下面的命令： 1sudo make modules_install 这条命令会将编译好的模块安装到主目录 /lib/modules 下。这样，会使得这些模块独立于虚拟机原有内核的模块。 复制内核文件可以使用下面的命令： 12345# 对于32位(i686)内核：sudo cp -v arch/x86/boot/bzImage /boot/vmlinuz-linux53# 对于64位(x86_64)内核：sudo cp -v arch/x86_64/boot/bzImage /boot/vmlinuz-linux53 将内核编译完成生成的bzImage（较大的压缩的内核映像，使用gzip压缩）文件复制到/boot目录下。 制作initramfs（初始内存盘）镜像可以通过复制并且修改mkinitcpio（一个创建initramfs的脚本）preset，这样就可以通过官方内核一样的方式生成自定义内核的initramfs镜像。复制之后需要使用vim修改这个文件。 12sudo cp /etc/mkinitcpio.d/linux.preset /etc/mkinitcpio.d/linux53.presetsudo vi /etc/mkinitcpio.d/linux53.preset 打开linux53.preset文件之后，修改部分字段使得它与新的自定义内核所匹配。需要修改的字段如下： 12345# /etc/mkinitcpio.d/linux53.presetALL_kver=&quot;/boot/vmlinuz-linux53&quot;default_image=&quot;/boot/initramfs-linux53.img&quot;fallback_image=&quot;/boot/initramfs-linux53-fallback.img&quot; 修改并保存之后执行sudo mkinitcpio -p linux53就可以使用官方内核生成的方式生成自定义内核的initramfs镜像。 复制System.map的步骤可能不是必须的。如果虚拟机的/boot挂载到的分区的文件系统是ext4格式。就需要将解压目录下的System.map文件复制到/boot中，并且创建/boot/System.map，将新建的System.map软链接到复制到其中的System.map中。需要执行的命令如下： 123sudo touch /boot/System.mapsudo cp System.map /boot/System.map-MyKernelsudo ln -sf /boot/System.map-Mykernel /boot/System.map 但是由于本次使用的虚拟机的 boot 分区挂载的分区是vfat文件系统的，无需也不必创建软链接；所以本次上机实验中这一步实际并没有去做。 最后需要更新更新 grub 引导的配置信息。在安装了 grub 之后，使用命令grub-mkconfig -o /boot/grub/grub.cfg可以生成grub默认的配置信息。它会自动地将刚添加的内核增加到启动配置中。在Ubuntu这种系统中，这个命令被包装成了update-grub或其他形式。因为本次实验使用的是 Arch 发行版，所以需要完整的命令。 最后使用 reboot 指令重启虚拟机，通过安装的 screenfetch 工具来获取当前的系统信息，就可以发现系统的内核信息已经更新了，实验完成。在 Arch 中，需要使用系统默认的包管理工具 pacman 安装 screenfetch。 脚本编写 分析实验要求，绘制程序执行流程图： 流程图 接下来就是使用一些具体的脚本语言实现这个设计了。 对于 Powershell 脚本，可以使用的“库”有很多，实现也就可以更加的花哨一些。单就读取用户输入方面们就有很多的方案可供选择：可以使用Powershell原生的Read-Host，也可以使用框架提供的GUI窗口；甚至还可以使用 Visual Basic 的窗口。 得益于 Powershell 脚本功能的强大，我们可以定义一个函数完成对于日期合法性的判断。最后根据用户输入的日期进行一些处理，得到输出的字符串即可。为了节约篇幅，这里省略了一些预先声明的，和处理日期生成输出字符串相关的一些变量的初始化（以省略号代替）。使用框架提供的输入窗口获取用户输入的源代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697Add-Type -AssemblyName System.Windows.FormsAdd-Type -AssemblyName System.Drawing[int[]] $days = 29,31,28,31,30,31,30,31,31,30,31,30,31$dayIsIllegal = &quot;The days you input is illegal. try again&quot;[string[]] $months = ...[string[]] $iiyokoiyo = @(...)function isLunar ([int] $y) &#123; if($y % 4) &#123;return &#x27;False&#x27;&#125; else &#123;if($y % 400) &#123;return &#x27;True&#x27;&#125; else &#123;if($y % 100) &#123;return &#x27;False&#x27;&#125; else &#123;return &#x27;True&#x27;&#125;&#125;&#125;&#125;while(1)&#123; $form = New-Object System.Windows.Forms.Form $form.Text = &#x27;Birthday input form&#x27; $form.Size = New-Object System.Drawing.Size(300,200) $form.StartPosition = &#x27;CenterScreen&#x27; $okButton = New-Object System.Windows.Forms.Button $okButton.Location = New-Object System.Drawing.Point(65,120) $okButton.Size = New-Object System.Drawing.Size(75,23) $okButton.Text = &#x27;OK&#x27; $okButton.DialogResult = [System.Windows.Forms.DialogResult]::OK $form.AcceptButton = $okButton $form.Controls.Add($okButton) $cancelButton = New-Object System.Windows.Forms.Button $cancelButton.Location = New-Object System.Drawing.Point(160,120) $cancelButton.Size = New-Object System.Drawing.Size(75,23) $cancelButton.Text = &#x27;Cancel&#x27; $cancelButton.DialogResult = [System.Windows.Forms.DialogResult]::Cancel $form.CancelButton = $cancelButton $form.Controls.Add($cancelButton) $label = New-Object System.Windows.Forms.Label $label.Location = New-Object System.Drawing.Point(10,20) $label.Size = New-Object System.Drawing.Size(280,20) $label.Text = &#x27;Input your Birthday as YYYY-MM-DD&#x27; $form.Controls.Add($label) $textBox = New-Object System.Windows.Forms.TextBox $textBox.Location = New-Object System.Drawing.Point(10,40) $textBox.Size = New-Object System.Drawing.Size(260,20) $form.Controls.Add($textBox) $form.Topmost = $true $form.Add_Shown(&#123;$textBox.Select()&#125;) $result = $form.ShowDialog() if ($result -eq [System.Windows.Forms.DialogResult]::OK) &#123; $x = $textBox.Text &quot;Your input: &quot;+$x if($x -eq &#x27;q&#x27; -or $x -eq &#x27;Q&#x27;) &#123; &quot;Exting ...&quot; exit &#125; [int[]] $data = $x.Split(&#x27;-&#x27;) if($data.Count -ne 3) &#123; Write-Host -ForegroundColor RED &quot;The String you input is not refer to a date.&quot; continue &#125; if($data[0] -lt 1) &#123; Write-Host -ForegroundColor YELLOW &quot;You cannot born before AC. try again&quot; continue &#125; if($data[1] -lt 1 -or $data[1] -gt 12) &#123; Write-Host -ForegroundColor RED &quot;The month is illegal. try again&quot; continue &#125; $lunar = isLunar $data[0] $month = $data[1] if ($lunar -eq &#x27;True&#x27; -and $data[1] -eq 2) &#123;$month = 0&#125; if($data[2] -lt 1 -or $data[2] -gt $days[$month]) &#123; Write-Host -ForegroundColor RED $dayIsIllegal continue &#125; Write-Host -ForegroundColor YELLOW &quot;PROOVE STRAT:&quot; &quot;You born in &quot;+$months[$data[1]]+&quot;, which means &quot;+$data[1]+&quot;, and there is &quot;+$iiyokoiyo[$data[1]] &quot;You born at &quot;+$data[2]+&quot;, and there is &quot;+$iiyokoiyo[$data[2]] Write-Host -ForegroundColor GREEN &quot;Q.E.D. You are HonMono No Yaju Senpai ! &quot; pause &#125;&#125; 使用原生的Read-Host获取用户输入也是一种选择；下面是使用Read-Host获得用户输入的部分代码（和上面代码不同的部分）： 123456789while(1)&#123; $x = Read-Host &quot;Please input your birthday as YYYY-MM-DD &quot; &quot;Your input: &quot;+$x if($x -eq &quot;&quot;) &#123;&quot;You input nothing, try again.&quot;&#125; ... ... pause&#125; 上述代码如果对于 Powershell 不甚了解的话则难以理解其中的一些部分，这是因为 Powershell 基于 .NET 框架，提供了很多 Windows 的原生接口。如果是相对低级的 bat 批处理程序，代码就会更加的简洁易懂。下面的代码是使用 bat 脚本语法书写的“算命大师”。和上面的 ps1 脚本不同，仅执行任务要求的星座、属性计算（使用分支语句实现），并且没有复杂的日期判断： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@echo offtitle 算命帶師:scanfset /p input=輸入出生日期（按照YYYYMMDD格式）set &quot;year=%input:~0,4%&quot;set &quot;md=%input:~4,4%&quot;set /a mod=%year%%%12set hint=您輸入的日期格式不太正確，請重試if %input% EQU &quot;Q&quot; exitif %input% EQU &quot;q&quot; exitif %md% LEQ 0099 (echo %hint% goto scanf)if %md% GEQ 0132 (if %md% LEQ 0200 (echo %hint%goto scanf) )if %md% GEQ 0229 (if %md% LEQ 0300 (echo %hint%goto scanf) )if %md% GEQ 0332 (if %md% LEQ 0400 (echo %hint%goto scanf) )if %md% GEQ 0431 (if %md% LEQ 0500 (echo %hint%goto scanf) )if %md% GEQ 0532 (if %md% LEQ 0600 (echo %hint%goto scanf) )if %md% GEQ 0631 (if %md% LEQ 0700 (echo %hint%goto scanf) )if %md% GEQ 0732 (if %md% LEQ 0800 (echo %hint%goto scanf) )if %md% GEQ 0832 (if %md% LEQ 0900 (echo %hint%goto scanf) )if %md% GEQ 0931 (if %md% LEQ 1000 (echo %hint%goto scanf) )if %md% GEQ 1032 (if %md% LEQ 1100 (echo %hint%goto scanf) )if %md% GEQ 1131 (if %md% LEQ 1200 (echo %hint%goto scanf) )if %md% GEQ 1232 (echo %hint%goto scanf)if %mod% EQU 0 echo 你属猴if %mod% EQU 1 echo 你属鸡if %mod% EQU 2 echo 你属狗if %mod% EQU 3 echo 你属猪if %mod% EQU 4 echo 你属鼠if %mod% EQU 5 echo 你属牛if %mod% EQU 6 echo 你属虎if %mod% EQU 7 echo 你属兔if %mod% EQU 8 echo 你属龙if %mod% EQU 9 echo 你属蛇if %mod% EQU 10 echo 你属马if %mod% EQU 11 echo 你属羊echo 而且是if &quot;%md%&quot; LEQ &quot;0119&quot; echo 魔蝎座if &quot;%md%&quot; GEQ &quot;0120&quot; if &quot;%md%&quot; LEQ &quot;0218&quot; echo 水瓶座if &quot;%md%&quot; GEQ &quot;0219&quot; if &quot;%md%&quot; LEQ &quot;0320&quot; echo 双鱼座if &quot;%md%&quot; GEQ &quot;0321&quot; if &quot;%md%&quot; LEQ &quot;0419&quot; echo 白羊座if &quot;%md%&quot; GEQ &quot;0420&quot; if &quot;%md%&quot; LEQ &quot;0520&quot; echo 金牛座if &quot;%md%&quot; GEQ &quot;0521&quot; if &quot;%md%&quot; LEQ &quot;0621&quot; echo 双子座if &quot;%md%&quot; GEQ &quot;0622&quot; if &quot;%md%&quot; LEQ &quot;0722&quot; echo 巨蟹座if &quot;%md%&quot; GEQ &quot;0723&quot; if &quot;%md%&quot; LEQ &quot;0822&quot; echo 狮子座if &quot;%md%&quot; GEQ &quot;0823&quot; if &quot;%md%&quot; LEQ &quot;0922&quot; echo 处女座if &quot;%md%&quot; GEQ &quot;0923&quot; if &quot;%md%&quot; LEQ &quot;1023&quot; echo 天秤座if &quot;%md%&quot; GEQ &quot;1024&quot; if &quot;%md%&quot; LEQ &quot;1122&quot; echo 天蝎座if &quot;%md%&quot; GEQ &quot;1123&quot; if &quot;%md%&quot; LEQ &quot;1222&quot; echo 射手座if &quot;%md%&quot; GEQ &quot;0321&quot; if &quot;%md%&quot; LEQ &quot;0419&quot; echo 白羊座if &quot;%md%&quot; GEQ &quot;1222&quot; echo 魔蝎座goto scanf bat可以取出字符串的一部分为变量赋值，然后再对变量的值进行判断。运行之后应该就可以看到结果了。 实验结果 这里是任务完成后的截图或其他证明。 任务一：增加系统调用 执行实验过程中的实例代码，使用dmesg -c命令可以获得以下输出： 屏幕截图_61_.jpg 可以看到已经在内核缓冲区输出了系统调用中的字符串了。 任务二：安装新内核 下图是安装新内核之后使用screenfetch命令看到的输出： 屏幕截图_33_.jpg 内核版本已经由默认的 5.3.4 变成了 5.3.10，说明新内核已经成功使用了。 任务三：脚本编程 使用Read-Host的 Powershell 脚本： __OWFP_BLXG_A2FQFD_I3ZE.jpg 使用 .NET 框架提供窗口的 Powershell 脚本： 1_3_1.png 输入内容后会得到和第一张图一样的输出。需要特别注意的是：一般的家用版本的 Windows 10 自带的 Powershell 是不允许直接加载ps1脚本的，需要先行修改运行策略。修改的脚本如下： 1Set-ExecutionPolicy -Scope CurrentUser RemoteSigned 最后是 BAT 批处理脚本“算命大师”的运行结果： 1_3_0.png 可以看到基本功能已经实现并且正常工作。 体会 通过这次实验，我熟悉了Linux内核的应用过程，对Linux命令的理解更进一步；更加生动的理解了系统调用的概念以及Linux操作系统从POST开始之后的启动过程；熟悉了 Powershell 脚本编程，以及基于这项技术的简单开发和部分 .NET API 的使用； 对于受众较小的 Arch Linux 操作系统，比起在网络上漫无目的的查找论坛、博客，不如认真研读官方文档的 trouble-shooting 以及对一些问题可能原因的分析和解释。不仅可以对解决问题带来更加精准的帮助，还可以拓宽我们看待问题的视野。","categories":[{"name":"课业","slug":"课业","permalink":"https://shiraha.cn/categories/%E8%AF%BE%E4%B8%9A/"},{"name":"操作系统","slug":"操作系统","permalink":"https://shiraha.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Windows","slug":"操作系统/Windows","permalink":"https://shiraha.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows/"},{"name":"Linux","slug":"操作系统/Linux","permalink":"https://shiraha.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://shiraha.cn/tags/Windows/"},{"name":"操作系统","slug":"操作系统","permalink":"https://shiraha.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"课内作业","slug":"课内作业","permalink":"https://shiraha.cn/tags/%E8%AF%BE%E5%86%85%E4%BD%9C%E4%B8%9A/"},{"name":"实验报告","slug":"实验报告","permalink":"https://shiraha.cn/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"Linux","slug":"Linux","permalink":"https://shiraha.cn/tags/Linux/"}]},{"title":"操作系统原理：第 3 次上机实验报告","slug":"class-FoDOS-experiment-3","date":"2020-05-12T06:34:10.000Z","updated":"2020-05-12T06:34:10.000Z","comments":true,"path":"2020/class-FoDOS-experiment-3/","link":"","permalink":"https://shiraha.cn/2020/class-FoDOS-experiment-3/","excerpt":"","text":"操作系统原理的上机实验的报告一共有四个，其他的报告的地址是： 第一次：https://shiraha.cn/2020/class-FoDOS-experiment-1/ 第二次：https://shiraha.cn/2020/class-FoDOS-experiment-2/ 第三次：https://shiraha.cn/2020/class-FoDOS-experiment-3/ 第四次：https://shiraha.cn/2020/class-FoDOS-experiment-4/ Front-matter 本次实验的所有源代码可以在https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job?path=%2Fosnmb%2Fexp 查看到。 实验要求 本次上机实验的实验要求如下： ##### 《操作系统原理》第三次上机实验 一、实验目的 理解线程/进程的通信机制和编程； 理解线程/进程的死锁概念和如何解决死锁； 二、实验内容 在 Ubuntu 或 Fedora 环境创建一对父子进程，使用共享内存的方式实现进程间的通信。父进程提供数据（1-100，递增），子进程读出来并显示 （考虑信号通信机制）在 Ubuntu 或 Fedora 环境创建父子 2 个进程 A，B。进程 A 不断获取用户从键盘输入的字符串或整数，通过信号机制传给进程 B。如果输入的是字符串，进程 B 将其打印出来；如果输入的是整数，进程 B 将其累加起来，并输出该数和累加和。当累加和大于 100 时结束子进程，子进程输出“My work done！”后结束，然后父进程也结束。 在 windows 环境使用创建一对父子进程，使用管道（pipe）的方式实现进程间的通信。父进程提供数据（1-100，递增），子进程读出来并显示。 （考虑匿名管道通信）在 windows 环境下创建将 CMD 控制台程序封装为标准的 windows 窗口程序。 在 windows 环境下，利用高级语言编程环境（限定为 VS 环境或 VC 环境或QT）调用 CreateThread 函数哲学家就餐问题的演示。要求： 提供死锁的解法和非死锁的解法； 有图形界面直观显示哲学家取筷子，吃饭，放筷子，思考等状态。 为增强结果的随机性，各个状态之间的维持时间采用随机时间，例如100ms-500ms 之间。 在上述任务中： [1,3,4]中任意 1 题和第2,5 题，共计 3 道题。 我选择了 1、2、5 三个题目。 实验内容 在 Ubuntu 或 Fedora 环境创建一对父子进程，使用共享内存的方式实现进程间的通信。父进程提供数据（1-100，递增），子进程读出来并显示 （考虑信号通信机制）在 Ubuntu 或 Fedora 环境创建父子 2 个进程 A，B。进程 A 不断获取用户从键盘输入的字符串或整数，通过信号机制传给进程 B。如果输入的是字符串，进程 B 将其打印出来；如果输入的是整数，进程 B 将其累加起来，并输出该数和累加和。当累加和大于 100 时结束子进程，子进程输出“My work done！”后结束，然后父进程也结束。 在 windows 环境下，利用高级语言编程环境（限定为 VS 环境或 VC 环境或QT）调用 CreateThread 函数哲学家就餐问题的演示。要求： 提供死锁的解法和非死锁的解法； 有图形界面直观显示哲学家取筷子，吃饭，放筷子，思考等状态。 为增强结果的随机性，各个状态之间的维持时间采用随机时间，例如100ms-500ms 之间。 实验过程 下面是对于每一个任务的原理和过程的简述： 共享内存 共享内存就是允许两个不相关的进程访问的同一个逻辑内存，是在两个正在运行的进程之间共享和传递数据的一种方式。进程之间共享的内存通常为同一段物理内存，并且可以将同一段共享内存连接到进程自己的地址空间中，所有进程都可以访问共享内存中的数据，并且可以进行修改；所做的改动将立即影响到可访问该共享内存的所有的其他进程。 共享内存并未提供同步机制；如果需要，可以配合其他机制（如信号量机制，需要使用 sem 家族的函数）来控制其他进程对于共享内存的同步访问。 在 Linux 下创建一个区域作为共享内存，需要用到 shm 系列函数；它们定义在sys/shm.h中，可以直接引入。在本次实验中，需要使用的这个系列的函数有： shmget函数：可以用来创建共享内存区域；声明式如下： 1int shmget(key_t key, size_t size, int shmflg); 它所接受的参数的含义如下： 标识共享内存的键值；当它取IPC_PRIVATE，或取 0 但是在第三个参数中设置了IPC_PRIVATE标志的时候，会创建一块新共享内存；当然也可以指定一个其他值，作为该 IPC 对象的名字，存储在ipc_perm结构中。因为在实际生产环境中难以约定一个唯一的键值，所以可以设置为IPC_PRIVATE让操作系统指定。 指定了共享内存的长度；实际获得的空间总是系统页面大小的倍数，因为 Linux 总是以页作为内存分配调度的最小单位。 是共享内存读写权限的标志；和在 Linux 中打开文件的权限标志是一样的，例如：当地一个参数指定的内存不存在的时候创建并打开，需要设置IPC_CREAT位；对应的还有IPC_EXCL，它仅在第一个参数指定的内存不存在时才可以正常创建打开；对于读写指定的标志时SHM_R和SHM_W，当然也可以直接用数字，比如 0660、0666、0644 等。 这个函数如果出现错误会返回 -1，并且设置errno位；否则返回与第一个参数key相关的共享内存标识符，可以用于后续对于这块共享内存的处理。 创建共享内存之后，还需要对它进行访问，这需要shmat函数；at 是 attach 的意思；它的声明如下： 1void *shmat(int shm_id, const void *shm_addr, int shmflg); 它所接受的参数的含义如下： 共享内存的标识符，是shmget的返回值； 指定当前进程下映射到共享内存的地址；当这个值取 0，表示让操作系统选择共享内存所在的地址，这样操作系统将会自动为映射分配一块内存；如果这里制定了地址，还需要预先处理分配内存。映射地址可能不是整页，将根据第三个参数的值决定内存是否取整页。 标志位参数；如果指定了SHM_RDONLY，共享内存将被映射为只读的；如果指定SHM_RND，则将内存大小设定为页面的尺寸。 如果成功，该函数将返回在当前进程的内存空间中，共享内存的映射地址；否则返回 -1，并且设置errno。 如果当前进程不再需要访问共享内存，则可以使用shmdt函数，dt 指 detach；该函数会使得共享内存和当前进程分离，但并不删除共享内存，只是当前进程无法访问；它的声明是： 1int shmdt(const void *shmaddr); 接受的参数是共享内存映射到当前进程的指针地址，也就是shmat函数调用成功的返回值；该函数调用成功返回 0，否则返回 -1. shmctl可以用来控制共享内存，ctl 指的是control，和semctl一样；它的声明式是这样的： 1int shmctl(int shm_id, int command, struct shmid_ds *buf); 它接受的参数的意义是这样的： 是共享内存的标识符；是shmget的返回值； 代表将要采取的操作：取IPC_STAT代表尝试获得共享内存当前的关联值，将该值存入第三个参数指向的shmid_ds结构中；取IPC_SET代表尝试设置共享内存当前的关联值，当线程有足够的权限操作时就将第三个参数指向的结构中的值设置为当前共享内存的关联值；取IPC_RMID代表删除当前共享内存段，但是并不是立即删除，只是给它加上待删标志，直到所有的进程都和它断开连接后才会真正的删除。 指向shmid_ds结构的指针；它包含了共享内存模式和访问权限。它至少包含了下面的这些成员： 123456struct shmid_ds&#123; uid_t shm_perm.uid; uid_t shm_perm.gid; mode_t shm_perm.mode;&#125;; 返回 0 表示执行成功，否则返回 -1 并设置errno值。 这样，我们就可以通过使用这些函数建立共享内存供两个进程使用了。进程随时修改内存，并设置标志供其他进程读取；若另一个进程正在操作内存，那么可以设置标志位，让另一个进程进入阻塞状态直到标志位被放开。 多线程传递数据 考虑使用管道在进程之间通信；进程之间的管道通信具有下面的特点： 管道只允许有血缘关系的进程之间通信——比如父子进程 管道的通信是单向的——如果需要双向通信，可以开设多个管道 管道内部保证同步机制——这保证了访问数据的一致性 管道和进程共存——进程关闭则端口关闭，所有进程关闭则管道销毁 管道通信是字节流——可以用来传输字节流数据 管道包含两端，一个是读端，一个是写端；如果要创建的管道是匿名管道pipe（除此之外还有有名管道FIFO），则可以使用定义在unistd.h中的pipe函数创建。pipe函数的声明是这样的： 1int pipe(int pipefd[2]); 接受的参数是一个包含两个整数的数组，是一个out参数：如果函数调用成功，将会在这个数组中存入两个文件标识符，表示了新创建的通道的读端和写端——[0]是读端，[1]是写端。管道对于进程而言就是一个打开的文件，可以使用read和write函数进行文件操作。如果函数成功执行将返回 0，否则返回 -1. 一般创建父子进程之间的匿名管道的步骤是： 父进程创建一个匿名管道，得到管道两端的文件标识符 父进程使用fork创建子进程，子进程复制了父亲的文件标识符变量 父进程关闭一段，子进程关闭另一端（使用close） 管道的实现是一个环形队列：数据从管道的一端流入，另一端流出，就实现了进程之间的通信 不论是什么方式进行的进程间通信，本质上都是不同进程可以看到一份同样的资源——在内核中开辟的一块缓冲区。不同的通信方式的区别只是这份公共资源提供的方式。既然管道本质是内核空间的缓冲区，它就有一个容量上限：这可以通过写端持续写入，读端不读取且不关闭读端来获得。 管道信息传输还存在特殊情况： 读端开启，但是不读取；写端持续写入——当缓冲区被写满之后再次write会导致管道阻塞，直到管道有空位置时才可以继续写入； 写端开启，但是不写入；读端持续读入——当缓冲区无数据可读的时候再次read会导致管道阻塞，直到管道有新数据时才可以继续读取； 写端关闭，读端持续读入——当缓冲区无数据可读的时候会读取到EOF； 读端关闭，写端持续写入——当缓冲区写满之后会产生信号SIGPIPE，导致进程中止； 简单地说，就是缓冲区占满会导致异常。 这样，我们就可以使用管道来进行进程间的通信，并且按照要求实现了。传输数据时可以在传输前判断输入的字符串的性质，随后提前通过管道传递一个信号给另一个进程说明数据类型，再传递数据。 在这个任务里，我在父亲进程中首先尝试对于读入的字符串进行转换：若不能完全转换为数字，则输入是字符串，先传递信号 0，再传递字符串占用的空间（(strlen(s)+1)*sizeof(char)）和字符串；否则，传递信号 1 之后再传递整形的大小，最后传递整数；子进程先通过读取的信号判断输出的方法，再通过读到的大小从管道里读取相应大小的字节流，执行对应的操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687if (id &gt; 0) // 這是父親進程&#123; close(fd[0]); close(rt[1]); int cnt = 0, msg; char s[BUF_SIZE]; char *sign; int flag, res; write(fd[1], &amp;cnt, sizeof(cnt)); while (cnt ++ &lt; 100) &#123; cout &lt;&lt; &quot;正在等待用戶的輸入……（輸入不要超過 &quot; &lt;&lt; BUF_SIZE - 1 &lt;&lt; &quot; 個字符）&quot; &lt;&lt; endl; cin &gt;&gt; s; cout &lt;&lt; &quot;父親進程收到了用戶輸入： &quot; &lt;&lt; s &lt;&lt; flush; msg = (int)strtol(s, &amp;sign, 10); if (sign - s == strlen(s)) &#123; cout &lt;&lt; &quot;，您輸入的是一個數字&quot; &lt;&lt; endl; flag = 1; write(fd[1], &amp;flag, sizeof(flag)); write(fd[1], &amp;INT, sizeof(INT)); write(fd[1], &amp;msg, sizeof(msg)); &#125; else &#123; cout &lt;&lt; &quot;，您輸入的是一個字符串&quot; &lt;&lt; endl; int SIZE = CHAR * strlen(s) + CHAR; flag = 0; write(fd[1], &amp;flag, sizeof(flag)); write(fd[1], &amp;SIZE, sizeof(SIZE)); write(fd[1], s, SIZE); &#125; sleep(SLEEP_TIME); ssize_t siz = read(rt[0], &amp;res, sizeof(res)); cerr &lt;&lt; &quot;收到子進程的信號： &quot; &lt;&lt; res &lt;&lt; &#x27;(&#x27; &lt;&lt; siz &lt;&lt; &quot;)\\n&quot;; if (~res &amp;&amp; res &lt;= TIME_MAX) continue; else if (res == -1) &#123; cout &lt;&lt; &quot;收到來自子進程的信號，父親進程即將退出……&quot; &lt;&lt; endl; exit(EXIT_SUCCESS); &#125; else break; &#125; cout &lt;&lt; &quot;父親進程的工作完成了，即將退出……&quot; &lt;&lt; endl; exit(EXIT_SUCCESS);&#125;else if (id == 0) // 如果這是子進程&#123; close(fd[1]); close(rt[0]); int msg, j = 0, size, flag, sum = 0; char ss[BUF_SIZE]; read(fd[0], &amp;msg, sizeof(msg)); const int offset = msg; cerr &lt;&lt; &quot;子進程已經初始化，offset值是： &quot; &lt;&lt; offset &lt;&lt; endl; while (j &lt; TIME_MAX) &#123; read(fd[0], &amp;flag, sizeof(flag)); ssize_t s = read(fd[0], &amp;size, sizeof(size)); cerr &lt;&lt; &quot;消息的大小是： &quot; &lt;&lt; s &lt;&lt; &quot;，消息的類型是 &quot; &lt;&lt; (flag ? &quot;int(&quot; : &quot;string(&quot;) &lt;&lt; size &lt;&lt; &quot;)&quot; &lt;&lt; endl; if (flag) &#123; read(fd[0], &amp;msg, sizeof(msg)); cout &lt;&lt; &quot;收到了來自父親進程的消息： &quot; &lt;&lt; msg &lt;&lt; endl; sum += msg; cout &lt;&lt; &quot;纍加值當前已經纍計了： &quot; &lt;&lt; sum &lt;&lt; &#x27;/&#x27; &lt;&lt; SUM_MAX &lt;&lt; endl; if (sum &gt;= SUM_MAX) &#123; cout &lt;&lt; &quot;纍加值達到要求，程序子進程退出……&quot; &lt;&lt; endl; j = -1; write(rt[1], &amp;j, sizeof(j)); exit(EXIT_SUCCESS); &#125; &#125; else &#123; read(fd[0], ss, size); cout &lt;&lt; &quot;收到了來自父親進程的消息： &quot; &lt;&lt; ss &lt;&lt; endl; &#125; ++ j; cerr &lt;&lt; &quot;這是子進程處理的第 &quot; &lt;&lt; j &lt;&lt; &quot; 條消息&quot; &lt;&lt; endl; write(rt[1], &amp;j, sizeof(j)); &#125;&#125; 上面的是关于功能的具体实现的片段。包括了关闭管道的端口，缓冲区字符串类型判断和字节流信息传递。 哲学家问题 因为没有合适的素材，所以没有做图形界面，改用文件输出了。 实现的伪代码已经在幻灯片里提到了，这里就不再展开详述了。 关于这个问题导致的死锁情况的分析：当一个哲学家已经拿起了左手边的筷子，准备拿起右手边筷子的时候，发现右手边的筷子被占用了，就会陷入阻塞，等待右手边的筷子释放后才能活动；但是于此同时，左边的那位哲学家可能也因为缺少右手边的筷子而陷入阻塞；这样推导下去就可能导致所有的哲学家陷入阻塞，即所谓死锁。 分析问题，发现该问题满足了死锁产生的四个条件： 互斥条件：一个资源每次只能被一个线程/进程使用。 请求与保持条件：一个线程/进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件：线程/进程已获得的资源，在未使用完之前，不能强行剥夺。 循环等待条件：若干线程/进程之间形成一种头尾相接的循环等待资源关系。 解决死锁通常的思路是预防-避免-检测：具体的做法就是设置资源获取的协议，动态决定是否赋予资源，并且设定专门的机构来外力破坏死锁，使进程回复。 对于这种情况，避免死锁可以使用资源有序分配的方法来解决：首先我们通过交换第 0 号哲学家的左右手筷子的编码，这样就可以导致所有的哲学家左手的筷子编号都比右手的筷子编号大，破坏了上述死锁发生条件的循环等待条件，就通过预防的方式避免了死锁。 除此之外，当然可以从其他角度入手：使用信号量限制同时吃面条的人数，或者让哲学家等待之前先释放已经拿到的筷子，都可以解决这个死锁的问题。 至于程序的实现，可以采用 Windows 自带的 CreateThread函数和信号量机制；API 在之前的上机实验报告中已经提到过了，这里就不再赘述。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546DWORD WINAPI philosopher(LPVOID lpParam)&#123; const auto rm = randomMachine(100, 500); int id = ++ cnt_id; const string out = FILE_NAME + to_string(id) + TXT; ofstream fout((PATH + out).c_str()); if (!fout) &#123; cerr &lt;&lt; &quot;哲學家 &quot; &lt;&lt; id &lt;&lt; &quot;： 文件打開失敗！程序即將退出……&quot; &lt;&lt; endl; exit(EXIT_FAILURE); &#125; int time, cnt = 0; HANDLE right, left; left = OpenSemaphore(SEMAPHORE_ALL_ACCESS, FALSE, chop[LeftHand]); right = OpenSemaphore(SEMAPHORE_ALL_ACCESS, FALSE, chop[RightHand]); while (cnt ++ &lt;= TIME_MAX) &#123; time = rm(); fout &lt;&lt; getNowTime() &lt;&lt; &quot;： 哲學家 &quot; &lt;&lt; id &lt;&lt; &quot; 思考了 &quot; &lt;&lt; time &lt;&lt; &quot; ms.&quot; &lt;&lt; endl; Sleep(time); time = rm(); fout &lt;&lt; getNowTime() &lt;&lt; &quot;： 哲學家 &quot; &lt;&lt; id &lt;&lt; &quot; 休息了 &quot; &lt;&lt; time &lt;&lt; &quot; ms.&quot; &lt;&lt; endl; Sleep(time); WaitForSingleObject(left, INFINITE); fout &lt;&lt; getNowTime() &lt;&lt; &quot;： 哲學家 &quot; &lt;&lt; id &lt;&lt; &quot; 拿起了左手邊的筷子 &quot; &lt;&lt; LeftHand &lt;&lt; endl; WaitForSingleObject(right, INFINITE); fout &lt;&lt; getNowTime() &lt;&lt; &quot;： 哲學家 &quot; &lt;&lt; id &lt;&lt; &quot; 拿起了右手邊的筷子 &quot; &lt;&lt; RightHand &lt;&lt; endl; time = rm(); fout &lt;&lt; getNowTime() &lt;&lt; &quot;： 哲學家 &quot; &lt;&lt; id &lt;&lt; &quot; 用餐了 &quot; &lt;&lt; time &lt;&lt; &quot; ms.&quot; &lt;&lt; endl; Sleep(time); ReleaseSemaphore(left, 1, NULL); fout &lt;&lt; getNowTime() &lt;&lt; &quot;： 哲學家 &quot; &lt;&lt; id &lt;&lt; &quot; 放下了左手邊的筷子 &quot; &lt;&lt; LeftHand &lt;&lt; endl; ReleaseSemaphore(right, 1, NULL); fout &lt;&lt; getNowTime() &lt;&lt; &quot;： 哲學家 &quot; &lt;&lt; id &lt;&lt; &quot; 放下了右手邊的筷子 &quot; &lt;&lt; RightHand &lt;&lt; endl; &#125; cout &lt;&lt; &quot;模擬測試達到最大次數，進程將要退出……&quot; &lt;&lt; endl; fout.close(); exit(EXIT_SUCCESS);&#125; 上面是单个哲学家进程的进程函数，被CreateThread函数创建多个同样的进程。 实验结果 这里是任务完成后的截图或其他证明。 任务一：共享内存 下面是在 WSL 终端下执行代码的部分输出： 3_1.png 编译源代码并执行之后，终端会先输出父亲进程的输出，随后自动输出儿子进程的输出。效果如上图所示。 任务二：管道通信 在 WSL-CLion 环境下执行源代码可以获得以下输出：绿色代表stdin，白色代表stdout，红色代表stderr。 3_2.png 子进程受到信息之后可以对于数字进行累加，并且正常输出父进程传入的字符串；当达到累加目标后，通过另一个管道向父亲进程发送终止信号，程序父进程退出而不是继续等待输入。 任务三：哲学家就餐 这是五个哲学家向不同文件输出日志中的一个的部分： 3_5.png 每条日志之前包含了时间轴，可以使用其他程序处理成一个文件。 体会 通过本次操作系统原理的上机实验，我更加熟练了在之前的实验中使用的在 Windows / Linux 平台上的多线程编程的能力。并了解到了使用一些方法可以实现在进程之中通信，对于内存空间和通信机制有了更加深刻的理解。可以使用所学的 API 完成在进程之间的简单通信。 哲学家就餐问题的模拟过程，让我亲身体会了从死锁产生的原因入手想方设法避免死锁产生的过程，更加深了我对于死锁产生的条件以及针对于这些条件的一些解决措施的理解和感受。","categories":[{"name":"课业","slug":"课业","permalink":"https://shiraha.cn/categories/%E8%AF%BE%E4%B8%9A/"},{"name":"操作系统","slug":"操作系统","permalink":"https://shiraha.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Windows","slug":"操作系统/Windows","permalink":"https://shiraha.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows/"},{"name":"Linux","slug":"操作系统/Linux","permalink":"https://shiraha.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://shiraha.cn/tags/Windows/"},{"name":"操作系统","slug":"操作系统","permalink":"https://shiraha.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"课内作业","slug":"课内作业","permalink":"https://shiraha.cn/tags/%E8%AF%BE%E5%86%85%E4%BD%9C%E4%B8%9A/"},{"name":"实验报告","slug":"实验报告","permalink":"https://shiraha.cn/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"Linux","slug":"Linux","permalink":"https://shiraha.cn/tags/Linux/"}]},{"title":"操作系统原理：第 4 次上机实验报告","slug":"class-FoDOS-experiment-4","date":"2020-05-11T17:32:04.000Z","updated":"2020-05-11T17:32:04.000Z","comments":true,"path":"2020/class-FoDOS-experiment-4/","link":"","permalink":"https://shiraha.cn/2020/class-FoDOS-experiment-4/","excerpt":"","text":"操作系统原理的上机实验的报告一共有四个，其他的报告的地址是： 第一次：https://shiraha.cn/2020/class-FoDOS-experiment-1/ 第二次：https://shiraha.cn/2020/class-FoDOS-experiment-2/ 第三次：https://shiraha.cn/2020/class-FoDOS-experiment-3/ 第四次：https://shiraha.cn/2020/class-FoDOS-experiment-4/ Front-matter 本次实验的所有源代码可以在https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job?path=%2Fosnmb%2Fexp 查看到。 实验要求 本次上机实验的实验要求如下： ##### 《操作系统原理》第二次上机实验 一、实验目的 理解页面淘汰算法原理，编写程序演示页面淘汰算法； 验证 Linux 虚拟地址转化为物理地址的机制； 理解和验证程序运行局部性的原理； 二、实验内容 在 Windows 环境下编写一个程序，模拟实现 OPT, FIFO, LRU 等页面淘汰算法。可以使用数组模拟内存，数组中的元素模拟为指令或数据。写不同方式的程序去访问数组来模拟 CPU 访问内存的情况。分析运算结果，在分配不同的物理块情况下， 各算法的缺页情况有什么规律？可以 srand() 和 rand() 等函数定义和产生“指令”序列，然后将指令序列变换成相应的页地址流，并针对不同的算法计算出相应的命中率。 例如，实验中可以产生 320 条“指令”，每个“虚拟页”存放 10 条指令。 进程分配的页框是 4（可变，例如 32）。 在 Linux 环境下，编写一个小程序，获取该程序中的某个变量的虚拟地址，虚拟页号，页内偏移地址，物理页框号，页内偏移地址，物理地址，并将它们打 印出来。建议使用 /proc/pid/pagemap 技术。 在 Windows 环境下，编写一个函数（特点：比较耗时，比如大型的多维数组读写），用不同的方法测试其所花费的时间。在不同环境下比较其时间是否不同，并分析其含义。测量时间的函数请 baidu。 实验指南：参考网络，课件等。 实验内容 在 Windows 环境下编写一个程序，模拟实现 OPT, FIFO, LRU 等页面淘汰算法。可以使用数组模拟内存，数组中的元素模拟为指令或数据。写不同方式的程序去访问数组来模拟 CPU 访问内存的情况。分析运算结果，在分配不同的物理块情况下， 各算法的缺页情况有什么规律？可以 srand() 和 rand() 等函数定义和产生“指令”序列，然后将指令序列变换成相应的页地址流，并针对不同的算法计算出相应的命中率。 例如，实验中可以产生 320 条“指令”，每个“虚拟页”存放 10 条指令。 进程分配的页框是 4（可变，例如 32）。 在 Linux 环境下，编写一个小程序，获取该程序中的某个变量的虚拟地址，虚拟页号，页内偏移地址，物理页框号，页内偏移地址，物理地址，并将它们打 印出来。建议使用 /proc/pid/pagemap 技术。 在 Windows 环境下，编写一个函数（特点：比较耗时，比如大型的多维数组读写），用不同的方法测试其所花费的时间。在不同环境下比较其时间是否不同，并分析其含义。测量时间的函数请 baidu。 实验过程 下面是对于每一个任务的原理和过程的简述： 算法模拟 要想完成这个任务，有两个问题需要解决：应该怎么模拟内存和指令？这些算法应该怎么实现？ 现代计算机采用的大多是段页式内存管理，可以平衡达到不错的性能，这里就不展开详细介绍了（毕竟还要扯到好多别的东西）。简单的建模大概就是：我们有一个物理内存，按照页框分好了页。这里先不管那些用来维护这些信息的辅助空间，只关注存储了实际数据的空间；因为内存算法的目的就是让小内存尽可能运行需要内存较多的程序，所以还要有一个虚拟内存空间：它至少比物理内存要大；此外抽象每条指令都是需要内存中的一个确定页面的数据——这也没有什么问题，当然这个内存是虚拟内存。 这样，我们就可以开设代表物理内存的数组，并且存储了一些虚拟内存中的数据页面；假设所有的指令（毕竟二进制的情况下，指令就是数据，数据也是指令；为了模型更加清晰和直观，我们将命令和数据分离；假设所有指令都占用极小内存并且不占用数据段，数据分页并载入数据段的虚拟内存空间）都是需要数据段的某一页数据；那么，当指令需要的数据页面在物理空间内时命中，否则缺页。 接下来就是算法部分了。首先是 OPT：它代表着理想中的最佳情况，在现实计算机中不可能被达成。这是因为它的实现过程中，需要“预知未来”的指令才可以做出最优判断，有些动态规划的思想。称它为“离线算法”比较合适，但是在现实计算机的“强制要求在线”的环境下，并不能实现这样的算法。 OPT 本质上在替换物理内存中的虚拟页的时候，会根据对未来指令的“观测”，找到当前物理内存中持有的距离下次调用最久远的内存页进行替换——这样做的最优性是显然的。在实现的过程中，我们可以开设一个长度等于指令全长度的数组，从后向前进行一次扫描，将每一个指令的下一次执行的时间戳记录下来；开始模拟后只需要对数组进行 O(1) 访问就可以知道下一次调用该页面的时间戳了。 FIFO 就显得非常的简单粗暴：它认为所有的数据页面被指令访问到的机会是“均等”的——这样就可以得到一个显然的结论，即先进入内存（被访问）的内存页下次被指令使用的可能性更小，所以在替换的时候会优先的替换掉这些先进入物理内存的数据页面。 FIFO 的实现也非常的简单：我们假设将数据载入内存的时候是按某个顺序进行的，在替换的过程中我们只需要遵循这个顺序找到下一个要被替换掉的内存块就可以了；具体的说是开一个静态变量记录上次置换的页面的物理页框编号，之后的替换就是对于这个页框增加一就可以了。 LRU 是这几个算法中最为平衡的一个算法：不仅具有可行性，而且也可以保证较好的命中率；此外基于这个算法还可以进行一些数据结构上的调整，增加优先级和队列的设计，让它的命中率更高（当然，相对的运算代价也会增大）。但是因为这次上机实验没有要求，这里就不再赘述了。和 FIFO 不同，LRU 算法认为如果一个内存页面在最近被访问过，那么它在较短时间内被再次访问的概率会比其他页面更高。所以相对地，需要淘汰的页面是物理内存中最久没有被访问过的页面。这样的算法其实更加符合人们的生活常识，事实上它确实在一般情况下可以带来比起 FIFO 算法更高的命中率。 在 LRU 实现的过程中，我们可以维护一个链表——它维持了当前物理内存中所有的页面；每当需要卸载一个页面的时候，我们从队尾取出一个物理页框，将它与新数据页置换；当载入一个新的数据页的时候，我们将它放入的物理页框作为一个节点加入到链表的队首；当访问一个物理内存中已经载入的页面的时候，我们将它从链表中原位置取出，并放置在链表队首。 根据上面的分析，我们可以显然得出这个链表占用的空间（长度）不会超过物理内存页框的数量，所以为了避免开节点/删节点频繁的内存访问，可以使用“对象池”技术进行优化。但是在我公开的代码里，我为了更加直观的展现这个过程，并没有采用这种设计模式。 在算法正确性测试的过程中，我特别采用了&#123;7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1&#125;这组数据；这是来源于网络上的参考资料中的数据，该博主给出了这组数据在这三种算法下的内存快照以供对比，可以验证我的算法的正确性。 4_1.png 可以在实验结果部分看到完整的程序输出。 在验证完正确性之后，为了方便之后的测试，我将整个测试流程提出作为接口；在我的源代码中可以看到它的定义以及使用方法，这里不再赘述；为了测试不同的算法在不同的物理内存/虚拟内存比率下的缺页率，我调用了这个接口创建了一组测试，代码如下： 12345678910111213dword institute[400];cout &lt;&lt; fixed &lt;&lt; setprecision(4);for (int i = 1; i &lt;= 8; ++ i)&#123; auto opt = new_process(i * 4, 32, 320, institute, OPT, true); auto fifo = new_process(i * 4, 32, 320, institute, FIFO); auto lru = new_process(i * 4, 32, 320, institute, LRU); cout &lt;&lt; &quot;物理内存 &quot; &lt;&lt; i * 4 &lt;&lt; &quot;，虚拟内存 32，命中率：\\t&quot; &lt;&lt; &quot;\\t\\tOPT = &quot; &lt;&lt; opt &lt;&lt; &quot;\\t\\tFIFO = &quot; &lt;&lt; fifo &lt;&lt; &quot;\\t\\tLRU = &quot; &lt;&lt; lru &lt;&lt; endl;&#125; 可以将这段代码粘贴到公开的源代码的指定位置进行测试，可以获得输出。 检查 Linux 变量 本任务的实验原理在操作系统原理的课堂上都有介绍，这里不再详细介绍；大体步骤是： 使用getpagesize获得系统设定的页框大小，将指针类型转换为ulong获得虚拟地址； 虚拟地址整除页面大小可以得到虚拟页框号，取余数可以得到页框内的偏移地址； 打开/proc/self/pagemap文件，找到对应项的起始位置，读取并记录该值； 取上一步获得的项值的 0-55 位，其意义是变量的物理页框号，加上偏移地址就是物理地址； 将上述的过程写成 C++ 代码并输出指定的结果，本任务就完成了。 源代码已经公开，实验结果请参见“实验结果”部分。 检查函数运行时间 对于 Windows 平台，C++ 环境下，测量时间的方法可以分为以下三类： C++ 标准库提供的方法：time、clock、std::chrono Windows 提供的系统调用：QueryPerformanceCounter、GetTickCount、timeGetTime 硬件平台提供的指令：__asm&#123;_emit 0x0F;_emit 0x31;&#125; 内联汇编比较的不靠谱，timeGetTime所需要的WinMM.Lib甚至不被包含在基础的 Windows SDK 内；所以选择剩下的五种方法予以实现。 源代码已经公开，实验结果请参见“实验结果”部分。 实验结果 这里是任务完成后的截图或其他证明，包含一些对实验结果的解释。 任务一：内存淘汰算法 这是测试数据使用三种算法执行后内存快照的输出，可以确保算法的正确性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400D:\\Workspaces\\ClionProjects\\osnmb\\cmake-build-debug\\osnmb.exe實驗： Windows 下的頁面淘汰算法模擬基礎測試：最佳置換算法（OPT）：----------------------------------------------------------------------物理幀 虛擬頁 載入時間 最後使用----------------------------------------------------------------------第 0 條指令進行内存訪問： 虛擬頁[7] 狀態：缺頁----------------------------------------------------------------------物理頁[0] * 7 0 0物理頁[1] INVALID INVALID INVALID物理頁[2] INVALID INVALID INVALID----------------------------------------------------------------------第 1 條指令進行内存訪問： 虛擬頁[0] 狀態：缺頁----------------------------------------------------------------------物理頁[0] 7 0 0物理頁[1] * 0 1 1物理頁[2] INVALID INVALID INVALID----------------------------------------------------------------------第 2 條指令進行内存訪問： 虛擬頁[1] 狀態：缺頁----------------------------------------------------------------------物理頁[0] 7 0 0物理頁[1] 0 1 1物理頁[2] * 1 2 2----------------------------------------------------------------------第 3 條指令進行内存訪問： 虛擬頁[2] 狀態：缺頁----------------------------------------------------------------------物理頁[0] * 2 3 3物理頁[1] 0 1 1物理頁[2] 1 2 2----------------------------------------------------------------------第 4 條指令進行内存訪問： 虛擬頁[0] 狀態：命中----------------------------------------------------------------------物理頁[0] 2 3 3物理頁[1] * 0 1 4物理頁[2] 1 2 2----------------------------------------------------------------------第 5 條指令進行内存訪問： 虛擬頁[3] 狀態：缺頁----------------------------------------------------------------------物理頁[0] 2 3 3物理頁[1] 0 1 4物理頁[2] * 3 5 5----------------------------------------------------------------------第 6 條指令進行内存訪問： 虛擬頁[0] 狀態：命中----------------------------------------------------------------------物理頁[0] 2 3 3物理頁[1] * 0 1 6物理頁[2] 3 5 5----------------------------------------------------------------------第 7 條指令進行内存訪問： 虛擬頁[4] 狀態：缺頁----------------------------------------------------------------------物理頁[0] 2 3 3物理頁[1] * 4 7 7物理頁[2] 3 5 5----------------------------------------------------------------------第 8 條指令進行内存訪問： 虛擬頁[2] 狀態：命中----------------------------------------------------------------------物理頁[0] * 2 3 8物理頁[1] 4 7 7物理頁[2] 3 5 5----------------------------------------------------------------------第 9 條指令進行内存訪問： 虛擬頁[3] 狀態：命中----------------------------------------------------------------------物理頁[0] 2 3 8物理頁[1] 4 7 7物理頁[2] * 3 5 9----------------------------------------------------------------------第 10 條指令進行内存訪問： 虛擬頁[0] 狀態：缺頁----------------------------------------------------------------------物理頁[0] 2 3 8物理頁[1] * 0 10 10物理頁[2] 3 5 9----------------------------------------------------------------------第 11 條指令進行内存訪問： 虛擬頁[3] 狀態：命中----------------------------------------------------------------------物理頁[0] 2 3 8物理頁[1] 0 10 10物理頁[2] * 3 5 11----------------------------------------------------------------------第 12 條指令進行内存訪問： 虛擬頁[2] 狀態：命中----------------------------------------------------------------------物理頁[0] * 2 3 12物理頁[1] 0 10 10物理頁[2] 3 5 11----------------------------------------------------------------------第 13 條指令進行内存訪問： 虛擬頁[1] 狀態：缺頁----------------------------------------------------------------------物理頁[0] 2 3 12物理頁[1] 0 10 10物理頁[2] * 1 13 13----------------------------------------------------------------------第 14 條指令進行内存訪問： 虛擬頁[2] 狀態：命中----------------------------------------------------------------------物理頁[0] * 2 3 14物理頁[1] 0 10 10物理頁[2] 1 13 13----------------------------------------------------------------------第 15 條指令進行内存訪問： 虛擬頁[0] 狀態：命中----------------------------------------------------------------------物理頁[0] 2 3 14物理頁[1] * 0 10 15物理頁[2] 1 13 13----------------------------------------------------------------------第 16 條指令進行内存訪問： 虛擬頁[1] 狀態：命中----------------------------------------------------------------------物理頁[0] 2 3 14物理頁[1] 0 10 15物理頁[2] * 1 13 16----------------------------------------------------------------------第 17 條指令進行内存訪問： 虛擬頁[7] 狀態：缺頁----------------------------------------------------------------------物理頁[0] * 7 17 17物理頁[1] 0 10 15物理頁[2] 1 13 16----------------------------------------------------------------------第 18 條指令進行内存訪問： 虛擬頁[0] 狀態：命中----------------------------------------------------------------------物理頁[0] 7 17 17物理頁[1] * 0 10 18物理頁[2] 1 13 16----------------------------------------------------------------------第 19 條指令進行内存訪問： 虛擬頁[1] 狀態：命中----------------------------------------------------------------------物理頁[0] 7 17 17物理頁[1] 0 10 18物理頁[2] * 1 13 19----------------------------------------------------------------------命中率： 0.55隊列置換算法（FIFO）：----------------------------------------------------------------------物理幀 虛擬頁 載入時間 最後使用----------------------------------------------------------------------第 0 條指令進行内存訪問： 虛擬頁[7] 狀態：缺頁----------------------------------------------------------------------物理頁[0] * 7 0 0物理頁[1] INVALID INVALID INVALID物理頁[2] INVALID INVALID INVALID----------------------------------------------------------------------第 1 條指令進行内存訪問： 虛擬頁[0] 狀態：缺頁----------------------------------------------------------------------物理頁[0] 7 0 0物理頁[1] * 0 1 1物理頁[2] INVALID INVALID INVALID----------------------------------------------------------------------第 2 條指令進行内存訪問： 虛擬頁[1] 狀態：缺頁----------------------------------------------------------------------物理頁[0] 7 0 0物理頁[1] 0 1 1物理頁[2] * 1 2 2----------------------------------------------------------------------第 3 條指令進行内存訪問： 虛擬頁[2] 狀態：缺頁----------------------------------------------------------------------物理頁[0] * 2 3 3物理頁[1] 0 1 1物理頁[2] 1 2 2----------------------------------------------------------------------第 4 條指令進行内存訪問： 虛擬頁[0] 狀態：命中----------------------------------------------------------------------物理頁[0] 2 3 3物理頁[1] * 0 1 4物理頁[2] 1 2 2----------------------------------------------------------------------第 5 條指令進行内存訪問： 虛擬頁[3] 狀態：缺頁----------------------------------------------------------------------物理頁[0] 2 3 3物理頁[1] * 3 5 5物理頁[2] 1 2 2----------------------------------------------------------------------第 6 條指令進行内存訪問： 虛擬頁[0] 狀態：缺頁----------------------------------------------------------------------物理頁[0] 2 3 3物理頁[1] 3 5 5物理頁[2] * 0 6 6----------------------------------------------------------------------第 7 條指令進行内存訪問： 虛擬頁[4] 狀態：缺頁----------------------------------------------------------------------物理頁[0] * 4 7 7物理頁[1] 3 5 5物理頁[2] 0 6 6----------------------------------------------------------------------第 8 條指令進行内存訪問： 虛擬頁[2] 狀態：缺頁----------------------------------------------------------------------物理頁[0] 4 7 7物理頁[1] * 2 8 8物理頁[2] 0 6 6----------------------------------------------------------------------第 9 條指令進行内存訪問： 虛擬頁[3] 狀態：缺頁----------------------------------------------------------------------物理頁[0] 4 7 7物理頁[1] 2 8 8物理頁[2] * 3 9 9----------------------------------------------------------------------第 10 條指令進行内存訪問： 虛擬頁[0] 狀態：缺頁----------------------------------------------------------------------物理頁[0] * 0 10 10物理頁[1] 2 8 8物理頁[2] 3 9 9----------------------------------------------------------------------第 11 條指令進行内存訪問： 虛擬頁[3] 狀態：命中----------------------------------------------------------------------物理頁[0] 0 10 10物理頁[1] 2 8 8物理頁[2] * 3 9 11----------------------------------------------------------------------第 12 條指令進行内存訪問： 虛擬頁[2] 狀態：命中----------------------------------------------------------------------物理頁[0] 0 10 10物理頁[1] * 2 8 12物理頁[2] 3 9 11----------------------------------------------------------------------第 13 條指令進行内存訪問： 虛擬頁[1] 狀態：缺頁----------------------------------------------------------------------物理頁[0] 0 10 10物理頁[1] * 1 13 13物理頁[2] 3 9 11----------------------------------------------------------------------第 14 條指令進行内存訪問： 虛擬頁[2] 狀態：缺頁----------------------------------------------------------------------物理頁[0] 0 10 10物理頁[1] 1 13 13物理頁[2] * 2 14 14----------------------------------------------------------------------第 15 條指令進行内存訪問： 虛擬頁[0] 狀態：命中----------------------------------------------------------------------物理頁[0] * 0 10 15物理頁[1] 1 13 13物理頁[2] 2 14 14----------------------------------------------------------------------第 16 條指令進行内存訪問： 虛擬頁[1] 狀態：命中----------------------------------------------------------------------物理頁[0] 0 10 15物理頁[1] * 1 13 16物理頁[2] 2 14 14----------------------------------------------------------------------第 17 條指令進行内存訪問： 虛擬頁[7] 狀態：缺頁----------------------------------------------------------------------物理頁[0] * 7 17 17物理頁[1] 1 13 16物理頁[2] 2 14 14----------------------------------------------------------------------第 18 條指令進行内存訪問： 虛擬頁[0] 狀態：缺頁----------------------------------------------------------------------物理頁[0] 7 17 17物理頁[1] * 0 18 18物理頁[2] 2 14 14----------------------------------------------------------------------第 19 條指令進行内存訪問： 虛擬頁[1] 狀態：缺頁----------------------------------------------------------------------物理頁[0] 7 17 17物理頁[1] 0 18 18物理頁[2] * 1 19 19----------------------------------------------------------------------命中率： 0.25最近最久未使用置換算法（LRU）：----------------------------------------------------------------------物理幀 虛擬頁 載入時間 最後使用----------------------------------------------------------------------第 0 條指令進行内存訪問： 虛擬頁[7] 狀態：缺頁----------------------------------------------------------------------物理頁[0] * 7 0 0物理頁[1] INVALID INVALID INVALID物理頁[2] INVALID INVALID INVALID----------------------------------------------------------------------第 1 條指令進行内存訪問： 虛擬頁[0] 狀態：缺頁----------------------------------------------------------------------物理頁[0] 7 0 0物理頁[1] * 0 1 1物理頁[2] INVALID INVALID INVALID----------------------------------------------------------------------第 2 條指令進行内存訪問： 虛擬頁[1] 狀態：缺頁----------------------------------------------------------------------物理頁[0] 7 0 0物理頁[1] 0 1 1物理頁[2] * 1 2 2----------------------------------------------------------------------第 3 條指令進行内存訪問： 虛擬頁[2] 狀態：缺頁----------------------------------------------------------------------物理頁[0] * 2 3 3物理頁[1] 0 1 1物理頁[2] 1 2 2----------------------------------------------------------------------第 4 條指令進行内存訪問： 虛擬頁[0] 狀態：命中----------------------------------------------------------------------物理頁[0] 2 3 3物理頁[1] * 0 1 4物理頁[2] 1 2 2----------------------------------------------------------------------第 5 條指令進行内存訪問： 虛擬頁[3] 狀態：缺頁----------------------------------------------------------------------物理頁[0] 2 3 3物理頁[1] 0 1 4物理頁[2] * 3 5 5----------------------------------------------------------------------第 6 條指令進行内存訪問： 虛擬頁[0] 狀態：命中----------------------------------------------------------------------物理頁[0] 2 3 3物理頁[1] * 0 1 6物理頁[2] 3 5 5----------------------------------------------------------------------第 7 條指令進行内存訪問： 虛擬頁[4] 狀態：缺頁----------------------------------------------------------------------物理頁[0] * 4 7 7物理頁[1] 0 1 6物理頁[2] 3 5 5----------------------------------------------------------------------第 8 條指令進行内存訪問： 虛擬頁[2] 狀態：缺頁----------------------------------------------------------------------物理頁[0] 4 7 7物理頁[1] 0 1 6物理頁[2] * 2 8 8----------------------------------------------------------------------第 9 條指令進行内存訪問： 虛擬頁[3] 狀態：缺頁----------------------------------------------------------------------物理頁[0] 4 7 7物理頁[1] * 3 9 9物理頁[2] 2 8 8----------------------------------------------------------------------第 10 條指令進行内存訪問： 虛擬頁[0] 狀態：缺頁----------------------------------------------------------------------物理頁[0] * 0 10 10物理頁[1] 3 9 9物理頁[2] 2 8 8----------------------------------------------------------------------第 11 條指令進行内存訪問： 虛擬頁[3] 狀態：命中----------------------------------------------------------------------物理頁[0] 0 10 10物理頁[1] * 3 9 11物理頁[2] 2 8 8----------------------------------------------------------------------第 12 條指令進行内存訪問： 虛擬頁[2] 狀態：命中----------------------------------------------------------------------物理頁[0] 0 10 10物理頁[1] 3 9 11物理頁[2] * 2 8 12----------------------------------------------------------------------第 13 條指令進行内存訪問： 虛擬頁[1] 狀態：缺頁----------------------------------------------------------------------物理頁[0] * 1 13 13物理頁[1] 3 9 11物理頁[2] 2 8 12----------------------------------------------------------------------第 14 條指令進行内存訪問： 虛擬頁[2] 狀態：命中----------------------------------------------------------------------物理頁[0] 1 13 13物理頁[1] 3 9 11物理頁[2] * 2 8 14----------------------------------------------------------------------第 15 條指令進行内存訪問： 虛擬頁[0] 狀態：缺頁----------------------------------------------------------------------物理頁[0] 1 13 13物理頁[1] * 0 15 15物理頁[2] 2 8 14----------------------------------------------------------------------第 16 條指令進行内存訪問： 虛擬頁[1] 狀態：命中----------------------------------------------------------------------物理頁[0] * 1 13 16物理頁[1] 0 15 15物理頁[2] 2 8 14----------------------------------------------------------------------第 17 條指令進行内存訪問： 虛擬頁[7] 狀態：缺頁----------------------------------------------------------------------物理頁[0] 1 13 16物理頁[1] 0 15 15物理頁[2] * 7 17 17----------------------------------------------------------------------第 18 條指令進行内存訪問： 虛擬頁[0] 狀態：命中----------------------------------------------------------------------物理頁[0] 1 13 16物理頁[1] * 0 15 18物理頁[2] 7 17 17----------------------------------------------------------------------第 19 條指令進行内存訪問： 虛擬頁[1] 狀態：命中----------------------------------------------------------------------物理頁[0] * 1 13 19物理頁[1] 0 15 18物理頁[2] 7 17 17----------------------------------------------------------------------命中率： 0.4自定義測試：您可以使用源代碼中的 new_process 函數進行自定義測試。實驗結束，程式將退出……Process finished with exit code 0 执行了实验过程的测试之后，可以得到如下的输出： 4_1_1.png 可以看到 FIFO 算法的命中率是高于 LRU 的；对这种情况可以进行合理的解释之一是随机生成的指令不能代表实际指令的执行情况，并不具有实际指令频繁访问关键页面的特性，而更加的趋向于“均等”，从而导致了 FIFO 的算法的实验测试值高于 LRU 算法。 此外，即使物理内存和虚拟内存相等的情况下，命中率也无法达到 100%，是因为实验开始时内存被初始化为空，此时对任何页面的访问都是缺页的；这个极限值的大小取决于虚拟内存和指令条数的比例。 任务二：获得 Linux 变量的地址 在 WSL-CLion 环境下执行实验过程中描述并已经实现的代码，得到如下结果： 4_2_0.png 在 WSL 原生环境下执行代码，得到如下结果： 4_2_1.png 检查errno值之后，发现进程无法打开/proc/pid/pagemap文件；考虑到 WSL 实现的机制是将 Linux 程序的进程作为 Windows 进程挂载，可能没有包括这个部分的模拟。遂在同学的 Ubuntu 笔记本设备上执行代码，得到了如下的结果： 4_2_2.jpg 这说明了代码可以正常工作；也说明了 WSL 并不能和 Linux 等量齐观，进一步地加深了我对于 Windows 和 Linux 操作系统之间的差距的直观认知。 任务三：检查函数运行时间 五种方法分别是：标准库 time 函数、标准库 clock 函数、标准库 chrono 命名空间、Windows 的 QueryPerformanceCounter 函数、Windows 的 GetTickCount 函数。 4_3.png 可以看出第一种方法的准确度非常差。事实上 time 函数的精确度只到秒，而其他的方法的精确度都大于毫秒；出现这样的结果也在意料之中。 体会 通过本次上机实验，我了解了更多的 C++ 中的计时方法，拓宽了自己的视野；手动实现了经典的内存调度的页面置换（淘汰）算法，增进了自己对于三种经典算法的理解，也加深了对于内存调度优化这一概念的理解和认知。内存调度算法实际上也是将一些算法的思想融会贯通的产物；本次的实验还增进了我对于这些内存调度算法背后的算法思想有了更加深刻的认知。 此外，LRU 算法还有很多的优化方法，更加的拓宽了我的视野，让我更加的了解了当代计算机操作系统的一些实现方法；LRU 算法还广泛的利用于用户分层等多个生活中常见的生产场景中，增强了我对于这些抽象算法的理解，带来了更加直观的感受。 此外，在解决任务二程序在 WSL 上运行出现问题的问题的时候，我阅读了一些 API 相关的文档，加深了自己对于这些函数在 Linux 操作系统中运行过程的理解。","categories":[{"name":"课业","slug":"课业","permalink":"https://shiraha.cn/categories/%E8%AF%BE%E4%B8%9A/"},{"name":"操作系统","slug":"操作系统","permalink":"https://shiraha.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Windows","slug":"操作系统/Windows","permalink":"https://shiraha.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows/"},{"name":"Linux","slug":"操作系统/Linux","permalink":"https://shiraha.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://shiraha.cn/tags/Windows/"},{"name":"操作系统","slug":"操作系统","permalink":"https://shiraha.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"课内作业","slug":"课内作业","permalink":"https://shiraha.cn/tags/%E8%AF%BE%E5%86%85%E4%BD%9C%E4%B8%9A/"},{"name":"实验报告","slug":"实验报告","permalink":"https://shiraha.cn/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"Linux","slug":"Linux","permalink":"https://shiraha.cn/tags/Linux/"}]},{"title":"操作系统原理：第 2 次上机实验报告","slug":"class-FoDOS-experiment-2","date":"2020-05-07T16:59:22.000Z","updated":"2020-05-07T16:59:22.000Z","comments":true,"path":"2020/class-FoDOS-experiment-2/","link":"","permalink":"https://shiraha.cn/2020/class-FoDOS-experiment-2/","excerpt":"","text":"操作系统原理的上机实验的报告一共有四个，其他的报告的地址是： 第一次：https://shiraha.cn/2020/class-FoDOS-experiment-1/ 第二次：https://shiraha.cn/2020/class-FoDOS-experiment-2/ 第三次：https://shiraha.cn/2020/class-FoDOS-experiment-3/ 第四次：https://shiraha.cn/2020/class-FoDOS-experiment-4/ Front-matter 本次实验的所有源代码可以在https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job?path=%2Fosnmb%2Fexp 查看到。 实验要求 本次上机实验的实验要求如下： ##### 《操作系统原理》第二次上机实验 一、实验目的 理解操作系统线程的概念和应用编程过程； 理解线程的同步概念和编程； 二、实验内容 在 Ubuntu 或 Fedora 环境使用 fork 函数创建一对父子进程，分别输出各自的进程号和提示信息串。 在 Ubuntu 或 Fedora 环境使用 pthread_create 函数创建 2 个线程 A 和 B。线程 A 在屏幕上用 while 循环顺序递增地输出 1-1000 的自然数；线程 B 在屏幕上用 while 循环顺序递减地输出 1000-1 之间的自然数。为避免输出太快，每隔 0.5 秒输出一个数。 在 windows 环境下，利用高级语言编程环境（限定为 VS 环境或 VC 环境）调用 CreateThread 函数实现（2）的功能。 在 windows 环境下，利用高级语言编程环境（限定为 VS 环境或 VC 环境）调用 CreateThread 函数和相关的同步函数，模拟实现“生产者-消费者”问题。 在 windows 环境下，利用高级语言编程环境（限定为 VS 环境或 VC 环境）调用 CreateThread 函数实现“并发地画圆和画方”。圆的中心，半径，颜色，正方形的中心，边长，颜色等参数自己确定，合适就行。圆和正方形的边界上建议取 720 个点。为直观展示绘制的过程，每个点绘制后睡眠 0.2 秒~0.5 秒。 在 windows 环境下，利用高级语言编程环境（限定为 VS 环境或 VC 环境）调用 CreateThread 函数实现“文件拷贝小工具”。功能如下： 具有一个编辑框，让用户任意指定源目录或文件 具有一个编辑框，让用户任意指定目的目录或文件 具有“开始拷贝”按钮 具有“停止拷贝”按钮 具有显示拷贝进度的 label，当为目录拷贝时以文件数来统计进度，当为文件拷贝时以字节数来统计进度。 以上六个题目中，选择四个完成（1,2 中任意 1 题和 3,4,5 或 3,4,6 共计 4 道题）； 我选择了 1、2、3、4、5 五个题目。 实验内容 在 Ubuntu 或 Fedora 环境使用 fork 函数创建一对父子进程，分别输出各自的进程号和提示信息串。 在 Ubuntu 或 Fedora 环境使用 pthread_create 函数创建 2 个线程 A 和 B。线程 A 在屏幕上用 while 循环顺序递增地输出 1-1000 的自然数；线程 B 在屏幕上用 while 循环顺序递减地输出 1000-1 之间的自然数。为避免输出太快，每隔 0.5 秒输出一个数。 在 windows 环境下，利用高级语言编程环境（限定为 VS 环境或 VC 环境）调用 CreateThread 函数实现（2）的功能。 在 windows 环境下，利用高级语言编程环境（限定为 VS 环境或 VC 环境）调用 CreateThread 函数和相关的同步函数，模拟实现“生产者-消费者”问题。 在 windows 环境下，利用高级语言编程环境（限定为 VS 环境或 VC 环境）调用 CreateThread 函数实现“并发地画圆和画方”。圆的中心，半径，颜色，正方形的中心，边长，颜色等参数自己确定，合适就行。圆和正方形的边界上建议取 720 个点。为直观展示绘制的过程，每个点绘制后睡眠 0.2 秒~0.5 秒。 实验过程 下面是对于每一个任务的原理和过程的简述： 父子进程 在 Linux 中，可以使用 C 语言函数式的系统调用 getpid获得当前进程的 ID，可以使用getppid获得可能存在的父亲进程 ID。为了存储这些函数返回的中间值，可能还需要引入sys/type.h。 系统调用fork可以复制当前的进程并创建一个一样的进程，子进程的控制流从调用该函数的位置开始；它的返回值可能有如下三种情况： 在父亲进程中，该函数返回子进程的 pid。 在孩子进程中，该函数返回 0. 出现错误时，该函数设置 errno 位并且返回负值。 一般来说fork函数是不会出错的，它仅会在两种情况下出错：要不是当前的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN；要不是系统内存不足，这时errno的值被设置为ENOMEM。 正因为fork函数的返回值有着上面所说的特性，所以可以在不同的进程内使用它的返回值来判断当前所属的进程是父亲还是孩子。 这些函数定义在unistd.h头文件中；在 VC++6.0 中，可以在 process.h中找到。 这样，实验任务的核心代码就可以这么写： 1234567891011121314pid_t son = fork();if (son)&#123; auto ppid = getppid(); cout &lt;&lt; &quot;父親進程： pid = &quot; &lt;&lt; getpid() &lt;&lt; &quot; ppid = &quot; &lt;&lt; ppid &lt;&lt; endl; cout &lt;&lt; &quot;父親的兒子： pid = &quot; &lt;&lt; son &lt;&lt; endl;&#125; else&#123; auto ppid = getppid(); cout &lt;&lt; &quot;兒子進程： pid = &quot; &lt;&lt; getpid() &lt;&lt; &quot; ppid = &quot; &lt;&lt; ppid &lt;&lt; endl; cout &lt;&lt; &quot;兒子的父親： pid = &quot; &lt;&lt; ppid &lt;&lt; endl;&#125;cout &lt;&lt; (son ? &quot;父親進程&quot; : &quot;兒子進程&quot;) &lt;&lt; &quot;死了&quot; &lt;&lt; endl; 返回值不为 0，就是父亲进程，否则就是儿子进程。在这个实验里这样做就够了。 创建线程 - Linux 在Linux环境下创建线程使用的系统调用是pthread_create，它定义在pthread.h中；声明是下面这样子的： 123456int pthread_create( pthread_t *restrict tidp, const pthread_attr_t *restrict_attr, void *(*start_rtn)(void *), void *restrict arg ); 每个参数的含义是这样的： 是新创建的线程ID指向的内存单元，也就是指向线程标识符的指针；这是一个out属性，该函数为它赋值为创建的新进程的标识符；利用这个标识符可以做一些其他的事情。 用来设置线程的属性。默认值为NULL，我们一般也直接使用默认值。 新创建的程序要运行的函数首址，也就是一个函数指针。这个函数必须接受一个 void*指针作为参数，并返回一个void*作为返回值。当然，你也可以强制类型转换。 是上面那个函数运行需要的参数，当然是一个void*指针。 一般来说，调用此函数时应当避免传入会被其它线程修改的变量作为参数。一般都是先memcpy之后再将复制品的首地址作为参数传入。此外，第二个参数缺省的时候创建的线程是非分离属性的，这意味着它结束的时候，它所占用的系统资源并没有真正的释放。只有使用pthread_join返回后，或者这个线程指定为分离属性时，才可以保证线程占用的资源被释放。 此外，还可以使用pthread_join函数获得线程函数的返回值，它的声明如下： 1int pthread_join __P (pthread_t __th, void **__thread_return); 它可以用来等待一个线程的结束并且获得返回值：第一个参数是线程标识符，也就是上面pthread_create函数通过第一个参数传出的标识符；第二个参数是线程函数的返回值指针的指针，是一个out属性。 这个函数是一个阻塞函数，如果某线程调用此函数等待另一个线程，那么该线程将持续阻塞直到被等待的线程结束并给出返回值；函数返回后，被等待线程的资源被收回，返回 0；如果此函数出错，将会返回错误号。 综上所述，本题的核心代码可以这么写： 1234567891011121314151617181920212223pthread_t sign_A, sign_B;parameter para_A = &#123;114514&#125;, para_B = &#123;1919810&#125;;if (pthread_create(&amp;sign_A, nullptr, reinterpret_cast&lt;func&gt;(threadA), &amp;para_A))&#123; cerr &lt;&lt; &quot;綫程 A 創建失敗，程序退出……&quot; &lt;&lt; endl; exit(EXIT_FAILURE);&#125;if (pthread_create(&amp;sign_B, nullptr, reinterpret_cast&lt;func&gt;(threadB), &amp;para_B))&#123; cerr &lt;&lt; &quot;綫程 B 創建失敗，程序退出……&quot; &lt;&lt; endl; exit(EXIT_FAILURE);&#125;void *res_A, *res_B;pthread_join(sign_A, &amp;res_A);pthread_join(sign_B, &amp;res_B);cout &lt;&lt; (char*)res_A &lt;&lt; endl;cout &lt;&lt; (char*)res_B &lt;&lt; endl;exit(EXIT_SUCCESS); threadA和threadB并没有定义为上述参数类型的函数；但是因为参数、返回值的大小是一致的，可以安全的使用强制类型转换转为指定类型的函数。 此外，因为pthread并不是Linux系统的默认库，所以如果使用命令行编译，需要加上编译指令-lpthread来链接相关的库；如果您使用 CMake 管理您的项目，还需要在 CMakeList.txt 中加上下面的内容： 123add_compile_options(-lpthread)find_package(Threads REQUIRED)target_link_libraries(main Threads::Threads) 其中，main 是你的项目目标名，可以在这个文档中找到。 创建线程 - Windows 在Windows中创建子进程需要用到CreateThread函数；在不使用CRT库的情况下，一般需要通过这个函数创建新进程；并使用WaitForMultipleObjects或者WaitForSingleObject等待线程的结束；使用GetExitCodeThread获得线程函数的返回值；并且使用CloseHandle关闭创建的线程对象。 CreateThread函数定义在processthreadsapi.h中，但是我们只需要通过引入windows.h来引入就好了；这个函数的声明式是下面这个样子的： 12345678HANDLE WINAPI CreateThread( _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ SIZE_T dwStackSize, _In_ LPTHREAD_START_ROUTINE lpStartAddress, _In_opt_ LPVOID lpParameter, _In_ DWORD dwCreationFlags, _Out_opt_ LPDWORD lpThreadId ); 一共接受六个参数，它们的含义如下： 表示线程内核对象的安全属性，一般使用NULL表示采用默认值：不可以被子线程继承 设置新线程的初始栈大小(B)，0 表示和调用线程相同（默认1MB）；因为Windows会根据需要自动延长栈空间，所以一般传入 0 就好了。 指向线程函数的指针，函数类型是 function&lt;DWORD WINAPI (LPVOID&gt;，多个线程可以共用一个函数；实际函数也可以不接受参数不返回，也可强制转换为LPTHREAD_START_ROUTINE类型使用。 传递给上面函数的参数，是void*类型；一般指向结构体，或者传入NULL表示不传参。 线程标志，用来控制新线程的创建：0 表示创建后立即调度，CREATE_SUSPENDED表明创建后立即挂起，直到函数ResumeThread被调用；还有一些其他的可选值。 是一个out属性，用来保存新线程的 ID。 当线程创建成功时，函数返回一个表示新线程对象的HANDLE；否则返回false。 虽然此函数有很多更推荐的替代，比如BeginThread；但是这里直接使用它就够了。 WaitForSingleObject函数用来等待线程：当指定线程（对象）处于有信号状态或者等待时间结束的状态时，此函数会返回；它的声明如下： 1234DWORD WaitForSingleObject( HANDLE hHandle, DWORD dwMilliseconds); 第一个参数是指向对象的HANDLE，第二个参数是等待的时间；这个函数使得当前线程进入等待状态，直到它返回；只可以等待HANDLE指定的那个支持被通知/未通知的内核对象，等待时间由第二个参数指定，一般使用INFINITE作为等待无穷时间；但是如果等待对象永远不改变状态，那么调用线程将不会被唤醒，但是也不会浪费CPU时间。 若对象变为已通知状态，则函数返回WAIT_OBJECT_0；若等待时间超过了设定的时间，返回WAIT_TIMEOUT；若函数错误（比如将一个无效句柄传给了它），则返回WAIT_FAILED，此时可以用GetLastError获得详细信息。 WaitForMultipleObjects则和上面的函数很像，但是可以同时等待多个内核对象，它的声明如下： 123456DWORD WaitForMultipleObjects( DWORD dwCount, CONST HANDLE *phObjects, BOOL fWaitAll, DWORD dwMilliseconds); 它的四个参数的含义如下： 需要让此函数等待的内核对象数量，范围在[1, MAXIMU M_WAIT_OBJECTS]内。 是内核对象HANDLE的数组，也就是数组第一个对象的指针。 表示此函数的工作方式：TRUE表示所有对象变为已通知状态后才返回；FALSE状态表示任一个对象状态变为已通知之后就返回。 等待时间，和WaitForSingleObject中的第二个参数一样。 使用的限制也和上面的函数大体相同。 GetExitCodeThread可以用于获取一个已经退出/中止的的线程对象的退出代码。比起说“获取”，“检查”应该更加合适：它不同于上面的两个等待的函数会使得调用线程进入等待状态，当它发现待检查的线程对象仍然活动的时候，它就会立即退出，而不阻塞当前进程（所以循环的调用这个函数是一种阻塞的等待）。它的声明如下： 1234BOOL GetExitCodeThread ( HANDLE hThread, LPDWORD lpExitCode ); 第一个参数是指向线程对象的HANDLE；第二个对象是一个out属性，用来储存线程结束的代码或返回值。返回值仅表示该函数是否调用成功，并不代表线程对象是否已经中止。 若检查的HANDLE代表的线程仍然在运行，那么这个函数会为第二个参数赋值STILL_ACTIVE；否则将函数的返回值赋值给它；一个危险的状况是，当函数返回值就是STILL_ACTIVE时，此函数会失效。因为LPDWORD大小有限，所以线程函数的返回值最好是一个指向结构体的指针。 最后，因为Windows中，线程执行完毕中止后线程对象仍然存在，所以需要使用CloseHandle手动关闭句柄。这个函数的声明式是这样的： 1BOOL CloseHandle(HANDLE hObject); 参数是一个用来表示已经打开的对象（包括线程）的HANDLE；返回值仅表示函数执行成功与否，返回FALSE时可以通过GetLastError来获得错误原因。 这个函数实质的工作就是减少该内核对象的引用次数 1，而不是直接关闭对象——当一个对象引用计数为 0 或进程结束时会自动被操作系统回收，所以可能存在调用该函数后系统对象仍然存在以至于泄露的情况。 综上所述，已经理清楚在Windows中一个线程的生老病死的全过程；所以核心代码可以这么写： 1234567891011121314151617181920212223242526272829303132333435363738394041424344parameter para_A = &#123;114514&#125;, para_B = &#123;1919810&#125;;HANDLE hThread[2];DWORD exitCode[2];DWORD threadId[2];WINBOOL close = 0;if (!(hThread[0] = CreateThread( nullptr, 0, threadA, (LPVOID)&amp;para_A, 0, &amp;threadId[0])))&#123; cerr &lt;&lt; &quot;進程 A 創建失敗，程序即將退出……&quot; &lt;&lt; endl; exit(EXIT_FAILURE);&#125;else cerr &lt;&lt; &quot;進程 A 創建成功，進程ID是 &quot; &lt;&lt; threadId[0] &lt;&lt; endl;if (!(hThread[1] = CreateThread( nullptr, 0, threadB, (LPVOID)&amp;para_B, 0, &amp;threadId[1])))&#123; cerr &lt;&lt; &quot;進程 B 創建失敗，程序即將退出……&quot; &lt;&lt; endl; exit(EXIT_FAILURE);&#125;else cerr &lt;&lt; &quot;進程 B 創建成功，進程ID是 &quot; &lt;&lt; threadId[1] &lt;&lt; endl;WaitForMultipleObjects(2, hThread, true, INFINITE);GetExitCodeThread(hThread[0], &amp;exitCode[0]);GetExitCodeThread(hThread[1], &amp;exitCode[1]);if (exitCode[0] == STILL_ACTIVE || exitCode[1] == STILL_ACTIVE)&#123; cerr &lt;&lt; &quot;進程仍在意料之外的運行，程序即將退出……&quot; &lt;&lt; endl; exit(EXIT_FAILURE);&#125;else&#123; CloseHandle(hThread[0]); CloseHandle(hThread[1]); close = 1; cout &lt;&lt; (char*)exitCode[0] &lt;&lt; endl; cout &lt;&lt; (char*)exitCode[1] &lt;&lt; endl;&#125; 其实额外的检查内核对象状态在这里没啥意义……毕竟出了错也只能EXIT(EXIT_FAILURE)。 生产者 - 消费者 关于生产者-消费者问题：又称为有限缓冲问题。两个线程，也就是生产者和消费者线程公用同一个固定大小的缓冲区；生产者会向其中放入数据，消费者会从中取出数据；需要保证的是生产者在缓冲区满后不会再继续加入数据，消费者在缓冲区空的时候不会继续取出数据，并且回避出现死锁的情况。这里我们使用信号量机制来实现这个问题的模拟。 显然，缓冲区可以看作这个问题的临界区；而Windows引入提供了专门的临界区对象： 1234CRITICAL_SECTION cs; //声明临界区对象InitializeCriticalSection(&amp;cs); //初始化临界区对象 EnterCriticalSection(&amp;cs); //进入临界区LeaveCriticalSection(&amp;cs); //离开临界区 此外，Windows还有定义了的信号量相关的函数，可用来模拟信号量完成对于临界资源的 P-V 操作： CreateSemaphore函数可以创建一个信号量，并且返回用来代表它的HANDLE： 123456HANDLE CreateSemaphore( LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCTSTR lpName ) 它接受的参数的含义是这样的： 代表了信号量的属性；设置为NULL时取默认值 信号量的初始值，要求在[0, lpMaximumCount]范围内；=0时信号量默认处于 unsignal 状态，否则为 signal 状态。 代表信号量可到达的最大值，必须为正数。 信号量的名字，是 C 字符串；字符串的长度不能超过MAX_PATH，设置为NULL表示无名信号量；如果传入的字符串已经代表了一个信号量，则直接打开它。 函数调用成功后将返回新建信号量的 HANDLE。 OpenSemaphore函数可以打开一个已经存在的信号量，它的声明如下： 12345HANDLE OpenSemaphore( DWORD dwDesiredAccess, BOOL bInheritHandle, LPCTSTR lpName); 这个函数接受的参数的含义是这样的： 描述了对于信号量的访问权限；SEMAPHORE_ALL_ACCESS，表示可对信号量执行尽可能多的操作；SEMAPHORE_MODIFY_STATE，表示允许使用ReleaseSemaphore释放信号量，以修改信号量；SYNCHRONIZE，表示用等待函数异步的等待信号量变为signal状态。 表示信号量的可继承性；TRUE表示该 HANDLE 可以被继承。 信号量的名字，是 C 字符串； 由上述参数描述可以看出，这个函数只可以用来打开一个有名字的信号量。 此外，还有上面描述中提及的用于释放信号量的函数ReleaseSemaphore： 12345BOOL ReleaseSemaphore( HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount ); 第一个参数是要操作的信号量的 HANDLE；第二个参数是要在此信号量中释放的数量；第三个参数是一个out参数，用来存储操作前信号量的数量，如果不需要也可以传入NULL； 当信号量使用完毕之后，它也要像其他的内核对象那样使用CloseHandle函数关闭 HANDLE。 综上所述，我们可以使用信号量的释放模拟问题中的V操作，使用对于信号量 HANDLE 的等待作为问题中的P操作，就可以模拟这个问题了。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#include &lt;bits/stdc++.h&gt;using namespace std;constexpr int COUNT_THREAD = 5;constexpr int COUNT_BUFFER = 10;constexpr int WAIT_TIME = 10010;constexpr int SLEEP_SHORT = 600;constexpr int SLEEP_LONG = 1000;constexpr int MAX_DEPTH = 10086;auto createRandomMachine(int lb, int rb)&#123; if (lb &gt; rb) swap(lb, rb); uniform_real_distribution&lt;double&gt; dm (lb, rb); random_device rd; default_random_engine rm(rd()); return [=]()mutable&#123;return dm(rm);&#125;;&#125;#ifdef WIN32#include &lt;windows.h&gt;#define sleep Sleep#define null nullptr#define fout coutstruct lpParam&#123; int id; int *buf, *ft, *bk; CRITICAL_SECTION *cs; int *flag;&#125;;string getNowTime()&#123; SYSTEMTIME now; GetLocalTime(&amp;now); string date; date.append(to_string(now.wYear)); date.append(&quot;-&quot;); date.append(to_string(now.wMonth)); date.append(&quot;-&quot;); date.append(to_string(now.wDay)); return date + &quot; &quot; + to_string(now.wHour) + &#x27;:&#x27; + to_string(now.wMinute) + &#x27;:&#x27; + to_string(now.wSecond) + &#x27;:&#x27; + to_string(now.wMilliseconds);&#125;DWORD WINAPI producer(LPVOID para)&#123; auto p = (lpParam*) para; int &amp;front = *p-&gt;ft, &amp;back = *p-&gt;bk, number, &amp;flag = *p-&gt;flag; HANDLE FULL = OpenSemaphore(SEMAPHORE_ALL_ACCESS, false, &quot;full&quot;); HANDLE EMPTY = OpenSemaphore(SEMAPHORE_ALL_ACCESS, false, &quot;empty&quot;); auto rm = p-&gt;id == 1 ? createRandomMachine(1000, 1999) : createRandomMachine(2000, 2999); // ofstream fout; int time = MAX_DEPTH; while (time --) &#123; number = rm(); WaitForSingleObject(EMPTY, INFINITE); EnterCriticalSection(p-&gt;cs); p-&gt;buf[back] = number; fout &lt;&lt; getNowTime() &lt;&lt; &quot;： 生產者 &quot; &lt;&lt; p-&gt;id &lt;&lt; &quot; 生產了物品 &quot; &lt;&lt; p-&gt;buf[back] &lt;&lt; &quot;，在緩衝池的 &quot; &lt;&lt; back &lt;&lt; &quot; 位置放入。&quot; &lt;&lt; endl; ++ flag; back = (back + 1) % COUNT_BUFFER; LeaveCriticalSection(p-&gt;cs); ReleaseSemaphore(FULL, 1, null); sleep(SLEEP_SHORT); &#125; return 0;&#125;DWORD WINAPI consumer(LPVOID para)&#123; auto p = (lpParam*) para; int &amp;front = *p-&gt;ft, &amp;back = *p-&gt;bk, &amp;flag = *p-&gt;flag; HANDLE FULL = OpenSemaphore(SEMAPHORE_ALL_ACCESS, false, &quot;full&quot;); HANDLE EMPTY = OpenSemaphore(SEMAPHORE_ALL_ACCESS, false, &quot;empty&quot;); // ofstream fout; int time = MAX_DEPTH; while (time --) &#123; WaitForSingleObject(FULL, INFINITE); EnterCriticalSection(p-&gt;cs); ++ flag; fout &lt;&lt; getNowTime() &lt;&lt; &quot;： 消费者 &quot; &lt;&lt; p-&gt;id &lt;&lt; &quot; 使用了物品 &quot; &lt;&lt; p-&gt;buf[back] &lt;&lt; &quot;，从緩衝池的 &quot; &lt;&lt; back &lt;&lt; &quot; 位置取出。&quot; &lt;&lt; endl; front = (front + 1) % COUNT_BUFFER; LeaveCriticalSection(p-&gt;cs); ReleaseSemaphore(EMPTY, 1, null); sleep(SLEEP_LONG); &#125; return 0;&#125;#endifint main()&#123;#ifdef WIN32 cout &lt;&lt; &quot;實驗： Windows 下的生產者-消費者問題&quot; &lt;&lt; endl; lpParam lp[COUNT_THREAD]; CRITICAL_SECTION section; HANDLE semaphore[2], hThread[COUNT_THREAD]; DWORD threadId[COUNT_THREAD]; int buffer[COUNT_BUFFER], ft = 0, bk = 0, flag = -1; InitializeCriticalSection(&amp;section); semaphore[0] = CreateSemaphore(null, 0, COUNT_BUFFER, &quot;full&quot;); semaphore[1] = CreateSemaphore(null, COUNT_BUFFER, COUNT_BUFFER, &quot;empty&quot;); int cnt_p = 0, cnt_c = 0; for (int i = 0; i &lt; COUNT_THREAD; ++ i) &#123; lp[i] = &#123;++ (i &gt;= 2 ? cnt_c : cnt_p), buffer, &amp;ft, &amp;bk, &amp;section, &amp;flag&#125;; auto func = i &gt;= 2 ? consumer : producer; hThread[i] = CreateThread ( null, 0, func, (LPVOID)&amp;lp[i], 0, &amp;threadId[i] ); cerr &lt;&lt; &quot;進程 &quot; &lt;&lt; i &lt;&lt; &quot; 已經創建，進程ID是 &quot; &lt;&lt; threadId[i] &lt;&lt; endl; &#125; WaitForMultipleObjects(COUNT_THREAD, hThread, true, WAIT_TIME); cout &lt;&lt; &quot;模擬層數達到限制，程式即將退出……&quot; &lt;&lt; endl;#else cout &lt;&lt; &quot;這個程序需要在Windows環境下才可以正常運行的，請檢查運行平臺&quot; &lt;&lt; endl;#endif return 0;&#125; 画圆画方 根据上面的任务中了解到的 Windows 环境下创建进程所需要的知识，我们仅需要定义好画圆和画方的函数，作为进程函数传给CreateThread函数就可以了。这部分的函数我使用了 Easy X 图形库完成。它只支持在 Visual Studio / Visual C++ 环境下使用。在使用前你可能需要去 Easy X 官网上去下载它最新的安装包安装后才可以正常编译该源代码。 下面是画圆和画方的线程函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243DWORD WINAPI drawSquare(LPVOID)&#123; for (auto i = 0; i &lt; 180; i++) &#123; putpixel(50 + i, 50, WHITE); Sleep(SLEEP_TIME); &#125; for (auto i = 0; i &lt; 180; i++) &#123; putpixel(50 + 180, 50 + i, WHITE); Sleep(SLEEP_TIME); &#125; for (auto i = 0; i &lt; 180; i++) &#123; putpixel(50 + 180 - i, 50 + 180, WHITE); Sleep(SLEEP_TIME); &#125; for (auto i = 0; i &lt; 180; i++) &#123; putpixel(50, 50 + 180 - i, WHITE); Sleep(SLEEP_TIME); &#125; return 0;&#125;DWORD WINAPI drawCircle(LPVOID)&#123; auto position_x = [](int i) &#123; return 350 + 100 * cos(-PI / 2 + (double)((i * PI) / 360)); &#125;; auto position_y = [](int i) &#123; return 140 + 100 * sin(-PI / 2 + (double)((i * PI) / 360)); &#125;; for (int i = 0; i &lt; 720; i++) &#123; putpixel(position_x(i), position_y(i), WHITE); Sleep(SLEEP_TIME); &#125; return 0;&#125; 实验时只需要将它们分别交给两个线程执行就可以了。 实验结果 这里是任务完成后的截图或其他证明。 任务一：父子进程 2_1.png 任务二：多线程 - Linux 2_2.png 任务三：多线程 - Windows 2_3.png 任务四：生产者 - 消费者 2_4.png 任务五：画圆画方 2_5.png 体会 通过本次的操作系统原理实验，我熟悉了在 Linux 上和 Windows 上和线程相关的一些函数的使用；熟练了面向操作系统的编程，可以将一些基本的功能需求使用多线程技术实现。从同一个功能在 Linux 和 Windows 平台上实现的不同，进一步地体会了两个操作系统之间的差异。 实验的过程中也遇到了一些看起来不太容易解释的问题，这说明要想学好面向操作系统的多线程编程，仅仅了解函数的声明式是远远不够的。除了表面的 API 调用之外，还应该更多的去了解函数内部的构造以及实现原理。在处理这些问题的过程中，加深了我对这些原理的理解。","categories":[{"name":"课业","slug":"课业","permalink":"https://shiraha.cn/categories/%E8%AF%BE%E4%B8%9A/"},{"name":"操作系统","slug":"操作系统","permalink":"https://shiraha.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Windows","slug":"操作系统/Windows","permalink":"https://shiraha.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows/"},{"name":"Linux","slug":"操作系统/Linux","permalink":"https://shiraha.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://shiraha.cn/tags/Windows/"},{"name":"操作系统","slug":"操作系统","permalink":"https://shiraha.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"课内作业","slug":"课内作业","permalink":"https://shiraha.cn/tags/%E8%AF%BE%E5%86%85%E4%BD%9C%E4%B8%9A/"},{"name":"实验报告","slug":"实验报告","permalink":"https://shiraha.cn/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"Linux","slug":"Linux","permalink":"https://shiraha.cn/tags/Linux/"}]},{"title":"算法分析与设计：实验4实验报告","slug":"class-algorithm-experiment-report-4","date":"2020-05-04T15:56:52.000Z","updated":"2020-05-04T15:56:52.000Z","comments":true,"path":"2020/class-algorithm-experiment-report-4/","link":"","permalink":"https://shiraha.cn/2020/class-algorithm-experiment-report-4/","excerpt":"","text":"前三次实验的链接是：https://shiraha.cn/2020/class-algorithm-experiment-report-1-3/ 这次实验的代码也在：https://dev.azure.com/Pure-Asahi/2020_Spring_In_Class_Job 实验四：最短路算法 实验要求如下： ##### 实验四：单源最短路径和全点对最短路径算法 一、实验目的 掌握复杂数据结构的存储和操作方法,实现图的搜索。 二、实验条件 计算机及程序语言开发平台（如 C、C++、Java、Matlab 等）。 三、实验内容及要求 描述并实现单源最短路径算法，显示在下图上的运算结果 描述并实现全点对最短路径算法，显示在下图上的运算结果 四、思考题 - 全点对最短路径算法动态规划算法范式 - 图的存储方式和运算效率之间的关系 实验分析 下面分析两个任务可以采用的算法。 单源最短路算法 主要有 Bellman-Ford 算法、DAG 算法、Dijkstra算法。 Bellman-Ford 算法的主要思想即是对所有的边进行 V-1 次的遍历，每次对 每一条边执行一次缩短操作，缩短操作的核心就是判断 d[v] &gt; d[u] + w(u, v)，如果是的话则更新 d[v],否则不变。算法结 束后还需要进行回路检测，如果存在负回路则返回 false，否则返回真，该算法较为简单，运行开销函数是 O(VE)。基于这个算法还有中国教授进行队列优化的SPFA算法，在一般情况下效率高于 Bellman-Ford 算法，但是最坏不会差于 Bellman-Ford 算法。 DAG 算法是针对图为有向无环图的特殊情况，显然它要求没有回路。这个算法首先需要对图进行拓扑排序，完成后再进行初始化，再根据拓扑排序的顶点顺序对邻接边进行 缩短操作，缩短操作同方法一。如果排序过程中出现不需要的边，只要更新父节点即可。运行时间开销是 O(V+E)，但是该算法限制较大，只能在图又这种特殊性质的情况下才可以使用。但是也可以使用 Tarjan 缩点，对于每个SCC内部再求最短路之后再使用这个算法，这样的话效率就不能保证了。 Dijkstra 算法要求不存在负权值的边，首先把所有节点压入队列 Q 中，然后每次让节点权值最小的节点出队，然后对其临接节点执行缩短操作，Q 为空时即结束。时间复杂度是 O(V*lgV+E)。实际实现的时候，可以使用堆进行贪心优化，使得实现的算法速度更快。 全点对最短路径算法 可以进行n次单源最短路径算法，也可以进行动态规划。 进行n次单源最短路径算法并不经济。单源最短路算法的复杂度大多和 E 相关，但是 E 的上限可以是 V²。当待解决问题的图是一个稠密图的时候，n次单源最短路径算法将会退化到 O(V³·logV) 甚至是 O(V⁴)，这是非常不好的。 动态规划法对于稠密图而言是很好的，唯一的缺点是会占用一定的空间：通过建立一个V*V的数组进行递推得到答案。这样做的正确性在于：最短路径的部分路径必然是最短的。因此，通过多个最短部分路径就可以找到全路径的最小值，每一个找到的部分最短路径也是它端点的最短值，没有进行重复的查找，时间复杂度是 O(V³)。经典的实现就是 Floyd 算法，它就是 O(V³) 的。 算法实现 首先，我们将图的边描述出来；点的编号从 1 开始，{u, v, w} 代表从 u 出发到达 v 的边，边权是 w。 单源最短路径的图可以这样描述： 123456789101 2 6 1 4 7 2 3 52 5 -42 4 83 2 -24 3 -34 5 95 1 25 3 7 起点是点 1. 全点对最短路径的图可以这样描述： 1234567891 2 31 3 81 5 -42 4 12 5 73 2 44 1 24 3 -55 4 6 上述数据将作为算法实现的输入。 对于单源最短路问题，因为题目所给的图包含负边权，所以不能够使用堆优化的Dijkstra算法，因此实现为使用了队列优化的SPFA算法。因为图并不算是稠密图，使用链式前向星存储图。使用memset可以设置的可加和的最大值0x3f3f3f3f3f3f3f3f作为INF值。 这里是链式前向星的简单实现，由于C++特性避免动态分配内存，限制了最大顶点数为100： 1234567891011121314151617181920212223242526272829struct edge &#123; int u, v, w; int next; edge() = default; edge(int u, int v, int w, int next) :u(u), v(v), w(w), next(next) &#123;&#125;&#125;;const int N = 100;struct fws &#123; int head[N + 1]&#123;&#125;; int tot&#123;&#125;; edge ee[(N + 1) * (N + 1) * 2]&#123;&#125;; fws() &#123; memset(head, -1, sizeof head); tot = 0; &#125; void addEdge(int u, int v, int w) &#123; ee[tot] = edge(u, v, w, head[u]); head[u] = tot ++; &#125; edge &amp;getEdge(int index) &#123; return ee[index]; &#125;&#125;; 然后就是最短路的核心算法SPFA的实现： 123456789101112131415161718192021222324long long *spfa(fws &amp;graph, int start, int n) &#123; if (start &lt; 0 || start &gt; n) return nullptr; auto *ans = new long long[n + 1]; std::queue&lt;int&gt; heap; bool visit[N + 1] &#123; 0 &#125;; memset(ans, 0x3f, sizeof(long long) * (n + 1)); heap.push(start); visit[start] = true; ans[start] = 0; while (!heap.empty()) &#123; auto now = heap.front(); heap.pop(); visit[now] = false; for (auto ii = graph.head[now]; ~ii; ii = graph.getEdge(ii).next) if (ans[now] + graph.getEdge(ii).w &lt; ans[graph.getEdge(ii).v]) &#123; ans[graph.getEdge(ii).v] = ans[now] + graph.getEdge(ii).w; if (!visit[graph.getEdge(ii).v]) &#123; heap.push(graph.getEdge(ii).v); visit[graph.getEdge(ii).v] = true; &#125; &#125; &#125; return ans;&#125; 每次搜索到邻接的边的时候，就观察它是否能缩短到达新边终点的距离；如果可以，那就对这个节点进行进一步松弛，将它加入队列；执行结果可以看后面。 对于全点对最短路问题，可以使用矩阵记录每两个顶点之间的最短路径，并且使用 Floyd 算法完成最短路径的计算。下面是核心的 Floyd 算法实现： 123456789101112131415long long **floyd(long long **graph, int n) &#123; auto a = new long long*[n + 1]; for (int i = 1; i &lt;= n; ++ i) &#123; a[i] = new long long[n + 1]; memset(a[i], 0x3f, sizeof(long long) * (n + 1)); &#125; for (int k = 1; k &lt;= n; ++ k) for (int i = 1; i &lt;= n; ++ i) for (int j = 1; j &lt;= n; ++ j) a[i][j] = std::min( std::min(a[i][j], a[i][k] + a[k][j]), std::min(graph[i][j], graph[i][k] + graph[k][j]) ); return a;&#125; Floyd 算法的核心思想就是上面说到的动态规划。 上述的两个算法输入样例后的输出如下： KNJaS4KXVZTGXQU6R2IY_W.png 显然，这些答案是正确的。 思考题 全点对最短路径算法动态规划算法范式 Step1：描述最优解的结构特征：最短路径的部分路径必然是最短的 Step2：定义最优解决方案的递归形式 \\[ \\begin{cases} m = 0: l_{i,j}^{(0)} = \\begin{cases} 0 ,&amp; i = j \\\\ ∞ ,&amp; i \\ne j \\end{cases} \\\\ m \\ge 1: l_{i,j}^{(m)} = min_{1\\le k\\le n} \\ l_{i,k}^{(m-1)}+w_{k,j} \\end{cases} \\] Step3：以自底向上的方式计算优解决方案的值：从最多只有 0 条边开始，一直计算到最多有 V-1 条边结束 Step4：从计算信息构造出优解决方案 由于不必计算所有 L(m)，而且如果没有负回路,可以得到： L(m) = L(n - 1) 对所有 m &gt;= n – 1 成立,所以我们可以通过下式计算： \\[ L^{(2n)} = W^{2n} = W^n \\cdot W^n \\] 图的存储方式和运算效率之间的关系 选择合适的数据结构，当然可以提高运算的效率；比如若采用矩阵的方式存储边集，如果在边不密集的情况下，那么有很多的空间将被浪费；除此之外，当遍历矩阵时，会有很多的无效遍历；所以对于稀疏图而言，链式前向星将是一种更加有效的方法：既不会很浪费空间（甚至在很多情况下比邻接矩阵还要节约空间），也可以很快的遍历；对于存在双向边的图而言，使用链式前向星还可以方便的通过^1找到边的反向边，还可以直接顺序遍历所有的边，从而为很多算法做好了基础。 在绝大多数的情况下，如果不是图比较稠密或者使用 Floyd 这种必须要使用矩阵存边的算法的时候，使用链式前向星存图是最优解。 后记 最后一次的算法比较板子，没什么代码量。最短路是很基础的算法了，但是很多思想都可以在其他的地方使用。即使是最短路算法的题目，也可以出的非常花哨。","categories":[{"name":"课业","slug":"课业","permalink":"https://shiraha.cn/categories/%E8%AF%BE%E4%B8%9A/"}],"tags":[{"name":"课内作业","slug":"课内作业","permalink":"https://shiraha.cn/tags/%E8%AF%BE%E5%86%85%E4%BD%9C%E4%B8%9A/"},{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"C++","slug":"C","permalink":"https://shiraha.cn/tags/C/"},{"name":"实验报告","slug":"实验报告","permalink":"https://shiraha.cn/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"}]},{"title":"点分治 & 动态点分治 - 学习笔记","slug":"learn-point-dc-on-tree-and-dynamic-point-dc","date":"2020-04-23T08:01:12.000Z","updated":"2020-04-23T08:01:12.000Z","comments":true,"path":"2020/learn-point-dc-on-tree-and-dynamic-point-dc/","link":"","permalink":"https://shiraha.cn/2020/learn-point-dc-on-tree-and-dynamic-point-dc/","excerpt":"","text":"开始之前首先是题单：这些题目都是洛谷上的，非常的友好（指访问上）；如果你有什么觉得不错的点分治的题目也可以评论告诉我，我去康康== 点分治 洛谷 P2634 [国家集训队]聪聪可可： 立即前往&gt;&gt; 洛谷 P3806 【模板】点分治1： 立即前往&gt;&gt; 洛谷 P4178 Tree： 立即前往&gt;&gt; 洛谷 P2664 树上游戏： 立即前往&gt;&gt; 洛谷 P4149 [IOI2011]Race： 立即前往&gt;&gt; 洛谷 P2305 [NOI2014]购票： 立即前往&gt;&gt; 洛谷 P2993 [FJOI2014]最短路径树问题： 立即前往&gt;&gt; 洛谷 P4292 [WC2010]重建计划： 立即前往&gt;&gt; 动态点分治 洛谷 P2056 [ZJOI2007]捉迷藏： 立即前往&gt;&gt; 洛谷 P3345 [ZJOI2015]幻想乡战略游戏： 立即前往&gt;&gt; 洛谷 P3241 [HNOI2015]开店： 立即前往&gt;&gt; 洛谷 P3676 小清新数据结构题： 立即前往&gt;&gt; 洛谷 P3920 [WC2014]紫荆花之恋： 立即前往&gt;&gt; 其他补充 弹幕装填中…… 因为我很屑，不能保证一次把上边的题目做完，所以需要吊在开头时刻警醒自己== 那么接下来开始本篇文章的正文内容： 背景 点分治是图论中一种树上分治的算法。树分治主要又有两种：点分治和边分治，还有一种以这个为思想的分治树。这里的点分治就是这篇文章要讨论的点分治。 有些题目看起来像是可以使用树上动规，但是却很难使用数组去维护它所需要的信息，这种题目往往需要点分治来解决。通过直接统计或者加上数据结构维护，就可以统计之前不好统计一些的东西。 顾名思义，点分治是一种分治，还是在点上的分治。每次把无根树拆成子树，递归进行处理，最后通过计算贡献的方式将计算结果合并，得到最终整个树的答案。 点分治 刚才也说了，点分治是分治，需要递归的处理子树。事实上代码里也是成块成块的DFS。显然，这样的递归的时间受到它最大的子树的大小的影响：比如极端情况下，链的递归时间复杂度是O(n²)。但是比起一般的搜索，点分治在拆分之前会优先寻找无根树的重心，将它作为根进行递归。 树的重心： 以重心为此无根树的根，这棵树的最大子树最小。若全树的大小为n，以重心为根时的每一个子树的大小都不超过n/2（可使用反证法证明）。 如果每次递归都是寻找树的重心进行，那么递归层数一定是最优的。所以本质上，点分治是优化的暴力，在合并过程还会用到容斥原理的思想。点分治每次递归都选择重心作为分治点，问题规模上界降低到原来的1/2，使得整体的复杂度降低到O(nlogn)。 接下来通过解最经典的点分治的题目洛谷 P4178 Tree，来详细说明点分治的每一个过程。建议看下面的内容之前先去读个题，或者拉到后面看完这个题的题解。 求树的重心 知道了重心好，那么怎么找到这个最优的分治点呢？暴力找：DFS的话可以在O(n)的时间里找到。findRoot函数可以找到一颗无根树的重心，将无根树转化为有根树，利用递归统计子树大小。这里的代码和后面的代码都使用了前向星存树，使用了FWS的一些经典变量： 123456789101112131415int findRoot(int u, int father)&#123; size[u] = 1; int maxPart = 0; for (int c = head[u]; ~c; c = ee[c].next) &#123; edge&amp; e = ee[c]; int&amp; v = e.v; if (v == father || vis[v]) continue; findRoot(v, u); size[u] += size[v]; maxPart = max(maxPart, size[v]); &#125; maxPart = max(maxPart, _sum - size[u]); if (maxPart &lt; _part) setRoot(u, maxPart); return _root;&#125; 上面的函数中：size[u]表示以u在当前递归的顺序下作为根节点的子树的大小（节点数量）；maxPart用来记录当前已经找到的最大子树；_sum保存了当前查找重心的全树的大小；_part和_root用来暂存结果：重心节点的编号和它的max-part，使用宏setRoot更新。 因为整个树是无根树，所以子树大小也只是“当前递归的顺序下作为根节点”意义上的。也就是说，虽然这个点可能是被递归调用的，father是有意义的节点；但是因为是无根树，节点u的“当前递归的顺序下“的父节点以及其他兄弟节点，也可以被看作u的一颗子树——这棵子树的大小就使用容斥原理进行计算：sum - size[u]。 显然，你的顶层调用（非递归调用）是为了寻找一整颗树的重心：你需要将_sum初始化为这棵树的大小、_part初始化为无穷大、_root初始化为不存在的节点，然后才能开始搜索。我写了宏cleanRoot来完成这项工作。 从重心开始分治 我们知道了重心，那么就可以以重心作为分治点开始分治递归了。虽然具体的分治函数要取决于问你的模型，但是分治函数具有相似的特点。对于这个题目，我们做出的分治是：对于每颗树，只考虑经过它的根的路径；其他的路径因为一定会经过子树的根，所以作为子问题分治。 这里贴的代码仅针对这道题目： 1234567891011121314void dc(int u)&#123; ans += process(u, 0); //////////////////////// vis[u] = true; for (int c = head[u]; ~c; c = ee[c].next) &#123; edge &amp;e = ee[c]; int &amp;v = e.v; if (vis[v]) continue; ans -= process(v, e.w); //////////////////// cleanRoot(size[v]); auto root = findRoot(v, u); dc(root); &#125;&#125; 两行用斜杠标记的部分是本题特殊的地方；一般的核心分治函数的大概结构就像上面这样。process是本题中用来计算答案的函数；宏cleanRoot用来重置root信息。 对于本题，process函数可以求出当前树中所有子节点到根节点的距离。我们先看它出现的两行：第一次出现不难理解，要求出经过根节点的路径，必然要先求出这些”半路径“进行组合；但是第二次出现却显得有些莫名其妙。 首先我们考虑下面的树： 1126418-20180317225729674-1956875804.png 第一行的process会求出这些半边：\"A\"、\"A - B\"、\"A - B - D\"、\"A - B - E\"、\"A - C\"、\"A - C - F\"——准确的说是将它们的长度可重复的存进数组。根据分析，接下来只要将它们俩俩组合，就可以得到分析的”通过树根的路径“。但是显然，\"A - B - D\"、\"A - B - E\"组合得到的\"D - B - A - B - E\"并不是一条合法路径。 究其原因，是因为参加组成的两条”半边“都来自于A的同一颗子树B。所以，最直接的方法，就是对于每颗子树单独统计来自它的到根的边的贡献，将它们从答案中减去。因为此时求的仍然是到根A的距离，但是DFS从B开始，所以统计得到到B的长度都应该加上\"A - B\"的边长。 这样利用容斥原理，最终在这次分治中对答案造成的贡献，就是分析中要求的”经过根节点的路径“。对于这个节点，总的时间复杂度是O(nlogn)。非常好。 那么接下来的分治的时间复杂度要怎么保证呢？这个时候，应该再次意识到这是一颗无根树——将一个节点算完之后，它的子树之间就互不影响了。对于它的每颗子树，我们都可以当作一个新问题——找到重心保证最优递归深度，然后继续分治。又因为重心的子树的大小不超过全树的一半，每次寻找重心的递归深度上界是logn，因此整体复杂度是O(nlog²n)。 能看到上面的代码的后半部分就是：首先重置并且寻找子树的重心，然后对子树启动分治。 子树找重心 因为子树完全和全树是同样的问题，所以可以采用同样的流水线：先初始化root，再从子树的”第一个端点“——也就是直接和上一轮的重心相连的节点开始找到重心，然后启动分治。 这里有一个问题：最开始，对于全树而言，_sum = n并没有什么问题。但是对于子树来说，_sum == size[u]真的成立吗？因为是无根树，子树中直接连接上轮重心的节点未必是本轮这颗子树的重心：这导致本轮处理的传入的树的总点数可能并不正确。我先列出正确的式子： 12- _sum = size[v];+ _sum = size[v] &gt; size[u] ? _sum - size[u] : size[v] 要想知道之前设置为size[v]对不对，我们首先要知道size是怎么来的：这里传入的size[v]，准确的定义是”本轮中与上一轮的重心相连的点，以上轮的根为根（父节点）的子树大小“。因为是无根树，我们已经知道了”根“可能并不是”重心“，于是就有可能出现下图所示的情况： RYH4YJ_5YN_XTMNHS2TD80K.png 上一轮的根为v，重心为u：此时若对重心u的子树v进行寻根，很显然size[v]并不是子树的大小。当本轮的根（起始搜索点）和上轮的根在上轮的重心的同一颗子树中的时候，size[v]是错误的值，应当修正。 但是这个错误真的影响这个算法的复杂度或正确性吗？我们先回顾一下我们的寻找重心的方式：从本轮的”根“开始DFS，并且计算子树大小；将传入的全树大小与以自身为根的子树大小的差作为”根方向“的子树的大小，从而计算最大子树的大小。 结论是不影响的，所以大可不必写麻烦的代码。数学证明可以去看这篇文章：传送门 算法流程 总结一下上面的内容，可知针对于无根树的点分治算法一共分为三步： 找到当前全树的重心，并以该重心作为分治点 启动分治，并且调用解题/计算函数处理当前树的整体 找到每一颗子树的重心，作为子问题发起新的分治 难点就在解题/计算函数的设计。一般而言，点分治适合处理树上简单路径的问题，但是也不止于此。很多题目通过巧妙的构造计算函数，也可以使用点分治快速解决。至于分治的设计：处理树上简单路径的时候，往往将树上的路径分为经过当前分治点的和不经过分治点的两种类型：第一类在本次分治时使用其他函数处理，第二类作为子问题递归处理。 动态点分治 刷题记录 这里刷题的顺序可能和上面的题单顺序不一样，请明察（ 洛谷 P4178 Tree 文 明 起 源（大雾； 这里只介绍点分治做法 给定一颗n个节点的有边权树，求树上两点距离小于等于k的点对数量。 数据规模：N = 4e4，边权小于1000，K = 2e4 虽然上面讲点分治已经非常仔细的介绍了，这里就简单的进行一下分析： 显然这个题目没办法用简单的DFS来统计——那应该怎么在DFS中统计树中符合条件的路径数量？一般的DFS对于这种树上路径统计的问题是苦手的。 假设我们已经找到了全树重心root。对于全树中的路径，我们把它分为两类：第一类经过了root，另一类没经过。显然，后者一定完全在t的某棵子树里面，而前者不在。也就是说，答案 = 经过root的路径的答案 + root的所有子树的子问题的答案；对于子问题，直接递归，只需要考虑第一类答案即可。 第一类答案是通过根节点的路径长度。这种长度显然可以拆成两条从根节点出发的简单路径的长度和，然而从根节点出发的简单路径的长度是很容易DFS得到的。对于一棵树，可以将从根节点出发得到的所有路径长度存进数组里，然后将它们两两匹配，就可以得到第一类路径。 这里还存在隐含的问题：若两条简单路径来自于根的同一颗子树，则它们组成的路径含有重边，是无效的；对于这种情况，我们依然可以利用容斥思想：仅统计子树中的节点到根的简单路径，将这些简单路径的贡献从答案中剔除，剩下的就都是来自不同子树的简单路径的贡献了。 统计完一棵树中所有路径长度之后，可以利用双指针的策略来获得所有满足要求的匹配的数量。至此，我们知道这样的实现步骤： DC主操作：统计全树合法匹配，对每一棵子树利用容斥减去来自同子树的贡献 计算函数：DFS计算全树所有节点到根的距离，并且存入特定数组 统计函数：利用双指针的技巧，统计出计算函数求出的路径的合法对数，并返回DC主操作 这样，就可以修改模板解出这个题目了。具体实现请看下面的全部代码。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;using longs = long long;const int inf = 0x3f3f3f3f;struct edge&#123; int u, v, w, next; edge() = default; edge(int u, int v, int w, int next) : u(u), v(v), w(w), next(next) &#123;&#125;&#125;;const int N = 4e4+5, M = N;int n, k, ans = 0;namespace FWS&#123; int head[N]; int tot; edge ee[M * 2]; void init() &#123; memset(head, -1, sizeof(int)*(n+1)); tot = 0; &#125; void addedge(int u, int v, int w) &#123; ee[tot] = edge(u,v,w,head[u]); head[u] = tot ++; &#125;&#125;namespace PointDC&#123; int size[N]; // size统计整个子树大小 bool vis[N]; // 记录子树是否已经被分治处理过 int _sum; // 记录将要分治的子树大小，以计算另一个子树的大小 int _root; // findRoot中用来临时记录找到的重心 int _part; // findRoot当前找到的重心的maxPart int path[N], cnt = 0; void(*calculate)(int,int,int) = [](int u, int father, int distance) &#123; path[cnt ++] = distance; using namespace FWS; for (int c = head[u]; ~c; c = ee[c].next) &#123; edge&amp; e = ee[c]; int&amp; v = e.v; if (v == father || vis[v]) continue; calculate(v, u, distance + e.w); &#125; &#125;; auto cleanRoot = [](int size) &#123; _root = 0; _part = inf; _sum = size; &#125;; auto setRoot = [](int u, int maxPart) &#123; _part = maxPart; _root = u; &#125;; inline void init() &#123; memset(vis, 0, sizeof(bool) * (n + 1)); setRoot(0, inf); &#125; int findRoot(int u, int father) &#123; size[u] = 1; int maxPart = 0; using namespace FWS; for (int c = head[u]; ~c; c = ee[c].next) &#123; edge&amp; e = ee[c]; int&amp; v = e.v; if (v == father || vis[v]) continue; findRoot(v, u); size[u] += size[v]; // 统计子树大小，以找到最大子树 maxPart = max(maxPart, size[v]); &#125; maxPart = max(maxPart, _sum - size[u]); if (maxPart &lt; _part) setRoot(u, maxPart); return _root; &#125; int process(int u, int distance) // 双指针做法 &#123; cnt = 0; calculate(u, 0, distance); int _ans = 0, l = 0, r = cnt - 1; sort(path, path + cnt); for (;; ++l) &#123; while (r != -1 &amp;&amp; path[l] + path[r] &gt; k) -- r; if (r &lt; l) break; _ans += r - l + 1; // 这个区间都可以和l配对 &#125; return _ans; &#125; void dc(int u) &#123; ans += process(u, 0); vis[u] = true; using namespace FWS; for (int c = head[u]; ~c; c = ee[c].next) &#123; edge &amp;e = ee[c]; int &amp;v = e.v; if (vis[v]) continue; ans -= process(v, e.w); // 只需要来自不同子树的配对 cleanRoot(size[v]); auto root = findRoot(v, u); dc(root); &#125; &#125; void solution() &#123; init(); cleanRoot(n); auto root = findRoot(1, 0); dc(root); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); auto addEdge = [&amp;](int u, int v, int w) &#123; FWS::addedge(u, v, w); FWS::addedge(v, u, w); &#125;; // freopen(R&quot;(D:\\shiroha\\Downloads\\P4178_1.in)&quot;, &quot;r&quot;, stdin); cin &gt;&gt; n; int u, v, w; FWS::init(); for (int i = 1; i &lt; n; ++ i) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; addEdge(u, v, w); &#125; cin &gt;&gt; k; PointDC::solution(); cout &lt;&lt; ans - n &lt;&lt; endl; // 答案不包括单点 return 0;&#125; 这个题目似乎还有其他的解法，但是这里就不赘述了。 洛谷 P3806 【模板】点分治1 我做的第一个点分治的题目（毕竟是模板 给定一颗 n 个节点的有边权树，询问树上距离为 k 的点对是否存在，询问 m 次。 N = 1e4，M ≤ 100，边权小于1e4，K = 1e7 和上一个题非常相似，只不过询问的东西变成了是否等于 k，并且询问的次数变多了。 每询问一次就找一次显然不太合算，反正题目也没有要求强制在线，可以一次读入所有的请求，然后离线处理所有的答案，最后统一输出。 和上一题一样，这一题也可以用一个DFS将全树/某一子树所有可能出现的到根节点的距离求出来。但是这一次如果像上一题那样求出所有的和，想必是不太划算的。为判断长度为k的边是否存在，每次扫完一颗子树之后，就求出询问长度对这次求出的路径长度的差，并记录。之后如果扫描到的长度恰好存在相等的”差“的记录，就说明它一定可以和之前子树中出现的某条路径组合成满足要求长度的边。 这是一种比较巧妙的做法：不仅避免了两条路径同源的问题，还避免了求出所有的路径和查找。记录这些”差“，可以采用访问是O(1)的桶。 注意到题目中说到询问的最大值是K，那么就可以使用K作为桶的大小：不论是超过K的边还是超过K的”差“的记录，一定不会对答案造成贡献，可以直接忽视。事实上，内存限制也不允许我们开太大的桶。 代码 其实这才是我做的最早的一个点分治的题目，有些风格和现在的不一样。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;functional&gt;using namespace std;struct edge&#123; int u, v, w, next; edge() = default; edge(int u, int v, int w, int next) : u(u), v(v), w(w), next(next) &#123;&#125;&#125;;const int N = 10010, M = N;const int INF = 0x3f3f3f3f;int n, m, queries[105];namespace FWS&#123; int head[N]; int tot; edge ee[M*2]; void init() &#123; memset(head, -1, sizeof(int)*(n+1)); tot = 0; &#125; void addedge(int u, int v, int w) &#123; ee[tot] = edge(u,v,w,head[u]); head[u] = tot ++; ee[tot] = edge(v,u,w,head[v]); head[v] = tot ++; &#125;&#125;namespace PointDC&#123; int maxPart[N]; // subtree记录最大子树 int size[N]; // size统计整个子树大小 bool vis[N]; // 记录子树是否已经被分治处理过 int sum; // 记录将要分治的子树大小，以计算另一个子树的大小 int _root; // findRoot中用来临时记录找到的重心 const int buf = 1e7; // 标记距离的桶大小：询问的上限 bool has[buf+5]; // 到根距离为i的路径是否存在 int rem[N]; // 记录全树中可能出现的路径长度；[0]记录实际长度 int dis[N]; // 记录节点到子树根的距离 int can[N]; // calculate中，和cnt一起用来临时记录出现过的距离 int* _query; // 离线算法：记录的询问 int _count; // 离线算法：询问的数量 bool test[N]; // 离线算法：用来标记i号询问的结果 inline void init() &#123; memset(vis, 0, sizeof(bool) * (n + 1)); memset(has, 0, sizeof(bool) * (n + 1)); memset(test, 0, sizeof(bool) * (n + 1)); _query = ::queries; _count = ::m; _root = 0; rem[0] = 0; &#125; int findRoot(int u, int father) &#123; size[u] = 1; maxPart[u] = 0; using FWS::head; using FWS::ee; for (int c = head[u]; ~c; c = ee[c].next) &#123; edge&amp; e = ee[c]; int&amp; v = e.v; if (v == father || vis[v]) continue; findRoot(v, u); size[u] += size[v]; // 统计子树大小，以找到最大子树 maxPart[u] = max(maxPart[u], size[v]); &#125; maxPart[u] = max(maxPart[u], sum - size[u]); if (maxPart[u] &lt; maxPart[_root]) return _root = u; else return _root; &#125; void distance(int u, int father) &#123; rem[++rem[0]] = dis[u]; // 标记当前树根的距离 using FWS::head; using FWS::ee; for (int c = head[u]; ~c; c = ee[c].next) &#123; edge &amp;e = ee[c]; int &amp;v = e.v; if (v == father || vis[v]) continue; dis[v] = dis[u] + e.w; distance(v, u); // 递归地查找子树 &#125; &#125; void calculate(int u) &#123; int cnt = 0; using FWS::head; using FWS::ee; for (int c = head[u]; ~c; c = ee[c].next) &#123; edge&amp; e = ee[c]; int&amp; v = e.v; if (vis[v]) continue; rem[0] = 0; dis[v] = e.w; distance(v, u); // 计算该子树中点到顶点u的距离 for (int j = rem[0]; j; --j) // rem记录了该子树所有点到u距离 for (int k = 1; k &lt;= _count; ++ k) if (_query[k] &gt;= rem[j]) test[k] |= has[_query[k] - rem[j]]; for (int j = rem[0]; j; --j) &#123; if (rem[j] &gt; buf) continue; // 针对：超出询问范围，忽略 can[++cnt] = rem[j]; has[rem[j]] = true; &#125; &#125; for (int i = 1; i &lt;= cnt; ++ i) // 处理完子树后，清空标记 has[can[i]] = false; &#125; void dc(int u) &#123; vis[u] = has[0] = true; calculate(u); // 查找子树u中的“第一类路径” using FWS::head; using FWS::ee; for (int c = head[u]; ~c; c = ee[c].next) &#123; edge&amp; e = ee[c]; int&amp; v = e.v; if (vis[v]) continue; sum = size[v]; // 顶层查找子树重心调用 maxPart[_root = 0] = ::INF; int root = findRoot(v, 0); dc(root); // 分治：进而处理子树 &#125; &#125; void solution() &#123; init(); maxPart[_root] = sum = n; // 初始化：查找全树重心 int root = findRoot(1, 0); dc(root); // 开始分治 &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr);// freopen(R&quot;(D:\\shiroha\\Downloads\\P3806_7.in)&quot;,&quot;r&quot;,stdin); int u, v, w; cin &gt;&gt; n &gt;&gt; m; FWS::init(); for (int i = 1; i &lt; n; ++ i) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; FWS::addedge(u,v,w); &#125; for (int i = 1; i &lt;= m; ++ i) cin &gt;&gt; queries[i]; PointDC::solution(); for (int i = 1; i &lt;= m; ++ i) cout &lt;&lt; (PointDC::test[i] ? &quot;AYE&quot; : &quot;NAY&quot;) &lt;&lt; endl; return 0;&#125; 注释还算比较详细吧，我觉得光看代码应该就很好懂了。 洛谷 P2634 [国家集训队]聪聪可可 实际上这题的最优复杂度是树上DP，可以O(n)解出来。 给一个有n个节点的带边权树，问树上长度可以被3整除的路径数量和全部树上路径数量的比值，并以约分后的分数的形式输出答案。 数据范围：N = 2e4 和前面几个题不一样，本题统计的是树上路径长度可以被3整除的路径数量。我们可以参考上面题目的做法：将树上路径分成两类——其中第一类路径可以通过两个不同源的”半边“组合得到。因为模3的余数只有三种情况，得到长度可以被3整除的路径只有两种情况：余0和余0组合或者余1和余2组合。我们可以统计当前子树中到根距离模3分别为0、1、2的路径数量，按照上述规则进行组合，得到第一类路径的数量。 因为组合路径不能同源，可以使用和上面第一题一样的容斥原理分别排除子树的同源贡献。因为我们只考虑对于3的模，所以读入边权时就取模，可以避免可能会出现的边权爆int的情况。 求出了全树中，路径长度模3为0的数量之后，意识到全树的边的数量就是n*n。然后求出总边数和符合要求的路径数量的gcd，约去后输出就是答案。 代码 因为这是讲点分治的文章，树形DP做法就不贴了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int inf = 0x3f3f3f3f;struct edge&#123; int u, v, w, next; edge() = default; edge(int u, int v, int w, int next) : u(u), v(v), w(w), next(next) &#123;&#125;&#125;;const int N = 4e4+5, M = N;int n, ans = 0, cnt[3], dis[N];namespace FWS&#123; int head[N]; int tot; edge ee[M * 2]; void init() &#123; memset(head, -1, sizeof(int)*(n+1)); tot = 0; &#125; void addedge(int u, int v, int w) &#123; ee[tot] = edge(u,v,w,head[u]); head[u] = tot ++; &#125;&#125;void addEdge(int u, int v, int w)&#123; FWS::addedge(u, v, w); FWS::addedge(v, u, w);&#125;namespace PointDC&#123; int size[N]; // size统计整个子树大小 bool vis[N]; // 记录子树是否已经被分治处理过 int _sum; // 记录将要分治的子树大小，以计算另一个子树的大小 int _root; // findRoot中用来临时记录找到的重心 int _part; // findRoot当前找到的重心的maxPart using dfs = void(*)(int, int); dfs search = [](int u, int father) &#123; ++ cnt[dis[u]]; using namespace FWS; for (int c = head[u]; ~c; c = ee[c].next) &#123; edge&amp; e = ee[c]; int&amp; v = e.v; if (v == father || vis[v]) continue; dis[v] = (dis[u] + e.w) % 3; search(v, u); &#125; &#125;; auto cleanRoot = [](int size) &#123; _root = 0; _part = inf; _sum = size; &#125;; auto setRoot = [](int u, int maxPart) &#123; _part = maxPart; _root = u; &#125;; inline void init() &#123; memset(vis, 0, sizeof(bool) * (n + 1)); setRoot(0, inf); &#125; int findRoot(int u, int father) &#123; size[u] = 1; int maxPart = 0; using namespace FWS; for (int c = head[u]; ~c; c = ee[c].next) &#123; edge&amp; e = ee[c]; int&amp; v = e.v; if (v == father || vis[v]) continue; findRoot(v, u); size[u] += size[v]; maxPart = max(maxPart, size[v]); &#125; maxPart = max(maxPart, _sum - size[u]); if (maxPart &lt; _part) setRoot(u, maxPart); return _root; &#125; int calculate(int u, int distance) &#123; memset(cnt, 0, sizeof cnt); dis[u] = distance; search(u, 0); return cnt[0] * cnt[0] + cnt[1] * cnt[2] * 2; &#125; void dc(int u) &#123; ans += calculate(u, 0); vis[u] = true; using namespace FWS; for (int c = head[u]; ~c; c = ee[c].next) &#123; edge &amp;e = ee[c]; int &amp;v = e.v; if (vis[v]) continue; ans -= calculate(v, e.w); cleanRoot(size[v]); auto root = findRoot(v, u); dc(root); &#125; &#125; void solution() &#123; init(); cleanRoot(n); auto root = findRoot(1, 0); dc(root); &#125;&#125;int gcd(int a,int b)&#123; return b == 0 ? a : gcd(b, a % b);&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n; FWS::init(); for (int i = 1; i &lt; n; ++ i) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; addEdge(u, v, w % 3); &#125; PointDC::solution(); cerr &lt;&lt; ans &lt;&lt; endl; int tot = n * n, xx = gcd(tot, ans); cout &lt;&lt; (ans / xx) &lt;&lt; &#x27;/&#x27; &lt;&lt; (tot / xx) &lt;&lt; endl; return 0;&#125; 和万物起源Tree一样，统计长度模3不同余数的路径数量再组装成”第一类路径“，递归处理”第二类路径“。 洛谷 P4149 [IOI2011]Race 题面言简意赅 给一棵树，每条边有权。求一条简单路径，权值和等于k，且边的数量最小；点从0开始编号；若不存在这样的路径，输出-1；否则，输出这样的路径包含的边数。 数据范围：N = 2e5，K = 1e6，边权不超过K。 这题要是用树形DP：设 f[i][j] 是以i为根的子树中长度为j的路径最小边数，那光是空间复杂度就已经是 N*K 的爆炸水准了，更不必说还要手动转移填满它的时间；所以使用点分治来做： 和前面求等于k的书上路径一样：使用桶存储之前开的子树中找到的长度，并且使用另一个桶维护每一种路径长度在已经搜索过的子树中出现的最少边数。在查找子树的过程中，利用当前的边的长度和桶维护的信息更新答案的最小值即可；用树规一点的说法，就是 f[j] 表示以重心为根的子树中长度为j的路径最小边数：在分治点DFS更新该数组，并顺便使用和为k的第一类路径去更新ans即可。 综上所述：使用点分治解决此题，空间复杂度是 O(K)，时间复杂度 O(nlogn)。 需要注意的是：因为询问有上限K，所以桶开到K就可以了；此外，当前搜索过程中距离已经大于k的情况，可以直接剪枝返回。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;using longs = long long;const int inf = 0x3f3f3f3f;const longs INF = 0x3f3f3f3f3f3f3f3f;struct edge&#123; int u, v, w, next; edge() = default; edge(int u, int v, int w, int next) : u(u), v(v), w(w), next(next) &#123;&#125;&#125;;const int N = 2e5+5, M = N;int n, k, ans = inf;longs dis[N];namespace FWS&#123; int head[N]; int tot; edge ee[M * 2]; void init() &#123; memset(head, -1, sizeof(int)*(n+1)); tot = 0; &#125; void addedge(int u, int v, int w) &#123; ee[tot] = edge(u,v,w,head[u]); head[u] = tot ++; &#125;&#125;void addEdge(int u, int v, int w)&#123; FWS::addedge(u, v, w); FWS::addedge(v, u, w);&#125;namespace PointDC&#123; int size[N]; bool vis[N]; int _sum; int _root; int _part; using dfs = void(*)(int, int); const int buf = 1e6 + 5; int rem[N], path[N], cnt = 0; int len[buf], _now; int used[buf], has[buf]; dfs distance = [](int u, int father) &#123; int nowPath = _now + 1; if (dis[u] &lt;= k) &#123; ans = min(ans, nowPath + len[k - dis[u]]); rem[++ cnt] = dis[u]; path[cnt] = nowPath; &#125; else return; using namespace FWS; for (int c = head[u]; ~c; c = ee[c].next) &#123; edge &amp;e = ee[c]; const int v = e.v; if (vis[v] || v == father) continue; dis[v] = dis[u] + e.w; _now = nowPath; distance(v, u); &#125; &#125;; auto cleanRoot = [](int size) &#123; _root = 0; _part = inf; _sum = size; &#125;; auto setRoot = [](int u, int maxPart) &#123; _part = maxPart; _root = u; &#125;; inline void init() &#123; memset(vis, 0, sizeof(bool) * (n + 1)); memset(len, 0x3f, sizeof(len)); memset(has, 0, sizeof(has)); len[0] = 0; setRoot(0, inf); &#125; int findRoot(int u, int father) &#123; size[u] = 1; int maxPart = 0; using namespace FWS; for (int c = head[u]; ~c; c = ee[c].next) &#123; edge&amp; e = ee[c]; int&amp; v = e.v; if (v == father || vis[v]) continue; findRoot(v, u); size[u] += size[v]; maxPart = max(maxPart, size[v]); &#125; maxPart = max(maxPart, _sum - size[u]); if (maxPart &lt; _part) setRoot(u, maxPart); return _root; &#125; void calculate(int u) &#123; dis[u] = used[0] = 0; using namespace FWS; for (int c = head[u]; ~c; c = ee[c].next) &#123; edge &amp;e = ee[c]; const int v = e.v; if (vis[v]) continue; dis[v] = e.w; cnt = _now = 0; distance(v, u); for (int j = cnt; j; -- j) &#123; if (!has[rem[j]]) &#123; used[++ used[0]] = rem[j]; has[rem[j]] = true; &#125; len[rem[j]] = min(len[rem[j]], path[j]); &#125; &#125; for (int i = used[0]; i; -- i) &#123; len[used[i]] = inf; has[used[i]] = false; &#125; &#125; void dc(int u) &#123; vis[u] = true; calculate(u); using namespace FWS; for (int c = head[u]; ~c; c = ee[c].next) &#123; edge &amp;e = ee[c]; int &amp;v = e.v; if (vis[v]) continue; cleanRoot(size[v]); auto root = findRoot(v, u); dc(root); &#125; &#125; inline void solution() &#123; init(); cleanRoot(n); auto root = findRoot(0, 0); dc(root); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr);// freopen(R&quot;(D:\\shiroha\\Downloads\\P4149_2.in)&quot;, &quot;r&quot;, stdin); cin &gt;&gt; n &gt;&gt; k; FWS::init(); for (int i = 1; i &lt; n; ++ i) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; addEdge(u, v, w); &#125; PointDC::solution(); cout &lt;&lt; (ans &gt;= inf ? -1 : ans) &lt;&lt; endl; return 0;&#125; 基本还是套板子：只是注意到顶点从0开始，需要修改PointDC::solution里查找重心的起点。 洛谷 P2664 树上游戏 和上面的裸的树上路径长度不同，这题就麻烦一些了： 一颗有 n 个节点的无边权树，每个节点有一个标号为 ci 的颜色；定义 s(i, j) 是树上路径 i - j 上出现的不同颜色种数；此外定义 sum(i) ： \\[ sum(i) = \\sum_{j = 1}^n s(i, j) \\] 求出这棵树的所有 sum(i)；数据范围：N = 1e5. 虽然，这种数据规模可以接受 nlogn，处理树上点对且单次询问的问题，一定是点分治；使用点分治通常的分治方法，问题集中到如何使用 O(n) 时间处理子树中“第一类路径”对答案的贡献。 对于树上的分治点：我们可以统计从它出发可到达的所有节点和它自身之间形成的路径对答案的贡献，也可以统计经过它的路径对于路径端点的贡献；两种都是属于第一类路径；对自己的贡献比较好统计，dfs的时候加和就行；接下来考虑如何统计第二类的贡献。 先说一个显而易见的结论：对于树中节点 i，若它的颜色在从它到当前树根（分治点）的路径中第一次出现，那么所有和 i 的LCA为根的节点（也就是根节点以及根节点的其他子树的节点）都可以和 i 的子树中的节点 j 形成“第一类路径”；在不考虑其他子树中出现相同颜色的情况下，i 的颜色会对这些点的答案产生 size[i] 的贡献（size[i] 条不同的路径，每条路径贡献1个颜色点）。 上面的内容也可以这么说：因为要求的是全部路径（所有点对），所以显然要考虑贡献；我们先考虑“半边”第一类路径，也就是从根出发到子树中的点组成的点对：那么如果点 i 的颜色在根到 i 中第一次出现，那么 i 和 i 的子树中所有点都会因为这个颜色而导致 s 值加 1——这一点贡献是 i 的颜色带来的。 然后就是遍历子树，分子树考虑：首先采用同样的DFS将当前子树的颜色的贡献从总贡献中减去；然后考虑这颗子树中的一个点，令这个点到当前根上的路径中的不同颜色数是colors，other表示当前树出了该子树之外的其他部分的点数，X是这个点到根的路径上不包括根的颜色的贡献之和；对于这些已经出现过的颜色，在它们作为子树根的时候必然已经考虑过了，所以先从总贡献中减去；这样就可以考虑对于子树节点的贡献了。 简单的说，在某点作为分治点时，统计了从它出发到它的所有子节点形成的“半边”对自己的sum产生的贡献：因为根的颜色的贡献只能是自己产生，所以要剪掉这个颜色的贡献，加上因为自己拥有这个颜色而导致的这个颜色的贡献加成size[u]；接下来，要考虑所有的子树的根出发向上经过本分治点对这些子树的根节点产生的贡献——半边已经确定，就是分治点到子树根的链上的颜色，另半边的颜色贡献已经使用total维护，当然，这里要减去那个已经确定的半边上有的颜色带来的贡献。这样，分治点的“第一类路径”就处理完了。 应当注意的是，sum只考虑起点和终点，并不考虑经过的点：这和分治的“第一类路径”的定义不太一致；这里主要是将每一个点的“第一类路径”分成对分治点下探对自身的影响和对于子树节点上探的影响。 综上所述，我们可以在每一层分治的分治点这么做： 执行DFS.count：统计转化为以分治点为根的有根树的各子树的大小，并统计上面结论里说的贡献（记录到contrib数组），以及这些贡献的和（total）； 考虑分治点下探对分治点带来的贡献：total - contrib[.c] + size 枚举子树，考虑子树节点上探经过分治点带来的贡献： 执行DFS.disContrib，消除当前子树自身对颜色带来的贡献； 执行DFS.update，加算贡献更新子树节点的答案； 执行DFS.reContrib，回复第一步扣除的子树影响，为其他子树所用； 清空颜色贡献数组：本层分治处理完成，返回dc进行下一步的分治 如果你还是觉得上面说的不太清楚，可以看看下面的代码。 代码 这里贴出的是使用点分治在 O(nlogn) 的时间内解决的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;using longs = long long;const int inf = 0x3f3f3f3f;struct edge&#123; int u, v, w, next; edge() = default; edge(int u, int v, int w, int next) : u(u), v(v), w(w), next(next) &#123;&#125;&#125;;const int N = 1e5+5, M = N;int n, c[N];longs sum[N];namespace FWS&#123; int head[N]; int tot; edge ee[M * 2]; void init() &#123; memset(head, -1, sizeof(int)*(n+1)); tot = 0; &#125; void addedge(int u, int v, int w) &#123; ee[tot] = edge(u,v,w,head[u]); head[u] = tot ++; &#125;&#125;void addEdge(int u, int v, int w)&#123; FWS::addedge(u, v, w); FWS::addedge(v, u, w);&#125;namespace PointDC&#123; int size[N]; bool vis[N]; int _sum, _root, _part; namespace innerDFS &#123; using dfs = void(*)(int, int); longs contrib[N]; longs total; int cnt[N], colors; longs other; void init() &#123; memset(cnt, 0, sizeof(cnt)); memset(contrib, 0, sizeof(contrib)); total = colors = 0; &#125; dfs count = [](int u, int father) &#123; size[u] = 1; bool zero = !(cnt[c[u]] ++); using namespace FWS; for (int ii = head[u]; ~ii; ii = ee[ii].next) &#123; edge &amp;e = ee[ii]; int &amp;v = e.v; if (v == father || vis[v]) continue; count(v, u); size[u] += size[v]; &#125; if (zero) &#123; total += size[u]; contrib[c[u]] += size[u]; &#125; -- cnt[c[u]]; &#125;; dfs disContrib = [](int u, int father) &#123; bool zero = !(cnt[c[u]] ++); using namespace FWS; for (int ii = head[u]; ~ii; ii = ee[ii].next) &#123; edge &amp;e = ee[ii]; int &amp;v = e.v; if (!vis[v] &amp;&amp; v != father) disContrib(v, u); &#125; if (zero) &#123; total -= size[u]; contrib[c[u]] -= size[u]; &#125; -- cnt[c[u]]; &#125;; dfs reContrib = [](int u, int father) &#123; bool zero = !(cnt[c[u]] ++); using namespace FWS; for (int ii = head[u]; ~ii; ii = ee[ii].next) &#123; edge &amp;e = ee[ii]; int &amp;v = e.v; if (!vis[v] &amp;&amp; v != father) reContrib(v, u); &#125; if (zero) &#123; total += size[u]; contrib[c[u]] += size[u]; &#125; -- cnt[c[u]]; &#125;; dfs update = [](int u, int father) &#123; bool zero = !(cnt[c[u]] ++); if (zero) &#123; total -= contrib[c[u]]; ++ colors; &#125; sum[u] += total + colors * other; using namespace FWS; for (int ii = head[u]; ~ii; ii = ee[ii].next) &#123; edge &amp;e = ee[ii]; int &amp;v = e.v; if (!vis[v] &amp;&amp; v != father) update(v, u); &#125; if (zero) &#123; total += contrib[c[u]]; -- colors; &#125; -- cnt[c[u]]; &#125;; dfs clear = [](int u, int father) &#123; cnt[c[u]] = contrib[c[u]] = 0; using namespace FWS; for (int ii = head[u]; ~ii; ii = ee[ii].next) &#123; edge &amp;e = ee[ii]; int v = e.v; if (!vis[v] &amp;&amp; v != father) clear(v, u); &#125; &#125;; &#125; auto cleanRoot = [](int size) &#123; _root = 0; _part = inf; _sum = size; &#125;; auto setRoot = [](int u, int maxPart) &#123; _part = maxPart; _root = u; &#125;; inline void init() &#123; memset(vis, 0, sizeof(bool) * (n + 1)); setRoot(0, inf); innerDFS::init(); &#125; int findRoot(int u, int father) &#123; size[u] = 1; int maxPart = 0; using namespace FWS; for (int ii = head[u]; ~ii; ii = ee[ii].next) &#123; edge&amp; e = ee[ii]; int&amp; v = e.v; if (v == father || vis[v]) continue; findRoot(v, u); size[u] += size[v]; maxPart = max(maxPart, size[v]); &#125; maxPart = max(maxPart, _sum - size[u]); if (maxPart &lt; _part) setRoot(u, maxPart); return _root; &#125; void calculate(int u) &#123; using namespace innerDFS; using namespace FWS; count(u, 0); sum[u] += total - contrib[c[u]] + size[u]; for (int ii = head[u]; ~ii; ii = ee[ii].next) &#123; edge &amp;e = ee[ii]; int v = e.v; if (vis[v]) continue; cnt[c[u]] = 1; total -= size[v]; contrib[c[u]] -= size[v]; disContrib(v, u); cnt[c[u]] = 0; other = size[u] - size[v]; update(v, u); cnt[c[u]] = 1; total += size[v]; contrib[c[u]] += size[v]; reContrib(v, u); cnt[c[u]] = 0; &#125; colors = total = 0; clear(u, 0); &#125; void dc(int u) &#123; vis[u] = true; calculate(u); using namespace FWS; for (int ii = head[u]; ~ii; ii = ee[ii].next) &#123; edge &amp;e = ee[ii]; int &amp;v = e.v; if (vis[v]) continue; cleanRoot(size[v]); auto root = findRoot(v, u); dc(root); &#125; &#125; inline void solution() &#123; init(); cleanRoot(n); auto root = findRoot(1, 0); dc(root); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n; FWS::init(); int x, y; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; c[i]; for (int i = 1; i &lt; n; ++ i) &#123; cin &gt;&gt; x &gt;&gt; y; addEdge(x, y, 0); &#125; PointDC::solution(); for (int i = 1; i &lt;= n; ++ i) cout &lt;&lt; sum[i] &lt;&lt; endl; return 0;&#125; 关于disContrib和reContrib：两个行为是对称的，你可以合成一个函数，也可以开一些全局变量记录这些修改；此外，这个题目还有 O(n) 的算法；想要了解可以去看这题的题解。 洛谷 P2305 [NOI2014]购票 这道题也相当的麻烦…… 一颗有n个节点的有根树，所有的子节点向父节点连边；你可以从节点出发，支付这个节点的旅行费用，然后到达这个节点距离不超过 l 的祖先节点；每个节点有不同的 l 和费用：费用的计算方式是：f(dis) = dis*p + q；p和q是节点的常数。现要求求出从每个子节点出发到达根节点时的最少花费。 数据范围：N = 2e5，P = 1e6，Q = 1e12 总结&amp;后记 参考资料 本篇博文在创作过程中参考了这些资料，在这里给出它们的链接： 树分治 - OI Wiki 点分治&amp;&amp;动态点分治学习笔记 一种基于错误的寻找重心方法的点分治的复杂度分析 点分治 &amp; 动态点分治小结 【算法学习】点分治 如果觉得哪里没有说清楚你们也可以去看看这些链接。","categories":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"树上算法","slug":"算法/树上算法","permalink":"https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%8A%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://shiraha.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]},{"title":"“Shopee杯” e起来编程暨武汉大学2020年大学生程序设计大赛（决赛）题解","slug":"whu-shopee-cup-2020-spring-final","date":"2020-04-19T13:59:02.000Z","updated":"2020-04-19T13:59:02.000Z","comments":true,"path":"2020/whu-shopee-cup-2020-spring-final/","link":"","permalink":"https://shiraha.cn/2020/whu-shopee-cup-2020-spring-final/","excerpt":"","text":"","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"https://shiraha.cn/tags/Nowcoder/"}]},{"title":"第二届“传智杯”全国大学生IT技能大赛（决赛）","slug":"chuanzhi-cup-final-2020-luogu","date":"2020-04-18T12:29:24.000Z","updated":"2020-04-18T12:29:24.000Z","comments":true,"path":"2020/chuanzhi-cup-final-2020-luogu/","link":"","permalink":"https://shiraha.cn/2020/chuanzhi-cup-final-2020-luogu/","excerpt":"","text":"按照惯例还是先挂出来一些链接。 比赛地址：https://www.luogu.com.cn/contest/29004 官方题解：https://www.zhihu.com/question/388180965/answer/1163540927 但是已经不能在上面的比赛链接里上交题目了，所有的题目已经加入公共题库了，所以你可以搜索题目的名字然后在公共题库中找到它们；好像直接点进去就会自动切到公共题库，还行。 两个黄题没有做出来，这不太行啊。 A - 暴力模拟 暴力模拟，语言题。但是数据范围给的有些歧义。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;using longs = long long;using longd = long double;using ulongs = unsigned long long;const int inf = 0x3f3f3f3f;const longs INF = 0x3f3f3f3f3f3f3f3f;const double eps = 1e-8;const char graph[100][100] = &#123; R&quot;(...........................,]]OOO@@@@OOO]`........)&quot;, R&quot;(....................,]OO@@@@@@@@@@@@@@@@@@@@O`....)&quot;, R&quot;(................./O@@@@@@@@@@@@@@@@@@@@@@@@@@@@^..)&quot;, R&quot;(............../O@@@@@@@@@@@@@@@OOOOOOO@@@@@@@@@@@.)&quot;, R&quot;(..........,/@@@@@@@@@@@@O/[.............[O@@@@@@@\\)&quot;, R&quot;(........,O@@@@@@@@@@O/`..................,O@@@@@@O)&quot;, R&quot;(.......O@@@@@@@@@O`......]OO@@@O\\`........O@@@@@@@)&quot;, R&quot;(.....,O@@@@@@@@/`.....]O@@@@@@@@@@^.......O@@@@@@@)&quot;, R&quot;(...,/@@@@@@@O/...../@@@@@@@@@@@@@@O....../@@@@@@@0)&quot;, R&quot;(..=@@@@@@@O`...../@@@@@@@@@@@@@@@@^.....O@@@@@@@O.)&quot;, R&quot;(./@@@@@@@/......O@@@@@@@@@@@@@@@O`..../@@@@@@@@O..)&quot;, R&quot;(=@@@@@@@O......O@@@@@@@@@@@@@@@^....O@@@@@@@@@O...)&quot;, R&quot;(O@@@@@@@^.....=@@@@@@@@@@@@@O[..../@@@@@@@@@O`....)&quot;, R&quot;(@@@@@@@O.......\\@@@@@@@@O[...../O@@@@@@@@@O`......)&quot;, R&quot;(@@@@@@@@^.........[`.......]OO@@@@@@@@@@O`........)&quot;, R&quot;(O@@@@@@@@O\\............]/@@@@@@@@@@@@O/...........)&quot;, R&quot;(=@@@@@@@OOOoo`........O@@@@@@@@@@@@/`.............)&quot;, R&quot;(..\\OOOOO*,`*..........O@@@@@@@@@O`................)&quot;, R&quot;(.....,[[..............O@@@@@@O`...................)&quot;, R&quot;(......................O@@@@@@O....................)&quot; &#125;;char campus[2060][2060];int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n, h, w; int x, y, r; auto initfill = [&amp;] &#123; for (int i = 0; i &lt; h; ++ i) &#123; for (int j = 0; j &lt; w; ++ j) campus[i][j] = &#x27;.&#x27;; campus[i][w] = &#x27;\\0&#x27;; &#125; &#125;; auto paint = [&amp;](int x, int y) &#123; for (int i = x, ii = 0; i &lt; h; ++ i, ++ ii) &#123; if (ii &gt;= 20) break; if (i &lt; 0) continue; for (int j = y, jj = 0; j &lt; w; ++ j, ++ jj) &#123; if (jj &gt;= 50) break; if (graph[ii][jj] == &#x27;.&#x27;) continue; if (j &lt; 0) continue; campus[i][j] = graph[ii][jj]; &#125; &#125; &#125;; auto paint180 = [&amp;](int x, int y) &#123; for (int i = x, ii = 19; i &lt; h; ++ i, -- ii) &#123; if (ii &lt; 0) break; if (i &lt; 0) continue; for (int j = y, jj = 49; j &lt; w; ++ j, -- jj) &#123; if (jj &lt; 0) break; if (graph[ii][jj] == &#x27;.&#x27;) continue; if (j &lt; 0) continue; campus[i][j] = graph[ii][jj]; &#125; &#125; &#125;; cin &gt;&gt; n &gt;&gt; h &gt;&gt; w; initfill(); while (n --) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; r; if (r) paint180(x,y); else paint(x,y); &#125; for (int i = 0; i &lt; h; ++ i) cout &lt;&lt; campus[i] &lt;&lt; endl; return 0;&#125; 或者说是贴标赞助题好一些？ B - 屑游戏 脑筋急转弯。考虑为0的边界情况之后，防御塔留一手给英雄，要是能鲨咯那就完事。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;using longs = long long;using longd = long double;using ulongs = unsigned long long;const int inf = 0x3f3f3f3f;const longs INF = 0x3f3f3f3f3f3f3f3f;const double eps = 1e-8;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; longs h, x, y; while (t --) &#123; cin &gt;&gt; h &gt;&gt; x &gt;&gt; y; if (!y) &#123;cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; continue;&#125; else if (!x) &#123;cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; continue;&#125; longs tt = h / x + 1; longs mm = h % x; if (!mm) mm += x, -- tt; if (mm / y + bool(mm % y) &lt;= tt) cout &lt;&lt; &quot;Yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;No&quot; &lt;&lt; endl; &#125; return 0;&#125; 记得开long long。 C - 加大范围 比赛时候的数据只要暴力模拟就行了，但是需要使用更优的算法：最优的算法是O(n³)的 朴素的想法：枚举重心的高度和所在坐标，然后判断每个位置是否可行，这是跑不满的五次方算法；如果把遍历获得所需操作数的行为使用二维前缀和/差分优化的话就可以压到四次方；如果使用二维RMQ问题的解决方法，判断一个方形区域是否都大于某个值，就可以压到最优复杂度。 1 D - 迫真最短路 又是一个暴力。传送门问题往往是先最短路，然后枚举传送门的位置。这个题目只不过就是题面有些吓人，但是数据范围是小的可怜的100，就算是四次方算法也是可以接受的（ 因为要求出所有的最短路之和，所以要用Floyd；然后再加上暴力枚举传送门位置，暴力枚举求出题目说的和，维护它的最小值即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;using longs = long long;using longd = long double;using ulongs = unsigned long long;const int inf = 0x3f3f3f3f;const longs INF = 0x3f3f3f3f3f3f3f3f;const double eps = 1e-8;longs dis[105][105], ans = INF;int n, m;inline void floyd()&#123; for (int k = 1; k &lt;= n; ++ k) // Floyd：中转点要写在外面 for (int i = 1; i &lt;= n; ++ i) for (int j = 1; j &lt;= n; ++ j) dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);&#125;longs sum(int ii, int jj)&#123; longs tmp = 0; for (int i = 1; i &lt;= n; ++ i) for (int j = i+1; j &lt;= n; ++ j) tmp += min( dis[i][j], min( dis[i][ii] + dis[jj][j], dis[i][jj] + dis[ii][j] )); return tmp; &#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; m; memset(dis, 0x3f, sizeof dis); while (m --) &#123; int u, v, w; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; dis[u][v] = dis[v][u] = w; &#125; for (int i = 1; i &lt;= n; ++ i) dis[i][i] = 0; floyd(); for (int i = 1; i &lt;= n; ++ i) for (int j = i+1; j &lt;= n; ++ j) &#123; longs tmp = sum(i, j); ans = min(tmp, ans); &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; Floyd算法三重循环的中转点在最外层！ E - 上课 本 次 比 赛 唯 一 的 一 个 绿 题 做法很多。我是找到所有连续的课程作为断点，然后对于每个连续的区间扫描一遍，记录扫描过的区域不同课出现的次数，然后加算贡献的。有点像是在乱搞，复杂度O(n)。 事实上这个题还可以DP，也可以莫队（？），还可以反向思维：也就是先算出所有大于l的点对，在用双指针法减掉各种不太行的情况，时间复杂度都是O(n)的。 贴的代码不是DP的，是比赛时乱搞的版本。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;using longs = long long;using longd = long double;using ulongs = unsigned long long;const int inf = 0x3f3f3f3f;const longs INF = 0x3f3f3f3f3f3f3f3f;const double eps = 1e-8;const int N = 5e5+5;int n, l, a[N], c[N];vector&lt;pair&lt;int,int&gt;&gt; vv;map&lt;int,int&gt; mm;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin &gt;&gt; t; auto jump = [&amp;] &#123; int s = 1, t = 0; for (int i = 1; i &lt; n; ++ i) &#123; if (c[i] != c[i+1]) &#123; a[i] = i+1; t = i; &#125; else &#123; if (s != t) vv.emplace_back(s, i); int j = i+1; while (c[++ j] == c[i]); for (int k = i; k &lt; j; ++ k) a[k] = j; i = j - 1; s = t = j - 1; &#125; &#125; if (s != n) vv.emplace_back(s, n); a[n] = 0; &#125;; while (t --) &#123; vv.clear(); cin &gt;&gt; n &gt;&gt; l; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; c[i]; if (n == 1 || n &lt; l) cout &lt;&lt; 0 &lt;&lt; endl; else &#123; jump(); longs ans = 0; for (auto ii : vv) &#123; if (ii.second - ii.first + 1 &lt; l) continue; int lim = ii.second - l + 1, noko = 0; for (int xx = ii.first + l - 1; xx &lt;= ii.second; ++ xx) &#123; ++ mm[c[xx]]; ++ noko; &#125; for (int xx = ii.first; xx &lt;= lim; ++ xx) &#123; ans += noko - mm[c[xx]]; -- noko; -- mm[c[xx + l - 1]]; &#125; mm.clear(); &#125; cout &lt;&lt; ans &lt;&lt; endl; &#125; &#125; return 0;&#125; 然后就是DP版本： 1 写了半天，我紫菜（ 后记 kkksc03：什么嘛，我的洛谷比赛系统还挺好用的嘛。 但是非专业性质的比赛打成这样，属实不太行。引人深思。","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Luogu","slug":"Luogu","permalink":"https://shiraha.cn/tags/Luogu/"}]},{"title":"“科大讯飞杯”第18届上海大学程序设计联赛春季赛暨高校网络友谊赛","slug":"SHU-iflytek-cup-18th-spring-contest","date":"2020-04-18T12:28:40.000Z","updated":"2020-04-18T12:28:40.000Z","comments":true,"path":"2020/SHU-iflytek-cup-18th-spring-contest/","link":"","permalink":"https://shiraha.cn/2020/SHU-iflytek-cup-18th-spring-contest/","excerpt":"","text":"科大讯飞冠名的上海大学校赛网络赛。一共五个小时，十二个题目。前六个题是简单题，后六个题是麻烦一点的题目；本来还想着能不能挑战一下A七个，然后……然后我就签到完六个题目光荣下岗（ A2B28BE5A2859BE14CE402031844A7D3.jpg 补题链接：https://ac.nowcoder.com/acm/contest/5278 因为官方目前还没有放出官方题解，只有民间题解，所以这里就不贴链接了。如果有了再补 Update：2020 - 4 - 20 官方的题解slide找到了，您可以点击这里下载。 如果上面的CDN链接崩了，您也可以在这个博客的素材仓库中找到这个文件：传送门 日后如果实现了静态博客的pdf展览的页面，那么链接也会在这里更新的。 小声bb：这科大讯飞属实有牌面啊，比起武大校赛就六百多个人，这场比赛报名了四千一百多个人，三千两百多人实际参加，简直不能比（ 然后接下来是题解，签到就直接贴码了。部分参考民间题解制作： A - 组队比赛 真正的签到题。但是我吃了一发罚时，因为我忘记加上绝对值了。 123456789101112131415161718#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int in[4]; for (int i = 0; i &lt; 4; ++ i) cin &gt;&gt; in[i]; sort(in,in+4); cout &lt;&lt; abs(in[0]+in[3]-in[1]-in[2]) &lt;&lt; endl; return 0;&#125; 第一发就WA给爷整傻了（ B - 每日一报 只要你会使用Arrays.sort，这个题就可以过。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;using namespace std;struct info&#123; int date; string id; double temp; info() = default; info(int date, string id, double temp) : date(date), id(id), temp(temp) &#123;&#125; bool operator&lt;(const info &amp;rhs) const &#123; if (date &lt; rhs.date) return true; if (rhs.date &lt; date) return false; if (temp &lt; rhs.temp) return true; if (rhs.temp &lt; temp) return false; return id &gt; rhs.id; &#125; bool operator&gt;(const info &amp;rhs) const &#123; return rhs &lt; *this; &#125; bool operator&lt;=(const info &amp;rhs) const &#123; return !(rhs &lt; *this); &#125; bool operator&gt;=(const info &amp;rhs) const &#123; return !(*this &lt; rhs); &#125;&#125;;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n, m = 0; int x; string y; double z; vector&lt;info&gt; v; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++ i) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; if (z &lt; 38.0) continue; ++ m; v.emplace_back(x,y,z); &#125; sort(v.begin(), v.end()); cout &lt;&lt; m &lt;&lt; endl &lt;&lt; fixed &lt;&lt; setprecision(1); while (m --) &#123; cout &lt;&lt; v[m].date &lt;&lt; &#x27; &#x27; &lt;&lt; v[m].id &lt;&lt; &#x27; &#x27; &lt;&lt; v[m].temp &lt;&lt; endl; &#125; return 0;&#125; 如果你愿意，你甚至还可以让CLion帮你自动重载运算符。 C - 最长非公共子序列 首先，题目给了你两个样例：告诉了你，当两个字符串一摸一样的时候答案是-1；然后，显然当两个字符串不一样长的时候，答案是长字符串的长度——因为长字符串自身一定是自己的子序列，而必不可能是短字符串的子序列； 那么，问题就集中在了两个字符串一样长但是不相等的情况了——然而，此时任何一个字符串自身也是满足上面的条件的，所以答案就是字符串长度。没了。 123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); string s1, s2; cin &gt;&gt; s1 &gt;&gt; s2; int l1 = s1.length(), l2 = s2.length(); if (l1 == l2) &#123; if (s1 == s2) cout &lt;&lt; -1; else cout &lt;&lt; l1; &#125; else cout &lt;&lt; max(l1, l2); return 0;&#125; 七海的大脑经过快速的思考，发现实际上只有两种情况啊草（ D - 最大字符集 签到题里一个比较有意思的题目。首先想到，n比较大的时候，单字肯定不可取；然后看样例，推测除了特殊情况，k = n - 1；那么问题就变成了如何构造这样的一系列字符串。 啊呀本质上这个题目做了半天就是被样例坑了：有一种万金油的构造方式：n = 2的时候选择\"11\"，然后n更大的时候向中间插'0'；这样肯定没问题，狂喜，遂敲代码，提交，WA（ 前面说了n比较大的时候，那么什么是比较大呢？n = 2？但是按照上面的构造方法，n = 2选\"11\"的话，似乎并不妨碍n = 1时我构造\"0\"啊……问题解决了== 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n, k; cin &gt;&gt; n; if (n == 1) &#123; cout &lt;&lt; n &lt;&lt; endl; cout &lt;&lt; 1 &lt;&lt; endl; &#125; else if (n == 2) &#123; cout &lt;&lt; 2 &lt;&lt; endl; cout &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; &quot;11&quot; &lt;&lt; endl; &#125; else &#123; k = n - 1; cout &lt;&lt; k &lt;&lt; endl; string s = &quot;&quot;; int len = 2; cout &lt;&lt; 1 &lt;&lt; s &lt;&lt; 1 &lt;&lt; endl; while (len &lt; n) &#123; ++ len; s.append(&quot;0&quot;); cout &lt;&lt; 1 &lt;&lt; s &lt;&lt; 1 &lt;&lt; endl; &#125; &#125; return 0;&#125; 害，因为这个盲点损失的不仅是+3罚时，还有思考时间和心态啊（ E - 美味的序列 “吃序列，感觉直接贪心模拟就好了啊——然后一边模拟一边开个变量存最大值，完美啊 ——我最开始是这么想的。然后就会显然的遇到一个问题：如果两头一样大，就要检查下一位直到可以分辨优劣的程度；但是这么做，最坏每次模拟时间复杂度会退化到O(n)，整个算法会变成平方，不可取；更何况如果整个数列的值一样，那么每次扫描全队列的我岂不是个憨憨。 啊呀不对啊，这不是一小时以内过了一千多个人的签到题吗，不应该有什么高深算法才对啊== 难道不知不觉我已经菜到这么离谱的程度了嘛（卑微 然后，七海的大脑经过了快速（不的思考，发现了题目中有一句话：“把整个序列吃完” 哦，吃完啊，那没事了。 12345678910111213141516171819202122#include &lt;iostream&gt;using namespace std;using longs = long long;const int N = 1e5 + 5;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n, a[N]; longs maxx = 0, disc = 0; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++ i) cin &gt;&gt; a[i], maxx += a[i]; disc = (n + 1ll) * n / 2ll - n; cout &lt;&lt; maxx - disc; return 0;&#125; 求个和，求个总损失，减一下完事。 F - 日期小助手 给日期，计算最近的父亲节或者母亲节。因为有日期，再加上这两个节日都和星期几有关，很快就想到了fstqwq学长无私分享的板子的 \\(Miscellany\\) 版块里提到的Zeller日期转换。 所谓Zeller日期转换，就是从公元后的年月日日期到正整数的一个双射。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;iostream&gt;using namespace std;string dateString(int y, int m, int d)&#123; string s; if (m == 5) s = &quot;Mother\\&#x27;s Day: May &quot;; else s = &quot;Father\\&#x27;s Day: June &quot;; s.append(to_string(d)); if (d / 10 == 1) s.append(&quot;th, &quot;); else if (d % 10 == 1) s.append(&quot;st, &quot;); else if (d % 10 == 2) s.append(&quot;nd, &quot;); else if (d % 10 == 3) s.append(&quot;rd, &quot;); else s.append(&quot;th, &quot;); s.append(to_string(y)); return s;&#125;namespace Zeller&#123; struct date &#123;int year, month, day; &#125;; enum weekday &#123;sun = 0, mon, tue, wed, thu, fri, sat&#125;; typedef int id; id getZellerId(int y, int m, int d) &#123; if (m &lt; 3) -- y, m += 12; return 365 * y + y / 4 - y / 100 + y / 400 + (153 * (m - 3) + 2) / 5 + d - 307; &#125; date getZellerDate(id zellerId) &#123; int x = zellerId + 1789995, n, i, j, y, m, d; n = 4 * x / 146097; x -= (146097 * n + 3) / 4; i = (4000 * (x + 1)) / 1461001; x -= 1461 * i / 4 - 31; j = 80 * x / 2447; d = x - 2447 * j / 80; x = j / 11; m = j + 2 - 12 * x; y = 100 * (n - 49) + i + x; return &#123;y,m,d&#125;; &#125; weekday getWeekday(id zellerId) &#123; return static_cast&lt;weekday&gt;((zellerId + 1) % 7); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); using Zeller::getZellerId; using Zeller::getWeekday; using Zeller::getZellerDate; auto getMotherDayId = [](int y) &#123; Zeller::id xx = getZellerId(y, 5, 1); int yy = getWeekday(xx); if (!yy) xx += 7; else &#123; int dd = 7 - yy; xx += dd + 7; &#125; return xx; &#125;; auto getFatherDayId = [](int y) &#123; Zeller::id xx = getZellerId(y, 6, 1); int yy = getWeekday(xx); if (!yy) xx += 14; else &#123; int dd = 7 - yy; xx += dd + 14; &#125; return xx; &#125;; int t; cin &gt;&gt; t; int y, m, d; while (t --) &#123; cin &gt;&gt; y &gt;&gt; m &gt;&gt; d; if (m &lt; 5) &#123; auto id = getMotherDayId(y); auto dd = getZellerDate(id); cout &lt;&lt; dateString(dd.year, dd.month, dd.day) &lt;&lt; endl; &#125; else if (m &gt; 6) &#123; auto id = getMotherDayId(y + 1); auto dd = getZellerDate(id); cout &lt;&lt; dateString(dd.year, dd.month, dd.day) &lt;&lt; endl; &#125; else &#123; auto ll = getMotherDayId(y); auto rr = getFatherDayId(y); auto mm = getZellerId(y,m,d); Zeller::date dd; if (mm &lt; ll) dd = getZellerDate(ll); else if (mm &lt; rr) dd = getZellerDate(rr); else &#123; auto id = getMotherDayId(y + 1); dd = getZellerDate(id); &#125; cout &lt;&lt; dateString(dd.year, dd.month, dd.day) &lt;&lt; endl; &#125; &#125; return 0;&#125; 于是这个题目就变成了愉快的板子题。 看了官方题解，采用的是打表找规律：因为每年365天满足 365 ≡ 1 mod 7，第x个星期日每次的日期偏移是1——所以某月第确定个个星期日一定是出现在一个确定的范围内；找规律可以发现出了闰年之外，每年变化一天；这样我们就可以先打表预处理本就不大的范围内的父亲解母亲节日期，然后再根据输入二分查找。 小声bb：出题人为了照顾大家的英语水平，甚至事后补充了十二个月的单词拼写和 st/nd/rd/th…… G - 血压游戏 一棵树上n个点，每个点有一些松鼠。有一个根节点，这些松鼠都会朝根节点跑，最后在根节点被救出。单位时间内，这些松鼠会按顺序做下面这些事情： 如果这个节点上有多只松鼠，那么先打架，导致一只松鼠去世 剩下来的松鼠跑到当前节点的父节点上；如果当前在根节点，那么被救出 问，所有的松鼠都被从树中救出后，一共还剩下多少只松鼠。 一些想法 暴力做法就是多次DFS更新树节点，统计答案，平均O(nh)；但是显然当树退化成一条链的时候，这样做就变成平方的了，也就是说没了（ 想过分层统计每一层树高上的松鼠数量然后……好像和上面没什么区别啊== 但是不同深度的松鼠确实是互不影响的，如果使用某种方法分层处理就好了（ 解题思路 虽然不是很懂，但是读完题之后就产生了这题要使用树剖的预感；虽然最后没做出来== 看了民间的题解，确实需要使用树剖的知识。在开始补题之前，先简单介绍一下这些前置知识： DSU on tree 官方题解思路一：对于每一种深度的点分块建虚树，对于每一棵虚树统计答案；总复杂度O(n log n)。 补题代码 H - 纸牌游戏 扑克，有n张牌，每张代表0~9的数字；要求从手牌中选出k张，组成一个能被3整除的k位非负整数，且不能有前导零；问最大能组成多少。 不超过1000组数据，不超过1e5张牌；这些数字用一个字符串给出；如果无解，输出-1. I - 古老的打字机 有n个小写字母构成的字符串si，每个字符串的价值是vi；有一个只有一个键的打字机，你的输入有50%的概率变成backspace，剩下的50%是输入一个随机小写字母；你按下了这个按键m次，得到了字符串t；这个字符串的价值可以这样计算：设字符串si在t中出现了ci次，那么价值是 \\[ \\sum_{i=1}^n c_i v_i \\] 求随机字符串t的价值的数学期望，并且输出这个值的\\(21^m\\)倍数关于1e9+7的模。 J - 能到达吗 n × m的地图中有k个障碍物，给定了障碍物的坐标；玩家最开始在左上角(1,1)，可以四方向在地图内无障碍物的地方移动；求地图中可以互相连通的点对的数量，关于1e9+7取模；这里的点对的两个点可以是一致的，但是颠倒的点对将被算作和原点对同一个。 K - 迷宫 n × m的迷宫，有障碍；给定起点和终点，玩家可以四方向移动，还可以使用一次穿越：无视连通性，在一步的时间内转移到切比雪夫/曼哈顿距离不超过d的另一片空地上；求到达终点所需要的最少步数，如果无解，输出-1. 一些想法 切比雪夫距离，扩展开来是一个 L - 动物森友会 你需要参加n个活动c次数，但这些活动每周只会在固定的m天开放；此外，你每天最多只能参加e次活动；问从一周的周一开始，你最少要几天后才能参加完这些活动。 一些想法 像极了二分图匹配模型，但是因为每天可以干多项活动，每天也有数量限制，那么就用具有通用性的网络流，应该就好可以了。于是，网络流建模完了然后呢？ 解题思路 这题目确实应该就是要用网络流的了。那么我们首先来建个模： 从源点向一周的七天连边，边的流量是这个日子经历的次数*e 每周天向当天可以举行的活动连边，边的流量是无穷大 从每个活动向汇点连边，第i个活动的边的流量是ci 非常的合理：从源点流出的是我们可以执行活动的总次数，流向汇点的是有效的次数；如果最后满流了，那么也就成了。但是这并不能帮助我们直观的求出来答案天数。 进一步分析，求的是满足条件的最小天数：显然这是一个具有二分单调性的经典模型；然后，这个网络流模型从源点流出的边的流量恰好需要一个确定的天数来确定，然后判断一个答案的可行性——那么一个使用二分+网络流模型来解题的思路就有了。 曾经某一次比赛中，可能有这么一个同学说过了这样一句话：“网络流的本质还是贪心”；那么这个题目（确实，七天不算是特别复杂）可不可以直接裸贪心来解决呢？ 693EA78014F78D5CE246D2818BCC3E4E.jpg 那等我想到了再补好了（ 补题代码 补题的时候这个题目总是过不了，一度让我认为我的板子出锅了== 然而经过多轮检查，发现它并没有什么问题（ 这是网络流最大流的dinic算法+当前弧的板子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556namespace FlowNetwork&#123; int dis[N], cur[N]; int S, T, cnt = 0; auto __addedge = [](int u, int v, longs w) &#123; FWS::addedge(u, v, w); FWS::addedge(v, u, 0); &#125;; bool bfs() &#123; using namespace FWS; static queue&lt;int&gt; q; memset(dis, 0x3f, sizeof(int)*(cnt + 1)); q.push(S); dis[S] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int cc = head[u]; ~cc; cc = ee[cc].next) &#123; edge&amp; e = ee[cc]; int v = e.v, w = e.w; cur[u] = head[u]; if (!w || dis[v] &lt;= dis[u] + 1) continue; dis[v] = dis[u] + 1; q.push(v); &#125; &#125; return dis[T] != inf; &#125; longs dfs(int u, longs inflow) &#123; using namespace FWS; if (u == T) return inflow; longs outflow = 0, rest = inflow; for (int &amp;cc = cur[u]; ~cc; cc = ee[cc].next) &#123; edge &amp;e = ee[cc]; int v = e.v; longs w = e.w; edge &amp;r = ee[cc ^ 1]; if (!w || dis[v] != dis[u] + 1) continue; longs t = dfs(v, min(w, rest)); outflow += t; e.w -= t; r.w += t; rest -= t; if (!rest) break; &#125; if (!outflow) dis[u] = 0; return outflow; &#125; longs dinic() &#123; longs maxflow = 0; while (bfs()) maxflow += dfs(S, inf); return maxflow; &#125;&#125; 日……loj的代码编辑器也太好看了吧== 个人觉得某些方面超过Monaco Editor了。如果我知道了这是哪个前端轮子的话我也去整一个——不过整哪里呢（ 然后就是本题的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;bitset&gt;#define FN FlowNetworkusing namespace std;using longs = long long;const signed inf = 0x3f3f3f3f;const longs INF = 0x3f3f3f3f3f3f3f3f;const int N = 1050, M = N * 8;int n, e, c[N], sum;bitset&lt;8&gt; a[N];struct edge&#123; int u, v, next; longs w; edge() = default; edge(int u, int v, longs w, int next) : u(u), v(v), w(w), next(next) &#123;&#125;&#125;;namespace FWS&#123; int head[N]; int tot; edge ee[M * 2]; void init(int n = N-1) &#123; memset(head, -1, sizeof(int)*(n+1)); tot = 0; &#125; void addedge(int u, int v, longs w) &#123; ee[tot] = edge(u,v,w,head[u]); head[u] = tot ++; &#125;&#125;namespace FlowNetwork&#123; int dis[N], cur[N]; int S, T, cnt = 0; const int __event = 9, __day = 2; auto event = [](int i)&#123;return __event+i;&#125;; auto day = [](int i)&#123;return __day+i;&#125;; auto __addedge = [](int u, int v, longs w) &#123; FWS::addedge(u, v, w); FWS::addedge(v, u, 0); &#125;; auto __build = [](int t) &#123; cnt = 0; FWS::init(n+9); S = ++ cnt; T = ++ cnt; for (int i = 1; i &lt;= 7; ++ i) __addedge(S, ++ cnt, (t/7+(t%7&gt;=i))*e); for (int i = 1; i &lt;= n; ++ i) &#123; __addedge(++ cnt, T, c[i]); for (int j = 1; j &lt;= 7; ++ j) if (a[i][j]) __addedge(day(j), cnt, INF); &#125; &#125;; bool bfs() &#123; using namespace FWS; static queue&lt;int&gt; q; memset(dis, 0x3f, sizeof(int)*(cnt + 1)); q.push(S); dis[S] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); for (int cc = head[u]; ~cc; cc = ee[cc].next) &#123; edge&amp; e = ee[cc]; int v = e.v, w = e.w; cur[u] = head[u]; if (!w || dis[v] &lt;= dis[u] + 1) continue; dis[v] = dis[u] + 1; q.push(v); &#125; &#125; return dis[T] != inf; &#125; longs dfs(int u, longs inflow) &#123; using namespace FWS; if (u == T) return inflow; longs outflow = 0, rest = inflow; for (int &amp;cc = cur[u]; ~cc; cc = ee[cc].next) &#123; edge &amp;e = ee[cc]; int v = e.v; longs w = e.w; edge &amp;r = ee[cc ^ 1]; if (!w || dis[v] != dis[u] + 1) continue; longs t = dfs(v, min(w, rest)); outflow += t; e.w -= t; r.w += t; rest -= t; if (!rest) break; &#125; if (!outflow) dis[u] = 0; return outflow; &#125; longs dinic() &#123; longs maxflow = 0; while (bfs()) maxflow += dfs(S, INF); return maxflow; &#125;&#125;signed main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); cin &gt;&gt; n &gt;&gt; e; int m, x; sum = 0; for (int i = 1; i &lt;= n; ++ i) &#123; cin &gt;&gt; c[i] &gt;&gt; m; sum += c[i]; while (m --) &#123; cin &gt;&gt; x; a[i][x] = true; &#125; &#125; auto check = [&amp;](int mid) &#123; if (e * mid &lt; sum) return false; FN::__build(mid); return FN::dinic() == sum; &#125;; int ll = 0, rr = inf / e, ans = 0; while (ll &lt;= rr) &#123; int mm = ll + rr &gt;&gt; 1; if (check(mm)) ans = mm, rr = -- mm; else ll = ++ mm; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 真的离谱：验完板子，还是那个板子重新敲一遍就一遍过了可还行（ 后记","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"https://shiraha.cn/tags/Nowcoder/"}]},{"title":"Nowcoder 练习赛61","slug":"nowcoder-practice-contest-61","date":"2020-04-10T16:07:41.000Z","updated":"2020-04-10T16:07:41.000Z","comments":true,"path":"2020/nowcoder-practice-contest-61/","link":"","permalink":"https://shiraha.cn/2020/nowcoder-practice-contest-61/","excerpt":"","text":"按照惯例，开始之前先码一下比赛的一些相关链接： 比赛地址： https://ac.nowcoder.com/acm/contest/5026#question 官方题解： https://ac.nowcoder.com/discuss/405216?type=101&amp;order=0&amp;pos=1&amp;page=1 题目比较的简单，做起来还算是比较舒服的—— 但是最后两个题目没做出来，不太行。题解还是一如既往的中规中矩，虽然说做起来或多或少都有些思路，有的题目应该还是有一些别的简单乱搞一些的办法来解决的； 夜。大雨，家里没水== 9O14_@MZ6L~_Z_X_NQQLP_9.jpg 下次还是多打点天梯舒服一点……话说周日就要武大校赛了啊== 害，要好好打啊（）下面开始： A - 打怪 非常简单，所有的怪的hp和atk是一样的。只需要计算你会挨它几下然后计算总伤害就可以了；因为要保证自己不死，所以还需要处理一下自己的余数；总而言之细心点准没错。 然后就吃了一发罚时，bksn 我的代码 这是比赛时交的代码： 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;using namespace std;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int t, hp, atk, h, a; auto solve = [&amp;]() -&gt; int &#123; int xx = h / atk; int yy = h - xx*atk; int tt = yy ? xx : xx-1; int dmg = a*tt; cerr &lt;&lt; dmg &lt;&lt; endl; if (!dmg) return -1; else return hp%dmg ? hp/dmg : hp/dmg-1; &#125;; cin &gt;&gt; t; while (t --) &#123; cin &gt;&gt; hp &gt;&gt; atk &gt;&gt; h &gt;&gt; a; cout &lt;&lt; solve() &lt;&lt; endl; &#125; return 0;&#125; 因为是直接写的所以就顾不上美观了（ B - 吃水果 算是一个贪心题吧。关于输入的两种水果的数量，设较多的那个是x，另一个是y；简单分析一下就可以得到下面几种情况： x = y： 直接吃就可以了，输出x； x = 2y：消费1使得较少的翻倍，然后就变成情况1了，输出x+1； x &lt; 2y：可以先吃一点变成情况2，然后再吃完，输出x+1； x &gt; 2y：……一眼看不出来，那除了翻倍y别无他法——但是这样一定可以转化为上面某一种情况； 所以，分情况讨论完了之后就简单了：分情况判断完了返回不同的值就可以了； 此外，题解提了一句说因为规模比较小可以模拟。 我的代码 综上所述，除了第四种情况需要一个递归（甚至也不需要）之外无他； 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;int solve(int n, int m)&#123; if (n == m) return n; int x = max(n,m), y = min(n,m); if (x == y&lt;&lt;1) return y&lt;&lt;1^1; else if (x &lt; y&lt;&lt;1) return x+1; else return solve(x,y&lt;&lt;1)+1;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int t, n, m; cin &gt;&gt; t; while (t --) &#123; cin &gt;&gt; n &gt;&gt; m; cout &lt;&lt; solve(n,m) &lt;&lt; endl; &#125; return 0;&#125; 图省事就没改成迭代了（ C - 选择题 稍微麻烦一点的题目。看题干还是比较容易想到是使用一个并查集，先把必须要答案相同的选择题合并起来，然后再分块搜索；心里想着最坏情况12个选择题全部独立，需要4¹²种情况绝对会T的……后来看看题目的样例，已经可以说是最坏情况了，因为有限制的存在，爆搜会剪枝——情况似乎大概也就369600大概的水平：3e5 &lt;&lt; 5e8，所以大概还是可行的；实际上也是可行的就是了（就这？ 题解的说法是使用DP——倒也不是没想到，甚至我的文件里还有注释掉了的写了一半的DP== 但是因为实在是有点麻烦，还是爆搜来的简单就偷懒没写了== 就结果而言是好的（ 因为这个题n=12，实在是太小了（）题解里还说了一些在n更大的时候可以做的一些优化： （多重背包问题）：如果数据量再大一点，可以把所有背包的体积的所有状态哈希一下，变成一个二维dp，再滚动一下第一维即可。 如果是使用DP来解的话，那就是比较经典的多重背包问题。我们定义 \\(dp[i][x_1][x_2][x_3][x_4]\\) 是枚举了i个物品，四个背包（答案选项）已经使用了\\(x_{1..4}\\)个的状态。那么转移就可以从其他不同背包转移过来，枚举所有的背包就可以了；因为每个背包有容量上限，所以有的情况是转移不了的，可以节约掉。 我的代码 比赛时直接莽了一波写了一个剪枝的暴力搜索；非常的丑陋但是因为不想重写了所以就这样： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;functional&gt;#include &lt;cstring&gt;#include &lt;map&gt;using namespace std;int max4(int a, int b, int c, int d)&#123; return max(a,max(b,max(c,d)));&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int na, nb, nc, nd, m; int x, y, p[13]; for (int i = 0; i &lt;= 12; ++ i) p[i] = i; function&lt;int(int)&gt; father = [&amp;](int ii) -&gt; int &#123; if (p[ii] == ii) return ii; else return p[ii] = father(p[ii]); &#125;; auto join = [&amp;](int x, int y) &#123; int px = father(x), py = father(y); p[px] = py; &#125;; int num[13], cnt = 0, ans = 0; map&lt;int,int&gt; mm; function&lt;int(int,int,int,int,int)&gt; search = [&amp;](int s, int a,int b, int c, int d) -&gt; int &#123; if (s == cnt) return 1; else if (num[s] &gt; max4(a,b,c,d)) return 0; int ret = 0; if (a &gt;= num[s]) ret += search(s+1,a-num[s],b,c,d); if (b &gt;= num[s]) ret += search(s+1,a,b-num[s],c,d); if (c &gt;= num[s]) ret += search(s+1,a,b,c-num[s],d); if (d &gt;= num[s]) ret += search(s+1,a,b,c,d-num[s]); return ret; &#125;; cin &gt;&gt; na &gt;&gt; nb &gt;&gt; nc &gt;&gt; nd &gt;&gt; m; while (m --) &#123; cin &gt;&gt; x &gt;&gt; y; join(x,y); &#125; memset(num,0,sizeof num); for (int i = 1; i &lt;= 12; ++ i) &#123; if (!mm[father(i)]) mm[p[i]] = ++cnt; ++ num[mm[p[i]]]; &#125; cout &lt;&lt; search(1,na,nb,nc,nd) &lt;&lt; endl; return 0;&#125; 使用并查集完了之后再统计一波——甚至还要为此开一个map是真的丑陋…… 虽然时间上大概是O(n)的而且n非常非常小，并不会带来什么影响但是还是丑陋== 下次还是少用点lambda表达式吧（ 因为这个题目理论上是要DP搜索的，所以还是补了一下丑陋的DP代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;functional&gt;#include &lt;cstring&gt;#include &lt;map&gt;using namespace std;typedef long long longs;typedef long double longd;const int N = 2e6+5;const int inf = 0x7fffffff;const longs INF = 0x7fffffffffffffff;const double eps = 1e-8;int max4(int a, int b, int c, int d)&#123; return max(a,max(b,max(c,d)));&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int na, nb, nc, nd, m; int x, y, p[13]; for (int i = 0; i &lt;= 12; ++ i) p[i] = i; function&lt;int(int)&gt; father = [&amp;](int ii) -&gt; int &#123; if (p[ii] == ii) return ii; else return p[ii] = father(p[ii]); &#125;; auto join = [&amp;](int x, int y) &#123; int px = father(x), py = father(y); p[px] = py; &#125;; int num[13], cnt = 0, ans = 0; map&lt;int,int&gt; mm; int f[13][13][13][13][13]; auto dp = [&amp;] &#123; memset(f, 0, sizeof(f)); f[0][0][0][0][0] = 1; for (int i = 1; i &lt;= cnt; ++ i) for (int a = 0; a &lt;= na; ++ a) for (int b = 0; b &lt;= nb; ++ b) for (int c = 0; c &lt;= nc; ++ c) for (int d = 0; d &lt;= nd; ++ d) &#123; auto &amp;xx = num[i]; if (a + xx &lt;= na) f[i][a+xx][b][c][d] += f[i-1][a][b][c][d]; if (b + xx &lt;= nb) f[i][a][b+xx][c][d] += f[i-1][a][b][c][d]; if (c + xx &lt;= nc) f[i][a][b][c+xx][d] += f[i-1][a][b][c][d]; if (d + xx &lt;= nd) f[i][a][b][c][d+xx] += f[i-1][a][b][c][d]; &#125; return f[cnt][na][nb][nc][nd]; &#125;; cin &gt;&gt; na &gt;&gt; nb &gt;&gt; nc &gt;&gt; nd &gt;&gt; m; while (m --) &#123; cin &gt;&gt; x &gt;&gt; y; join(x,y); &#125; memset(num,0,sizeof num); for (int i = 1; i &lt;= 12; ++ i) &#123; if (!mm[father(i)]) mm[p[i]] = ++cnt; ++ num[mm[p[i]]]; &#125; cout &lt;&lt; dp() &lt;&lt; endl; return 0;&#125; 至于背包的状态的哈希那就没有做了。 D - 最短路 这样的题目不出意外应该是第三次遇到了——一种显而易见的套路就是正向反向最短路，然后枚举要”修改“的边，根据最短路求出的值快速计算新值，从而进行判断；而且这个题目也没有像洛谷那个题目那样卡了遍历，可以说没有什么路子都是套路了。 关于判断的部分：首先我们可以求出原来的最短路；然后可以快速算出来的新路长度，一定是包含反转后的这条路的最短路——其他的路要不不变，要不变了也不是最短路。所以：如果它可以更新最短路，那么最短路显然变短；否则，一定不会存在其他的路可以更新最短路。 唯一有些担心的是：如果这些更新是累计的更新的话，这种针对一条边修改的套路就会失效。方法……等我想出来再说吧（ 题解分析 题解里最后提了一句，问应该如何判断修改单边之后，判断最短路长度是否不变的做法。 解决这个问题之前，我们应该先意识到：如果最短路因为单边修改而缩短，那么显然这样就可以；但是如果单边的修改破坏了原有最短路，我们并不能直接看出增长之后的最短路的长度——于是就不能判定不变了。 我的代码 使用dijkstra正反扫描最短路，然后针对询问进行O(1)的查询。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;typedef long long longs;struct edge&#123; int u, v, w, next; edge() = default; edge(int u, int v, int w, int next) : u(u), v(v), w(w), next(next) &#123;&#125;&#125;;const int N = 1e5+5, M = 2e5+5;int n, m;namespace FWS&#123; int head[N]; int tail[N]; int tot; edge ee[M*2]; void init() &#123; memset(head, -1, sizeof(int)*(n+1)); memset(tail, -1, sizeof(int)*(n+1)); tot = 0; &#125; void addedge(int u, int v, int w) &#123; ee[tot] = edge(u,v,w,head[u]); head[u] = tot ++; ee[tot] = edge(v,u,w,tail[v]); tail[v] = tot ++; &#125;&#125;namespace dij&#123; using namespace FWS; bool vis[N]; longs ds[N], dt[N]; void dijkstra(int goal) &#123; priority_queue&lt;pair&lt;longs ,int&gt;&gt; q; int* li = goal == n ? tail : head; longs* dis = goal == n ? dt : ds; q.push(make_pair(0, goal)); memset(vis,0, sizeof(bool)*(n+1)); memset(dis,0x3f, sizeof(longs)*(n+1)); dis[goal] = 0; while (!q.empty()) &#123; int u = q.top().second; q.pop(); if (vis[u]) continue; vis[u] = true; for (int c = li[u]; ~c; c = ee[c].next) &#123; edge&amp; e = ee[c]; int v = e.v; if (dis[v] &gt;= dis[u] + e.w) q.push(make_pair( -(dis[v] = dis[u] + e.w), v )); &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); using dij::dijkstra; int u, v, c; int x, q; cin &gt;&gt; n &gt;&gt; m; FWS::init(); while (m --) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; c; FWS::addedge(u,v,c); &#125; dijkstra(1); dijkstra(n); const longs shortest = dij::ds[n]; cin &gt;&gt; q; while (q --) &#123; cin &gt;&gt; x; auto&amp; ii = FWS::ee[(x-1)&lt;&lt;1]; longs to = dij::ds[ii.v] + dij::dt[ii.u] + ii.w; if (to &lt; shortest) cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; &#125; return 0;&#125; 一直抄板子一直爽 E - 字符串 这个题目做的有点憋屈……最后一个多小时几乎都砸在这个题目上：我一直觉得这个题目是KMP，然而我对于KMP的next数组理解的并没有那么的透彻（除了板子一无所有）；最后就演变成了对着log打出来的next数组找规律，嗯……找规律……属实离谱（ 然而，标答给的算法是二分答案+DP——看似奇妙又显而易见，啊这…… 我也许是受了吹水群里一波接着一波的KMP的影响吧。但是这个题目真的不能使用KMP吗……就算是不能使用KMP也应该有一个反例来证明才是。我想通了就再这里写清楚好了。 题解分析 显然，这个问题相当于求解：字符串s中有k个相同的子串p，要求使得 x = p.length() 最大化；显然这个x，又具有显而易见的二分单调性——x的极限值之下均可行，以上均不可行；问题转化为寻找简单的验证x是否可行的方法——然而这又可以使用显而易见的DP完成，于是就大概有做这个题的思路了。 那么这个DP具体应该怎么操作呢：直接比较字符串，且不说是不是会暴毙，想想都觉的丑陋== 这个时候就可以使用万能的hash——将所有的长度为m的子串hash化，然后使用map储存hash-dp键值对；具体的操作方法如下： 开dp数组和map：map用来存储长度为x且 hash code 为h的字符串在已经扫描过的部分中最后一次出现的位置，用开头的下标表示；dp[i]的含义是下标i开头的（长度为x）字符串在子串[begin, i + x]中出现的最大次数；知道定义之后，操作就比较的简单了：从头扫描到尾，当扫描的部分长度大于x的时候，就每次将长度为x后缀计算hash放进map中，并且标记它的开头位置；然后计算从i开始的长度为x的子串的哈希：如果这个哈希还没出现在map中，那么它出现了一次，暂且可以标记dp[i] = 1；否则，它可以从上次出现的位置转移过来，这个位置就是被map记录的位置。 然后我们二分这个x，check当子串长度为x时所有字串出现的最大次数是否能够超过k即可；特别注意要特判0——因为0不是一个字符串，上述统计方法无法正常转移，会统计出确定值1.（其实应该是∞） 想想都觉得这个hash-dp十分的诡异……如果这真的是唯一做法那我认了（但其实这题还可以使用后缀数组 我的代码 真的是debug到吐血——这样的经历说明了一件事情：标准是根据算法来的，而不是个人喜好来的== 比如这字符串哈希，一般最好是字符串存储在[1 ... n]的下标，用[L, R]来标记子串比较方便自然。然而我采用经典的[0 ... n)、[L, R)标记法，就会导致一堆情况要特判（ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;unordered_map&gt;#include &lt;cstring&gt;using namespace std;typedef unsigned long long ulongs;const int N = 2e6+5;int n, k; char s[N];int ff[N];namespace StringHash&#123; const int __base = 6151; const int __offset = 97; ulongs pow[N], var[N]; int __idx(const char ch) &#123; return ch - &#x27;a&#x27; + 1; &#125; void init(const char* s) &#123; pow[0] = 1; var[0] = __idx(s[0]) + __offset; int n = strlen(s); for (int i = 1; i &lt; n; ++ i) &#123; pow[i] = pow[i - 1] * __base; var[i] = var[i - 1] * __base + __idx(s[i]) + __offset; &#125; &#125; ulongs getHashCode(int l, int r) &#123; if (l == r || !r) return 0ull; auto __elim = l ? var[l - 1] : 0ull; return var[r - 1] - __elim * pow[r - l]; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); auto check = [&amp;](int mid) -&gt; bool &#123; if (mid == 0) return true; using StringHash::getHashCode; static unordered_map&lt;ulongs, int&gt; map; int ret = 0, lim = n - mid; for (int i = 0; i &lt;= lim; ++ i) &#123; if (i - mid &gt;= 0) map[getHashCode(i - mid, i)] = i - mid; ulongs hashcode = getHashCode(i, i + mid); ff[i] = map.count(hashcode) ? ff[map[hashcode]] + 1 : 1; ret = max(ret, ff[i]); &#125; map.clear(); return ret &gt;= k; &#125;; cin &gt;&gt; n &gt;&gt; k &gt;&gt; s; StringHash::init(s); int ll = 0, rr = n, ans = 0; check(0); while (ll &lt;= rr) &#123; int mm = ll + rr &gt;&gt; 1; if (check(mm)) ans = mm, ll = ++ mm; else rr = -- mm; &#125; cout &lt;&lt; ans &lt;&lt; endl; return 0;&#125; 这个代码的上一个版本也AC了，但是使用Valgrind分析发现有一处[-1]的越界访问，就离谱（ F - 林檎树 唔姆……看了下答案，我完全没有想对== 但是出于学习目的，还是把我的一些想法在这里记录一下好了： 首先肯定建树，然后用一个set维护苹果的成熟度和位置；这样每次新建苹果就会变成向set中插入节点，找到所有符合条件的苹果就变成STL的两个bound；求到一个苹果的距离就等于说是带权LCA，在所有的苹果里求一个最小值就好办了；除了带权LCA之外的都可以用STL轻松实现，美滋滋（ 看起来十分的美好，但是可能被一些极端的数据卡掉——如果所有的苹果都落在了符合条件的区间内的话，就算题目给了4s也会被活活卡死== 因为没有写这只是推测，但是至少说明这个算法还需要进一步的优化或者说根本就不行。 然而…… 78_0_9_S2_2LN9518NZ1DSP.jpg 事实上，当我找了半个小时发现我并没有现成的、完成度比较好的带权LCA板子之后我就放弃写这题了（ 题解分析 要想做这个题，首先你要先学会线段树和点分治。明白，这就去学习点分治（ 我的代码 后记 虽然这场打的还算是比较顺利的，但是实际上还是并不理想；之后的准备，一方面是要多整一点模板：有了想法却没有优秀的板子支撑实在是太令人心痛了（）平时算法学习还是要注意理解——甚至到现在我还是觉得，E题可以通过魔改KMP利用next数组求解== 比赛是打不完的，今晚（明天凌晨）的cf教育场，明天AtCoder和洛谷的公开赛，后天的武大校赛…… 既来之则安之，砥砺前行，尽心尽力完成每一个题目吧。 又及：Typora里的排版到博客上渲染不了内联CSS有些难受……&lt;br/&gt;强制换行就很蠢（ 2020-4-11 1:11:11 雨未停","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"https://shiraha.cn/tags/Nowcoder/"}]},{"title":"洛谷ACM春季多校训练营：第五场","slug":"luogu-ACM-2020-spring-multi-5","date":"2020-03-31T01:40:01.000Z","updated":"2020-03-31T01:40:01.000Z","comments":true,"path":"2020/luogu-ACM-2020-spring-multi-5/","link":"","permalink":"https://shiraha.cn/2020/luogu-ACM-2020-spring-multi-5/","excerpt":"","text":"这一波还是只有八个题目。简单题基本上算是真正的简单题，套模板或者自己认真写一写就出来了；但是麻烦的题就总是感觉还差一把火的样子——倒不如说这应该是水平不足的通常表现吧。还是因为版权原因，并不能把题目挂出来，所以只能看我空讲了： 根据出题人的定义，题目的难度分配大概是下面这样的： 简单题 中档题 困难题 C、F、G A、D B、E、H 既然给了难度定义，那就根据出题人的思路来补这套题。部分题就直接使用赛场上的代码了。 C - Change 给n个题，每个题有一些可用的名字，问能否让第i个题以第i个字母开头；可以改变题目的顺序。 说白了就是二分图匹配：每个题有的名字的头文字就是连边，表示这个题可以和这些头文字匹配；二分图两侧都有n个元素，问是否存在满匹配；这种问题有多个模板解法，比如匈牙利DFS和dinic算法。矩阵乘法是怎么解决的我不太了解，了解了再做一个专题好了。这里我就直接套了一个匈牙利的板子。 代码 这是套了匈牙利算法的板子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std;typedef long long longs;int n,q,m;bool li[30][30]; // =&gt;[n][m]bool visit[30]; // =&gt; m(首字母)int match[30]; // =&gt;match[m]=nbool nextMatch(int i)&#123; for(int j=0;j&lt;m;++j) // 不要从中途开始 if(li[i][j]&amp;&amp;!visit[j]) &#123; visit[j] = true; if(!~match[j]||nextMatch(match[j])) &#123; match[j] = i; return true; &#125; &#125; return false;&#125;inline int maxMatch()&#123; int ans = 0; for(int i=0;i&lt;n;++i) // 要重置visit &#123; memset(visit,0,sizeof(bool)*(m+1)); if(nextMatch(i)) ++ans; &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); cin&gt;&gt;n; m = n; string s; memset(li,0,sizeof li); memset(match,-1,sizeof match); for (int i = 0; i &lt; n; ++ i) &#123; cin &gt;&gt; q; while (q--) &#123; cin &gt;&gt; s; li[i][s[0]-&#x27;a&#x27;] = true; &#125; &#125; const int matches = maxMatch(); cerr &lt;&lt;matches&lt;&lt;endl; cout&lt;&lt;(matches == n ? &quot;Yes&quot; : &quot;No&quot;)&lt;&lt;endl; return 0;&#125; 需要注意的是，一般来说都使用0表示未匹配状态；但是这里因为每个待匹配元素是char-'a'，所以0本身也是一个匹配元素，应该使用其他方便的数字比如-1作为未匹配状态；或者也可以修正字符的值。虽然是很细节的东西但是吃了罚时所以还是要注意一下。不如之后的模板都使用-1作为未匹配状态，更加健壮。 F - Flaw 给定一个不等式，问在自然溢出的意义下成立的方案数 这里的溢出指的是int溢出。出题人也说少考虑了好多种情况；对于不等式a+n1&lt;/&gt;n2来说，左侧的a+n1是分成多个区间的：一个区间是未溢出时正常运算，还有一部分是溢出后的部分；分别讨论处理一下就可以了——具体地说，可以是下面这样： 对于a+n1&lt;n2： 未溢出的部分是[-2³¹, n2-n1)，溢出的部分是[2³¹-n1,INTMAX]； 对于a+n1&gt;n2： 未溢出的部分是(n2-n1, INTMAX-n1]，溢出的部分是[INTMAX+n2-n1,INTMAX]； 处理一下读入的字符串然后进行对应的计算就可以了。但是本题更为经济的做法是观察题目样例，找到规律。比如下面的代码： 代码 进行一些线性组合的猜测后发现这个答案似乎只和n2有关，因此可以这么写： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long longs;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n1,n2; char ch; cin&gt;&gt;ch&gt;&gt;ch&gt;&gt;n1&gt;&gt;ch&gt;&gt;n2; longs ans; if (ch == &#x27;&gt;&#x27;) &#123; ans = 2147483647ll-n2; &#125; else &#123; ans = 2147483648ll+n2; &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 说是int范围，但是答案还是会爆int的。 G - Gene 给定两个大写字符串进行匹配：其中匹配是alpha分，失配是-beta分，gap是-gamma分；问最大匹配得分 看题目样例给的图，真的像极了LCS——其实它就是一个LCS：只是转移的规则不太一样——失配有减益效果，使用空格也需要费用。那么简单修改LCS的模板就可以了：转移不再仅通过判等来转移，而是直接通过成本转移；因为空挡有损失，所以dp[0,i]和dp[i,0]都需要预先填入i个空挡的消费。 最后算法的时间复杂度是O(nm)的。 代码 这是n²空间的写法；实际上这是显然可以优化到线性空间的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long longs;const int N = 5050, M = 5050;inline longs max3(longs a, longs b, longs c)&#123; return max(max(a,b),c);&#125;int n,m,a,b,y;char s1[N],s2[N];longs dp[N][M];int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); cin&gt;&gt;n&gt;&gt;m&gt;&gt;a&gt;&gt;b&gt;&gt;y; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; s1[i]; for (int i = 1; i &lt;= m; ++ i) cin &gt;&gt; s2[i]; dp[0][0] = 0; for (longs i = 1; i &lt;= n; ++ i) dp[i][0] = -y*i; for (longs i = 1; i &lt;= m; ++ i) dp[0][i] = -y*i; for (int i = 1; i &lt;= n; ++ i) &#123; for (int j = 1; j &lt;= m; ++ j) &#123; dp[i][j] = max3( dp[i-1][j-1]+(s1[i]==s2[j]?a:-b), dp[i-1][j]-y, dp[i][j-1]-y ); &#125; &#125; cout &lt;&lt; dp[n][m] &lt;&lt;endl; return 0;&#125; 然后这题评测机闹了个乌龙：我连续两发WA的莫名其妙，最后队友一交就过了=== 唯一的区别是我是C++14 O2，他直接交的C++(11)；后来我尝试关掉O2优化也通过了，他把我的cin.tie(nullptr)搞成0，开O2也过了，就比较的玄学。 纯 氧 杀 人 （大嘘） A - Ammunition 有三个物品，第一种值是a，第二种值是b，第三种值在[0,b/2]中任选，物品的值是整数，现在拿了n个物品，问值的和是否可能是m，保证a&lt;b。 就是说，你有a，b和[0,b&gt;&gt;1]的整数，能否可以从中选取n个整数，使得他们的和为m。 因为自己的一些考虑炸了，所以直接按照标准答案的方法：首先排除不可能的情况——比如超过了max(a,b)*n的话，是无论如何都不可能解决的；话说题目里保证了a&lt;b，那就不用max了；在接下来的讨论中，我们将[0,b&gt;&gt;1]记为c。 然后就是先只考虑b：如果只选b，那显然就是{kb}，k∈[0,n]；换一个b成c，可以达成[kb, kb+(b&gt;&gt;1)]，k∈[0,n)；换两个，那就可达成[kb, kb+(b&gt;&gt;1&lt;&lt;1)]，k∈[0,n-1)；综合考虑，就是说可以选到[0,(n-1)b+(b&gt;&gt;1)] ∪ {nb}范围内的所有数字。这已经是一个很稳健的范围了； 接下来在上面的基础上再考虑a：如果a ≤ (b&gt;&gt;1)，那没事了，要你何用；否则，绝大多数的可能性也都被上面的很大的范围包含了，只需要考虑处于((n-1)b+(b&gt;&gt;1), nb)范围内的值就可以了，而这样的值是有限个的；虽然得出这样的值也是有一定的策略的： 理论上，a可以由b或c变过来，但是如果遍历的话就比较蠢了；我们可以反向考虑：这个值之所以还需要a，是因为它大于上述的连续区间——也就是容不得b&gt;&gt;1存在；如果这个只有ab构成的值要变成上界nb，那只能把它的a全部换成b——也就是它和max的差必须是b-a的倍数；这样就可以做出来这个题目了。 出题人的标程使用了__int128这种标准库不支持且仅可以在Linux环境下使用的类型，实际上用unsigned long long也可以刚过去。 做题记录 这个题目，我最开始想着是解不等式：首先设选了x个a和y个b，满足下面不等式的情况： \\[ \\begin{cases} f(x,y) = m-ax-by&gt;0 \\\\ g(x,y) = x+y&lt;n \\end{cases} \\] 并且两个函数的值都尽可能的小。然后再根据剩余的值进行判断；但是最后因为情况实在是太多了于是作罢。也许这种做法需要gcd等一些东西？看起来又有点像是线性规划…… 最后尝试写出来的代码也没有考虑f大于0的情况，最后就导致一些本不可能的情况变得可能了起来== 如果再乱搞一波说不定还是可以的，但是实在管不了这么多特殊情况的乱搞了。但是果然还是没有上述标准做法来的简单轻松——不是没有想过换两个b，但是对于b换a考虑多了。 代码 使用出题人标程的策略完成的判断 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;typedef long long longs;typedef unsigned long long ulongs;const char ok[] = &quot;Yes&quot;;const char no[] = &quot;No&quot;;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); ulongs t, n, m, a, b; cin &gt;&gt; t; while (t --) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b; if (!n) cout &lt;&lt; (!m ? ok : no) &lt;&lt; endl; else &#123; ulongs max = n*b; ulongs maxx = max - b + (b&gt;&gt;1); ulongs diff = max - m; ulongs dis = b - a; if (m &gt; max) cout &lt;&lt; no &lt;&lt; endl; else if (m == max || m &lt;= maxx) cout &lt;&lt; ok &lt;&lt; endl; else if (diff % dis == 0) cout &lt;&lt; (diff / dis &lt;= n ? ok : no) &lt;&lt; endl; else cout &lt;&lt; no &lt;&lt; endl; &#125; &#125; return 0;&#125; 这么分析一波之后真实简单…… D - Duliu 定义maxpre和maxsuf（以下简称函数P和S）为参数区间的最大前缀/后缀和，要求求出： \\[ \\sum^n_{l=1}\\sum^n_{r=l+1}\\sum^{r-1}_{i=l}P(l,i)S(i+1,r) \\] 并且输出答案对指定质数取模后的值。 题如其名，看起来毒瘤的不行== 但是考虑上一次多校的那个A题，这种“全子串状态”考虑的问题——而且还是求和——更是要从考虑每个元素的贡献的角度入手；姑且大方向是确定的。 B - Bolshevik 有n个人，第i个人有ai元，钱包里有bi元，问第x个人想成为最有钱的人至少偷几个钱包 在这个题里，偷钱包有两种策略：一种是偷最有钱的人的钱包，降低成为最有钱的人的门槛；还有一种是偷钱包最有钱的人的钱包，获得最大收益。但是这两种策略不能等量齐观，都得视情况而定——这是显然的。 做题记录 感觉像极了贪心，但是又不知道应该怎么偷；毕竟偷最有钱的人还是最大方的人带来的收益并不能直观的表示出来…… 感觉和之前做过的两个人抢占目标点完全不一样== 虽然这是废话。 尝试了使用两个堆来维护钱包里钱的数量和总钱数，但是总是谜之挂在#7……就不是很能理解；感觉就凭自己还是不太能看出问题了……解决了这个问题再贴代码。 E - Earthquake 给定长度为n的序列，初值为0；给定两种操作：1：区间对x取max，然后这里从区间两端开始向两边传播，传播的过程中每传播一格就-1；2：区间max。 H - Heartfelt Fancy 给一个图，已经给定了部分边的边权；你可以加一条u和v之间的边，边权为 (u-v)²，以最小化s到t的最短路。 这是一个比较经典的问题：和上一次校内训练的添加节点是一样的思路——正向扫一遍反向扫一遍最短路，然后再遍历节点求出 (u-v)² 最优解；但是在这个题目里这样做会超时——不论最短路怎么求，最后遍历是O(n²)的，对于2e5的数据规模来说无论怎么也不可能过；因此可能需要考虑一些优化。 后记","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Luogu","slug":"Luogu","permalink":"https://shiraha.cn/tags/Luogu/"}]},{"title":"洛谷ACM春季多校训练营：第四场","slug":"luogu-ACM-2020-spring-multi-4","date":"2020-03-23T05:20:24.000Z","updated":"2020-03-23T05:20:24.000Z","comments":true,"path":"2020/luogu-ACM-2020-spring-multi-4/","link":"","permalink":"https://shiraha.cn/2020/luogu-ACM-2020-spring-multi-4/","excerpt":"","text":"因为是版权原因，这里并不能公开的放题目链接和题目的讲评之类的东西。各位看官就将就着看看我说吧== 已经没什么好怕的了（笑 这次的题解给的是比较干净的PDF，先行给个好评。这下要做的工作就要少很多—— 但是还是要认真的补题的。一共有八个题目，三个题目是比较白给的，但是不白给的一个也做不出（）现在想想这场要是足够能干的话还是可以AK的——我的意思是并不是标准场。 但是相对地，这次的讲评直播是 洛 谷 最 速 传 说（迫真 如果可以的话甚至想直接贴PDF，但是想想看看还是算了——还是一点一点听我讲罢了。 A - Ancient Tree 有一颗树，每个点都有点权。求这棵树的一颗Y型子树，这颗子树包含的所有点的点权xor和最大。所谓Y型树，就是最多有三条链连接到同一个节点的树，用题解的话说，就是求两条到根的链； B - Blooming Gentians 给定 n×m 的矩阵；每次先随机选择一种颜色删去，删去该颜色之后，与其他颜色不相邻的颜色也会被删去；求出将矩阵的所有颜色删去的次数的数学期望； C - Chests 给定n个数集，从每个集合中可以选择一个元素，要求选出的数字的方差最小； D - Decryption E - Eel F - Firm Structure 定义k-连通图为：至少删去 k 个点才能让图不连通的图。求 n 个点的 k-连通图的最小边数。 G - Giovanni's Ticket 解方程： A = ((x&gt;&gt;B) ^ C) + ((x&lt;&lt;D) ^ E) + x (mod (1&lt;&lt;32))。 H - Ham Sausage 将两头是半球体，中间是圆柱体的香肠尽可能的切成n段，求每一段的体积。 后记","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Luogu","slug":"Luogu","permalink":"https://shiraha.cn/tags/Luogu/"}]},{"title":"2015 NEERC 回顾","slug":"2015-neerc","date":"2020-03-23T03:17:56.000Z","updated":"2020-03-23T03:17:56.000Z","comments":true,"path":"2020/2015-neerc/","link":"","permalink":"https://shiraha.cn/2020/2015-neerc/","excerpt":"","text":"校队欢乐赛其三。现在还是觉得欢乐赛的氛围还是属实比较欢乐的，但是很快就要随着三月的结束而结束了。接下来就是正式结成队伍训练了。 按照惯例，先码官方网站：https://neerc.ifmo.ru/archive/2015.html 可以下载到问题集、测试数据和标程，但是不知道是什么原因，没有能找到题解的PPT…… 最后在谷歌上找到的题解PPT，链接在下面： 题解PPT：https://www.slideshare.net/elizarov/acm-icpc-2015-neerc-northeastern-european-regional-contest-problems-review?from_action=save 按照LinkedIn账号登陆就可以下载，也可以在线观看。等博客图书馆功能施工完成后也会提供站内链接 补题地址：http://codeforces.com/gym/100851 在开始之前应当特别注意：本次比赛中的绝大多数题目的输入输出都不是标准输出/输入文件，需要重定向输入流到特定文件。C++选手需要使用freopen(\"fileName\",\"r\",stdin)和freopen(\"fileName\",\"w\",stdout)；Java选手需要使用System.setIn(new BufferedInputStream(new FileInputStream(\"fileName\")))和System.setOut(new PrintStream(new FileOutputStream(\"fileName\")))；Python选手需要使用sys.stdin=open(\"fileName\",\"r\")和sys.stdout=open(\"fileName\",\"w\")。 根据官方提供的提交数据，可以对本次题目做出以下的难度划分： 简单题：E、A、G、F —— 通过数量均为100+ 中档题：L、J、K ——通过数量在24~60之间 困难题：C、B、D、H、I ——通过数量不超过20，甚至还有0 欢乐赛过程中，所有队伍一共做了A、B、E、F、G、J、K、L八道题，最高通过七道题。 废话不多说，开始补题了： Problem A. Adjustment Office 给一个N*N的矩阵A，A[i,j] = i+j；一共Q次操作，操作有两种类型：R r 取出第r行还未被取的所有数，并输出和；C c取出第c列还未被取出的所有数并输出和；要求输出每次操作之后需要输出的和。n的范围是1e6，q的范围是1e5. 分析 Problem B. Binary vs Decimal 首先，我们先定义专有名词bindecimal数字： 一个数字是bindecimal，当且仅当它的十进制表示是它的二进制表示的后缀。 输入一个n，要求你求出第n个bindecimal的十进制表示。n的规模是10000. Problem C. Cactus Jubilee 首先先定义仙人掌树：仙人掌树是一般树的一些拓展——允许在树上出现一些环，但是要求每条边最多只能在一个环中。该无向图中不会出现重边和自环；现在给定一个仙人掌树，允许移动一条边（不可以放在原处），求移动之后还是仙人掌树的方案数。 输入n和m——顶点数和不同的路径数；接下来的m行每行包含一个路径：第一个整数k表示该行数字数量；保证输入的是仙人掌，并且每条边只遍历了一次。n和m的数据规模是5e4. Problem D. Distance on Triangulation 给一个n个顶点的凸多边形，和对它的一种三角剖分（n-3条对角线）；接下来进行q次查询：每次查询有两个顶点索引组成，要求查找两个顶点间在多边形的边和给定的对角线上移动的最短距离——每个边和对角线的长度记为1. 输入顶点数量 n，接下来 n-3 行包含所有对角线；输入查询数 q，接下来 q 行包含了查询的两个定点序号。 Problem E. Easy Problemset 一共有n个考官，每个人有pi个难度介于049的简单问题和无限个复杂问题；每次从1n顺序选当前考官的问题，如果这个问题的难度≥之前所有问题难度系数和，则将这个问题加入问题集；否则，舍弃这个问题。 比赛一共需要k个问题。当一个考官拿不出简单的问题时，它会拿出难度系数为50的困难问题。求最终比赛的问题集的难度总和是多少。 Problem F. Froggy Ford 有一条宽度为w的河流，河的两岸位于 x = 0 和 x = w 两条直线上；在 x ∈ (0,w) 的河流中有 n 块石头，每块石头的坐标是 (xi,yi)；小青蛙现在想要过河，但是它只能从石头上跳着走；现在你可以在河流中任意一处放置一块石头来帮助小青蛙，使得它在过河的最短路中单次跳跃的最大距离尽可能最小化。 题目给出w和n，以及石头的坐标，求为了达成目的，新石头应当放置的坐标。 Problem G. Generators 线性同余生成器：可以由 x₀ a b c 四个整数定义，可以根据递归定义 x' = (ax + b) mod c 产生无穷序列。 一共有n个序列，每个序列包含 x a b c 四个值，描述了一个LCG；求从每一个LCG生成的序列中取出一个数，求和之后不是k的倍数的最大值。如果求出，输出最大值和一种具体选取方案，否则输出-1。n k 给出，n规模1e4，k规模1e9. Problem H. Hypercube Problem I. Iceberg Orders Problem J. Jump 我们基于游戏 OneMax （猜字串中猜中的位数）定义游戏 Jump ： Jump游戏的交互方法： 你知道一个整数n，有一个长度为n的01字符串S，你不知道它的具体内容。 你可以猜一个01字符串并且发起询问，根据你给出的字符串Q： 当Q和S完全相同时，系统返回 n 并退出 当Q和S恰好有一半的位置相同时，系统返回 n/2 并等待下次询问 其他情况时，系统返回 0 并等待下次询问 您被允许最多发起 n+500 次询问，要求在这些询问次数之内使得 Q=S 系统退出后尝试输出，或者超过指定的询问次数将会导致WA；如果询问包含了非法字符或长度≠n，会导致PE和系统退出；完成要求会AC，并且在超过时间限制的情况下会TLE。 给一个长度 n，按照Jump游戏规则进行猜测；要求在 n+500 次猜测之内猜出字符串 S。 Problem K. King’s Inspection 给定一个有n个节点和m条边的有向图，问是否存在一条路从1号节点出发，访问每个其他节点一次后回到1号节点（哈密顿环）；如果存在，输出以1作为首尾的哈密顿环；否则输出指定字符串。 Problem L. Landscape Improved 给定一个宽度为N的网格，第i列上有高度为hi的方块；现在给w个方块，要求使得加上这些方块后，得到的网格的最高列的高度尽可能高；放置方块需要放置的位置的下方、左下方、右下方都有方块——也就是说最左和最右两列不能放置方块。 后记","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://shiraha.cn/tags/Codeforces/"},{"name":"Gym","slug":"Gym","permalink":"https://shiraha.cn/tags/Gym/"}]},{"title":"洛谷ACM春季多校训练营：第三场","slug":"luogu-ACM-2020-spring-multi-3","date":"2020-03-20T07:43:41.000Z","updated":"2020-03-20T07:43:41.000Z","comments":true,"path":"2020/luogu-ACM-2020-spring-multi-3/","link":"","permalink":"https://shiraha.cn/2020/luogu-ACM-2020-spring-multi-3/","excerpt":"","text":"因为是版权原因，这里并不能公开的放题目链接和题目的讲评之类的东西。各位看官就将就着看看我说吧== 又是一场接近爆零的比赛呢（笑 打的很丑，补题不及时罪加一等。题目不多，难度不做评价，但是就英语来说题目都很好懂，读起来都不费劲就是自己做不出来。……所以就不多废话，直接讲题目。 首先是出题人自己对于这次题目难度的评价： 简单题 中档题 较难题 B,C,D H,E,G A,F 然后，我根据出题人当晚讲评的顺序来说这些题目： B - Bit fixer 给你一个二进制串，宇宙射线每天会取反一个bit，你很辣鸡，每天只能掰反一个bit；给你一个目标串，问你最少多少天能完成任务。数据规模在1e5之内。 引导 官方讲评在说这个题目之前说了一道下面这样的题目。 这题来源于一道CF题目： 有一条船，速度v1；水速每天都会变，船的方向也可以每天调整，但在一天中方向都不变；而且船每天的航行时间相同。给出两点距离，以及每天的水流大小和方向，问最少需要花多少天？ 对于这个题：因为船和水的位移都是矢量，如果把船和水的位移加起来等于起点到终点的向量，就表示船可以到达终点。 又因为矢量相加符合交换律，所以可以先计算水的总位移，与起点-&gt;终点的向量相减，就可以得到船要走的位移。 因此，这个题目，只要枚举天数，得到船应走的唯一，判断能不能走完就行了。 所以这个题目，仔细想想也可以用这种思想来解决。 分析 二进制串，每次会被动的变一次；你每次可以修改一位。如果把二进制串也看成向量的话，那么在第x天，你最多只能满足目标串和当前串相差的模≤x的情况。因为每天原串都会变化，所以模也在不断变化；又因为相反一位的值，也就是异或，也是满足交换律的；所以也可以像上面那个题目那样。 为什么反复提到交换律呢？我们的做法，相当于把每个时间片的“外力”和“内力”造成的偏移分离之后统一考虑：然而题目原模型是交错的。只有满足了交换律，我们才能随意挪移一个式子中的不同项，整理组合从而简化。 实现的话，直接枚举然后求差的话，1e10就爆炸了。但是实际上，因为这是一个二进制串，每次只需要更新修改的那一位的状态就可以了（也就是出题人说的曼哈顿法），或者也可以二分答案。 二分单调性：显而易见的，因为外力和内力是可以抵消的。当某个x可以达成目标之后，之后只需不断抵消内外力即可。 总而言之，有了交换性，随便怎么整理（移项）都可以哦。 误区 因为题目只让我们求一个具体的值——也就是能不能在指定天数内达成目标，而不是求一个具体的方案。所以完全可以通过挪移整理来简化模型。最开始我的分析是顺推，分不同的情况，使用队列维护修改的优先级。这样做也许是对的，但是我赛场上没有分析出来（逃），这题就这么死了。事实上只要能想到是只求天数的话，完全没有必要这样麻烦自己。 此外，因为这个题目时求一个最小天数的，且显然具有二分单调性——如果能想到一个二分答案，即使是我那样处理来判别，也是有可能做出来的。总而言之，做不出来就是你傻了。 代码 这是使用优化的枚举的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;using namespace std;typedef long long longs;const int N = 1e5 + 5;int len,lim,cnt,pos;char str[N], ch;bool dis[N];int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); cin&gt;&gt;len&gt;&gt;lim; cnt = 0; for (int i=0;i&lt;len;++i) cin&gt;&gt;str[i]; for (int i=0;i&lt;len;++i) &#123; cin&gt;&gt;ch; if (str[i] != ch) &#123; ++ cnt; dis[i] = false; &#125; else dis[i] = true; &#125; for (int i=1;i&lt;=lim;++i) &#123; cin&gt;&gt;pos; pos = len-1-pos; if (dis[pos]) &#123; dis[pos] = false; ++ cnt; &#125; else &#123; dis[pos] = true; -- cnt; &#125; if (cnt &lt;= i) &#123; cout&lt;&lt;i&lt;&lt;endl; return 0; &#125; &#125; cout&lt;&lt;&quot;icu&quot;&lt;&lt;endl; return 0;&#125; 有一个需要注意的就是，输入中的这个index实际上是从右到左的，所以需要进行处理之后才可以使用。当然也可以输入的时候就从后向前存储。 C - Coprime 给你一个整数序列，再给你一个操作：每次你可以把某个数变成任意的另一个数；问最少经过多少次操作，使得序列中任意相邻两个数互质。数据规模1e5。 分析 首先，互质也就是说 gcd(a, b) =1. 如果a b中有一个数是1，那这就是板上钉钉的了；所以要改，肯定就是改成1. 然后对于具体的数列来说，可以使用贪心处理：假设从左向右处理，如果a b相邻但是不互质，最好肯定还是修改b：因为改a只能保证和b互质，而改b还可以保证和未来的c也一定互质。 代码 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long longs;const int N = 1e5 + 5;int a[N];int gcd(int a, int b)&#123; if (b &gt; a) return gcd(b,a); else if (!b) return a; else return gcd(b, a%b);&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n, cnt = 0; cin&gt;&gt;n; for (int i=0;i&lt;n;++i) cin&gt;&gt;a[i]; for (int i=1;i&lt;n;++i) if (gcd(a[i-1],a[i])-1) a[i] = 1, ++ cnt; cout&lt;&lt;cnt&lt;&lt;endl; return 0;&#125; 豆知识（模外挂）：其实比起a%b取模，加上判断地使用a-s/b*b来的更快哦。 D - Dodo bird painting 有一根绳子，每次往绳子上滴一滴墨水，墨水会一固定速度扩散；给出滴墨水的时间和位置，问最早什么时候， 绳子完全被墨水覆盖。绳子长度是1e9，墨水数量1e5. 分析 这其实是一个二分套路题。 虽然不是大家都喜欢的经典最大求最小或者最小求最大的问题，但是依然是可以用二分求解： 二分单调性：如果某个时间t恰好可以给整条绳子染色，那么小于t的时间一定不能全部染色，且大于t的时间一定也可以给整条绳子染色。 问题特性：直接求解（比如DP？），至少需要O(n²)的时间；而确认一个答案可不可以全部染色，只需要O(n)的时间。符合二分答案问题的特点 综上所述，采用二分答案的方法，把最优化问题转化为可行性问题。 这个题目就可以做了，复杂度大约是O(nlogk)，k和墨水的传输速度和绳子长度相关。 具体的说，对于具体的时间，求解这个时间下每滴墨水可以染色的区间，再按顺序合并：如果出现无法合并的情况，就说明不可全部染色。 误区 其实不想话太多笔墨来说自己是怎么错的。但是既然蠢了，就要挂起来婊着。我最开始想着是DP每两滴墨水之间的绳子长度被墨水染色需要的时间，再考虑墨水“跨界点染色”的事情，也就是说DP。这确实是模拟的思路，但是会TLE。并且只要是这种DP，就必须要确认每滴墨水的可能性。可以说就是没什么太大的优化空间，复杂度O(n²)，对于这个题目的1e5的数据规模，那是死的透透的。 其次是实现方面的一些事情：合并区间并不可以贪心！除非经过稳健的排序。否则，位置处在后方的区间仍然可以覆盖前面并未合并的区间，如果贪心退出就判断错误了。 代码 理清思路的情况下还能吃一发WA也是没谁了。只能说不愧是我== 写代码的时候还是不能太过于自以为是了。这里的check要做的事是合并区间，而这个行为并不能通过贪心来节约时间——原因上面也提到了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;#define pos first#define spd second#define npos (q+1)using namespace std;typedef long long longs;typedef pair&lt;double,double&gt; ink;struct range &#123;double left,right;&#125;;const int N = 1e5 + 5;int n,q;const double EPS = 1e-6;ink li[N];range r[N];bool operator&lt;(range&amp; a, range&amp; b)&#123; if (fabs(a.left - b.left) &lt; EPS) return a.right &lt; b.right; else return a.left &lt; b.left;&#125;bool check(int q, double t)&#123; double tmp; for (int i=1;i&lt;=q;++i) &#123; auto &amp;ii = li[i]; tmp = t*ii.spd; r[i] = &#123;ii.pos-tmp, ii.pos+tmp&#125;; &#125; sort(r+1,r+q+1); range rr = &#123;r[1].left, r[1].right&#125;; for (int i=2;i&lt;=q;++i) &#123; if (r[i].left &gt; rr.right) return false; else rr.right = max(r[i].right,rr.right); &#125; return !(rr.left &gt; 0 || rr.right &lt; (double)n);&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); cin&gt;&gt;n&gt;&gt;q; li[0] = make_pair(0,0); li[npos] = make_pair(n,0); double maxv = 0; double x,v; for (int i=1;i&lt;=q;++i) &#123; cin&gt;&gt;x&gt;&gt;v; li[i] = make_pair(x,v); maxv = max(maxv,v); &#125; double left = 0, right = n/maxv; int times = 100; while (times --) &#123; double mid = (left + right) / 2; (check(q,mid) ? right : left) = mid; &#125; const double ans = (left + right) / 2; cout&lt;&lt;fixed&lt;&lt;setprecision(7)&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 有几个比较坑的地方：首先输入的墨水的位置和速度都是浮点数——这我还是查了标程才知道的；然后，关于check函数里面的rr.right的问题：看起来这里的max判断是非必要的，因为我已经排序了；但是因为eps的存在以及一些其他的原因，这里必须要强制保证才可以AC。 另一件事情：如果你不想要使用std::pair&lt;T1,T2&gt;的默认大小判断的话，就干脆的建立一个新类，而不是重命名一个pair——即使你显式的重写了operator&lt;，它用的是什么也不为人知——其实这可实验验证。 H - Huaji robot 有一个n*n的网格图，坐标范围为[(1,1),(n,n)]；横纵坐标互质的地方不能通行；每次移动都是八个方向的移动；给定起点和终点，问能否到达。地图大小n的数据规模是1e9. 引导 出题人讲评的幻灯片上，有下面这段文字： ◦ 推公式？我菜得一比，不会推公式！ ◦ 此题更可行的办法是打表+猜结论。 ◦ 打表小技巧：当打出的表只有0和1时，就不需要用空格隔开，进一步地，把1换成空格，这样每一个数字和它周围的 关系就更清楚。 这个题目的障碍物非常的奇特——横坐标和纵坐标互质则不能通行。看起来没什么规律，可以打个表来看看特点。这里就直接写打表可以得到的信息： x=y对角线除了x=1时均可以通行：正确性显然 对于质数行列，会有长段连续的不可通行区域 连通块被质数的行列等切成了比较规则的区域 综上所述，可以猜想：除了与整张图的主对角线相连的，所有的连通块都不会太大。因为会被编号时质数行列的直线切开。虽然质数直线并不是连续的，但是还是可以证明每个连通块不大： 因为每个数的质因子数是 log 级别的，所以在 x=p1 和 x=p2 之间，至多会有 log n×(p2-p1) 个点，把相邻的联通块连接起来。所以每个块的大小是 log n×max(pi-pj) 级别，其中 pi 和 pj 是相邻的两个质数。 又因为，1e9的范围内两个质数的差不会太大——实际上1e9内，最大的质数间距为282。这真的不大，这样就可以有一种思路： 从起点和终点开始搜索，只要到达 y=x≠1 的点即视为联通 使用 map、哈希、偏移量数组来做这次搜索 这样这个题目就可以做了， 分析 其实也并不需要打表，稍微想想也可以得到上面看出来的两点结论：对角线联通，质数直线阻塞。然而这种题目似乎除了搜索别无他法，只要能够简化搜索就可以做了。也可以得出双向搜索，使用 map 存储遍历情况来做。 但是在实现的过程中还要注意，可能两个点都连接到 当然，这种奇怪的题目也有可能是一个结论，这个时候就别无他法只能当场去世了。 代码 使用 map 作为访问数组的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;queue&gt;#define bound(x,y) (x&lt;=n&amp;&amp;x&gt;=1&amp;&amp;y&lt;=n&amp;&amp;y&gt;=1)using namespace std;typedef long long longs;struct pos&#123;int x,y;&#125;;const int dx[] = &#123;1,1,0,-1,-1,-1,0,1&#125;;const int dy[] = &#123;0,1,1,1,0,-1,-1,-1&#125;;int n,sx,sy,ex,ey;map&lt;int,map&lt;int,short&gt;&gt; m;bool found = false;int gcd(int a, int b)&#123; if (b &gt; a) return gcd(b,a); else if (!b) return a; else return gcd(b, a%b);&#125;bool check(int x, int y, short flag)&#123; queue&lt;pos&gt; q; pos top; m[x][y] = flag; q.push(&#123;x,y&#125;); while(!q.empty()) &#123; top = q.front(); q.pop(); for (int i = 0; i &lt; 8; ++ i) &#123; int xx = top.x + dx[i]; int yy = top.y + dy[i]; if (bound(xx,yy) &amp;&amp; gcd(xx,yy) != 1) &#123; if (!m[xx][yy]) &#123; if (xx == yy &amp;&amp; xx != 1) return true; m[xx][yy] = flag; q.push(&#123;xx,yy&#125;); &#125; else if (m[xx][yy] != flag) return found = true; &#125; &#125; &#125; return false;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); cin&gt;&gt;n&gt;&gt;sx&gt;&gt;sy&gt;&gt;ex&gt;&gt;ey; bool c1 = check(sx,sy,1); bool c2 = check(ex,ey,2); bool checked = c1 &amp;&amp; c2; cout&lt;&lt;((checked||found)?&quot;gl&quot;:&quot;gg&quot;)&lt;&lt;endl; return 0;&#125; 第一次写的时候不知道犯了什么浑，结果按照标程的方法布局代码就过了，不是很懂…… 也许两头搜索就应该使用 vis 数组记录具体哪一次搜索到达的信息吧。 E - Eluos blocks 给了一个由三种俄罗斯方块拼成的图形，记为ABC；A类俄罗斯方块只有一个，而其他的有无数个；求出这唯一的A类方块的位置。整个图形的规模小于500。求出解的数量。并且按照指定的顺序输出所有的解。 AHCKV__1S9__8P_GBE_BGY.png ↑这是三种俄罗斯方块的样子↑ 引导 这种一看就是考智商的思维题。这道题再加大难度之前是这样的： 弱化版的条件有这样的区别：无B类方块，依然是一个A类和若干C类方块 这种情况下，只有两种不同的图形，图形之间的差距挺容易被对比出来的，这里直接说： 显然，A是斜杠的对角线的两个方块缺失，C是反斜杠的对角线。 即使这些方块不断的堆积，这种特性也会得以保留。 A图形跨三行：首尾两行只有一个方块，中间一行有两个；C跨两行，每行两个。 那么这题的解法就有眉目了：可以利用最后一条特性，确定A所在的水平位置，再搜索垂直方向，找到满足条件的情况输出即可；也可以利用前两条特性，找到最左上角的“孤立”方块，若右侧无方块那就可以肯定是A，否则是C，删去。这种做法的正确性也可以比较容易的讨论证明。 现在的情况是不仅有AC，还有B类方块；这样的话上面的方法就不行了，我们需要去找新的规律： 分析 虽然对角线上的两个方块的独特性已经消失了，但是参考上面的特性，我们还是可以找出新的特性：从反对角线方向观察方块的“厚度”，也可以观察到这样的特点： A类方块占有斜杠方向对角线的四列，每列有一个方块； B类、C类方块占有斜对角线方向的两列，每列有两个方块； 这样就和上面简单版题目的第三条特性相似，可以使用同样的方法来做了：通过统计对角线的方块数量，找到数量是奇数的四列方块，然后再遍历某对角线上的所有方块，检查它们是A的一部分时的正确性，就可以在O(n³)的时间内求解。所有的解都会出现在这个范围内。 这里说的斜杠方向指的是将整个图逆时针旋转45°。旋转之后可以得到图形的“列”和“厚度”。 这个题目似乎实际上O(n⁴)的算法也可以卡过去。也就是说枚举能过的。 代码 特别注意：输出的坐标是需要排序的。也就是说这题没有SPJ。 1 G - Game 给5个整数，要求使用加减乘除括弧运算符以及前4个数字拼成一个算式，使得算式结构等于第5个数；问是否可以构造出这样的算式。 分析 非常经典的问题：你可以不停枚举，枚举数字排列，枚举运算符，枚举括号位置，然后求解验证；也可以每次选出两个数字和一种运算符计算，将计算结果丢回去，重新选择计算直到只剩下一个数字，都可以。怎么做都可以做出来，暴力只要写对了也可以AC。 误区 这个游戏和常规24点游戏有一个根本上的不同：数字的顺序是可以随机调换的，最后构造的算式中，数字出现在式子中的顺序未必是输入的顺序。如果按照一般24点写死的话就会死。这有可能就是赛场上我和队友没有AC这个题目的原因所在。 代码 首先四选二，再三选二，枚举所有可能的运算方式（包括反向的减法除法）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;typedef long long longs;const double eps = 1e-6;const struct&#123;int x,y;&#125; other[4][4] = &#123; &#123;&#123;&#125;,&#123;2,3&#125;,&#123;1,3&#125;,&#123;1,2&#125;&#125;, &#123;&#123;3,2&#125;,&#123;&#125;,&#123;0,3&#125;,&#123;0,2&#125;&#125;, &#123;&#123;3,1&#125;,&#123;3,0&#125;,&#123;&#125;,&#123;0,1&#125;&#125;, &#123;&#123;2,1&#125;,&#123;2,0&#125;,&#123;1,0&#125;,&#123;&#125;&#125; &#125;;int ed;double operate(double a, double b, int mode)&#123; switch (mode) &#123; case 0: return a+b; case 1: return a*b; case 2: return a-b; case 3: return b-a; case 4: return !a?0:b/a; default: return b?a/b:0; &#125;&#125;bool deepSearch(double a[])&#123; for (int i=0;i&lt;3;++i) for (int j=i+1;j&lt;3;++j) for (int op1=0;op1&lt;6;++op1) for (int op2=0;op2&lt;6;++op2) if (fabs(operate( operate(a[i],a[j],op1),a[3-i-j],op2 )-ed)&lt;eps) return true; return false;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int t,op[4]; cin&gt;&gt;t; auto fun = [&amp;]() -&gt; bool &#123; double arr[3]; for (int i=0;i&lt;4;++i) for (int j=i+1;j&lt;4;++j) for (int k=0;k&lt;6;++k) &#123; arr[0] = operate(op[i],op[j],k); arr[1] = op[other[i][j].x]; arr[2] = op[other[i][j].y]; if (deepSearch(arr)) return true; &#125; return false; &#125;; while (t--) &#123; cin&gt;&gt;op[0]&gt;&gt;op[1]&gt;&gt;op[2]&gt;&gt;op[3]&gt;&gt;ed; cout&lt;&lt;(fun()?&quot;Yes&quot;:&quot;No&quot;)&lt;&lt;endl; &#125; return 0;&#125; 现在觉得适当的多用用lambda表达式声明一些函数还是蛮好的== 有点香 A - Able was I ere I saw Elba 给一个长度为 n 字符串，以及m个操作；每个操作能让你花 c 个代价把字符 a 变成字符 b；对于串中的所有子串[l,r]，都可以花一个最小的代价来把它变成回文串；问对于所有n*(n-1)/2个子串，最小代价和是多少。 引导 首先题目里是子串，而不是子序列（否则个数也不对了），子串是连续的。 和很多的区间数据结构题目不同，这个题目并不是每次询问一个空间内的子串，而是所有可能的子串。这和随机询问不同，是一种特殊性，可以加以利用；下面我们考虑一对字符 s[i] 和 s[j] 的贡献： 设 i j 的对称轴为 k，显然k是中点；显然，所有以k为对称轴的子串都会受到同样来自 i j 的贡献； 这样的子串数量是 min(i,n-j+1)，这也是显然的。 直接枚举复杂度太大，但是可以简化：若贡献 i 次，那么一定满足 i &lt; n-j+1， j 的取值有范围； 假设 j 的最大值为 m，则 i &lt; n-m+1 =&gt; m&lt;n-i+1 。 至于让 i j 字符相同，可以修改两者中的一个，也可以同时修改两个字符使他们的值相等，找到最小的花费。又因为它们有不同的贡献度，还要记得加算倍数。事实上，分贡献的倍数讨论就可以了。 根据上面的分析，可以确定这样的实现思路： 根据奉献的次数来分别处理：奉献次数为 i 时，也就是a[i]与所有的 a[t] (i&lt;t&lt;n-i+1) 不发生冲突的最少花费的和；奉献 j 次时，就是反向同理； 因为字符集只有26，可以处理每个字母数量的前缀和，从而快速得出区间 (i,n-i+1) 内存在的不同字符个数，以累加对答案的总贡献； 因为变化字符使得相等有多种方案，需要预先处理任意两个字符的转化代价，再处理消除任意两个冲突字符的代价；这可以使用 Floyd 预处理。 这样，就可以着手实现这个题目了。 分析 首先看懂题目。我们选择样本不大且有代表性的样例2： 输入数据 输出数据 5 2 aabaa a b 1 b a 10 6 字符串\"aabaa\"一共有十个子串，下面只列出需要修改字符的子串： \"aaba\", \"abaa\" =&gt; \"abba\"：a -&gt; b，消费1*2 \"aab\", \"baa\" =&gt; \"bab\"：a -&gt; b，消费1*2 \"ab\", \"ba\" =&gt; \"bb\"：a -&gt; b，消费1*2 综上所述，将这个字符串的全部子串变为回文串的总消费是6，也就是要求解输出的值。 首先维护一个字符集的前缀和；然后根据输入的转化成本信息，使用Floyd求出所有可互相转化的字符转化的最低成本；然后考虑解决冲突：当字符 i j 不同时，将它们改成相同的时候所需要的最低成本；随后遍历串中每一个字符，只考虑单个字符的贡献以统计答案。具体地说，统计答案是这样做的： 对于下标为 [0,n-1] 的字符串的第 i 个字符：它的左侧有 i 个字符，右侧有 n-i-1 个字符； 若字符靠左侧，则 i 较小；这里仅考虑 i 作为对称轴左侧字符的情况，因为右侧的情况会被更小的 i 考虑到； 若字符 i 在左侧，那么它的左侧还可能有 [0,i] 个字符；这里仅考虑 i 的情况，因为其他情况会被从右侧对称考虑到；但是仍然要计算所有的可能前缀的回文串； 问题转化成：当子串的对称轴左侧最前端有 substr(0,i) 的前缀时，字符 i 可以为回文串奉献的最小修改成本； 因为有了长度为 i 的前缀，所以可能在子串中和 i 对称的字符只有下标为 [i+1,n-i-1] 的字符；尝试修改字符 i 使得字符 i 与每个这些字符都相等； 因为有可选的长度为 i 的前缀，所以上述计算得到的奉献还需要加算奉献倍数 i+1； 当字符 i 在右侧时，需要注意的是：使用全部后缀的情况已经被对应的左侧字符考虑过了，所以考虑的对称字符只有下标为 [n-i, i-1] 的字符。 特别注意，字符串长度为奇数的时候，最中间的一个字符单独计算贡献时不能带来任何贡献； 注意上述的所有细节，方可写出这个题目的代码。 代码 1 F - Fake information 空间中有 m 个点，有 n 个粒子在这些点上随机运动；开始时所有粒子处在1号点；每轮运动，粒子都会随机运动到其它另一个点，运动持续无数次；设 d[i,j] 表示第 i 个粒子和第 j 个粒子运动轨迹的最长公共前缀，求 max{d[i,j]} 的期望值。数据规模是100. 引导 分析 后记 菜呢，是真的菜。签到题的思路全部歪了，到最后除了最简单的划水题，一个题目也没有做出来。甚至根本都没有向二分答案的方向上去想。","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Luogu","slug":"Luogu","permalink":"https://shiraha.cn/tags/Luogu/"}]},{"title":"算法分析与设计：实验1-3实验报告","slug":"class-algorithm-experiment-report-1-3","date":"2020-03-17T06:01:14.000Z","updated":"2020-03-17T06:01:14.000Z","comments":true,"path":"2020/class-algorithm-experiment-report-1-3/","link":"","permalink":"https://shiraha.cn/2020/class-algorithm-experiment-report-1-3/","excerpt":"","text":"所有的三次实验的源码由博主使用 Java/Kotlin 写成，已经开源： 项目首页： https://dev.azure.com/Pure-Asahi/2020_Spring_In_Class_Job 仓库地址： https://dev.azure.com/Pure-Asahi/_git/2020_Spring_In_Class_Job 代码正确性不做绝对保证，使用需谨慎；有问题欢迎指出。 Front-matter 去网上找成品代码太难了，写错的还有一大堆。最后还是得自己写…… 对于每一个实验，只需要执行项目下的Main.main(String[] args)就可以全自动的解出题目所要求的数据。因为项目使用IDEA写的，使用了一些Jetbrains自己的特性。所以请使用IDEA打开项目。 因为有很多的基础算法，它们的原理这里就不再赘述了，要是不知道的自己去看书。 实验一：排序算法 实验要求如下： ##### 实验一：排序算法 一、实验目的 1. 掌握算法科学解决问题的基本模式 2. 了解确定性算法和随机性算法区别 3. 分析同一问题不同解决算法之间的效率差 二、实验条件 - 硬件：计算机 - 软件：计算机程序语言开发平台，如 C、C++、Java、Matlab。 - 学生：至少掌握一门计算机程序设计语言，如 C、C++、Java、Matlab 三、实验内容及要求 1. 利用计算机程序设计语言，实现教材第 2 章介绍的“插入排序算法”，自主拟定一组输入数据，输出相应的算法结果。 2. 利用计算机程序设计语言，实现教材第 2 章介绍的“合并排序算法”，自主拟定长度分别为偶数和奇数的输入数据，输出相应的算法结果。 3. 利用计算机程序设计语言，实现教材第 7 章介绍的“快速排序算法”，自主拟定一组输入数据，输出相应的算法结果。 4. 利用计算机程序设计语言，实现教材第 7 章介绍的“随机快速排序算法”，采用实验内容 3的输入数据，输出相应的算法结果。 5. 利用计算机程序设计语言，实现教材第 8 章介绍的“计数排序算法”，自主拟定一组适合“计数排序”问题特征的输入数据，输出相应的算法结果。 6. 利用计算机程序设计语言，实现教材第 8 章介绍的“基数排序算法”，自主拟定一组适合“基数排序”问题特征的输入数据，输出相应的算法结果。 7. 利用计算机程序设计语言，实现教材第 8 章介绍的“桶排序算法”，自主拟定一组适合“桶排序”问题特征的输入数据，输出相应的算法结果。 8. 分析上述 7 种排序算法的效率，并用直观的形式表达出效率随输入规模的变化趋势 四、思考题 - 算法科学解决问题的一般模式是什么？ - 确定性算法和随即性算法的差异在那里？随机化对于算法效率的影响如何？ - 如何理解算法效率分析的渐近特征和相对性？ 实现算法 算法的原理参考《算法导论》，使用Java实现了整数排序机IntegerSorter类，包含任务要求的所有排序算法。 源代码可以看仓库，代码的具体内容这里不再赘述。 测试函数使用Java虚拟机提供的计时器计时，计算整个函数运行的时间消耗并输出到控制台上。根据用户的输入多次连续的测试某种算法的时间消耗，并且验证正确性后输出到控制台。 查看核心代码 实验结果 算法正确性 控制台的输出如下： W_AZ_1Q_4TKI2_NACZQ_SXK.png 可见算法的正确性是可以保障的。 算法效率 执行源代码的Main.main方法，输入不同的数据大小，可以得到这样的测试结果（控制台文件）： K0ILDUBZ_37Y_EO_PQK__ME.png 小于1000的数据集规模因为时间过短，统计时间为0ms；大于1e7的数据集规模因为Java内部原因，运行常数过大导致虚拟机中断，未能输出结果。合并排序速度较慢的一大原因是因为Java内部数据拷贝以及内存分配释放速度较慢导致。 因为算法实现以及Java的一些原因，所有的非原位排序算法都将面临一个很大的常数。这是由于内存分配和释放带来的额外开销。也许可以在更加优雅的实现方式中使用一些方法来降低这方面的开销。 算法分析 以下是包含本次实验的七个排序算法在内的算法分析表： 排序方法 平均时间复杂度 最坏时间复杂度 最好时间复杂度 空间复杂度 稳定性 插入排序 \\(O(n^2)\\) \\(O(n^2)\\) \\(O(n)\\) \\(O(1)\\) 稳定 希尔排序 \\(O(n^{1.3})\\) \\(O(n^2)\\) \\(O(n)\\) \\(O(1)\\) 不稳定 选择排序 \\(O(n^2)\\) \\(O(n^2)\\) \\(O(n^2)\\) \\(O(1)\\) 不稳定 堆排序 \\(O(nlog_2n)\\) \\(O(nlog_2n)\\) \\(O(nlog_2n)\\) \\(O(1)\\) 不稳定 冒泡排序 \\(O(n^2)\\) \\(O(n^2)\\) \\(O(n)\\) \\(O(1)\\) 稳定 快速排序 \\(O(nlog_2n)\\) \\(O(n^2)\\) \\(O(nlog_2n)\\) \\(O(nlog_2n)\\) 不稳定 归并排序 \\(O(nlog_2n)\\) \\(O(nlog_2n)\\) \\(O(nlog_2n)\\) \\(O(n)\\) 稳定 计数排序 \\(O(n+k)\\) \\(O(n+k)\\) \\(O(n+k)\\) \\(O(n+k)\\) 稳定 桶排序 \\(O(n+k)\\) \\(O(n^2)\\) \\(O(n)\\) \\(O(n+k)\\) 稳定 基数排序 \\(O(nk)\\) \\(O(nk)\\) \\(O(nk)\\) \\(O(n+k)\\) 稳定 上述表格只提供了对算法的简单分析。诸如基数排序等部分排序算法的复杂度还受到了一些其他可控因素的影响，这里不再讨论。 这些算法的运行时间/空间将会随着输入规模的变化大致按照上表所示的趋势变化。但是因为并不能收集到数量级跨较大范围的数据变化趋势，所以无法绘图。 思考题 算法科学解决问题的一般模式 简单地说，算法就是解决问题的方法和步骤。这些步骤可以简要的概括为： - 分析问题：对问题进行思考分析 - 设计算法编写程序：设计出合理的算法并将其改写为计算机程序 - 运行程序并验证结果：运行所得的程序验证是否能够解决问题，如果不能，重新设计算法或改写程序 - 解决问题：使用所得程序解决问题 确定性算法和随机性算法的差异 随机化算法是一种在算法中使用了随机函数，且随机函数的返回值直接或间接的影响了算法的执行流程或执行结果的算法。而确定性算法是与随机化算法相对的：算法本身执行的过程是相对确定的。具体地说，随机化算法，即指的是在运行的过程中的某一步或某几步涉及一个随机决策，或者说其中的一个决策依赖于某种随机事件的一类算法；而相对应地，确定性算法不具有此特征。通常而言，对于确定的输入，确定性算法能输出稳定一致的结果，而随机化算法不一定能。 随机化对于算法效率的影响 在许多情况下，当算法在执行过程中面临一个选择时，随机化选择常比最优选择省事。 因此，大多数情况下，随机化算法都可以在很大程度上降低算法的复杂度。 例如对于快排而言，快排的排序速度取决于数组的无序程度，数组越乱，快排的效率越高；所以，对快排算法加入随机化十分重要。 一个简单的应用，例如：数据读入时将数据排放在随机位置，这样就可以将快排的的时间复杂度维持在较好状态。 如何理解算法效率分析的渐近特征和相对性 渐进性：在算法效率度量中，常常采用渐进表达式；因为常数间的差异较小，而渐进表达式的核心就是忽略常数。 相对性：算法的效率是相对的，我们选取的参照不同，数值的意义就不同；我们需要为自己的算法效率评估确定一个基准，然后相对于这个基准我们来做算法效率评估。 例如希望测试快排的效率，不能直接对大量数据进行快排计算时间；而应选取参照，例如与冒泡，桶排序等方案进行比较，从而分析出快排的效率的优越性 实验二：Strassen’s 矩阵乘法和最近点对算法 实验要求如下： ##### 实验二：Strassen’s 矩阵乘法和最近点对算法 一、实验目的 1. 理解“分治法”算法设计思想及其实现步骤 2. 掌握分治算法效率递归分析方法 3. 掌握主方式求解递归式方法 二、实验条件 - 硬件：计算机 - 软件：计算机程序语言开发平台，如 C、C++、Java、Matlab。 - 学生：至少掌握一门计算机程序设计语言，如 C、C++、Java、Matlab 三、实验内容及要求 1. 利用计算机程序设计语言，实现教材第 28.2 章介绍的“Strassen’s 矩阵乘法算法”，自主生成两个 8×8 的矩阵，检验算法的正确性并输出算法结果。 2. 比较 Strassen’s 矩阵乘法算法和数学定义的矩阵乘法算法效率之间的区别，并用直观的表达方式把两种不同矩阵乘法的效率随矩阵维数的变化趋势。 3. 利用计算机程序设计语言，实现教材第 33.4 章介绍的“最近点对算法”，在拟定的二维空间点集上检验算法的正确性并输出算法结果。 四、思考题 1. 分治法算法设计思想的三个基本步骤是什么？如何证明分治算法的正确性？ 2. 利用主方式求解 Strassen’s 矩阵乘法和最近点对算法效率的递归分析结果。 3. 解释怎样修改 Strassen’s 矩阵乘法算法，使得它也可以用于大小不必为 2 的幂的矩阵 任务一： Stressen 方法 关于 Stressen 矩阵乘法方法的描述，详见算法导论： 就这样，先把矩阵分块，然后根据书上的做法敲一遍。只要不敲错就不会有什么问题。验证请看实验结果。 下面是我实现的Stressen方法的核心部分。具体内容请参见源代码中的Matrix类下的一些方法的实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private static int[][] stressen(int[][] ma, int[][] mb) &#123; final int n = ma.length, half = n / 2; int[][] ret = new int[n][n]; if(n == 1) &#123; ret[0][0] = ma[0][0] * mb[0][0]; &#125; else &#123; int a11[][] = new int[half][half]; int a12[][] = new int[half][half]; int a21[][] = new int[half][half]; int a22[][] = new int[half][half]; int b11[][] = new int[half][half]; int b12[][] = new int[half][half]; int b21[][] = new int[half][half]; int b22[][] = new int[half][half]; for(int i = 0; i &lt; half; ++i) &#123; for(int j = 0; j &lt; half; ++j) &#123; a11[i][j] = ma[i][j]; a12[i][j] = ma[i][j+half]; a21[i][j] = ma[i+half][j]; a22[i][j] = ma[i+half][j+half]; b11[i][j] = mb[i][j]; b12[i][j] = mb[i][j+half]; b21[i][j] = mb[i+half][j]; b22[i][j] = mb[i+half][j+half]; &#125; &#125; int[][] s1 = sub(b12,b22); int[][] s2 = add(a11,a12); int[][] s3 = add(a21,a22); int[][] s4 = sub(b21,b11); int[][] s5 = add(a11,a22); int[][] s6 = add(b11,b22); int[][] s7 = sub(a12,a22); int[][] s8 = add(b21,b22); int[][] s9 = sub(a11,a21); int[][] s10 = add(b11,b12); int[][] p1 = stressen(a11,s1); int[][] p2 = stressen(s2,b22); int[][] p3 = stressen(s3,b11); int[][] p4 = stressen(a22,s4); int[][] p5 = stressen(s5,s6); int[][] p6 = stressen(s7,s8); int[][] p7 = stressen(s9,s10); int c11[][] = sub(add(p5,p4),sub(p2,p6)); int c12[][] = add(p1,p2); int c21[][] = add(p3,p4); int c22[][] = sub(add(p5,p1),add(p3,p7)); for(int i = 0; i &lt; half; ++i) &#123; for (int j = 0; j &lt; half; ++j) &#123; ret[i][j] = c11[i][j]; ret[i][j+half] = c12[i][j]; ret[i+half][j] = c21[i][j]; ret[i+half][j+half] = c22[i][j]; &#125; &#125; &#125; return ret;&#125; 任务二： 最近点对问题 问题简述 在一个二维空间内有一些点，求出所有点对中距离最小的点对以及距离值。这里的距离指的是欧几里得距离即直线距离。 问题分析 这个问题可以分解成一些互不相干的子问题，并且小规模求解更加简单，同时还具有最优的子结构。满足使用分治思想求解的问题的特点，故可以使用分治思想求解。参考《算法导论》上的相关内容，分治的步骤可以是下面这样： 分治 对所有的点按照x坐标（或者y）从小到大排序。（排序方法时间复杂度\\(O(nlogn)\\)） 根据下标进行分割，使得点集较平均地分为两个集合。 求解 递归的寻找两个集合中的最近点对。 取两个集合最近点对中的最小值\\(d=min(d_{L},d_{R})\\)。 合并 最近距离不一定存在于两个集合中，可能在分解的两侧。 若一个点在集合A，一个点在集合B，那么这两点间距离小于d。 前面的部分还都比较好理解，关键就在于合并步骤。根据上面的分析：当最近点对在分割线两侧的时候，它们的距离一定会小于d；因此，我们可以在分割线m的周围取以下区间\\([m-d,m+d]\\)；显然，若最小点对跨过了分界线，那么一定会出现在这个条状区域内。那么只需要遍历一端在\\([m-d,m]\\)另一端在\\([m,m+d]\\)内的所有点对并计算距离就可以了。 但是这里有一个显而易见的最坏情况：若两侧所有的点都出现在这一个带状区域之内，那么我们做的分治只是白白地增加了整个算法的常数而已。所以要在这个的基础之上进行优化。这里，算法导论上还给出了一个方法——把带状区域中的点按照另一个坐标排序；则在该数组中，对于任何一个点，最多只需要检查紧随其后的7个点，就可以确保找到存在的最小点对或确保它不存在。我们着重讨论这种做法的正确性所在： 首先先给出一个结论：若（p,q）是Q的最近点对，且p在带域左半部分，则q点必在下图所示的δ∗2δ长方形上；而在该长方形上，最多只能有边点集的6个点；每个点对之间的距离不小于δ。 2018092815112973.png 可以使用反证法来证明它的正确性：我们现在将上面的这个δ∗2δ的长方形划分成6个2δ/3∗δ/2的小长方形。如果存在第七个符合条件的点，那么一定有一个长方形拥有了两个点——然而这个长方形内最长的距离，也就是对角线，也不过长5δ/6；然后我们将这个打长方形对折到p同侧：根据同样的考虑，同侧最多也只能再有额外的两个点的距离大于δ；在考虑扫描的顺序，即可说明仅扫描随后7个点的正确性。 经过这种简化，扫描带状区域的复杂度被压缩到了常数级别，大大提升了算法的效率。 此外，还有如下的更进一步的优化： 1998年，由周玉林、熊鹏荣、朱洪教授提出了平面最近点对的一个改进算法，针对Preparata-Shamos算法提出的6个点，又证明其实只需要4个点就可以确定最近点对距离，该证明提出2个定理，利用更加准确的半径画圈，证明了只要对左半域上的每个点p，检验右半域y坐标与p最近的至多4个点即可（上下个两个）。具体明可以参考《求平面点集最近点对的一个改进算法》。 根据以上的优化，可以在合并时，通过检测与左半域点p的y坐标相邻的2个或者3个，即使用4点或者6点来检测，一般为了省事，只求与p点y坐标上界或者下界右半域连续的6个、4个点即可。 版权声明：本文为CSDN博主「码到sucess」的原创文章，遵循 CC 4.0 BY-SA 版权协议。 原文链接：https://blog.csdn.net/sinat_35678407/article/details/82874216 经过上述的优化之后，我们就可以确实地使用分治策略来优化这个问题了。上面说到的按照另一坐标轴排序的部分，还可以使用预排序的方法，再额外优化掉每次排序的一个\\(log n\\)的复杂度。排序的预处理消耗\\(O(nlogn)\\)，处理阶段消耗\\(\\Theta (n)\\)；最终的时间复杂度的递推公式如下： \\[ T(n) = \\begin{cases} 1 ,&amp; n \\leq 3 \\\\ 2T(\\frac{n}{2}) + O(n) ,&amp; n &gt; 3 \\end{cases} \\] 也就是说，整体的复杂度是 O(nlog n)。 代码实现 分治分为三个模块：分治模块，合并模块和暴力模块；当区间较小时直接由暴力模块求解，否则则先递归的分治，之后再使用合并模块合并两区间的答案求解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081private Point[] mergeDivisor(double m, double d, Point[] set) &#123; ArrayList&lt;Point&gt; list = new ArrayList&lt;&gt;(); final double l = m-d, r = m+d; for (Point pii : set) if (pii.x &gt;= l &amp;&amp; pii.x &lt;= r) list.add(pii); Point[] ret = new Point[2]; final int length = list.size(); if (length &lt;= 1) &#123; ret[0] = new Point(-inf); ret[1] = new Point(inf); return ret; &#125; ret[0] = list.get(0);ret[1] = list.get(1); double now = ret[0].distance(ret[1]), tmp; for (int i = 0; i &lt; length; ++ i) &#123; final int lim = Math.min(length, i + 7); for (int j = i+1; j &lt; lim; ++ j) &#123; tmp = list.get(i).distance(list.get(j)); if (tmp &lt; now) &#123; now = tmp; ret[0] = list.get(i); ret[1] = list.get(j); &#125; &#125; &#125; return ret;&#125;private Point[] solveDivisor(int l, int r, Point[] arr) &#123; final int m = arr.length / 2, ml = m + l; if (arr.length == 2) return new Point[]&#123;arr[0],arr[1]&#125;; else if (arr.length == 3) return bruteDivisor(arr); double mid = (arr.length % 2 == 1) ? this.set[l+m].x : (double)(this.set[l+m].x + this.set[l+m-1].x) / 2.0; int lcredit = 0, rcredit = 0, cur = l + m; while (cur &lt; r &amp;&amp; this.set[cur++].x == mid) ++rcredit; cur = l + m - 1; while (cur &gt;= l &amp;&amp; this.set[cur--].x == mid) ++lcredit; int ca = 0, cb = 0, mm = arr.length - m; Point[] left = new Point[m], right = new Point[mm]; for (int i = 0; i &lt; arr.length; ++ i) &#123; if (arr[i].x &lt; mid) left[ca++] = arr[i]; else if (arr[i].x &gt; mid) right[cb++] = arr[i]; else &#123; if (rcredit &gt; 0) &#123; right[cb++] = arr[i]; -- rcredit; &#125; else if (lcredit &gt; 0) &#123; left[ca++] = arr[i]; -- lcredit; &#125; &#125; &#125; Point[] ans1 = solveDivisor(l,ml,left), ans2 = solveDivisor(ml,r,right); final double d1 = ans1[0].distance(ans1[1]); final double d2 = ans2[0].distance(ans2[1]); Point[] ans3 = mergeDivisor(mid,Math.min(d1,d2),arr); final double d3 = ans3[0].distance(ans3[1]); if (d3 &lt; Math.min(d1,d2)) return ans3; else return d1 &gt; d2 ? ans2 : ans1;&#125;private Point[] bruteDivisor(Point[] set) &#123; Point[] ret = new Point[2]; double now = set[0].distance(set[1]), tmp; ret[0] = set[0]; ret[1] = set[1]; for (int i = 0; i &lt; set.length; ++ i) &#123; for (int j = i+1; j &lt; set.length; ++ j) &#123; tmp = set[i].distance(set[j]); if (tmp &lt; now) &#123; now = tmp; ret[0] = set[i]; ret[1] = set[j]; &#125; &#125; &#125; return ret;&#125; 实现的不够优雅…… 虽然说预排序确实减少了每次排序的一个 log n 的复杂度，但是每次分治都要复制数组还是不够优雅；若是像Java这种分配空间开销极大，并且面临不定时的垃圾回收的语言来说，想必常数是极大的吧。 实验结果 Stressen 正确性验证 随机生成 8x8 矩阵，分别使用定义和Stressen方法计算矩阵乘法；将答案对比并输出结果到控制台，运行结果如下： O_U_09LTHT43NVU9X~_RTYN.png 可以证明实现是正确的。 效率对比 随机生成矩阵，使用两种方法进行多次重复计算；每次改变方阵规模，并计时输出到控制台；运行结果如下： _QIYW71_VE_UCW8ARS7YB7.png 因为Stressen方法实现过程中有大量的矩阵新建/销毁的操作，反复的分配/释放内存，导致了常数大幅提高；在实验中的表现甚至不如一般的矩阵乘法。 最小点对测试 进行随机测试，运行结果如下： Z__FNF_F3O7I3_U__L5M_HW.png 关于自动测试程序的正确性，可以参照源代码中的Main.main方法的调用。下面的运行结果是输出暴力和分治求解结果的一些测试结果： _N8~YP_NTBALAW_1XR4207R.png 这些测试结果足以证明了算法实现的正确性。 思考题 分治算法的步骤和正确性 分治算法包括三个基本步骤： Step1：Devide——将要解决的问题划分成若干规模较小的同类问题 Step2：Conquer——当子问题划分得足够小时，用较简单的方法解决 (一般都是递归) Step3：Combine——将子问题的解逐层合并构成原问题的解 正确性可用数学归纳法证明。 使用主方法分析 Stressen 方法和点对分治 Strassen’s 矩阵乘法的递归式为 \\(T(n) = 7T(\\frac n 2) + Θ(n^2)\\)，可以由主定理的公式 FN2D2S89GW3SGVR6L7_L_F.png 得到：\\(T(n) = n^{lg7}\\)。 修改 Stressen 方法增广使用范围 首先，先梳理一下 Stressen 方法要求方阵的规模是二次幂的原因： Stressen 方法将子矩阵的乘法变成了加法，而加法对于两个“加数”矩阵的规模要求十分严格——即满足相同规模；因此，为了保证每次分治二分的矩阵都可以进行矩阵加法，才要求矩阵的规模必须是2的幂。基于这一点，我们有两种思路： 将矩阵补成二次幂形式： 因为矩阵乘法性质规定了，以补0的方式扩大现有方阵，乘法的结果依然不变；也就是说可以先将矩阵扩大到二次幂形式，相乘之后再取出特定部分的值还原矩阵即可。但是这样做将面临可能的很大的空间开销，并不是很好的方案。 规定一个小方阵规模： 小方阵直接使用定义求解；令这个最小规模为m，那么我们要求的方阵规模就从二次幂转化为了\\(n*2^a\\)，其中 n &lt; m。这样扩充矩阵造成的空间浪费就得以控制，且较小范围内，由于常数原因并不会损失太多的性能。 因为基本的思路都是扩充矩阵，还有一种可行的方案是：每次进行分治的时候检测方阵的规模，若方阵的规模为奇数且不为1时（或者大于最小方阵规模时）将它扩充为+1的偶数。这样下次再遇到扩充的数值就缩小了一半，也不会造成过多的空间浪费。 实验三：作业排程和最长共同子序列算法 实验要求如下： ##### 实验三：作业排程和最长共同子序列算法 一、实验目的 理解动态规划算法设计思想，利用动态规划算法设计方法解决作业排程和最长共同子序列问题。 二、实验条件 计算机及程序语言开发平台（如 C、C++、Java、Matlab 等）。 三、实验内容及要求 - 描述并实现动态规划的作业排程算法，并显示下图的排程结果。 - 描述并实现最长共同子序列动态规划 算 法 ， 并 显 示 S1 = ACCGGTCGAGATGCAG，S2 = GTCGTTCGGAATGCAT 的最长共同子序列。 四、思考题 - 动态规划算法范式是什么？ - 利用动态规划算法设计方法解决矩阵链相乘问题？ 任务一：作业排程问题 问题简述 有一个车间，有n条生产线，每条生产线有m个工序组成。每个工序可以组装一个零件，且第i条生产线的第j个工序花费的时间是a(i,j)；如果在一条生产线上加工产品，则产品在不同的工序之间流转的消费是0；否则，如果要将在第i条生产线的第j个工序处理之后的产品移动到另一条生产线的第j+1个工序，则需要额外的成本t(i,j)；此外，对于每条生产线，将零件送上生产线需要e(i)，将产品撤下生产线需要x(i)。 装载一个产品恰好需要经历一整条生产线上的所有工序，请问如果要生产一个产品，所需要的最小花费是？ 问题分析 在每一个工序上花费的时间是恒定的。如果决定某工序在确定的生产线上生产，那么它的耗时仅取决于处理之前所有工序的最短时间。这说明了这个模型具有可转移性；并且这个模型具有无后效性：因为处理某工序之前，无论之前的工序在哪条生产线上完成都不会影响到该工序的处理。所以这是一个DP模型，可以使用DP解。 我们设\\(dp_{i,j}\\)的含义是：产品到达第i条生产线上的第j个工序时，可能的最短耗时。那么根据上面的分析易得推导关系： \\[ dp_{i,j} = min \\begin{cases} dp_{k,j-1}+a_{k,j-1} ,&amp; k = i \\\\ dp_{k,j-1}+a_{k,j-1}+t_{k,j-1} ,&amp; k \\neq i \\end{cases} \\] 上式中有$k $；特别地，在最后一道工序和第一道工序的时候，因为有上下费用，所以推导式略有不同： \\[ \\begin{cases} dp_{i,1} = e_i \\\\ ans = min(dp_{i,m}) ,&amp; i \\in [1,n] \\end{cases} \\] 这样ans就是最小的时间费用了。如果要求出具体的转移方案也很简单：在转移的同时开一个数组记录转移的前缀。找到答案后再倒退回去就可以了。 核心代码 下面的这些代码可以在文首仓库的DP_Algorithm\\src\\com\\shiroha\\curriculum\\algorithm\\dp目录下找到。 不包含追踪，仅求出最少花费的版本： 12345678910111213141516171819202122public static int solve(Problem p) &#123; final int m = p.getLines(), n = p.getStations(); int dp[][] = new int[m][n+1]; for (int i = 0; i &lt; m; ++ i) &#123; dp[i][0] = p.getEntry(i); &#125; for (int j = 1; j &lt; n; ++ j) &#123; for (int i = 0; i &lt; m; ++ i) &#123; dp[i][j] = dp[i][j-1] + p.getTime(i,j-1); for (int k = 0; k &lt; m; ++ k) &#123; if (k == i) continue; dp[i][j] = Math.min(dp[i][j], dp[k][j-1] + p.getTransfer(k,j-1) + p.getTime(k, j - 1)); &#125; &#125; &#125; int ans = 0x7fffffff; for (int i = 0; i &lt; m; ++ i) &#123; dp[i][n] = dp[i][n-1] + p.getExit(i) + p.getTime(i,n-1); ans = Math.min(ans, dp[i][n]); &#125; return ans;&#125; 包含回溯的版本： 12345678910111213141516171819202122232425262728293031323334353637383940public static String[] backtraceSolve(Problem p) &#123; final int m = p.getLines(), n = p.getStations(); String[] ret = new String[2]; int dp[][] = new int[m][n+1], tmp, cur; int trace[][] = new int[m][n], f[] = new int[n]; for (int i = 0; i &lt; m; ++ i) &#123; dp[i][0] = p.getEntry(i); &#125; for (int j = 1; j &lt; n; ++ j) &#123; for (int i = 0; i &lt; m; ++ i) &#123; dp[i][j] = dp[i][j-1] + p.getTime(i,j-1); cur = i; for (int k = 0; k &lt; m; ++ k) &#123; if (k == i) continue; tmp = dp[k][j-1] + p.getTransfer(k,j-1) + p.getTime(k, j - 1); if (tmp &lt; dp[i][j]) &#123; dp[i][j] = tmp; cur = k; &#125; &#125; trace[i][j] = cur; &#125; &#125; int ans = 0x7fffffff, pos = -1; for (int i = 0; i &lt; m; ++ i) &#123; dp[i][n] = dp[i][n-1] + p.getExit(i) + p.getTime(i,n-1); if (dp[i][n] &lt; ans) &#123; ans = dp[i][n]; pos = i; &#125; &#125; for(int i = n-1; i &gt;= 0; -- i) &#123; f[i] = pos; pos = trace[pos][i]; &#125; ret[0] = Integer.toString(ans); ret[1] = backtraceToString(f); return ret;&#125; 详情请参考全部源代码。 任务二：LCS问题 问题简述 子序列的定义：对于由序列\\(A_{1..n}\\)中的元素构成的子序列\\(A_i..A_j\\)，若对于任意 i,j 都有 i &lt; j，那么该序列就是原序列的子序列。 现给定两个字符串，求出它们的最长子序列。 问题分析 同样是简单的递推关系：若对于两个序列\\(A\\),\\(B\\)：设序列\\(A_i\\)的意义是从串A开始到第i个字符阶段的字符串，\\(a_i\\)是A串位于第i位 的字符；那么，设\\(dp_{i,j}\\)的含义是\\(lcs(A_i,B_j)\\)，易得推导关系： \\[ dp_{i,j} = \\begin{cases} dp_{i-1,j-1}+1 ,&amp; a_i = b_j \\\\ max(dp_{i-1,j},dp_{i,j-1}) ,&amp; a_i \\neq b_j \\end{cases} \\] 同理，若要求出其中一种最长子序列，只需要记录前缀信息，求出答案后回溯即可。 核心代码 无回溯版本： 12345678910111213141516171819public static int basicSolve(String s1, String s2) &#123; int l1 = s1.length(), l2 = s2.length(); int[][] dp = new int[l1+1][l2+1]; Arrays.fill(dp[0],0); for (int i = 0; i &lt; l1; ++ i) &#123; dp[i][0] = 0; for (int j = 0; j &lt; l2; ++ j) &#123; if (s1.charAt(i) == s2.charAt(j)) &#123; dp[i+1][j+1] = dp[i][j] + 1; &#125; else &#123; dp[i+1][j+1] = Math.max(dp[i][j + 1], dp[i + 1][j]); &#125; &#125; &#125; return dp[l1][l2];&#125; 回溯版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243public static String backtraceSolve(String s1, String s2) &#123; int l1 = s1.length(), l2 = s2.length(); int[][] dp = new int[l1+1][l2+1]; byte[][] backtrace = new byte[l1+1][l2+1]; Arrays.fill(dp[0],0); Arrays.fill(backtrace[0], (byte) -1); for (int i = 0; i &lt; l1; ++ i) &#123; dp[i][0] = 0; backtrace[i][0] = 1; for (int j = 0; j &lt; l2; ++ j) &#123; if (s1.charAt(i) == s2.charAt(j)) &#123; dp[i+1][j+1] = dp[i][j] + 1; backtrace[i+1][j+1] = 0; &#125; else &#123; if (dp[i][j + 1] &gt; dp[i + 1][j]) &#123; dp[i+1][j+1] = dp[i][j + 1]; backtrace[i+1][j+1] = 1; &#125; else &#123; dp[i+1][j+1] = dp[i + 1][j]; backtrace[i+1][j+1] = -1; &#125; &#125; &#125; &#125; backtrace[0][0] = 0; StringBuilder sb = new StringBuilder(); int x = l1, y = l2; while(x != 0 &amp;&amp; y != 0) &#123; switch (backtrace[x][y]) &#123; case 0: --x; --y; sb.append(s1.charAt(x)); break; case 1: --x; break; case -1: --y; break; default: break; &#125; &#125; return new StringBuffer(sb.toString()).reverse().toString();&#125; 详情请参考全部源代码。 实验结果 任务一 样例运行结果： 0SWM5YS978YWB0I~GU7A_0.png 自行测试结果： 5_L_YNZ_7W4POEXE0_M2UC.png _S5VX_Q6N84PZ4U8T8FVW.png 任务二 样例运行结果： VS_FN_VE~67Q_VJK9A2_FUG.png 自行测试结果： ~_E_M3G6GDXQ@WCVRTOPLDF.png 上述运行结果和预想结果一致，说明了算法实现的正确性。 思考题 动态规划算法范式 动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中,可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。 其基本思想是将待求解问题分解成若干个子问题：先求解子问题，然后从这些子问题的解得到原问题的解。这一点和分治法类似。 适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。有些子问题会被重复计算了很多次，对于这部分子问题可以记忆化。 简单的说，适合使用动态规划求解的问题往往具有可转移性和无后效性两大特点。 利用动态规划算法设计方法解决矩阵链相乘问题 不同矩阵相乘所需要的乘法次数是不同的。而当大量矩阵以链的形式相乘的时候，因为矩阵的乘法满足结合律，所以可通过适当选择乘法计算的优先级，可以找到某种计算顺序：它所需要进行的乘法计算次数是最少的。 首先：n*m的矩阵和m*k相乘所需要进行的乘法次数是nmk。设矩阵连乘的公式是\\(A_iA_{i+1}..A_j,i \\leq j\\)，简写为\\(A[i:j]\\)。假设对于这个连乘的最优分割位置是k，那么就有\\(A[i:j]=A[i:k]A[k+1:j]\\)。设\\(A[i:j]\\)的计算量是\\(p[i:j]\\)，那么显然：最优的\\(p[i:j]\\)是最优的\\(p[i:k]\\)和最优的\\(p[k+1:j]\\)之和加上\\(A[i:k]A[k+1:j]\\)的消耗。 这样就可以建立起状态转移方程了。记\\(p[i:j]\\)为\\(dp_{i,j}\\)，矩阵\\(A_i\\)是\\(a_i*b_i\\)矩阵；那么显然有： \\[ dp_{i,j} = dp_{i,k}+dp_{k+1,j}+a_ib_kb_j \\] 显然，当 i=j 的时候，\\(dp_{i,j}\\)为0；在其他情况下，只需要遍历区间内的k，找到最小的dp进行转移就可以了。最后可以得到最少的乘法数；如果需要获得一种具体的方案，也可以通过回溯前缀的方法实现。 参考资料 https://blog.csdn.net/alzzw/article/details/98100378 https://www.jianshu.com/p/b749a8afdfd2 https://blog.csdn.net/sinat_35678407/article/details/82874216","categories":[{"name":"课业","slug":"课业","permalink":"https://shiraha.cn/categories/%E8%AF%BE%E4%B8%9A/"}],"tags":[{"name":"课内作业","slug":"课内作业","permalink":"https://shiraha.cn/tags/%E8%AF%BE%E5%86%85%E4%BD%9C%E4%B8%9A/"},{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"实验报告","slug":"实验报告","permalink":"https://shiraha.cn/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"Java","slug":"Java","permalink":"https://shiraha.cn/tags/Java/"}]},{"title":"操作系统原理：脚本程序编写实验报告","slug":"class-FoDOS-experiment-bat-programming","date":"2020-03-16T06:11:17.000Z","updated":"2020-03-16T06:11:17.000Z","comments":true,"path":"2020/class-FoDOS-experiment-bat-programming/","link":"","permalink":"https://shiraha.cn/2020/class-FoDOS-experiment-bat-programming/","excerpt":"","text":"开始之前先简单介绍一下这次的任务要求： ##### 《操作系统原理》第一次上机实验 一、实验目的 理解操作系统生成的概念和过程； 理解操作系统两类用户界面（操作界面，系统调用）概念； 二、实验内容 在 Ubuntu 或其他 Linux 平台环境下裁剪和编译 Linux 内核，并启用新的内核。 在 Ubuntu 或其他 Linux 平台为 Linux 内核增加 1-3 个新 的系统调用，并启用新的内核，编写一个应用程序测试新增加的系 统调用是否能正确工作。 在 Windows 环境下，编写一个批处理程序（算命大 师.bat），程序运行后，输入：出生年月日（例如 2000-07-31）。系 统输出相应的属相和星座，例如：你属兔， 狮子座。要求：输入进 行合法性检查，能循环接收用户的输入，直到输入 q 或 Q 就退出。 Front-matter 由于增加系统调用的部分在之前已经做过了，而且一遍下来耗时很多…… 在家里一台电脑折腾的情况下挺浪费时间的就不做了。想要看上次怎么做的请去看这里。 因为Bat年久失修，微软官网上都找不到它的文档，于是考虑写一个Powershell脚本。况且新型Windows的cmd都是可以执行Powershell脚本的，就直接写了；然后因为我实在是不懂星座，当不了星座带师；干脆就把之前大一无聊写的简易野兽先辈论证器的逻辑搞过来整成了Powershell版本的野兽先辈论证器（ 事实上后来也有补充一个Bat的简单的版本。算了这篇文章还是文风清新了一点，我重写一篇好了 == 新文章的地址是： 好的，接下来是实验报告正文： 实验目的 理解操作系统生成的概念和过程； 理解操作系统两类用户界面（操作界面，系统调用）概念； 实验内容 在 Ubuntu 或其他 Linux 平台环境下裁剪和编译 Linux 内核，并启用新的内核。 在 Ubuntu 或其他 Linux 平台为 Linux 内核增加 1-3 个新 的系统调用，并启用新的内核，编写一个应用程序测试新增加的系 统调用是否能正确工作。 在 Windows 环境下，编写一个批处理程序（算命大 师.bat），程序运行后，输入：出生年月日（例如 2000-07-31）。系 统输出相应的属相和星座，例如：你属兔， 狮子座。要求：输入进 行合法性检查，能循环接收用户的输入，直到输入 q 或 Q 就退出。 因为裁剪、增加系统调用和应用修改后的内核已经在上一次实验中做过了，这里仅简述实验过程和实验结果。 实验过程 第一个实验包含了编辑内核，生成补丁已经应用内核三个步骤。这里将简要介绍。第二个实验仅包含编码和测试。 编辑内核 在下载的内核使用menuconfig打开图形化的内核裁剪页面，进行必要的调整之后保存为配置文件就可以了。 复制一份下载的纯净内核文件，修改其中的include/uapi/asm-generic/unistd.h和include/linux/syscalls.h两个头文件来增加系统调用的函数。 进入系统调用注册表的目录arch/x86/entry/syscalls，根据要安装的操作系统位数修改其下的tbl文件，注册增加的系统调用。特别注意不应该与已经存在的系统调用的编号冲突。 使用vim打开系统调用的实现的源文件kernel/sys.c来增加刚才增加的函数的实现。如果要增加的是在内核缓冲区打印消息这种最简单的系统调用，则它可以是下面这样： 123456asmlinkage void sys_shirohashow(void)&#123; printk(&quot;Shiroha do your best!&quot;); printk(&quot;\\n@Edit by Shiroha on 2019-11-15.&quot;); return 0;&#125; 这样，我们就增加了一个系统调用函数sys_shirohashow的实现。完成之后还要在include/uapi/asm-generic/unistd.h增加宏。 生成补丁并应用内核 将修改过的内核和纯净内核使用diff -Naur生成差异补丁，再使用patch命令应用到纯净内核上。使用make -j6进行多线程编译。 编译成功后执行安装，并将必要的文件复制到特定的地方之后更新grub的引导信息，就完成了内核的应用。 在运行新内核的操作系统上写C程序，调用增加的系统调用，就可以看到我们在内核中编写的程序可以成功运行了。 编写Powershell程序 简要分析实验要求，大概得出这个程序的工作流程： 流程图 因为Powershell支持绝大多数的C语言特性，可以开强类型变量也可以构造函数，并且可以使用 .NET Framework 的一些东西，所以很轻松的就写出来了。 编码环境和工具： 文本编辑器 ： Microsoft Visual Studio Code 1.44 操作系统版本 ： Windows 10 Pro 1903 18362.720 Powershell版本 ： Windows Powershell 5.1 关于输入文字的方式，可以使用Powershell原生的Read-Host，也可以使用框架提供的GUI窗口；甚至还可以使用 Visual Basic 的窗口。这就看个人喜好了，下面的代码是使用了框架的窗口实现的生日数字论证器： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130Add-Type -AssemblyName System.Windows.FormsAdd-Type -AssemblyName System.Drawing[int[]] $days = 29,31,28,31,30,31,30,31,31,30,31,30,31$dayIsIllegal = &quot;The days you input is illegal. try again&quot;[string[]] $months = &#x27;Feb&#x27;,&#x27;Jan&#x27;,&#x27;Feb&#x27;,&#x27;Mar&#x27;,&#x27;Apr&#x27;,&#x27;May&#x27;,&#x27;Jun&#x27;,&#x27;Jul&#x27;,&#x27;Aug&#x27;,&#x27;Sep&#x27;,&#x27;Oct&#x27;,&#x27;Nov&#x27;,&#x27;Dec&#x27;[string[]] $iiyokoiyo = @( &#x27;1+1+4-5-1^4=0&#x27;, &#x27;1+1+4-5*1^4=1&#x27;, &#x27;1+1+4-5+1^4=2&#x27;, &#x27;1+1-4+5*1^4=3&#x27;, &#x27;1+1+4-5-1+4=4&#x27;, &#x27;1+1+4-5+1*4=5&#x27;, &#x27;1+1+4+5-1-4=6&#x27;, &#x27;1+1+4+5-1*4=7&#x27;, &#x27;1+1+4+5+1-4=8&#x27;, &#x27;1+1*4+5-1^4=9&#x27;, &#x27;1+1+4+5-1^4=10&#x27;, &#x27;1+1+4+5*1^4=11&#x27;, &#x27;1+1+4+5+1^4=12&#x27;, &#x27;1+1*4+5-1+4=13&#x27;, &#x27;1+1+4+5-1+4=14&#x27;, &#x27;1+1+4+5+1*4=15&#x27;, &#x27;1+1+4+5+1+4=16&#x27;, &#x27;1+1+4*5-1-4=17&#x27;, &#x27;1+1+4*5-1*4=18&#x27;, &#x27;1+1+4*5+1-4=19&#x27;, &#x27;1+1*4*5-1^4=20&#x27;, &#x27;1+1+4*5-1^4=21&#x27;, &#x27;1+1+4*5*1^4=22&#x27;, &#x27;1+1+4*5+1^4=23&#x27;, &#x27;1+1*4*5-1+4=24&#x27;, &#x27;1+1+4*5-1+4=25&#x27;, &#x27;1+1+4+5*1*4=26&#x27;, &#x27;1+1+4*5+1+4=27&#x27;, &#x27;(1+1)*4+5*1*4=28&#x27;, &#x27;(1+1+4)*5-1^4=29&#x27;, &#x27;(1+1+4)*5*1^4=30&#x27;, &#x27;(1+1+4)*5+1^4=31&#x27;)function isLunar ([int] $y) &#123; if($y % 4) &#123;return &#x27;False&#x27;&#125; else &#123;if($y % 400) &#123;return &#x27;True&#x27;&#125; else &#123;if($y % 100) &#123;return &#x27;False&#x27;&#125; else &#123;return &#x27;True&#x27;&#125;&#125;&#125;&#125;while(1)&#123; $form = New-Object System.Windows.Forms.Form $form.Text = &#x27;Birthday input form&#x27; $form.Size = New-Object System.Drawing.Size(300,200) $form.StartPosition = &#x27;CenterScreen&#x27; $okButton = New-Object System.Windows.Forms.Button $okButton.Location = New-Object System.Drawing.Point(65,120) $okButton.Size = New-Object System.Drawing.Size(75,23) $okButton.Text = &#x27;OK&#x27; $okButton.DialogResult = [System.Windows.Forms.DialogResult]::OK $form.AcceptButton = $okButton $form.Controls.Add($okButton) $cancelButton = New-Object System.Windows.Forms.Button $cancelButton.Location = New-Object System.Drawing.Point(160,120) $cancelButton.Size = New-Object System.Drawing.Size(75,23) $cancelButton.Text = &#x27;Cancel&#x27; $cancelButton.DialogResult = [System.Windows.Forms.DialogResult]::Cancel $form.CancelButton = $cancelButton $form.Controls.Add($cancelButton) $label = New-Object System.Windows.Forms.Label $label.Location = New-Object System.Drawing.Point(10,20) $label.Size = New-Object System.Drawing.Size(280,20) $label.Text = &#x27;Input your Birthday as YYYY-MM-DD&#x27; $form.Controls.Add($label) $textBox = New-Object System.Windows.Forms.TextBox $textBox.Location = New-Object System.Drawing.Point(10,40) $textBox.Size = New-Object System.Drawing.Size(260,20) $form.Controls.Add($textBox) $form.Topmost = $true $form.Add_Shown(&#123;$textBox.Select()&#125;) $result = $form.ShowDialog() if ($result -eq [System.Windows.Forms.DialogResult]::OK) &#123; $x = $textBox.Text &quot;Your input: &quot;+$x if($x -eq &#x27;q&#x27; -or $x -eq &#x27;Q&#x27;) &#123; &quot;Exting ...&quot; exit &#125; [int[]] $data = $x.Split(&#x27;-&#x27;) if($data.Count -ne 3) &#123; Write-Host -ForegroundColor RED &quot;The String you input is not refer to a date.&quot; continue &#125; if($data[0] -lt 1) &#123; Write-Host -ForegroundColor YELLOW &quot;You cannot born before AC. try again&quot; continue &#125; if($data[1] -lt 1 -or $data[1] -gt 12) &#123; Write-Host -ForegroundColor RED &quot;The month is illegal. try again&quot; continue &#125; $lunar = isLunar $data[0] $month = $data[1] if ($lunar -eq &#x27;True&#x27; -and $data[1] -eq 2) &#123;$month = 0&#125; if($data[2] -lt 1 -or $data[2] -gt $days[$month]) &#123; Write-Host -ForegroundColor RED $dayIsIllegal continue &#125; Write-Host -ForegroundColor YELLOW &quot;PROOVE STRAT:&quot; &quot;You born in &quot;+$months[$data[1]]+&quot;, which means &quot;+$data[1]+&quot;, and there is &quot;+$iiyokoiyo[$data[1]] &quot;You born at &quot;+$data[2]+&quot;, and there is &quot;+$iiyokoiyo[$data[2]] Write-Host -ForegroundColor GREEN &quot;Q.E.D. You are HonMono No Yaju Senpai ! &quot; pause &#125;&#125; 代码中的自定义函数isLunar完成对闰年的判断。通过返回字符串作为布尔值代表结果。每次循环都调用框架创建一个包含两个按钮和一个文本框的窗口，用来获得用户的输入。输入之后从文本框组件中获得输入的字符串进行后续处理。 这里使用了Add-Type引入了框架，使用$来定义变量和数组，使用[]来指定强类型限制。对于输入字符串不是YYYY-MM-DD格式的情况，我利用强类型转换的失败自动抛出异常，并继续到下一个循环。关于弹出GUI窗口的操作，具体请参照微软的官方文档。 显而易见地，也可以使用控制台直接输入文字而不是弹出一个GUI窗口来获取用户输入。这就需要使用到Read-Host。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788[int[]] $days = 29,31,28,31,30,31,30,31,31,30,31,30,31$dayIsIllegal = &quot;The days you input is illegal. try again&quot;[string[]] $months = &#x27;Feb&#x27;,&#x27;Jan&#x27;,&#x27;Feb&#x27;,&#x27;Mar&#x27;,&#x27;Apr&#x27;,&#x27;May&#x27;,&#x27;Jun&#x27;,&#x27;Jul&#x27;,&#x27;Aug&#x27;,&#x27;Sep&#x27;,&#x27;Oct&#x27;,&#x27;Nov&#x27;,&#x27;Dec&#x27;[string[]] $iiyokoiyo = @( &#x27;1+1+4-5-1^4=0&#x27;, &#x27;1+1+4-5*1^4=1&#x27;, &#x27;1+1+4-5+1^4=2&#x27;, &#x27;1+1-4+5*1^4=3&#x27;, &#x27;1+1+4-5-1+4=4&#x27;, &#x27;1+1+4-5+1*4=5&#x27;, &#x27;1+1+4+5-1-4=6&#x27;, &#x27;1+1+4+5-1*4=7&#x27;, &#x27;1+1+4+5+1-4=8&#x27;, &#x27;1+1*4+5-1^4=9&#x27;, &#x27;1+1+4+5-1^4=10&#x27;, &#x27;1+1+4+5*1^4=11&#x27;, &#x27;1+1+4+5+1^4=12&#x27;, &#x27;1+1*4+5-1+4=13&#x27;, &#x27;1+1+4+5-1+4=14&#x27;, &#x27;1+1+4+5+1*4=15&#x27;, &#x27;1+1+4+5+1+4=16&#x27;, &#x27;1+1+4*5-1-4=17&#x27;, &#x27;1+1+4*5-1*4=18&#x27;, &#x27;1+1+4*5+1-4=19&#x27;, &#x27;1+1*4*5-1^4=20&#x27;, &#x27;1+1+4*5-1^4=21&#x27;, &#x27;1+1+4*5*1^4=22&#x27;, &#x27;1+1+4*5+1^4=23&#x27;, &#x27;1+1*4*5-1+4=24&#x27;, &#x27;1+1+4*5-1+4=25&#x27;, &#x27;1+1+4+5*1*4=26&#x27;, &#x27;1+1+4*5+1+4=27&#x27;, &#x27;(1+1)*4+5*1*4=28&#x27;, &#x27;(1+1+4)*5-1^4=29&#x27;, &#x27;(1+1+4)*5*1^4=30&#x27;, &#x27;(1+1+4)*5+1^4=31&#x27;)function isLunar ([int] $y) &#123; if($y % 4) &#123;return &#x27;False&#x27;&#125; else &#123;if($y % 400) &#123;return &#x27;True&#x27;&#125; else &#123;if($y % 100) &#123;return &#x27;False&#x27;&#125; else &#123;return &#x27;True&#x27;&#125;&#125;&#125;&#125;while(1)&#123; $x = Read-Host &quot;Please input your birthday as YYYY-MM-DD &quot; &quot;Your input: &quot;+$x if($x -eq &quot;&quot;) &#123;&quot;You input nothing, try again.&quot;&#125; if($x -eq &#x27;q&#x27;) &#123; &quot;Exting because of &#x27;q&#x27;...&quot; exit &#125; [int[]] $data = $x.Split(&#x27;-&#x27;) if($data.Count -ne 3) &#123; Write-Host -ForegroundColor RED &quot;The String you input is not refer to a date.&quot; continue &#125; if($data[0] -lt 1) &#123; Write-Host -ForegroundColor YELLOW &quot;You cannot born before AC. try again&quot; continue &#125; if($data[1] -lt 1 -or $data[1] -gt 12) &#123; Write-Host -ForegroundColor RED &quot;The month is illegal. try again&quot; continue &#125; $lunar = isLunar $data[0] $month = $data[1] if ($lunar -eq &#x27;True&#x27; -and $data[1] -eq 2) &#123;$month = 0&#125; if($data[2] -lt 1 -or $data[2] -gt $days[$month]) &#123; Write-Host -ForegroundColor RED $dayIsIllegal continue &#125; Write-Host -ForegroundColor YELLOW &quot;PROOVE STRAT:&quot; &quot;You born in &quot;+$months[$data[1]]+&quot;, which means &quot;+$data[1]+&quot;, and there is &quot;+$iiyokoiyo[$data[1]] &quot;You born at &quot;+$data[2]+&quot;, and there is &quot;+$iiyokoiyo[$data[2]] Write-Host -ForegroundColor GREEN &quot;Q.E.D. You are HonMono No Yaju Senpai ! &quot; pause&#125; 和上一个代码不同，因为没有引入框架创建GUI窗口，这个脚本的代码就显的短得多。理论上还可以使用[Microsoft.VisualBasic.interaction].Inputbox(string,string,string)来构建输入的GUI窗口，这里就不尝试了。 当然，文首提到的仓库中也包含了功能并不复杂的简单的 bat 脚本版本。如果你想看那些内容，可以前往这篇文章的重制版的地址：https://shiraha.cn/2020/class-FoDOS-experiment-1/ 实验结果 应用新内核 详情请看上一次的实验报告。 编写脚本程序 特别要注意的地方是，因为安全原因的考虑，Windows 10 系统自带的Powershell因为安全考虑，默认是禁止通过控制台加载ps1脚本文件的。我们需要进行检查： 使用以下命令检查当前的执行策略；如果值为Restricted，将不允许任何的脚本加载运行。 1get-executionpolicy 如果是Restricted，我们需要将它变更为RemoteSigned，通过执行以下命令来实现。 1Set-ExecutionPolicy -Scope CurrentUser RemoteSigned 这样，我们就可以通过ps1脚本的相对路径/绝对路径来运行任何的ps1脚本了。以下默认你已经保证你的Powershell允许直接加载脚本。 在某个目录新建一个文件，后缀名叫做ps1；比如我的叫YJSNPI.ps1。将实验过程中的两端代码中的任何一段复制到其中保存；随后右键开始菜单，打开Windows Powershell，使用cd命令到达你现在的目录（或者在Explorer的“文件”选项卡中，在当前的目录下启动Windows Powershell）；使用命令.\\YJSNPI.ps1执行刚才我们创建的脚本。 如果上述步骤不出现问题，预计就会看到下面的画面： 有窗口版本弹出的GUI输入框： LMD_7SEUR7_E9V_6_4WF~YB.jpg 输入不合法判定： PZ__B794716QTC_4_7P_ZTF.jpg 输入正确之后进行后处理输出字符串： J~__XMFPF__AP19MFI_QD6D.jpg 输入Q之后退出脚本： ~WL_PYFOW4DLB@_LY3H__YC.jpg 无弹出窗口的输入版本的基本操作： __OWFP_BLXG_A2FQFD_I3ZE.jpg 上述截图足以证明这些操作已经正确的实现。 体会 通过这次实验，我： 熟悉了Linux内核的应用过程，对Linux命令的理解更进一步； 更加生动的理解了系统调用的概念以及Linux操作系统从POST开始之后的启动过程； 熟悉了Powershell简单开发和部分.NET API的使用； 特别的，一般的家用Windows 10的Powershell是不允许直接加载ps1脚本的，需要先行修改运行策略。 后记 编程开始之前查查官方文档基本就差不多了。需要了解的只有运算，输入输出就可以了。因为有了这些东西，无论什么程序都可以写出来——因为它已经“图灵完备”了。如果提供了更多的支持（比如框架），只会降低我们开发的难度。 其实所有的整数都可以被用某些方式计算得到114514 参考资料 https://docs.microsoft.com/zh-cn/powershell/scripting/samples/creating-a-custom-input-box?view=powershell-7 https://www.cnblogs.com/zhaozhan/archive/2012/06/01/2529384.html https://blog.csdn.net/qishine/article/details/98216418 https://www.pstips.net/pass-boolean-to-script.html https://blog.csdn.net/weixin_33785972/article/details/91540883 https://www.pstips.net/powershell-specify-return-value-from-function.html https://www.pstips.net/powershell-create-new-function.html https://www.pstips.net/continue-and-labels.html https://www.pstips.net/powershell-creating-new-arrays.html https://www.cnblogs.com/victor963/p/12010909.html https://www.zhihu.com/question/264059954?sort=created","categories":[{"name":"课业","slug":"课业","permalink":"https://shiraha.cn/categories/%E8%AF%BE%E4%B8%9A/"},{"name":"操作系统","slug":"操作系统","permalink":"https://shiraha.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Windows","slug":"操作系统/Windows","permalink":"https://shiraha.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://shiraha.cn/tags/Windows/"},{"name":"操作系统","slug":"操作系统","permalink":"https://shiraha.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"课内作业","slug":"课内作业","permalink":"https://shiraha.cn/tags/%E8%AF%BE%E5%86%85%E4%BD%9C%E4%B8%9A/"},{"name":"实验报告","slug":"实验报告","permalink":"https://shiraha.cn/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"Powershell","slug":"Powershell","permalink":"https://shiraha.cn/tags/Powershell/"}]},{"title":"Nowcoder 练习赛59","slug":"nowcoder-practice-contest-59","date":"2020-03-14T03:23:56.000Z","updated":"2020-03-14T03:23:56.000Z","comments":true,"path":"2020/nowcoder-practice-contest-59/","link":"","permalink":"https://shiraha.cn/2020/nowcoder-practice-contest-59/","excerpt":"","text":"按照惯例，开始之前先码一下比赛的一些相关链接： 比赛地址： https://ac.nowcoder.com/acm/contest/4743 官方题解： https://ac.nowcoder.com/discuss/381692?type=101&amp;order=0&amp;pos=1&amp;page=1 这次题目可以说是优化DP/树形数据结构专场？六个题目很大一部分都可以使用优化DP的方法来解决。但是总体感觉还是题目没有出好，很多的题目只要你思维敏捷也能方便的使用其他的方法解决。 嘛……毕竟是马后炮，怎么说都是可以的（不过有一说一，从七点发呆到九点错过比赛时间，比赛结束之后立马补题倒也是有点真实== YS@39GS0XAKAL@L_CIKUTXN.jpg 不过比起打休闲，还是打天梯技术进步的更快，所以还是多打比赛，少自己补题休闲的好；虽然就算是事后自己做，结果好像也没做出来几个题目就是了== A - 字符串 签到题，直接找就行。 我的代码 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;string&gt;using namespace std;typedef long long longs;string s;char xq[] = &quot;XiaoQiao&quot;;char xhh[] = &quot;XiaoHuiHui&quot;;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); cin&gt;&gt;s; auto x = s.find(&#x27;X&#x27;); if(x==string::npos) // 必须的 &#123; cout&lt;&lt;&quot;emm&quot;; return 0; &#125; int ca = 1, cb = 1; int lim = s.length(); for (int i = x; i &lt; lim; ++ i) &#123; if(s[i]==xq[ca]) if(xq[ca]) ++ca; if(s[i]==xhh[cb]) if(xhh[cb]) ++cb; &#125; if(xq[ca] || xhh[cb]) cout&lt;&lt;&quot;emm&quot;; else cout&lt;&lt;&quot;Happy&quot;; return 0;&#125; 唯一的笔记就是string::npos不能忽视，还是要进行特判的。 B - 修路 签到题，排个序然后累加得到的就是最小生成树。 题目中的那个费用整理一下合并就可以得到费用至于每个小镇相关，而和哪两个小镇无关。 我的代码 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#define fee(a,b) (abs(f[a]-f[b]))using namespace std;typedef long long longs;const int N = 1e5+5;int n;longs f[N];int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); cin&gt;&gt;n; longs x,y; for(int i = 1; i &lt;= n; ++ i) &#123; cin&gt;&gt;x&gt;&gt;y; f[i] = y*(x-y)*(x-y); &#125; sort(f+1,f+1+n); longs ans = 0; for(int i = 1; i &lt; n; ++ i) ans += f[i+1]-f[i]; cout&lt;&lt;ans; return 0;&#125; C - 买装备 首先两种装备的消耗是给死了的。所以可以列方程，这恰好是二元一次不等式，可以线性规划。但是线性规划因为是一个浮点数，所以可能存在误差，需要对规划结果周围的数字进行一下判定，同时也需要特判解出负数的情况； 当然，因为题目写死了数据的原因，易得这个问题的单调极值性，那就可以三分来做了；同样是为了保险起见，区间缩小到一定范围就遍历求解比较就行。 如果不给死的话就是一个典型DP，但是这题目既然写死了还多组数据，显然就不是DP了。 我的代码 线性规划法：单次询问 O(1) 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;algorithm&gt;#define getN(m) min(y-3*(m),(x-2*(m))&gt;&gt;2)using namespace std;typedef long long longs;longs solve(int x, int y)&#123; longs m = (4ll*y-x)/10ll; longs n = getN(m); if(m &lt;= 0 || n &lt;= 0) return max(min(x&gt;&gt;1,y/3),min(x&gt;&gt;2,y)); longs ans = max(m+n,m+1+getN(m+1)); return max(ans,m-1+getN(m-1));&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); longs t,x,y; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;x&gt;&gt;y; cout&lt;&lt;solve(x,y)&lt;&lt;endl; &#125; return 0;&#125; 三分答案法：单次复杂度 O(log n) 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long longs;int x,y;longs check(longs m)&#123; longs n = min((x-(m&lt;&lt;1))&gt;&gt;2, y-3*m); return m+n;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;x&gt;&gt;y; int l = 0; int r = max(min(x/2,y/3),min(x/4,y)); while(r-l&gt;10) &#123; int t = (r-l)/3; int m1 = l+t, m2 = r-t; if(check(m1) &gt; check(m2)) r = m2; else l = m1; &#125; longs ans = 0; for(int i=l;i&lt;=r;++i) ans = max(ans,check(i)); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 理论上是一个DP，但是这个DP你就挂了== D - 石头游戏 异想天开的找规律，你不死谁死呢（叹气 玩家先手，如果是1，根据游戏定义那必败；那么因为大家都会采用最优战略，所以只要能转移到1的状态的状态就是必胜态；相反的，如果一个状态是必败态，那么它能转移到的状态一定都是必胜态； 所以，设每一个状态有效区间是[s,e]，从必败转移到必胜的区间就是[e+1,2e+1]（或者[2s,2e+1]），从必胜转移到必败就是[e+1,2e]。显然，必胜-必败区间是相互交错的。 得到了推导式，就可以算出包含输入的上限1e18的所有区间的状态。输入之后查询属于的区间后输出结果就可以。因为区间是翻倍的所以会指数级别增长，推导大约只需要进行64轮就可以完成所需要的预处理。 我的代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;typedef long long longs;const int N = 100;const int M = 64;longs st[N], ed[N];void preProcess()&#123; st[0] = ed[0] = 1; for(int i = 1; i &lt;= M; ++i) &#123; st[i] = ed[i-1] + 1; ed[i] = (ed[i-1]&lt;&lt;1) + (i&amp;1); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); preProcess(); int t; longs n; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n; int s = upper_bound(st,st+M,n) - st; if(s&amp;1) cout&lt;&lt;&quot;XiaoQiao&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;XiaoHuiHui&quot;&lt;&lt;endl; &#125; return 0;&#125; E - 搬石头 看起来贼像一个贪心，甚至还能装模做样大胆地猜出几个结论：贪，你接着贪——贪完你就去世了== 首先对于一堆确定数量的石头，分成x次搬运成本最低的方法显然是平均分配。但是要注意如果分配出0的话就没有意义了。 然后就是贪心的不正确性：大堆的石头分成多份可能比好几堆小的分成两份带来的收益大。所以这需要DP：将两堆石头分成m份带来的最优解是可以由两堆石头不同的分割方案递推而来的；这个时候还需要引入虚堆标记，有些麻烦。 计算单堆石头的所有分割方案的成本是O(n)，再加上虚堆求出整个石头堆的最佳方案的成本就是O(n³)。嗯其实还可以接受，如果数据量不是特别大的话； 但是这个题目不仅要分配方案，这堆石头还在不停的变化；每次变化都是要重新DP才能得到最优解的，这样整体的复杂度就变成了O(n⁴)了，这可不就凉凉== 刚才提到了DP是需要虚点的，所以可以利用线段树的思想，维护一个区间；每一次的石头堆的变化相当于单点修改；这样的话可以节约相当一部分的资源，每一次单点修改就是使用O(n)重新计算一堆石头的所有分割方案，然后更新相关联的区块的DP。线段树的单点修改的复杂度是O(nlog n)，加上这次的修改复杂度就是O(n²log n)，再算上修改次数就是O(n³log n)，差不多可以接受了。 虽然线段树的常数大的离谱，但是因为跑不满等诸多原因，这个题目还是可以勉勉强强的卡过去的。 社区讨论 这道题由很多大佬认为线段树过于愚蠢，可以使用其他优秀的办法来解决；可是又语焉不详，叫人听的半懂不懂的。因为我不是大佬，所以我只能爬简单的做一些大佬语录。如果之后了解了这些做法还记得这里的话就再更新了。 查.无.此.人. 4# ： E题怎么做都比题解优吧 闵可夫斯基和n^3 贪心每次取变化量最小的n^2log😑 boxxxx 15# ： E题裸dp每次是n3,但是可以3分优化成n2logn …… 三分我或多或少能理解…… 但是三分优化的DP是什么操作我就不得而知了（ 我的代码 这就是题解的线段树代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define cline(x) memset(x,0x3f,sizeof(longs)*(m1))using namespace std;typedef long long longs;const int N = 405;const longs INF = 0x3f3f3f3f3f3f3f3f;longs f[N&lt;&lt;2][N];int wide[N&lt;&lt;2];int n,m,li,m1;int a[N];int sum = 0;void update(int line)&#123; cline(f[line]); const int l = line&lt;&lt;1; const int r = l^1; int p; for(int i = wide[l]; i &lt;= m; ++ i) for(int j = wide[r]; (p = i+j) &lt;= m; ++ j) f[line][p] = min(f[line][p], f[l][i]+f[r][j]);&#125;void calculate(int num, int index)&#123; cline(f[index]); const int lim = min(li,a[num]); for(int i = 1; i &lt;= lim; ++i) &#123; const longs val = a[num] / i; const longs mod = a[num] % i; f[index][i] = mod*(val+1)*(val+1) + (i-mod)*val*val; &#125;&#125;void build(int l, int r, int index)&#123; wide[index] = r - l + 1; if(l==r) &#123; calculate(l,index); return; &#125; int m = l+r&gt;&gt;1; build(l, m, index &lt;&lt; 1); build(m+1, r, index &lt;&lt; 1 ^ 1); update(index);&#125;void modify(int l, int r, int index, int x)&#123; if(l==r) &#123; calculate(l,index); return; &#125; int m = l+r&gt;&gt;1; if(x &lt;= m) modify(l, m, index &lt;&lt; 1, x); else modify(m+1, r, index &lt;&lt; 1 ^ 1, x); update(index);&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); cin&gt;&gt;n&gt;&gt;m; li = m-n+1; m1 = m+1; for(int i = 1; i &lt;= n; ++ i) &#123; cin&gt;&gt;a[i]; f[i][1] = a[i]*a[i]; sum += a[i]; &#125; build(1,n,1); int q,x,v; cin&gt;&gt;q; while(q--) &#123; cin&gt;&gt;x&gt;&gt;v; sum += v-a[x]; a[x] = v; modify(1,n,1,x); cout&lt;&lt;f[1][min(m,sum)]&lt;&lt;endl; // 总数不超过x的石头不会被分为超过x堆 &#125; return 0;&#125; 一个特别的小细节就是要注意到分割成0是无意义的，因此需要一直统计sum F - 吃果果 相当于说，告诉你所有的果子落地的时间和位置，当然还有营养；问你应该怎么吃才能获得最大的营养。 显然题目开始之前，先根据时间排序。对于 j &gt; i，如果吃到了第i个果果还能吃到第j个，那么两者的时间差一定大于距离；但是因为果果有不同的营养价值，所以还是不能贪，需要DP（话说就算全是1，似乎还是要DP……）。i和j都是n的复杂度，O(n²)对于本题1e5的数据会自动暴毙== 然后接下来的部分就是题解的申必优化： 对于位置 pi ≥ pj： 能吃到的条件就可以化为 ti - pi ≥ tj - pj 对于位置 pi ≤ pj： 能吃到的条件就可以化为 ti + pi ≥ tj + pj 记 Xi = ti - pi，Yi = ti + pi；再利用树套树来优化DP的转移过程，就可以把时间复杂度降低到 O(nlog²n)，就可以卡过这个题目了= 说实话我还没学树套树，不是很能理解这种做法；那就学完了在更新好了（ 事后分析 这其实是一个二位偏序的问题。题解使用的算法是一种叫做树套树的在线算法：但是常数大的离谱，模板也很长。如果出错的话后果不堪设想== 但是也是可以做的。可是题目并不是要求强制在线，所以可以使用一些高效率的离线算法来解决。不仅写代码更好写，也不容易出错，时间复杂度还更低。 这个题目的离线算法Tag： CDQ分治， 带权LIS 我的代码 还没写呢（ 总的来说这次的题目主要还是用来优化写代码的熟练度，以及各种树形数据结构的使用== 当然也见识到了各种DP的常见优化。在这个的指引下，又可以学习一些新的知识了。不也挺好吗（ 所以说不仅要补题，还要补的是基本功和知识储备啊== 2D~HSI7CWL46_WU__M~A590.jpg 谁叫咱现在的知识储备还处于精卫填海，女娲补天的水平呢== 人要有自知之明，不会的东西就得赶快去补（","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"https://shiraha.cn/tags/Nowcoder/"}]},{"title":"2016 NWERC 回顾","slug":"2016-nwerc","date":"2020-03-10T05:23:49.000Z","updated":"2020-03-10T05:23:49.000Z","comments":true,"path":"2020/2016-nwerc/","link":"","permalink":"https://shiraha.cn/2020/2016-nwerc/","excerpt":"","text":"欢乐赛2，既然表现不佳那自然是要认真的补题的。按照惯例，在开始之前首先先码一下官方的题解： 官方网址： https://people.bath.ac.uk/masjhd/2016.NWERC/ 在这里你可以下载到题目、官方题解、判题官写的标程以及测试数据。 由于本人实力原因以及各种其他原因，补题仍然有很多不全面的地方，只好先暂时搁置了……（希望Utaha学长教我）目前这个题解仍然存在这些问题： D、G两题我是真的不会写…… J题网络流做法还没有写 I题的Steiner Tree也没有深入的讨论，直接搬的赛场上的代码 其他我还没能确定的一些小问题 希望看官可以理解。若是我做出来了那些题目，一定会及时更新在这里的. E – Exam Redistribution 本次签到题，是个人都做出来了。 题目大意 n个房间包含不同数量的学生，收卷子然后发卷子交换批改；先收的卷子先发，求一个安全的顺序，让所有学生都不能改到本房间的试卷。 也就是说给一个序列，求一个满足题目要求的顺序； 分析 暴死的情况有两种： 1. 要不就是改自己的卷子——一个房间的大小超过了所有其他房间大小的和，那么本身就是不可能的； 2. 要不就是进房间的时候卷子不够用了，那只能改自己的卷子了；所以要先大房间再小房间； 只要没有出现那种极端大的房间，那就先整大房子再整小房子就好了，上面两种情况必不会出现。写代码注意点就行了。 其实看这个白给的数据规模直接暴力模拟都成…… 我的代码 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;utility&gt;using namespace std;typedef long long longs;pair&lt;int,int&gt; s[40];inline void init()&#123; for(int i=0;i&lt;=30;++i) s[i].second = i;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n,sum = 0; init(); cin&gt;&gt;n; for(int i=1;i&lt;=n;++i) cin&gt;&gt;s[i].first,sum+=s[i].first; sort(s+1,s+1+n); if(s[n].first &gt; sum&gt;&gt;1) cout&lt;&lt;&quot;impossible&quot;; else &#123; for(int i=n;i&gt;0;--i) cout&lt;&lt;s[i].second&lt;&lt;&#x27; &#x27;; cout&lt;&lt;endl; &#125; return 0;&#125; 因为忘记初始化和大于等于忘记=而吃了一发WA也是没谁了…… H – Hamiltonian Hypercube 另一个签到题，是个人都做出来了。 题目大意 n位Gray码可以通过某种申必的方法映射到那个申必n维立方体上，并且还能形成哈密顿路（环）；但是这不重要——只是方便大家理解Gry码的。题目会输入两个Gray码，然后你要输出在这个申必立方体上两个码映射的节点在这个哈密顿路上的区间内包含的节点数。 也就是说求两个Gray码代表的数字的差的绝对值-1. 分析 妹啥好分析的，你会Gray码直接写个转换函数就成；不会的多读几遍题目也该会了。转化方式有好多种，我用的也是最常用的定义法——递归： \\[ ind(x_n) = \\begin{cases} ind(x_{n-1}), &amp; x = 0\\ x_{n-1} \\\\ 2^{n} - ind(x_{n-1}) - 1, &amp; x = 1\\ x_{n-1} \\\\ \\end{cases} \\] 只要注意点别手贱，写出了转换函数之后求差的绝对值-1输出就可以了。和n是没什么关系的，n只是方便了读入以及告诉你转换结果开long long是能存的下而已。 我的代码 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstdio&gt;using namespace std;typedef long long longs;char s1[100],s2[100];longs gray(char* s, int n)&#123; if(n==1) return s[0]-&#x27;0&#x27;; if(s[0]==&#x27;0&#x27;) return gray(s+1,n-1); else &#123; longs ret = 1ll&lt;&lt;n; return ret-1-gray(s+1,n-1); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin&gt;&gt;n; for(int i=0;i&lt;n;++i) cin&gt;&gt;s1[i]; for(int i=0;i&lt;n;++i) cin&gt;&gt;s2[i]; longs v1 = gray(s1,n); longs v2 = gray(s2,n); if(v1&gt;v2) swap(v1,v2); longs ans = v2-v1-1; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 考试的时候不知道为什么没有写对，但是事后一遍过，就非常的离谱。我寻思该注意的应该都注意到了啊。 C – Careful Ascent 又一个签到题，是个人都做出来了。 题目大意 垂直速度恒定，水平速度理论上恒定：但是会受到不同高度区间的水平风的影响，导致最后实际的速度并不是恒定的。现在在高远的前方有一个目标，你的飞行器要从原点开始升起，要求恰好可以到达这个目标点应该控制的水平速度。 也就是说告诉你目标点的坐标以及不同高度的水平风信息，问你怎么控制水平速度。 分析 初中物理学过吧？那列个方程拿电脑解出来就行。 然后那答案还给了一种比较通用的方法，用于情况稍微复杂一点的状况（但是这个题目一点也不复杂）：二分法，然后模拟验证答案的正确性——偏离目标点左侧就加速，否则减速；直到和目标点的距离差距在eps之内。说不定只要能模拟判断可行性的答案都可以二分的去找。 我的代码 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;iomanip&gt;using namespace std;typedef long long longs;typedef long double longd;typedef unsigned long long ulong;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout&lt;&lt;fixed&lt;&lt;setprecision(9); longs x,y; cin&gt;&gt;x&gt;&gt;y; int n; cin&gt;&gt;n; longd sum = 0, k; longs u,l, d = 0; while(n--) &#123; cin&gt;&gt;l&gt;&gt;u&gt;&gt;k; d += u-l; sum += k*(u-l); &#125; longd ans = x/(y-d+sum); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; F – Free Weights 算是一个比较简单的题目，校队的朋友们都做出来了。 题目大意 一个健身房里有两排哑铃，每种重量的轮盘只有两个。现在我们想要把相同重量的轮盘放在一起；每排的空间是无限的，如果你想要将哑铃轮盘滚到旁边的空位上，这是免费的；否则你挪动任何一个轮盘都会消耗和轮盘等重的费用；问你整理完了这一波哑铃之后单次消耗的最高费用是多少。 也就是说求的是整理好这一波哑铃轮盘必须要挪动的轮盘的最大重量的最小值。 分析 如果要是求总的消费我可真是没太多想法，但是既然都说了“最大xx的最小值”，这一看就是一个二分答案的题目。但是应该怎么来模拟这个行为进行快速判定呢？ 因为题目说了只求最高费用，换句话说就是比最高费用低的费用都免费了——随便挪的意思。那我们不如把所有较小的哑铃全部挪到千里之外并且让他们有序——恰好空间也是无限大的；然后再看留下来的轮盘是不是匹配的——不匹配咱也挪不了，说明这个最大重量不行；这样就可以方便的判断答案可行性了。 我的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long longs;typedef long double longd;typedef unsigned long long ulong;const int N = 1e6+5;int n;int in[2][N];bool check(int m)&#123; int last; bool got = false; for(int i=0;i&lt;n;++i) &#123; if(in[0][i]&lt;=m) continue; if(!got) &#123; got = true; last = in[0][i]; &#125; else &#123; if(last!=in[0][i]) return false; got = false; &#125; &#125; if(got) return false; for(int i=0;i&lt;n;++i) &#123; if(in[1][i]&lt;=m) continue;// 上点心吧 if(!got) &#123; got = true; last = in[1][i]; &#125; else &#123; if(last!=in[1][i]) return false; got = false; &#125; &#125; return !got;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); // freopen(R&quot;(D:\\shiroha\\Downloads\\nwerc2016testdata.tar\\nwerc2016testdata\\free_weights\\6-lightly-shuffled.in)&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n; int max = 0, min = 0x7fffffff; for(int i=0;i&lt;n;++i) &#123; cin&gt;&gt;in[0][i]; if(in[0][i]&gt;max) max = in[0][i]; if(in[0][i]&lt;min) min = in[0][i]; &#125; for(int i=0;i&lt;n;++i) &#123; cin&gt;&gt;in[1][i]; if(in[1][i]&gt;max) max = in[1][i]; if(in[1][i]&lt;min) min = in[1][i]; &#125; longs l = 0; longs r = max; while(l&lt;=r) &#123; const longs mid = (l+r)&gt;&gt;1; if(check(mid)) r = mid-1; else l = mid+1; &#125; cerr&lt;&lt;&quot;check(9589) = &quot;&lt;&lt;check(9589)&lt;&lt;endl; cout&lt;&lt;l&lt;&lt;endl; return 0;&#125; 依然是一个不会写代码的玩家因为犯了低级错误而连续WA的结果…… 附录 虽然说是一个典型的二分的题目，但是这个模型可以利用的地方还是比较多的：感觉像是降低难度而牵强附会了一些条件。所以还是有别的路子可以走——比如说标程里这位老哥写的sweep法。它非常符合我们的直观感受，且可以解出正确答案，在这里码一下好了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//this solution considers one element after another on the rack// A. consider the first two weights next to each other:// 1. they are equal -&gt; just delete them, nothing to do// 2. they are different, so I know I have to lift the lighter one, rember the weight of the lighter one and delete it// go to A//// Running time: O(n)#include &lt;bits/stdc++.h&gt;using namespace std;typedef vector&lt;int&gt; vi;int sweep_rack(const vi &amp;rack)&#123; int res=0; int cand=0; for(const int &amp;e:rack)&#123; if(e==cand)//found second! cand=0; else if(e&lt;cand)//I have to be strong enough to lift e (but who knows, maybe also cand) res=max(res, e); else&#123;// if(e&gt;cand), There is no way out, I have to lift the candidate, but it is not yet clear with e-&gt; make it candidate res=max(res, cand); cand=e; &#125; &#125; return max(res, cand);&#125;vi read_rack(int n)&#123; vi res(n); for (auto &amp;e:res) cin &gt;&gt; e; return res;&#125;int main()&#123; int n; cin &gt;&gt; n; cout &lt;&lt; std::max(sweep_rack(read_rack(n)), sweep_rack(read_rack(n))) &lt;&lt;&quot;\\n&quot;;&#125; 相当于扫行的时候做这样的事情：如果已经放在一起了，就直接删除；否则，就挪比较轻的那个（反正没有损失，之后要挪重的话更新答案便是），把另一个比较轻的也给删喽。这样子跑一边下来就能得到题目要的答案。每一步删除的正确性都能保证，稍微想想就知道了。 I – Iron and Coal 一个图论题，可以用搜索来解决。但是其实是一个 Steiner Tree 命运石之树（大嘘）的问题，有深挖的价值。 按照惯例，先问是不是再问为什么，所以先科普一下： Steiner Tree 斯坦纳树问题是组合优化学科中的一个问题。将指定点集合中的所有点连通，且边权总和最小的生成树称为最小斯坦纳树（Minimal Steiner Tree）。最小生成树是它的一种特殊情况，而斯坦纳树则是最小斯坦纳树的另有一种情况：只保证指定的点集合联通，但是不保证最小距离。 此外，一般来说，求一个最小斯坦纳树是一个 NP-complete 问题。 此外关于这个有篇博文写的不错，大家可以去看看： https://www.cnblogs.com/ECJTUACM-873284962/p/7643445.html 题目大意 给你一张图，有的点有矿，有的点有煤，你全都要；如果要拥有这个点的资源，你必须要占点才行；从一个点只能到达相邻的点，你最开始只有一号点；题目确保不存在任何一个节点同时拥有两个资源；问你如果能两个都要，最少所需要占的点数；如果不能两个都要就输出\"impossible\"。 也就是说要求出占领两种资源的最优方法。 分析 最开始做的时候我的队友也没想那么多。首先不能两个都要的情况很简单，就是无路可走。这个判断一下就可以了；两个都要的情况大概分成两种： 一种是一路到头，不仅找到了煤还找到了矿，应有尽有； 另一种是走到某个点然后兵分两路，最后也是两手捧花； 判定最小路径你之前需要先知道怎么求出路径：根据或不根据上面的分析，我们要想判定一个路径（也就这样的树），需要知道三个值：从家到这个点的距离、从这个点到最近的煤的距离、这个点到最近的矿的距离。然而这些距离都是可以通过搜索求出来的，每次搜索复杂度可控制在O(n)，然后遍历所有可能的“三方会谈点”，就可以找到这个最小值了。 不用担心上面的一步到位的情况，它就相当于节点在资源点，然后某条边的长度为0. 然后就是我没有深挖的题解的做法。题解提供了两种做法，一种是类似于我采用的做法，一种是Steiner树归约。先翻一下官方的题解： 解法一： Steiner树归约 将地图上的每个单元都抽象地看作一个节点 为每一个可到达的邻居点增加一条权重为0的有向边 将所有的每种资源都向该资源的超级节点连一条权重为0的边 以原点作为起点，对每一个超级节点求一个最小Steinner树 458HPW6_1_5NF_ZJ84KS8O8.png ↑这是大概的示意图↑ 除了第二条没怎么看懂…… 写了代码在更新这里好了 解法二： 多项式算法 虽然一般来说这是个NPC问题，但是在这种三个节点的特殊情况下，可以设计出多项式的算法来求这个最小Steinner树。我们假设已经建立了解法一所说的超级节点，具体步骤如下： 使用BFS找出原点到所有其他节点的距离 使用BFS在反图上求出每种资源的超级节点到所有点的距离 找到到原点和每种资源的超级节点的距离和最短的点 整个算法是一个O(n)时间的算法。 也就是我们队伍在赛场上采用的做法。 我的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define norm 0#define iron 1#define coal 2using namespace std;typedef long long longs;typedef long double longd;typedef unsigned long long ulong;struct edge&#123; int to,next;&#125;;const int N = 2e5+5;const int INF = 0x1f1f1f1f; // 因为会出现3*INF，所以不能是0x3f3f3f3fconst char cannot[] = &quot;impossible&quot;;int n,m,k;int o[N],c[N];int a,b;int dis[3][N]; // dis[!norm]代表了从某点能到达的最近的矿源的距离int head[N];edge e[(N&lt;&lt;1)+(N&lt;&lt;3)];int tot = -1;int tail[N];edge re[(N&lt;&lt;1)+(N&lt;&lt;3)];inline void init()&#123; tot = -1; memset(head,-1,sizeof(int)*(n+1)); memset(tail,-1,sizeof(int)*(n+1)); memset(dis[0],0x1f,sizeof(int)*(n+1)); memset(dis[1],0x1f,sizeof(int)*(n+1)); memset(dis[2],0x1f,sizeof(int)*(n+1));&#125;inline void addedge(int u, int v)&#123; ++tot; e[tot] = &#123;v,head[u]&#125;; head[u] = tot; re[tot] = &#123;u,tail[v]&#125;; tail[v] = tot;&#125;void BFS(int typ)&#123; queue&lt;int&gt; q; if(typ) &#123; if(typ==iron) for(int i=1;i&lt;=m;++i) q.push(o[i]), dis[iron][o[i]] = 0; else for(int i=1;i&lt;=k;++i) q.push(c[i]), dis[coal][c[i]] = 0; while(!q.empty()) &#123; int top = q.front(); q.pop(); int c = tail[top]; while(~c) &#123; if(dis[typ][re[c].to] &gt; dis[typ][top]+1) &#123; dis[typ][re[c].to] = dis[typ][top]+1; q.push(re[c].to); // 有可能更新距离时再更新 &#125; c = re[c].next; &#125; &#125; &#125; else &#123; q.push(1); dis[norm][1] = 0; while(!q.empty()) &#123; int top = q.front(); q.pop(); int c = head[top]; while(~c) &#123; if(dis[norm][e[c].to] &gt; dis[norm][top]+1) &#123; dis[norm][e[c].to] = dis[norm][top]+1; q.push(e[c].to); &#125; c = e[c].next; &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr);// freopen(R&quot;(D:\\shiroha\\Downloads\\nwerc2016testdata.tar\\nwerc2016testdata\\iron_and_coal\\022_one_ore_of_many.in)&quot;,&quot;r&quot;,stdin); cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; init(); dis[norm][1] = 0; for(int i=1;i&lt;=m;++i) cin&gt;&gt;o[i]; for(int i=1;i&lt;=k;++i) cin&gt;&gt;c[i]; for(int i=1;i&lt;=n;++i) &#123; cin&gt;&gt;a; while(a--) cin&gt;&gt;b, addedge(i,b); &#125; BFS(norm); BFS(iron); BFS(coal); int ans = INF; for(int i=1;i&lt;=n;++i) ans = min(ans,dis[norm][i]+dis[iron][i]+dis[coal][i]); if(ans-INF) cout&lt;&lt;ans&lt;&lt;endl; else cout&lt;&lt;cannot&lt;&lt;endl; return 0;&#125; 特别需要注意的地方也就是我代码里注释提到的地方：因为最终我们会把三个值加起来，INF就算开了0x3f3f3f3f，加起来也是会暴毙的。所以应该采用一个更小的INF。我的代码种使用0x1f1f1f1f就可以通过了。啊理论上你开long long或者是开unsigned int都是可以的。 A – Arranging Hat 血麻烦、代码极其难写的一个题目。虽然很快的有了思路但是代码不知道写了多久…… 题目大意 会输入一列n数字，每个数字有m位，且包含前缀0；你可以花费1并且改动任何一个数字的任何一位的数字；问最少需要改动多少次才能将原数列改成一个升序的数列，并且输出任何一个结果； 也就是说给一写字符串型的数字，输出一个符合字典序的新序列，它花费了最少的费用。 分析 这题有两种思路。一种是显而易见但是难写的二维DP，另一种是不那么显而易见但是同样难写的递归。两种做法官方的题解里都有提到。 有一个需要注意到的事情：因为n的上限是不超过100的。最坏情况下我们只需要把整个序列的数字的前两位的数字改成递增的，就可以保证整个数列是递增的。也就是说改动次数的上限是2n。如果只是输出一个数值的话似乎只需要看一下前几位就可以了，但是因为还要输出任何一种方案，所以代码瞬间变得难写了起来。（不过似乎本来也就不是多少好写） 在开始前我先翻译一下官方的题解： 解法一： 递归 对于所有数量X，将前X个数字将第一个数字修改位0 现在，原问题被拆解为两个规模更小的子问题 对于前X个数字，处理他们除了第一位的部分 对于接下来的数字，修改第一位成为 ≥0 的数字 查找序列的每一个子区间，每一个起始索引和数字 利用记忆化搜索，可以控制时间复杂度在 O(N³·M) 不要使用缓慢的Python递归，会死的！ 解法一是比较的直观的一种方法。维护这个序列字典序可以简单的划分为这几部： 将前X个数的第一位改成0；并且保证前X个数除了第一位的部分是有序的 将剩下的数字的第一位改成大于0的某个数，并且保证它们是有序的 尾递归是当区间、数字、数位无效或者必然有序（比如只有一个）时返回。但是因为我们没有什么好的办法方便的确定这个X的具体的值，所以就需要尝试所有的X。当更优的时候更新分页标签（split数组存储的就是对于每一个子问题的最优划分位置X），就可以在找到最小费用的桶式得到一种具体的方案。 解法二： 动态规划 首先我们把一个数字字符串看成一个整体 令dp[i,j]是我们对前i个数字修改j次可以得到的最小的第i数字 对于每一种状态，尝试修改第i+1个数字 从现有的状态贪心地在O(M)的时间内得到最小的数字 如果转移得到的数字比原状态大，该次转移有效 这样的状态复杂度是O(N²·M)，转移的复杂度是O(M²) 但是可以推导出答案的复杂度不会大于O(N·log₁₀N) 所以最终实际复杂度是：状态O(N²·log₁₀N)，转移O(N·log₁₀N·M) 网上的题解多半也是这样做的，这也确实更加符合一般的思维。只是代码会比较的难写。在之前已经说到了改动次数是由上限的，所以可以用在这里。而且因为dp数组最终的推导值并不是我们需要的答案，所以还要开数组记录一下前缀状态用来还原答案。 另一个麻烦的地方就是有效转移和无效转移：定义上有效转移是转移结果符合字典序的转移。显然对于无效转移，已经没有再推导下去的必要了。所以只要基于有效转移进行有效转移，就可以推导出答案了。虽然基于状态构造有效转移也是一件麻烦事。 我的代码 首先是递归的代码：因为写的时候没少出事，所以注释也都详细的写了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#define toChar(x) (&#x27;0&#x27; + x)#define cur [st][ed][pos][x] // 当前函数处理的位置using namespace std;typedef long long longs;typedef long double longd;typedef unsigned long long ulong;const int N = 45;const int M = 405;const int INF = 0x3f3f3f3f;int n,m;char s[N][M];int best[N][N][M][10]; // 最优修改次数，初值INFint split[N][N][M][10]; // 修改标签，初值是0int recurse(int st, int ed, int pos, int x) // 将第[st,ed)个数字的第pos位改为x后，生成有效答案的最少步数&#123; if (pos &gt;= m || st == ed) return 0; // 参数无效：无贡献 if (x &gt;= 10) return INF; // 不可能的情况：返回INF int &amp; that = best cur; if (that &lt; INF) return that; // 记忆化搜索 int cost = 0; for (int k = st; k &lt;= ed; ++k) // 尝试修改区间内所有分界点为 x &#123; int now = cost // 当前的费用 = 修改当前位的费用 + 维护两个区间的有效性的费用 + recurse(st, k, pos+1, 0) + recurse(k, ed, pos, x+1); if (now &lt; that) // 更新最小费用和分界标签 &#123; split cur = k; that = now; &#125; if (k &lt; ed) cost += (s[k][pos] != toChar(x)); // 这次的修改在区间内且是有效更改，累加步数 &#125; return that;&#125;void remake(int st, int ed, int pos, int x) // 利用split还原最优方案，以修改原数组 &#123; if (x &gt;= 10 || pos &gt;= m || st == ed) // 无效参数 return; int &amp; val = split cur; for (int i = st; i &lt; val; ++ i) s[i][pos] = toChar(x); // 根据标签的指示修改 remake(st, val, pos+1, 0); remake(val, ed, pos, x+1);&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); cin&gt;&gt;n&gt;&gt;m; for (int i=0;i&lt;n;++i) cin&gt;&gt;s[i]; memset(best,0x3f,sizeof(best)); cerr&lt;&lt;&quot;COST: &quot;&lt;&lt;recurse(0,n,0,0)&lt;&lt;endl; // cerr输出最优步数 remake(0,n,0,0); for (int i=0;i&lt;n;++i) cout&lt;&lt;s[i]&lt;&lt;endl; return 0;&#125; 首先，一个答案是可以通过一个方案来导出来的。所以先寻找更优的方案存储起来，这样最终利用存储的方案就可以得到最优解。寻找最优解需要尝试，每次尝试修改时更新最优方案的存储。代码中利用了尝试函数recurse完成了尝试和记录的工作。 对于尝试函数，整列数字分为三个部分：前X个数字的第一位，前X个数字的剩余部分（子问题1），后面的数字（子问题2）。每次都尝试修改第一部分，并统计这些修改中的有效修改（显然，0→0并不是有效的修改），最后递归统计剩余两部分的消费，就可以找到最小的修改次数和修改方案。使用数组split存储在这个参数的状态下最优的X。最后利用它还原修改的结果就可以了。 因为这种递归是可能出现多种相同的状态的。而因为这个函数的结果只会和状态相关，所以可以使用记忆化搜索来减少这部分不必要的开支。 然后是二维DP的代码，这是我在赛场上写的：所以没什么注释，我简单的补了一些 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 45, M = 405;const int N2 = N&lt;&lt;1;int n, m;char in[N][M];char tmp[M]; // findNext的返回值char dp[N][N2][M];bool flag[N][N2]; // 转移是否有效int pre[N][N2]; // 前导状态表char* ans[N];/** * 当前dp值now，下一个原数字Next，长度为m，k次修改机会 * 能否构造出有效转移；能则将转移结果存入tmp */bool findNext(char *now, char *Next, int m, int k)&#123; int num = k, pos; strcpy(tmp, Next); if(!k) // 无修改次数 return strcmp(tmp, now) &gt;= 0; // 下一个数有效则找到 for(pos = 0; pos &lt; m &amp;&amp; num &gt; 0; ++pos) if(tmp[pos] != now[pos]) &#123; tmp[pos] = now[pos]; // 贪心修改高位 --num; &#125; if(strcmp(tmp, now) &gt;= 0) return true; // 若未返回，说明未修改部分[pos,m]不够大 for(--pos; pos &gt;= 0 &amp;&amp; now[pos] == &#x27;9&#x27;;) --pos; // 找到可以修改的高位部分中最低的一位 if(pos &lt; 0) // 如果不可能将已修改的位改的更大，就不可能 return false; num = k; strcpy(tmp, Next); // 重新开始 for(int i = 0; i &lt; pos; ++i) &#123; if(tmp[i] != now[i]) &#123; tmp[i] = now[i]; --num; &#125; &#125; if(tmp[pos] != now[pos] + 1) // 尝试可修改的最低位改为+1 &#123; tmp[pos] = now[pos] + 1; --num; &#125; for(++pos; pos &lt; m &amp;&amp; num &gt; 0; ++pos) &#123; if(tmp[pos] != &#x27;0&#x27;) // 用尽所有的修改次数尽可能减小答案 &#123; tmp[pos] = &#x27;0&#x27;; --num; &#125; &#125; return true; // 这样的修改一定是有效的&#125;inline void init()&#123; memset(flag, false, sizeof(flag)); for(int i = 0; i &lt; m; ++i) dp[0][0][i] = &#x27;0&#x27;; dp[0][0][m] = &#x27;\\0&#x27;; flag[0][0] = true;&#125;int main()&#123; scanf(&quot;%d%d%*c&quot;, &amp;n, &amp;m); const int n2 = n &lt;&lt; 1; for(int i = 1; i &lt;= n; ++i) scanf(&quot;%s&quot;, in[i]); init(); for(int i = 0; i &lt; n; ++i) for(int j = 0; j &lt; n2; ++j) &#123; if(!flag[i][j]) continue; // 跳过无效状态 for(int k = 0; k &lt;= m &amp;&amp; j + k &lt; n2; ++k) // 尝试所有可能的转移 &#123; if(findNext(dp[i][j], in[i + 1], m, k) &amp;&amp; ( !flag[i + 1][j + k] || strcmp(tmp, dp[i + 1][j + k]) &lt; 0 // 找到有效的转移 )) &#123; flag[i + 1][j + k] = true; strcpy(dp[i+1][j+k], tmp); pre[i+1][j+k] = j; // 做标记，存储字符串，记录前导 &#125; &#125; &#125; int ptr; for(ptr = 0; ptr &lt; n2; ++ptr) if(flag[n][ptr]) break; // 找到次数最少的有效转移 cerr&lt;&lt;&quot;COST: &quot;&lt;&lt;ptr&lt;&lt;endl; for(int i = n; i &gt; 0; ptr = pre[i][ptr], --i) ans[i] = dp[i][ptr]; for(int i = 1; i &lt;= n; ++i) puts(ans[i]); return 0;&#125; 这里主要来说一下最麻烦的构造有效转移，也就是findNext函数（也是我不知道写暴毙多少次的一个地方）。这里我们使用贪心的策略：尽可能的修改高位，并且尽可能的让高位小，同时也要保证字典序。这样，对于每一位数字只有两种可能： 因为从高位向低位修改，每次修改都按照上面的规则，所以可以认为前半部分是一致的。 这一位的后面部分足够给力，比前一个数字的同位部分大；那么这一位只需和前一个数字的这一位一样就行； 否则，这一位必须领头，修改成比前一个数字同位的数字大一；且这一定是最后一次修改。 简单的说，就是要不改成和前一个数字同位值相等，要不改成大1；因为尽可能构造小的满足字典序的数字，所以大1的这次修改一定只会出现在最后一次。……不仅说起来绕口，写起来也很麻烦。我采用的方法是这样的： 首先贪心的用完所有次数，从高位向低位修改：一律改成和同位值相等 如果这样已经满足了字典序，那必然是最小的有效转移 否则，向高位遍历，寻找可以再大1的位置；它可以不是刚才已经修改过的位置，因为它一定比最后一次贪心修改的位置靠前 重新修改，将找到的这一位之前所有数字改成相等，这一位改成大1. 此时字典序可以保证 若还有未用尽的次数，可以贪心地修改这一位后的高位来尽可能降低返回值 这样就完成了基于有效状态的有效转移的构造。再将构造结果传给DP用来进行状态转移即可。 J – Jupiter Orbiter 这是一个好题目，但是不难做。标准解法是最大流问题，但是可以简单的贪心出答案。不过俗话说得好，最大流不过是套在网络流模型上的贪心罢了，从这题来看就非常的正确。 题目大意 一个探测器有s个传感器和q个FIFO的存储卡。这些存储卡有一定的容量；每个传感器都会将它收集到的数据存储到属于该传感器的唯一的存储卡中；现在这台探测仪要进行n轮探测，每次探测过程分为收集阶段和传输阶段；收集阶段每个传感器都会收集到ai的数据存储到它的存储卡中；传输阶段可以将总量不超过d的信息从存储卡发送回地球。告诉你上面的这些所有的量，问你会不会有数据因为装不进存储卡而丢失。 换句话说，就是有Q和容量为C的FIFO队列，有n个从这些队列中删除数据的机会，且每次最多的删除总量为d。并且每次删除前队列都会获得a的数据，但是存不下的部分会丢失。请问能不能做到在最后一次删除数据之后，所有的队列为空。 分析 我的队友并没有考虑的很复杂。虽然说是先接受数据在传输数据，但是这题并不一定这样做：我们可以先接受数据，静等下一轮的情况，然后选择性的传输容量最紧缺的地方的数据。倒是也可以顺风顺水的做出来。但是还是先说比较常规的网络流做法： 说之前依然先看题解： 解法一： 网络流最大流 将本题根据网络流模型建模 确认最大流是否和产生的数据总量相等 M7DIIU_S_T_A_@GL0OPWR@4.png ↑建模大概是这样的↑ 题解说的非常简单，然后给了一个图。我自己又根据第一组测试样例画了一个： WD2Z4_Y_WS_3SWFKF~3_P.png 简单的总结一下我自己的建模方法，和题解画图略有不同但是本质是一样的；大概就是这样： 对于每一轮的探测，将每个传感器和队列都建立一个节点；对于每次传输数据也建立一个节点 从原点出发，向每轮的所有传感器连边，容量是它们这一轮获得的数据数量 对于每一轮的每个传感器，向它对应的本轮的队列连边，容量是队列的流量 从本轮的队列节点出发，向本轮的传输节点连边，容量是无限大；向可能存在的下一轮的对应探测器连边，容量是无限大 对于所有的传输数据节点，则可以向汇点连边，容量是本轮可以发送数据量的最大值 完成了这样的建模，就可以套板子来一遍最大流，轻松而愉快的解出这个题目了。 此外，题解也提供了贪心的做法： 解法二： 模拟贪心 模拟接受数据的全过程 只要队列满了，就记录多出去的部分：这是必须要在上一轮处理掉的数据 再模拟一次数据接受的全过程 使用第一轮得到的经验进行数据处理：处理不了时就失败了 因为要尽可能避免失败，所以要尽早的回避记录的限制 可以在排序后的记录表的指导下贪婪的传输数据 感觉有点怪怪的…… 不知道是我翻译的问题还是思维上的不同。但是总体的指导思想就是在知道下一轮的情况下科学安排本轮数据传输的侧重点。这其实并不需要扫两遍模拟，一次模拟就可以实现目的。我简单介绍下我的队友实现的思路： 对于每一轮的数据：如果可以完全传输，那么就今日事今日毕，清空队列 对于任何一组数据：如果当局获得的数据总量比容量大，那必然是会丢失数据 如果本轮数据不能完全传输，那就先不处理；可传输容量带到下一轮 模拟接受下一轮的数据时，如果有的队列溢出了，那这部分就是上一轮必须要处理的部分 如果最后一轮结束时队列仍然不能清零，那么失败；否则成功 应该还是非常清晰的，具体可以看我的代码。 我的代码 因为我想要偷懒，所以就先把比赛时候的代码搬上来了。这个代码并没有使用最大流： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long longs;typedef long double longd;typedef unsigned long long ulong;const char can[] = &quot;possible&quot;;const char cannot[] = &quot;impossible&quot;;const int N = 35;const int M = 105;int n,q,s;int uq[M], c[N];int d, a;int tmp[N];bool state = true;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); longs todo = 0; longs cando = 0; cin&gt;&gt;n&gt;&gt;q&gt;&gt;s; for(int i=1;i&lt;=s;++i) cin&gt;&gt;uq[i]; for(int i=1;i&lt;=q;++i) cin&gt;&gt;c[i]; for(int i=1;i&lt;=n;++i) &#123; cin&gt;&gt;d; // 本回合的资金 for(int j=1;j&lt;=s;++j) &#123; cin&gt;&gt;a; if(a &gt; c[uq[j]]) state = false; // 不可能装下：直接暴毙 tmp[uq[j]] += a; if(tmp[uq[j]] &gt; c[uq[j]]) // 用上回合的资金处理危险部分 &#123; cando -= tmp[uq[j]] - c[uq[j]]; if(cando &lt; 0) state = false; tmp[uq[j]] = c[uq[j]]; &#125; if(!state) break; &#125; if(!state) break; cando += d; // 使用本回合资金 todo = 0; for(int i=1;i&lt;=q;++i) todo += tmp[i]; if(todo &lt;= cando) // 可以全部处理完：清零 &#123; cando = todo = 0; memset(tmp,0,sizeof(int)*(q+1)); &#125; // 否则看下回合情况 &#125; if(todo &gt; cando) state = false; if(state) cout&lt;&lt;can&lt;&lt;endl; else cout&lt;&lt;cannot&lt;&lt;endl; return 0;&#125; 思路就是上面分析里提到的那样，简单解决。 K – Kiwi Trees 计算几何的题目。因为没有板子（理由！）和忘掉了很多非常非常基础的几何知识最后没有做出来。但是其实是一个比较好写的题目，不会写属实有些吃亏。 题目大意 隔壁老王有一个形状是简单多边形的院子。这个多边形有一些特点：每条边的长度大于30m；任何的一个角的大小在18°~144°之间，但是不保证多边形是凸多边形；现在老王想在这个院子里种两棵一模一样的果树，于是它买来了两棵树。老板告诉他这两棵树长大了之后会占用以种树点为圆心的，半径为3.999m的圆的区域；而且两棵树如果树冠长在一起是NG的。种的时候邻居也来抗议，称如果老王的树冠长出了他自家的院子，他们就向居委会举报。问老王应该把这两棵树中在哪里才能避免树的死亡以及居委会的整改？ 换句话说，就是告诉你一个有点特殊的多边形，能不能在这个多边形内摆两个不相交的圆。能的话就算出两个圆心坐标。 特别提示：输入的多边形的顶点对于多边形而言是顺时针的。 分析 因为这个多边形的边有保底长度，所以不用想太多：就算是一个极端的情况下，一般来说一个凸角塞一个圆就没什么问题了。塞完之后再遍历所有可以塞的地方，找到一对满足要求的输出就可以了。 但是实现的时候要更加的注意细节。因为即使你将这个圆塞进了某个凸角里，它仍然有可能和一切不是这个角的边相交。所以为了保险起见还要扫一遍所有的边判断确保没有这种情况的发生。 然后就是具体实现了。有了几何板子和几何知识就是顺理成章的事情。但是为了照顾一下没有这些东西的看客比如我，这里简单的进行一下知识的科普。如果之后有时间的话会整理专题的： 二维向量叉乘的作用： - 求两个向量的夹角，因为可以由定义式求出sinθ - 求两个向量为两条边形成的平行四边形的面积 - 在顺/逆时针下判断多边形角的凹凸性 比如对于顺时针多边形，叉乘为正的时候，这个角是一个凹角 高等数学白学力（大悲） 然后题目给了一个官方题解。大体类似但是也有不同，姑且给翻译了一波： 任何大于四个顶点的简单多边形至少会有两个凸角 由题意可知，多边形的角度是18~144度，边长至少30m 这样的一个凸角割成三角形，一定能容纳一个半径不超过4.008m的圆 特判：当输入是一个三角形的时候，可以直接判定不可以 怎么说呢，这样做的话题目的代码大概会变的更加地好写。数学论证凸角一定可以塞下，然后只需要随便找两个凸角算一下圆心就可以了——这个也可以通过角平分线算出来。但是关于三角形的特判我是不太苟同：因为如果三角形的边足够大，它还是可以塞下符合标准的两个圆的。所以我觉得这一步还是应该进行尝试。 我的代码 因为没有板子，所以补题的时候基本计算的板子抄了校队另一个同学的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;#include &lt;vector&gt;#define THIS (*this)using namespace std;typedef long long longs;typedef long double longd;typedef unsigned long long ulong;class point&#123;public: longd x, y; point operator +(const point&amp; rhs) const; point operator -(const point&amp; rhs) const; longd operator *(const point&amp; rhs) const; // 点乘 point operator *(longd rhs) const; // 数乘 point operator *(double rhs) const; point&amp; operator +=(const point&amp; rhs); point&amp; operator -=(const point&amp; rhs); point&amp; operator *=(longd rhs); point&amp; operator *=(double rhs); longd cross(const point&amp; rhs) const; // 叉乘模：平行四边形面积 longd length() const; // 向量的模 point normal() const; // 单位化向量 longd distance(const point&amp; b) const; // 到某点的距离 longd distance(const point&amp; ls,const point&amp; rs) const; // 到直线ls-rs的距离 void println(); // 一行输出坐标&#125;;const int R = 4000;const double r = 4000;const double eps = 1e-3;const double r2 = 2*r - eps;const int N = 2060;int n;point p[N];vector&lt;point&gt; v;point calculate(point a,point b)&#123; a = a.normal(); b = b.normal(); longd angle = acos(a*b) / 2; // 计算夹角的1/2 point k = (a+b).normal(); // 角平分线的单位向量 return k * (R / sin(angle)); // 返回满足垂直距离≥R的相对坐标&#125;bool intersect(point&amp; x,point&amp; ls,point&amp; rs) // 相交（距离不足）返回false&#123; if ((ls-x)*(rs-ls) &gt; 0) return x.distance(ls) &gt;= r-eps; // x在ls的远端 if ((rs-x)*(ls-rs) &gt; 0) return x.distance(rs) &gt;= r-eps; return x.distance(ls,rs) &gt;= r-eps; // x在直线ls-rs的正上方&#125;bool test(point&amp; x) // 遍历检查点到所有边的距离&#123; for (int i = 1; i &lt;= n; ++ i) if (!intersect(x,p[i-1],p[i])) return false; return true;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); cin&gt;&gt;n; for (int i = 1; i &lt;= n; ++ i) cin &gt;&gt; p[i].x &gt;&gt; p[i].y; p[0] = p[n]; p[n+1] = p[1]; for (int i = 1; i &lt;= n; ++ i) &#123; if ((p[i]-p[i-1]).cross(p[i+1]-p[i]) &gt; 0) // 跳过多边形的凹角 continue; auto tmp = p[i] + calculate(p[i-1]-p[i],p[i+1]-p[i]); // 得到绝对位置 if (test(tmp)) v.push_back(tmp); &#125; bool found = false; for (auto&amp; p1 : v) for (auto&amp; p2 : v) if (p1.distance(p2) &gt;= r2) // 判断两个点之间的距离 &#123; cout&lt;&lt;fixed&lt;&lt;setprecision(10); p1.println(); p2.println(); found = true; goto END; &#125; END: if(!found) cout&lt;&lt;&quot;impossible&quot;&lt;&lt;endl; return 0;&#125;point point::operator +(const point&amp; rhs) const &#123;return (point)&#123;x + rhs.x, y + rhs.y&#125;;&#125;point point::operator -(const point&amp; rhs) const &#123;return (point)&#123;x - rhs.x, y - rhs.y&#125;;&#125;longd point::operator *(const point&amp; rhs) const &#123;return x * rhs.x + y * rhs.y;&#125;point point::operator *(const longd rhs) const &#123;return (point)&#123;rhs * x, rhs * y&#125;;&#125;point point::operator *(const double rhs) const &#123;return (point)&#123;rhs * x, rhs * y&#125;;&#125;point&amp; point::operator +=(const point&amp; rhs) &#123;x += rhs.x; y += rhs.y; return THIS;&#125;point&amp; point::operator -=(const point&amp; rhs) &#123;x -= rhs.x; y -= rhs.y; return THIS;&#125;point&amp; point::operator *=(longd rhs) &#123;x *= rhs; y *= rhs; return THIS;&#125;point&amp; point::operator *=(double rhs) &#123;x *= rhs; y *= rhs; return THIS;&#125;longd point::cross(const point&amp; rhs) const &#123;return rhs.y * x - rhs.x * y;&#125;longd point::length() const &#123;return sqrtl(THIS*THIS);&#125;point point::normal() const&#123; longd l = this-&gt;length(); return (point)&#123;x/l,y/l&#125;;&#125;longd point::distance(const point&amp; b) const &#123;return (THIS-b).length();&#125;longd point::distance(const point&amp; ls,const point&amp; rs) const&#123; return fabsl((ls-THIS).cross(rs-THIS))/ls.distance(rs);&#125;void point::println() &#123;cout &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; y &lt;&lt; endl;&#125; 想清楚了，套板子出答案也是相对简单的事情；不过就是要想清楚才行。实际赛场上A了这个题目的两支队伍都吃了那么两三发罚时才A的，这个和事后套板子应该还是有很大的差距吧。有一个可能要注意的地方就是：在把圆塞进某个具体的角的时候也要去判断它和其他边的情况——而判断这个实际上还要分情况讨论。细节就是有点多啊== B – British Menu 一个比较典型的SCC缩点+DAGdp的题目。如果有板子并且打的比较熟练的话应该能很快的做出来吧，但是可惜我两者都不是。 题目大意 你去英国旅行，想吃英国菜，但是酒店只给了你一张自助餐餐券；所以你打算今晚往死里吃，尽可能多吃几种菜。但是有的菜连着吃可能会出问题比如温两碗酒，要一份头孢，但是如果把它们分开吃就没毛病。旅游指南告诉了你你可以在吃完一种菜之后吃哪些菜，但是这样的话就难免重复：你发现如果有一种菜可以吃两次，那么它们之间一定不会有超过四种的不同的菜。但是你并不想吃两次一样的菜，所以今晚你应该怎么吃，才能尽可能多的吃到不同的菜？ 换句话说，就是给你一个有向图，途中的每个环最多包含五个不同的节点。然后你要计算出图中不经过相同节点的最长路。 特别提示：这道题的时空限制是10000ms，512MB。 分析 有向有环图，它有环；求最长路，一般要求无环图。怎么样才能做这个题目？有环缩环成点不就有无环图了嘛。怎么缩点呢？那必然是Tarjan法。因为还要求最长路，所以要求出每个SCC内的路的长度——反正最多五个点，怎么玩都行。至于缩成的DAG可以怎么求最长路？拓扑排序啊！……才不是咧，SCC缩成的点可不能和一般的点等量齐观，所以需要DAGdp。那这个题目大概的思路就有了。 然后就是抄板子→手抖抄错了→WA了然后肉眼扫描→……的死循环（悲） 官方依然给了题解，所以还是翻译一下： 这个问题一般来说是 NP-complete 的。但是这个问题可通过在DAG中使用DP，在O(n+m)的时间内求解 由题意可得，图中的每个SCC最多只有五个节点 所以可以暴力地求出每个SCC内任何两个顶点之间的最长路。O(n!)已经够快了 将所有的SCC缩成一个点 现在图变成DAG了，可以DP；需要读取刚才对每个SCC计算的最长路。 大概写代码实现的思路就是这样。因为给了10s，这个算法基本上只要敲对了都能过。 我的代码 真正的模板题，事后重写也差不多要了我的老命，是时候准备一份优秀的板子了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#define same(u,v) (sccId[u]==sccId[v])#define cleanDis() memset(dis,0,sizeof dis)#define V e[c].tousing namespace std;typedef vector&lt;int&gt; arrays;struct edge &#123;int to,next;&#125;;const int N = 1e5 + 5;const int M = 1e6 + 5;int n,m;namespace FrontStar&#123; int head[N]; edge e[M]; int tot = -1;&#125;namespace Tarjan&#123; int dfn[N], low[N]; int nextDfn = 1; bool instack[N]; stack&lt;int&gt; s;&#125;namespace SCCcomponent&#123; int cnt; int sccId[N]; // 顶点属于的SCC分量 int id[N]; // 顶点在分量内的编号 arrays group[N]; // SCC分量包含的点 int dis[6][6]; bool visit[N]; arrays inEdge[N]; // 分量内的边&#125;namespace DAGgraph&#123; int in[N]; queue&lt;int&gt; q; int tmp[N], dp[N];&#125;inline void init()&#123; using namespace Tarjan; using namespace FrontStar; using namespace SCCcomponent; using namespace DAGgraph; memset(head, -1, sizeof(int) * (n + 1)); memset(dfn,0,sizeof(int)*(n+1)); memset(low,0,sizeof(int)*(n+1)); memset(sccId, 0, sizeof(int) * (n + 1)); memset(id,0,sizeof(int)*(n+1)); memset(tmp,0,sizeof(int)*(n+1)); memset(dp,0,sizeof(int)*(n+1)); memset(in, 0, sizeof(int) * (n + 1)); memset(instack,0,sizeof(bool)*(n+1)); memset(visit,0,sizeof(bool)*(n+1)); tot = -1; cnt = 0; nextDfn = 1;&#125;inline void addedge(int u, int v)&#123; using namespace FrontStar; e[++tot] = &#123;v,head[u]&#125;; head[u] = tot;&#125;void tarjan(int U)&#123; using namespace Tarjan; using namespace SCCcomponent; using namespace FrontStar; dfn[U] = low[U] = nextDfn++; s.push(U); instack[U] = true; int c = head[U]; while (~c) &#123; if (!dfn[V]) &#123; tarjan(V); low[U] = min(low[U], low[V]); &#125; else if (instack[V]) low[U] = min(low[U], low[V]); c = e[c].next; &#125; if (dfn[U] == low[U]) &#123; int cur, tagId = 0; ++cnt; do &#123; cur = s.top(); s.pop(); instack[cur] = false; sccId[cur] = cnt; group[cnt].push_back(cur); id[cur] = ++tagId; &#125; while (cur != U); &#125;&#125;void dfs(int now, int raw, int length)&#123; using namespace SCCcomponent; dis[id[raw]][id[now]] = max(dis[id[raw]][id[now]], length); visit[now] = true; for (auto that : inEdge[now]) if (!visit[that]) dfs(that, raw, length + 1); visit[now] = false;&#125;inline void topsort()&#123; using namespace DAGgraph; using namespace SCCcomponent; using namespace FrontStar; for (int i=1; i &lt;= cnt; ++i) if (!in[i]) q.push(i); while (!q.empty()) &#123; int now = q.front(); q.pop(); cleanDis(); for (auto node : group[now]) dfs(node,node,0); for (auto i : group[now]) for (auto j : group[now]) tmp[i] = max(tmp[i],dp[j]+dis[id[j]][id[i]]); for (auto node : group[now]) dp[node] = tmp[node]; for (auto U : group[now]) &#123; int c = head[U]; while (~c) &#123; if (!same(U, V)) &#123; dp[V] = max(dp[V], dp[U] + 1); --in[sccId[V]]; if (!in[sccId[V]]) q.push(sccId[V]); &#125; c = e[c].next; &#125; &#125; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); cin&gt;&gt;n&gt;&gt;m; init(); int u,v; while (m--) &#123; cin&gt;&gt;u&gt;&gt;v; addedge(u,v); &#125; using namespace Tarjan; using namespace SCCcomponent; using namespace DAGgraph; using namespace FrontStar; for (int i=1;i&lt;=n;++i) if (!dfn[i]) tarjan(i); cerr &lt;&lt; &quot;SCC component count: &quot; &lt;&lt; cnt &lt;&lt; endl; for (int i=1;i&lt;=n;++i) &#123; int c = FrontStar::head[i]; while (~c) &#123; if (same(i, e[c].to)) inEdge[i].push_back(e[c].to); else ++in[sccId[e[c].to]]; c = e[c].next; &#125; &#125; topsort(); int ans = 0; for (int i=1;i&lt;=n;++i) ans = max(ans,dp[i]); cout&lt;&lt;ans+1&lt;&lt;endl; return 0;&#125; 小 心 全 局 变 量（警觉.jpg） 好像在ACM里，前向星比起开着氧气的vector并没有太大的优势，写起来还容易出错…… 了解，下次还敢== D – Driving in Optimistan 光是读题都读了很久才大概看明白的一个题目，比赛时没有做出来。 意外地，这个题和G题都没有查到好心CSDN博主的解析。 题目大意 奥普提米斯坦国有很多个港口城镇组成；为了省钱，它们只修了能连接所有港口城镇的必要道路，因此从一处到另一处只有一条路；路上每公里都有一个牌子，包含了当前位置到所有城市的最短距离。这个国家的旅游指南上有一张表，记录了任意两个城市之间的最短距离；问能不能通过这些信息，计算出所有的路牌上的数字的平均值。 也就是说，给定一棵树所有叶子节点之间的距离，求出每1公里道路上都会放置的路标上写着的距离的平均数。 分析 贴一下官方题解的翻译： 直接考虑整个树上的所有标志太难了，只考虑叶节点和交叉点 把每个城市作为一个孤立的节点 按照距离排序所有的城市点对 给这两个节点加一个树根，合并两棵子树 对于以r为树根的每个子树T，在以下两种情况下计算穿过r的最短路的平均长度： 两个端点都在子树T内时，记为 Ar² 仅一个端点在子树T内时，记为 Ar¹ 这两个值可以通过r的所有孩子的 A¹ 和它们到r的距离来计算 也就是说是一个树上DP…… 且慢，这种讨论方式，之前是不是做过差不多的题目…… 我的代码 还没呢，写完了就给补上（ G – Gotta Nudge ’Em All 宝可梦GO模拟器一道非常恶毒的题目：恶毒就恶毒在它那巨长的题目以及乱七八糟的规则，光是都题目都能让人觉得恶心的一个题目。校队的朋友应该是没有一个人去尝试这个题目的——我们队也不例外；甚至整个vjudge上只有两年前和三年前有两发AC的提交，当年区域赛似乎也没几个队伍A了这题目…… 直说了，我不想做这个题目== 估计是为了防止阿克的，但是比赛的时候还是有一支队伍阿克了（ 题目大意 这是一个宝可梦GO模拟器：给你若干条宝可梦的进化链；糖果是游戏中的货币：捉一只宝可梦可得3颗糖果，放一只宝可梦可得1颗糖果，糖果和进化链相关。进化宝可梦花费糖果，且进化高级的宝可梦的花费不低于低级宝可梦的花费；捉一只宝可梦可得100经验，进化一只宝可梦可得500经验；开局有一个道具幸运蛋，在使用它后的1800s内获得的经验翻倍；题目规定只在它生效期间内进化宝可梦；现在给你捕捉宝可梦的时间序列，求可以获得经验的最大值。 也就是说，给你一个你抓到宝可梦的时间表，然后求出可以最大化你获得的XP的翻倍道具的使用时刻。 分析 本体最大的难点：英语阅读 别的就不知道啦，刚读完题，还没分析呢// 题解又臭又长也不想翻译== 完事了会贴在这里的 我的代码 还没呢，写完了就给补上（ 后记 一些感想 就比赛而言，如果真的是简单的签到题就快快委托给代码手，早交早仏== 虽然前期开题确实重要，但是真正比赛应该更加的灵活多变一些；虽然最后我们A了8个题（一般是学弟A的，悲），但是前一个小时只签到了一个题目。这是非常的吃亏的== 就写代码而言，主要还是准备板子吧。一个题目有成熟的板子和没有成熟的板子差距还是很大的== 然后就是代码手多辛苦，你不行你就别上（指自己WA了签到题），老老实实叫队友来写。真要是心有不甘课后补题，自己多练练啊（） 就个人而言，写代码能力实在是过于欠缺。下次练习专题也整成私人比赛好了。但是就目前情况来看，三人云练习还是水分很多的，不要被蒙蔽了双眼。 小 心 全 局 变 量 参考资料 http://clatisus.com/NWERC%202016?tdsourcetag=s_pctim_aiomsg","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://shiraha.cn/tags/Codeforces/"},{"name":"Gym","slug":"Gym","permalink":"https://shiraha.cn/tags/Gym/"}]},{"title":"有趣的博客小插件 & 特效","slug":"interesting-blog-plugins-i","date":"2020-03-09T10:11:54.000Z","updated":"2020-03-09T10:11:54.000Z","comments":true,"path":"2020/interesting-blog-plugins-i/","link":"","permalink":"https://shiraha.cn/2020/interesting-blog-plugins-i/","excerpt":"","text":"旋转的图片立方体 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183&lt;style&gt; /*最外层容器样式*/ .wrap &#123; width: 100px; height: 100px; margin: 150px; position: relative; &#125; /*包裹所有容器样式*/ .cube &#123; width: 50px; height: 50px; margin: 0 auto; transform-style: preserve-3d; transform: rotateX(-30deg) rotateY(-80deg); animation: rotate linear 20s infinite; &#125; @-webkit-keyframes rotate &#123; from &#123; transform: rotateX(0deg) rotateY(0deg); &#125; to &#123; transform: rotateX(360deg) rotateY(360deg); &#125; &#125; .cube div &#123; position: absolute; width: 200px; height: 200px; opacity: 0.8; transition: all .4s; &#125; /*定义所有图片样式*/ .pic &#123; width: 200px; height: 200px; &#125; .cube .out_front &#123; transform: rotateY(0deg) translateZ(100px); &#125; .cube .out_back &#123; transform: translateZ(-100px) rotateY(180deg); &#125; .cube .out_left &#123; transform: rotateY(-90deg) translateZ(100px); &#125; .cube .out_right &#123; transform: rotateY(90deg) translateZ(100px); &#125; .cube .out_top &#123; transform: rotateX(90deg) translateZ(100px); &#125; .cube .out_bottom &#123; transform: rotateX(-90deg) translateZ(100px); &#125; /*定义小正方体样式*/ .cube span &#123; display: block; width: 100px; height: 100px; position: absolute; top: 50px; left: 50px; &#125; .cube .in_pic &#123; width: 100px; height: 100px; &#125; .cube .in_front &#123; transform: rotateY(0deg) translateZ(50px); &#125; .cube .in_back &#123; transform: translateZ(-50px) rotateY(180deg); &#125; .cube .in_left &#123; transform: rotateY(-90deg) translateZ(50px); &#125; .cube .in_right &#123; transform: rotateY(90deg) translateZ(50px); &#125; .cube .in_top &#123; transform: rotateX(90deg) translateZ(50px); &#125; .cube .in_bottom &#123; transform: rotateX(-90deg) translateZ(50px); &#125; /*鼠标移入后样式*/ .cube:hover .out_front &#123; transform: rotateY(0deg) translateZ(200px); &#125; .cube:hover .out_back &#123; transform: translateZ(-200px) rotateY(180deg); &#125; .cube:hover .out_left &#123; transform: rotateY(-90deg) translateZ(200px); &#125; .cube:hover .out_right &#123; transform: rotateY(90deg) translateZ(200px); &#125; .cube:hover .out_top &#123; transform: rotateX(90deg) translateZ(200px); &#125; .cube:hover .out_bottom &#123; transform: rotateX(-90deg) translateZ(200px); &#125; &lt;/style&gt; &lt;!-- 外层最大容器 --&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;!--包裹所有元素的容器--&gt; &lt;div class=&quot;cube&quot;&gt; &lt;!--前面图片 --&gt; &lt;div class=&quot;out_front&quot;&gt; &lt;img src=&quot;https://i.loli.net/2018/05/03/5aeb0eef73838.jpg&quot; class=&quot;pic&quot;&gt; &lt;/div&gt; &lt;!--后面图片 --&gt; &lt;div class=&quot;out_back&quot;&gt; &lt;img src=&quot;https://i.loli.net/2018/05/03/5aeb0f2fb9a83.jpg&quot; class=&quot;pic&quot;&gt; &lt;/div&gt; &lt;!--左面图片 --&gt; &lt;div class=&quot;out_left&quot;&gt; &lt;img src=&quot;https://i.loli.net/2018/05/03/5aeb0f55411f0.jpg&quot; class=&quot;pic&quot;&gt; &lt;/div&gt; &lt;!--右面图片 --&gt; &lt;div class=&quot;out_right&quot;&gt; &lt;img src=&quot;https://i.loli.net/2018/05/03/5aeb0f79a1124.jpg&quot; class=&quot;pic&quot;&gt; &lt;/div&gt; &lt;!--上面图片 --&gt; &lt;div class=&quot;out_top&quot;&gt; &lt;img src=&quot;https://i.loli.net/2018/05/03/5aeb0f98a8b66.jpg&quot; class=&quot;pic&quot;&gt; &lt;/div&gt; &lt;!--下面图片 --&gt; &lt;div class=&quot;out_bottom&quot;&gt; &lt;img src=&quot;https://i.loli.net/2018/05/03/5aeb0fdd51b7e.jpg&quot; class=&quot;pic&quot;&gt; &lt;/div&gt; &lt;!--小正方体 --&gt; &lt;span class=&quot;in_front&quot;&gt; &lt;img src=&quot;https://i.loli.net/2018/05/03/5aeb100223dd0.jpg&quot; class=&quot;in_pic&quot;&gt; &lt;/span&gt; &lt;span class=&quot;in_back&quot;&gt; &lt;img src=&quot;https://i.loli.net/2018/05/03/5aeb101c2c24b.jpg&quot; class=&quot;in_pic&quot;&gt; &lt;/span&gt; &lt;span class=&quot;in_left&quot;&gt; &lt;img src=&quot;https://i.loli.net/2018/05/03/5aeb1038127b5.jpg&quot; class=&quot;in_pic&quot;&gt; &lt;/span&gt; &lt;span class=&quot;in_right&quot;&gt; &lt;img src=&quot;https://i.loli.net/2018/05/03/5aeb0dce1ca55.jpg&quot; class=&quot;in_pic&quot;&gt; &lt;/span&gt; &lt;span class=&quot;in_top&quot;&gt; &lt;img src=&quot;https://i.loli.net/2018/05/03/5aeb1057bb167.jpg&quot; class=&quot;in_pic&quot;&gt; &lt;/span&gt; &lt;span class=&quot;in_bottom&quot;&gt; &lt;img src=&quot;https://i.loli.net/2018/05/03/5aeb107514579.jpg&quot; class=&quot;in_pic&quot;&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt;","categories":[{"name":"有趣的东西","slug":"有趣的东西","permalink":"https://shiraha.cn/categories/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%B8%9C%E8%A5%BF/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://shiraha.cn/tags/hexo/"},{"name":"个性化","slug":"个性化","permalink":"https://shiraha.cn/tags/%E4%B8%AA%E6%80%A7%E5%8C%96/"}]},{"title":"基础知识：单调栈","slug":"The-concept-of-monotonous-stack","date":"2020-02-28T06:41:37.000Z","updated":"2020-02-28T06:41:37.000Z","comments":true,"path":"2020/The-concept-of-monotonous-stack/","link":"","permalink":"https://shiraha.cn/2020/The-concept-of-monotonous-stack/","excerpt":"","text":"练习题 LeetCode - 柱状图中的最大矩形 题目地址：https://leetcode-cn.com/problems/largest-rectangle-in-histogram/ 12345678910111213141516171819202122232425262728class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; stack&lt;int&gt; s; const int n = heights.size(); int *L = new int[n+1]&#123;0&#125;; int *R = new int[n+1]&#123;0&#125;; for(int i = 0;i &lt; n;++i) &#123; while(s.size() &amp;&amp; heights[s.top()] &gt; heights[i]) &#123; R[s.top()] = i; s.pop(); &#125; if(s.empty()) L[i] = -1; else L[i] = s.top(); s.push(i); &#125; while(!s.empty()) &#123; R[s.top()] = n; s.pop(); &#125; int ans = 0, tmp; for(int i = 0;i &lt; n;++i) &#123; tmp = heights[i]*(R[i]-L[i]-1); if(tmp &gt; ans) ans = tmp; &#125; return ans; &#125;&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#define npos (n+1)using namespace std;typedef long long longs;const int N = 1e5+5;int h[N],l[N],r[N];longs ans;inline void pop(stack&lt;int&gt; &amp;s, int i)&#123; r[s.top()] = i; s.pop();&#125;inline void push(stack&lt;int&gt; &amp;s, int i, int a[])&#123; while(s.size()&amp;&amp;a[s.top()]&gt;a[i])pop(s,i); if(s.empty()) l[i] = 0; else l[i] = s.top(); s.push(i);&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n; while(cin&gt;&gt;n&amp;&amp;n) &#123; stack&lt;int&gt; s; ans = 0; for(int i=1;i&lt;=n;++i) &#123; cin&gt;&gt;h[i]; push(s,i,h); &#125; while(!s.empty()) pop(s,npos); for(int i=1;i&lt;=n;++i) ans = max(ans,(longs)h[i]*(r[i]-l[i]-1)); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 洛谷 P4147 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;using namespace std;typedef long long longs;struct item&#123;int w,h;&#125;; // w是宽度，h是高度const int N = 1050;int n,m;char in;int tmph[N]&#123;0&#125;; // 可维持的最好高度int ans = 0;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); stack&lt;item&gt; s; // 严格递减的单调栈 cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=m;++j) &#123; cin&gt;&gt;in; if(in==&#x27;F&#x27;) ++tmph[j]; else tmph[j] = 0; int tmpw = 0; // 可维持的最好宽度 while(!s.empty()&amp;&amp;s.top().h&gt;=tmph[j]) // 可以延长 &#123; tmpw += s.top().w; // 外延宽度 ans = max(ans,s.top().h*tmpw); s.pop(); &#125; s.push(&#123;tmpw+1,tmph[j]&#125;); // 增加自己的宽度 &#125; int tmpw = 0; while(!s.empty()) // 出来时最好高度是严格递减的，均可外延 &#123; tmpw += s.top().w; ans = max(ans,s.top().h*tmpw); // 反向外延更新答案 s.pop(); &#125; &#125; longs out = 3ll*ans; cout&lt;&lt;out&lt;&lt;endl; return 0;&#125; 补充练习题 参考资料 https://oi-wiki.org/ds/monotonous-stack/ https://www.cnblogs.com/ACMSN/p/10738687.html https://www.cnblogs.com/1024th/p/10778050.html https://blog.csdn.net/lucky52529/article/details/89155694","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://shiraha.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"数据结构","slug":"数据结构","permalink":"https://shiraha.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"Codeforces Round#622 div.2 回顾","slug":"codeforces-round-622-div2","date":"2020-02-27T12:54:02.000Z","updated":"2020-02-27T12:54:02.000Z","comments":true,"path":"2020/codeforces-round-622-div2/","link":"","permalink":"https://shiraha.cn/2020/codeforces-round-622-div2/","excerpt":"","text":"题解 A - Fast Food Restaurant 题目地址：http://codeforces.com/problemset/problem/1313/A 外部链接：您可以选择洛谷来源或者vjudge来源的 Remote Judge。 还是比较简单的一个贪心题。根据题目描述的这个厨师的要求来看，他最多只能为七名客人上不同的菜：就是abc排列组合了。因为优先使用最多的菜式，所以排个序，再单独对七种情况if就可以了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int t,a,b,c; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; int ans = 0; if(a&gt;0)++ans,--a; if(b&gt;0)++ans,--b; if(c&gt;0)++ans,--c; int ar[3] = &#123;a,b,c&#125;; sort(ar,ar+3); if(ar[2]&gt;0&amp;&amp;ar[1]&gt;0) &#123; --ar[2]; --ar[1]; ++ans; &#125; if(ar[2]&gt;0&amp;&amp;ar[0]&gt;0) &#123; --ar[2]; --ar[0]; ++ans; &#125; if(ar[1]&gt;0&amp;&amp;ar[0]&gt;0) &#123; --ar[1]; --ar[0]; ++ans; &#125; a=ar[0];b=ar[1];c=ar[2]; if(a&gt;0&amp;&amp;b&gt;0&amp;&amp;c&gt;0)++ans; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 最开始犹豫了好久应该怎么实现，，早知道最开始就一部排序贪心就好了，毕竟和abc没什么关系啊……嗒哈哈（） B - Different Rules 题目地址：http://codeforces.com/problemset/problem/1313/B 外部链接：您可以选择洛谷来源或者vjudge来源的 Remote Judge。 这题目就很有意思：这就是真正的思维题吗？加了诸多的限制条件导致结论并不是那么的显而易见，倒也极大的增加了这个题目的难度（毕竟这题过的人数比C要少……不过也算不上是毒瘤题吧 首先是题目（啊我就翻译了这一个）： 题目描述 Nikolay最接近开始打算法竞赛了，且获得了一场著名比赛的决赛资格。这次决赛将会有包括Nikolay在内的n个参与者。向其他比赛一样，这场决赛由两轮组成。但是和之前不一样的是，组织者提出了新的规则：假设参赛者A第一轮排名x位，第二轮排名y位，那么参赛者A的总得分是x+y，总排名是总分小于等于A的总分的包括A在内的参赛者的数量。请注意：某些参赛者最后可能会有共同的总体排名。此外，在第一轮和第二轮的比赛中，没有多个参赛者并列的情况（也就是说，对于1~n之间的每个i，每轮比赛中都恰好只有一个人获得第i名）。 比赛结束后，Nikolay直到他在第一轮获得了第x位，第二轮获得了第y位的成绩。Nikolay不知道其他参赛者的成绩，但是他想知道在最坏和最好的情况下，他可以获得的总排名是多少。请帮助Nikolay解决这个问题。 输入格式 第一行包含一个整数t(1≤t≤100)，它是待解决的测试用例数； 在接下来的ttt行内，每行都包含三个整数n，x，y(1≤n ≤10⁹，1≤x，y≤n)，它们分别是这场决赛的参与者人数、Nikolay在第一轮和第二轮中取得的排名。 输出格式 每个测试样例输出两个整数：分别是Nikolay在在这次决赛中可以获得的最高排名和最低排名。 说明/提示 对于第一个测试样例的解释： 设这次比赛的 5 个参与者是 A-E。我们令 Nikolay 为参与者 A。那么对于 Nikolay 来说的最好的情况就是像下表所示的那样： 第一种情况 然而，这场比赛的结果也可能是这样： 第二种情况 在上述第一种情况，Nikolay 可以取得最高排名：第一位；然而在第二种情况中只能获得第三位。 说白了，比起最简单的最好最坏情况的限制条件就是： 没有并列情况的出现（其实降低了难度？） 总得分一致的情况下，玩家的排名尽可能的低 也就是说，最差的排名在尽可能多的人和他分数相等的时候取到：毕竟总分是有限的，相等的分能够压住玩家，就不要多浪费其他的小分数；最好的排名在尽可能多的人比他的分数大一的时候取到，这样也会尽可能不浪费分数来构造大分。 在纸上模拟或者脑内模拟，最终得到的结论就是： x+y&lt;=n时，最优情况是 1，最差情况是 min(x+y-1,n)。 x+y&gt;n时，最优情况是 min(x+y-1,n)，最差情况是 n。 虽然模拟确实也能推导出式子，但是果然还是想要更加科学的解释啊： 最坏情况就是总得分等于x+y的人数：将一个整数k拆成两个整数的和的情况显然是k-1种。但是这个题目有限制：不能相等，要在参赛人数范围内。没事啊，这x+y-1只会比n大不会比n小，限制边界就行了啊（） 最好情况略微麻烦一点。刚才说了：如果我们希望某人排名比玩家低，那么最优做法就是让某人分数为x+y+1。进行一下分类讨论： x+y不比n大：对于任何其他人，若第一轮p位，那么一定可能让他在第二轮排名为x+y+1-p甚至更差，所以此时玩家能得第一。 x+y比n大：这就比较的有意思。比玩家高的人是玩家的阻碍，但比玩家低的人可以成为玩家的助力，应当利用。若某人第一轮p位且比玩家最好水平要好，那么就让他第二轮继续p位，从而忽略他。这样做使得问题的规模缩小，且所有剩下的参赛人的排名绝对值变小（但不影响）——直到问题变成一个上面情况的子问题，玩家在剩下来的部分中得第一名：设已经忽略了t人，那么这样的问题规模缩减的边界是(x-t)+(y-t)=n-t，轻松解出t=x+y-n；剩下的部分中玩家第一，那么玩家名次是t+1=x+y-n+1。 呜呼……就是贪心啊，无他== 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;inline int best(int n, int x, int y)&#123; return min(max(x-n+y+1,1),n);&#125;inline int worst(int n, int x, int y)&#123; return min(max(x+y-1,1),n);&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int t,n,x,y; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;x&gt;&gt;y; cout&lt;&lt;best(n,x,y)&lt;&lt;&#x27; &#x27;&lt;&lt;worst(n,x,y)&lt;&lt;endl; &#125; return 0;&#125; ちくしょう……大家都说就算纸上推导也能画出来为啥我就是模拟不出来啊（） TIM图片20200228100516.png 哦，我知道了，可以在两场比赛中获得相同的排名，是我大意没有仔细看样例导致想复杂了，草。噫呜呜噫，我要回家（） C1 - Skyscrapers (easy version) 题目地址：http://codeforces.com/problemset/problem/1313/C1 外部链接：您可以选择洛谷来源或者vjudge来源的 Remote Judge。 这题后面还有一个困难版本，难就难在n的取值范围变大了好多。这个版本n只有1e3，完全可以n方枚举。显然最终建成的大楼是山包形状的——最高点左侧单调不递减，右侧单调不递增，只是取不同的极大值可能会有不同的结果，找到最大的就好了。 因为数据范围太小的原因，甚至连极大值都不用找：只是枚举最高点然后向两侧走，更新答案就好了（） 代码就不贴了，C2再贴好了。 特别注意，别忘记开long long，这每一栋楼都是1e9，爆int轻而易举。 C2 - Skyscrapers (hard version) 题目地址：http://codeforces.com/problemset/problem/1313/C2 外部链接：您可以选择洛谷来源或者vjudge来源的 Remote Judge。 根据刚才的分析，这个楼最终盖起来的样子一定是中间有一个峰值，然后两侧的高度分别是方向相反发不严格的两个单调序列。根据刚才说的暴力方法，向两侧行走的时候直到遇到比当前楼层高度低的楼层之后，再更新楼层高度。也就是说，假设第 \\(i\\) 个楼是中心的“峰值”，高度为\\(h_i\\)；先考虑它的左侧 $ k&lt;i $ 是左侧第一个高度低于它的楼；另设\\(f_i\\)是\\(i\\)左侧的楼层的高度和的最大值，那么可以得到这样的推导式： \\(f_i = f_k + h_k + h_i \\cdot (i-k-1)\\) 相应的，对于中心楼层\\(i\\)右侧的第一个小于\\(i\\)的楼\\(k&gt;i\\)，令\\(f&#39;_i\\)是\\(i\\)右侧的楼层的高度和的最大值，也可以得到类似的关系： \\(f&#39;_i = f&#39;_k + h_k + h_i \\cdot (k-i-1)\\) 知道了这个表达式之后，我们就能用比C1中的暴力要快得多的方法求出以i作为峰值时的最高高度总和。那么问题就转化成了我们应该怎么样快速地求出序列中i两侧的第一个小于它的高度的楼层。好在这个问题可以使用一个经典的数据结构单调栈来解决。我们先简单的看一下单调栈的定义： 单调栈： 顾名思义，单调栈中存放的数据是单调有序的；根据这个次序调栈也分为单调递增栈和单调递减栈 单调递增栈：数据出栈的序列为单调递增序列 单调递减栈：数据出栈的序列为单调递减序列 特别注意：这里所说的递增递减指的是出栈的顺序，而不是在栈中数据的顺序。 那么，为了维持这个有序性，在push和pop的时候就要检查栈顶元素。根据检查结果还可以方便的构造两个数组 L 和 R，分别储存了当前元素 i 两侧的第一个小于/大于（等于）的元素的序号。这个行为的时间复杂度是 O(n) 的，因为序列中的每一个元素只会入栈一次。 数组 L 和 R 的具体含义取决于检查栈顶元素使用的运算符：例如，如果你使用&gt;作为判定，那么 L 数组就是第一个小于等于 i 的元素，而 R 数组是第一个小于 i 的元素。应该注意到两个数组的严格单调性不一致。 那么问题就变得简单了起来，我们只需要使用 O(n) 的时间使用单调栈构建出序列的 L 和 R 数组，再根据这两个数组以及上面推出的递推公式完成对每一个位置作为峰值的最好结果的求解，进行比较筛选就能找到最大的值了。再根据最大值出现的位置填写每栋楼的高度输出即可。 此外，这个题目还有一种使用线段树和分治思想的方法，下次写好了也会在这里补上的。下面是使用单调栈完成的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;using namespace std;typedef long long longs;const int N = 5e5+50;longs n,m[N]; longs ans[N]; int l[N],r[N];longs fl[N],fr[N];stack&lt;int&gt; s;inline void pop(int i)&#123; r[s.top()] = i; s.pop();&#125;inline void push(int i)&#123; while(!s.empty()&amp;&amp;m[s.top()]&gt;m[i]) pop(i); if(s.empty()) l[i] = 0; else l[i] = s.top(); s.push(i);&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); cin&gt;&gt;n; const int npos = n+1; fl[0] = fl[npos] = 0; fr[0] = fr[npos] = 0; m[0] = m[npos] = 0; for(int i=1;i&lt;=n;++i) &#123; cin&gt;&gt;m[i]; push(i); &#125; while(!s.empty()) pop(npos); for(int i=1,j=n;i&lt;=n;++i,--j) // 根据递推式计算 &#123; fl[i] = fl[l[i]]+m[i]*(i-l[i]-1)+m[l[i]]; fr[j] = fr[r[j]]+m[j]*(r[j]-j-1)+m[r[j]]; &#125; longs max = 0, tmp; int pos = 0; for(int i=1;i&lt;=n;++i) // 加上m[i]进行比较 if((tmp=fl[i]+fr[i]+m[i])&gt;max) max = tmp, pos = i; ans[pos] = m[pos]; // 填值 for(int i=pos-1;i&gt;0;--i) ans[i] = min(m[i],ans[i+1]); for(int i=pos+1;i&lt;=n;++i) ans[i] = min(m[i],ans[i-1]); for(int i=1;i&lt;=n;++i) cout&lt;&lt;ans[i]&lt;&lt;&#x27; &#x27;; return 0;&#125; 日，口口声声的说要开long long结果最后自己也还是忘记了，结果整了好几发WA才搞清楚问题在哪里，甚至还有把i和j混写、下标起始值混乱这种不知道该说什么的错误……我真是服了……啪，我死了== 自裁，请（无慈悲 虽然说单调栈是一侧严格一侧不严格的去找要求的值，但是似乎在大多数的题目中都不会有影响的。所以大可直接放心的使用。 D - Happy New Year 题目地址：http://codeforces.com/problemset/problem/1313/D 外部链接：您可以选择洛谷来源或者vjudge来源的 Remote Judge。 E - Concatenation with intersection 题目地址：http://codeforces.com/problemset/problem/1313/E 外部链接：您可以选择洛谷来源或者vjudge来源的 Remote Judge。 后记 参考资料 https://www.cnblogs.com/JHSeng/p/12358750.html","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://shiraha.cn/tags/Codeforces/"}]},{"title":"Nowcoder 小白月赛22","slug":"nowcoder-newbie-contest-22","date":"2020-02-26T00:56:52.000Z","updated":"2020-02-26T00:56:52.000Z","comments":true,"path":"2020/nowcoder-newbie-contest-22/","link":"","permalink":"https://shiraha.cn/2020/nowcoder-newbie-contest-22/","excerpt":"","text":"比赛赛题地址：https://ac.nowcoder.com/acm/contest/4462 按照惯例，开始之前先码了官方题解：https://ac.nowcoder.com/discuss/369662 TIM图片20200226090513.jpg 怎么说呢，虽然做题目的情况也并没有多少的改善，但是这次确实就是div3水平== 好多题目都是暴力求解的，姑且在这里简单的提一下，算是一个总结吧。毕竟只有比赛途中自己做出来的题目才算的上是真正会的== 题解 A - 操作序列 题目地址：https://ac.nowcoder.com/acm/contest/4462/A 看讨论帖子中五花乱坠的平衡树啊、线段树啊……什么的，我只觉得他们吵闹——这个题目并没有涉及到任何的区间变动，完全可以直接STL的map怼上去。只是要注意一点，查询一个不存在的元素会导致它被新建，所以查完了还得把它删掉，不然就比较麻烦。 官方题解提示了平衡树在线，但是它自己也是拿set做的，和我用map并没有什么本质的区别/// 唯一值得一提的就是读入的时候，因为cin在读取的时候不会自动略过换行符什么的，所以一开始getline容易读到空行。可以直接用循环跳过读入的空行即可。 B - 树上子链 题目地址：https://ac.nowcoder.com/acm/contest/4462/B 还算是比较简单的递推关系，题解说这算是DP那就算吧。大概就是每个节点都要查询一次，然后更新一次答案并返回一个最长链供父亲使用的感觉。官方题解说的dp[i]就是要返回的以i节点为根的最长子链，最大值官方题解也是维护了最大和次大的长链求和的，没啥好说的。 题解大多说这是一个求“树的直径”的问题，是一个没有听说过的名词，所以在这里介绍一下这个定义： 树的直径：我们将一棵树 T = ( V，E ) 的直径定义为 maxδ ( u，v )，其中 u，v ∈ V。也就是说，树中所有最短路径距离的最大值即为树的直径。 一般这种题目给的是边长，但是这个题目给的是点权，因此做法有略微的差别。经典的求树的直径的做法有两种：BFS/DFS和树形DP。先码一个例题在这里：POJ 1985。 搜索方法：先从任意一点P出发，找离它最远的点Q，再从点Q出发，找离它最远的点W，W到Q的距离就是树的直径。正确性的证明可以看下方的引用： 原作者： forever_dreams 来源： https://blog.csdn.net/forever_dreams/article/details/81051578 搜索方法的正确性证明： ① 若P已经在直径上，根据树的直径的定义可知Q也在直径上且为直径的一个端点 ② 若P不在直径上，我们用反证法，假设此时WQ不是直径，AB是直径： 若AB与PQ有交点C，由于P到Q最远，那么PC+CQ&gt;PC+CA，所以CQ&gt;CA，易得CQ+CB&gt;CA+CB，即CQ+CB&gt;AB，与AB是直径矛盾，不成立，如下图（其中AB，PQ不一定是直线，画成直线是为了方便）： 20180715124201842.jpg 若AB与PQ没有交点，M为AB上任意一点，N为PQ上任意一点。首先还是NP+NQ&gt;NQ+MN+MB，同时减掉NQ，得NP&gt;MN+MB，易知NP+MN&gt;MB，所以NP+MN+MA&gt;MB+MA，即NP+MN+MA&gt;AB，与AB是直径矛盾，所以这种情况也不成立，如下图： 20180715145337618.jpg 上面的证明排除了可能失败的两种情况，反证了做法的正确性。无论是上述的哪一种情况，都不能确定除了WQ之外的任意直径AB的存在，因此找到的WQ必然是直径。 树形DP方法：也就是这个题目推荐的做法，每个节点i维护两个值。一个是以i为根的子树中，i到叶子节点的最长链的长度；另一个是同样的条件下，这个长度的次大值。我们将它们记为dp1和dp2数组。 然后这个值是可以由下而上的推导的，设j是i的儿子，两节点之间路径的长度w[i][j]；具体更新策略是： 若 dp1 [ i ] &lt; dp1 [ j ] + w [ i ][ j ]，先更新 dp2 [ i ] = dp1 [ i ]，再更新 dp1 [ i ] = dp1 [ j ] + w [ i ][ j ]； 否则，若 dp2 [ i ] &lt; dp1 [ j ] + w [ i ][ j ]，直接更新 dp2 [ i ] = dp1 [ j ] + w [ i ][ j ]； 这是很容易理解的：首先假定最长链和次长链和此节点构成了直径，更新最大值；然后再将最大值向上传递。最后的答案就是 ans = max(dp1[i]+dp2[i])。 C - 交换游戏 题目地址：https://ac.nowcoder.com/acm/contest/4462/C 真就暴力搜索呗（）预处理所有的情况随便DFS可也太顶了== 不过反正字符串就长度只有12，确实可以为所欲为（） D - 收集纸片 题目地址：https://ac.nowcoder.com/acm/contest/4462/D 10张纸片，不同的顺序也没多少种情况，还是一个因为范围不大所以可以为所欲为的题目。出题人说了，全排列然后找最小值也是能过的，但是也有一些还算是算法的做法：就是使用状压DP的方法的旅行商问题的解法。 这代码事后补的，直接看还是有点混乱的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define rint register intusing namespace std;typedef long long longs;typedef long double longd;const char mod[] = &quot;The shortest path has length &quot;;struct coord&#123; int x,y; int operator-(const coord&amp; c);&#125;;int t,N,M,n;coord st,pp[20];int dis[20][20];int dp[1&lt;&lt;11][20]; // dp数组：经过点的状压标记，最后到达的点int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); while(cin&gt;&gt;t) while(t--) &#123; cin&gt;&gt;N&gt;&gt;M&gt;&gt;st.x&gt;&gt;st.y; cin&gt;&gt;n; pp[0] = st; for(int i=1;i&lt;=n;++i) cin&gt;&gt;pp[i].x&gt;&gt;pp[i].y; for(int i=0;i&lt;=n;++i) for(int j=i;j&lt;=n;++j) dis[i][j]=dis[j][i]=pp[i]-pp[j]; memset(dp,0x3f,sizeof(dp)); const int lim = (1&lt;&lt;n+1)-1; dp[0][0] = dp[1][0] = 0; // 1（1&lt;&lt;0) 是起点 for(rint i=1;i&lt;=lim;++i) // i是状压标记：记录经过的点 for(int j=0;j&lt;=n;++j) if(i&gt;&gt;j&amp;1) // 找到了一个已经经过了的点j for(int k=0;k&lt;=n;++k) if(i&gt;&gt;k&amp;1) // 再找到一个经过了的点k dp[i][j]=min(dp[i][j],dp[i^(1&lt;&lt;j)][k]+dis[k][j]); int ans = 0x7fffffff; for(int i=1;i&lt;=n;++i) // 从每种经过所有点的情况回到起点 ans = min(ans,dp[lim][i]+dis[i][0]); cout&lt;&lt;mod&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;int coord::operator-(const coord&amp; c)&#123; return abs(x-c.x)+abs(y-c.y);&#125; G - 仓库选址 题目地址：https://ac.nowcoder.com/acm/contest/4462/G 温馨提示： 本题的C++时间限制是4s 本来还看着是一个非常奇怪的题目，但是给了4s的话就完全可以暴搜了== 当然也可以做一些力所能及的但是没啥x用的优化：比如记录二维前缀和，用贡献差来替换多次的暴搜；也可以利用直观感受，直接查找中位数进行检查。 所有数与中位数的绝对差之和最小。 这里的代码就是查找中位数的版本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;utility&gt;using namespace std;typedef long long longs;typedef long double longd;int mat[105][105];longs row[105],col[105]; // 行、列的总值longs res = 0;pair&lt;int,int&gt; midium(int n,int m)&#123; const longs half = res+1&gt;&gt;1; // 这儿要+1的 longs tmp; int i,j; for(i=1,tmp=0;i&lt;=m,tmp&lt;half;++i) tmp += row[i]; for(j=0,tmp=0;j&lt;=n,tmp&lt;half;++j) tmp += col[j]; return make_pair(--i,--j); // for检查会多+1&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int T,n,m; while(cin&gt;&gt;T)while(T--) &#123; cin&gt;&gt;n&gt;&gt;m; res = 0; memset(row,0,sizeof(row)); memset(col,0,sizeof(col)); for(int i=1;i&lt;=m;++i) for(int j=1;j&lt;=n;++j) &#123; cin&gt;&gt;mat[i][j]; row[i]+=mat[i][j]; col[j]+=mat[i][j]; res+=mat[i][j]; &#125; auto mid = midium(n,m); int &amp;x = mid.first, &amp;y = mid.second; longs out = 0; for(int i=1;i&lt;=m;++i) for(int j=1;j&lt;=n;++j) out += mat[i][j]*(abs(i-x)+abs(j-y)); cout&lt;&lt;out&lt;&lt;endl; &#125; return 0;&#125; 总感觉这题目给人一种既视感，但是又不是很清楚…… 之所以能利用中位数的原因是题目采用的是曼哈顿距离吧。如果距离采用的是直线连接的小数距离的话，这个题目还可以利用中位数来解决吗？曼哈顿距离和直线距离可不是一回事了（ H - 货物种类 题目地址：https://ac.nowcoder.com/acm/contest/4462/H 题目说区间修改，那就是说要维护一个差分序列；区间操作，只在最后有一次询问，询问少，大概是要用线段树的。一开始以为不能用树状数组，后来寻思了一下应该还是可以用的，只是不能维护max值，需要一次遍历来找出最大值就是了（）。 但是线段树还是太麻烦了，所以还是直接维护差分数组算了。此处吐槽一下题解的代码，有点小乱（） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;typedef long long longs;typedef long double longd;const int N = 1e5+10;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int n,m,l,r,d; while(cin&gt;&gt;n&gt;&gt;m) &#123; vector&lt;int&gt; mount[N]; // 装载区间 vector&lt;int&gt; umount[N]; // 卸载区间 map&lt;int,int&gt; mounted; // 区间重叠 while(m--) &#123; cin&gt;&gt;l&gt;&gt;r&gt;&gt;d; mount[l].push_back(d); umount[r].push_back(d); &#125; int now = 0, max = -1, pos = 1; for(int i=1;i&lt;=n;++i) &#123; for(int j : mount[i]) &#123; if(!mounted[j])++now; ++mounted[j]; &#125; if(now&gt;max) &#123; max = now; pos = i; &#125; for(int j : umount[i]) &#123; --mounted[j]; if(!mounted[j])--now; &#125; &#125; cout&lt;&lt;pos&lt;&lt;endl; &#125; return 0;&#125; 第一次自己写的时候是寻思着合并区间的，然后一次给加上去，再根据差分求出最大值，但是不知道因为什么原因最后WA了…… 于是就因为各种原因懒得一行一行看自己的代码，不再合并区间重新写了一遍，就A了。 再感慨一下，这map用来当JavaScript中的无限大的稀疏数组实在是太舒服了（） I - 工具人 题目地址：https://ac.nowcoder.com/acm/contest/4462/I 这题大概就是这次比赛中的毒瘤题吧？明显要用到浮点运算，然后还是一个看起来就很乱的模型…… 整个比赛中途只有个位数的人A了这个题，截止我补题，我才是第十个A了这个题目的人（） 要说做法倒也毫无新意，就是贪心。不过这次不是光线的距离——这也没法算，而是巧妙地将这个随着距离变化而权重变化的距离变成了到原点的角度范围，然后利用角度范围作为贪心区间。这种贪心的结果显然是确定了起点就确定了，可能会考虑不到跨边界的联合，所以为了保证每一种情况都被考虑到，切换起点进行贪心取最小值就可以做出来。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long longs;typedef long double longd;enum bound &#123;st=0,ed=1&#125;;const double EPS = 1e-8;const double PI = 3.1415926535897932384626;const double PI2 = 2*PI;struct ray&#123; int num; double angle; bound type; ray(int n,double ag,bound typ); bool operator&lt;(const ray &amp;r) const; bool operator&lt;(const ray &amp;&amp;r) const;&#125;;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); int t,n,d,x,y; int cnt; while(cin&gt;&gt;t) while(t--) &#123; cin&gt;&gt;n&gt;&gt;d; vector&lt;ray&gt; v; longs d2 = d*d; longd r2; cnt = 0; for(int i=1;i&lt;=n;++i) &#123; cin&gt;&gt;x&gt;&gt;y; r2 = x*x+y*y; if(r2-EPS &lt;= d2) continue; longd angle = atan2(y,x); longd delta = asin(d/sqrt(r2)); ++cnt; v.emplace_back(cnt,angle-delta,st); // 原地构造代替 push_back+构造器 v.emplace_back(cnt,angle+delta,ed); &#125; if(!cnt) &#123; cout&lt;&lt;1&lt;&lt;endl; // 原点周围d内必命中，一次解决 continue; &#125; sort(v.begin(),v.end()); // 逆时针 int vs = v.size(); int ans = cnt; for(int i=0;i&lt;vs;++i) // 以射线i作为起点，确保了所有可能 &#123; vector&lt;bool&gt; mark(cnt+1,false); vector&lt;int&gt; list; int c = 0; for(int j=0;j&lt;vs;++j) // 贪心：每道光尽可能消灭更多 &#123; auto &amp;vj = v[(i+j)%vs]; if(!vj.type) // 找到开始边界 &#123; mark[vj.num] = true; list.push_back(vj.num); &#125; else if(mark[vj.num]) // 找到已贪心的关闭边界 &#123; ++c; for(auto li : list) mark[li] = false; list.clear(); &#125; &#125; c += list.size(); // 可能存在的未关闭节点 if(c&lt;ans) ans = c; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;bool ray::operator&lt;(const ray &amp;r) const&#123; if(fabs(angle-r.angle)&gt;EPS) return angle &lt; r.angle; return type &lt; r.type; // 开始边界在结束边界前&#125;bool ray::operator&lt;(const ray &amp;&amp;r) const&#123; return *this &lt; r;&#125;ray::ray(int n, double ag, bound typ)&#123; num = n; type = typ; angle = fmod(ag+PI2,PI2); // 转变到[0,2π]范围内&#125; 关键就在于想到将距离变成角度。也许……起到了开拓思维的作用？第一次写的时候使用不太熟练的C++简化构造器炸了，所以写代码还是少搞这些没用的东西== 签到题 本次的签到题是E题、F题和J题。特别要注意的是J要手打高精度，应当注意细节。 后记 怎么说呢，不是暴力就是简单题。但是做题的那个状态下还真就不一定能做的出来== I题算是一个比较有点思维的题目，代码实现也应当更加谨慎。很多题目还是要多参考参考数据范围，万一暴搜行呢（捂脸） 参考链接 树的直径部分：https://blog.csdn.net/forever_dreams/article/details/81051578","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"https://shiraha.cn/tags/Nowcoder/"}]},{"title":"基础知识：树状数组","slug":"The-concept-of-binary-indexed-tree","date":"2020-02-21T04:02:43.000Z","updated":"2021-03-26T04:49:20.000Z","comments":true,"path":"2020/The-concept-of-binary-indexed-tree/","link":"","permalink":"https://shiraha.cn/2020/The-concept-of-binary-indexed-tree/","excerpt":"","text":"没错，是我。练习时长两年半的个人练习生又出来丢人了== 呜呼！一直以来都以为树状数组就是二叉树的数组表示，然后做题的时候感觉越来越不对劲——我印象里树状数组可没有这么多方便的性质和功能啊？这题目怎么就树状数组呢？但是因为懒惰就一直得过且过，尽可能忽略的都忽略了……直到矛盾爆发的今天：我读了一个自称树状数组的题目，结果发现我并不能读得懂它的代码== 才发觉大事不妙，该学了（） 202002202155511.png 不知道树状数组这个东西在我的那些纸质书籍里有没有记载，现在这篇文章就是基于网上可以查到的公开资料整理写成的。如果之后看了书有新的收获再在这里补充就好了。 本文出现的图片大多来自互联网。 定义 首先先看一下来自百度百科的树状数组的定义： 树状数组(Binary Indexed Tree(B.I.T), Fenwick Tree)是一个查询和修改复杂度都为\\(log(n)\\)的数据结构。主要用于查询任意两位之间的所有元素之和，但是每次只能修改一个元素的值；经过简单修改可以在\\(log(n)\\)的复杂度下进行范围修改，但是这时只能查询其中一个元素的值(如果加入多个辅助数组则可以实现区间修改与区间查询)。 特点 复杂度：查询和修改的时间复杂度都是\\(log(n)\\)，空间复杂度则为\\(O(n)\\)。 用途：通常用来高效的计算数列的前缀和，区间和，和线段树有点像。 可解决的问题：可以解决大部分基于区间上的更新以及求和问题。 缺陷：比起线段树来说，在遇到复杂的区间问题还是不能解决。所以说该上线段树还是得上== 解题时，应当优先考虑使用树状数组，再考虑使用线段树。 渐近式理解 关于二叉树、线段树和树形数组的理解大概可以简单归纳成这样： 二叉树 线段树 树状数组 就是二叉树啊，一个爸爸两个儿子，儿子可能还有儿子，这样形成的一个结构啊。 如果每个爸爸都存两个儿子的值，就可以方便一些区间问题的解决了。 比起线段树又删去了一部分节点，这样子就可以使用数组建树了。 图示 然后我就在网上找了个树状数组的图，它长这样： 这里的A数组就是原来的数组，C数组就是利用这个数组构建的树状数组。可以看出A数组和C数组的节点数是一样的。但是和原数组不同的是，树状数组的每个节点存储的是在这个意义上它的子节点的值和。也就是： \\[ \\begin{align} C_1\\ &amp;=\\ A_1 \\\\ C_2\\ &amp;=\\ A_1 + A_2 \\\\ C_3\\ &amp;=\\ A_3 \\\\ C_4\\ &amp;=\\ A_1 + A_2 + A_3 + A_4 \\\\ C_5\\ &amp;=\\ A_5 \\\\ C_6\\ &amp;=\\ A_5 + A_6 \\\\ C_7\\ &amp;=\\ A_7 \\\\ C_8\\ &amp;=\\ A_1 + A_2 + A_3 + A_4 + A_5 + A_6 + A_7 + A_8 \\\\ C_9\\ &amp;=\\ A_9 \\end{align} \\] 可以发现C数组的取值是有规律的：\\(C_i=A_{i-2^k+1}+A_{i-2^k+2}+\\cdots+A_i\\)。这里公式里的k就是i的二进制中从最低位到高位连续零的长度。 光是这么说还是比较的混乱，那么我们先引入lowbit的概念： lowbit： 数字二进制表示的最低1所在位的值。 它的实现是#define lowbit(x) (x&amp;-x)，返回数字x的二进制表示的最低位的二进制1所在的位置所代表的值。 特别地，有lowbit(0) = 0。这样的时候可能会死循环，所以写成函数再加上一个判断会好一些。事实上0就是边界。 lowbit返回的值只有一个二进制数字位是1，所以显然它是2的幂。这真的是一个非常巧妙的实现。我是不知道先辈是怎么想出来的，但是又过于理所应当所以不详细解释了。 天呐之前写lowbit竟然还是循环加移位，太蠢了我死了 如果不知道原码补码反码我就说一下 整数的最高位是符号位，0是正数，1是负数；其他的是数字位。 正整数的原码，反码和补码都是这个数字的二进制表示。 负整数的原码的数字位和相对应的正整数是一样的，只是符号位是1；它的反码就是数字位全部取反，补码就是反码加上二进制1. 这样，我们就知道刚才的公式里的k其实是满足这样的关系的：\\(lowbit(x) = 2^k\\)。那么也就是说上面的公式说明了：C数组的每个节点（假设位置i）的值等于从A数组上它的位置开始向前数lowbit(i)个节点的值的和。这也就是树状数组的性质：\\(C_i = \\sum_{j=i+1-lowbit(i)}^{i} A_j\\)，已经知道了lowbit(i)是位置i的最大的是2的幂的因子。 构建树状数组 从上面的基本定义已经可以了解到C数组的指定位置的值的求法。C数组的节点可能包含多个A数组节点的值，相应地A数组的一个节点可能会被多个C数组的节点包含。在这个基础上就可以介绍对树状数组的一些操作了： 节点修改 因为A数组的节点可能被多个C数组的节点包含，所以更新的时候要把这些都考虑到。因为\\(C_i = \\sum_{j=i+1-lowbit(i)}^{i} A_j\\)，所以\\(A_k\\)会被$C_j j kJ_iN J_1 = k, J_i = J_{i-1} + lowbit(J_{i-1}) $更新A节点的代码大概长这样： 123456789void add(int i, int x)&#123; if (i &lt; 1) return; // 在数组外 while (i &lt;= N) // N 指数组长度 &#123; C[i] += x; i += lowbit(i); // 向上找爹爹 &#125;&#125; 这样，就可以在已知A数组的情况下构建出树状数组C了，大概这么做： 12345void build() // 一般不写成函数&#123; for (int i=1;i&lt;=N;++i) add(i,A[i]);&#125; 因为是无后效的在线算法，所以可以一边输入一边构建。事实上一般解题过程中就是这么做的。 节点查询 因为并不是每个节点都包含了在自己前面所有节点的值，所以当需要查询前缀和的时候，仍然需要向前推进。下面的query(int):int函数返回的是原数组在区间[1,p]上的前缀和。 12345678910111213141516171819int query(int p)&#123; int res = 0; while (p &gt; 0) &#123; res += C[p]; p -= lowbit(p); &#125; return res;&#125;/* 或者也可以写成这个样子 */int query(int p)&#123; int res = 0; for (int i=p;i;i-=i&amp;-i) res += C[p]; return res;&#125; 既然可以求出前缀和，那么也可以简单的利用前缀和求出区间的和： 1234int query(int l, int r)&#123; return query(r)-query(l-1);&#125; 以上就是单点更新的树状数组的两项基本操作了。但是当题目要求更新区间内的所有值时，它的优势就不那么明显了。 树状数组的变式 上面说到的树状数组是最普通的单点更新的树状数组，它可以在\\(O(log(n))\\)的时间内更新单个节点的值，或者计算出区间和。但是如果数组的更新形式不是单点更新而是区间更新，这样的树状数组就没那么好用了，需要进行一些变换才好。 毕竟，高级树状数组即使是在很大的范围也可以进行局部优化降低复杂度的……我不会就是了 区间修改+节点查询 这里的修改区间指的是将原数组的某个区间内的每个值都增加x。这样的操作如果是在单点更新的树状数组中，就只能遍历更新区间内的每一个值，复杂度达到\\(O(nlog(n))\\)，这是不好的。 一种改进的方法就是不再根据数据的值建树，转而引入差分，利用差分建树。 那么差分是什么呢，赶紧百度百科一下 差分： 又名差分函数或差分运算，差分的结果反映了离散量之间的一种变化，是研究离散数学的一种工具。它将原函数\\(f(x)\\)映射到\\(f(x+a)-f(x+b)\\) 。差分对应离散，微分对应连续。差分又分为前向差分、向后差分及中心差分三种。 差分算子： 设y依赖于自变量t，当t变化量为1时因变量y的改变量记为\\(Dy_1\\)，称为函数\\(y(t)\\)在点t处步长为1的(一阶)差分。 所谓前向/后向/中心差分就是这个变化量的方向不同。对原序列进行差分计算可以得到长度相等（或长度大一）的差分序列。它有着这样的性质： 对差分序列求前缀和可以降低差分序列的阶数，最终得到原序列。 原序列[L,R]区间内值+x等价于差分序列中，L处+x，R+1处-x。 在了解差分的基础上，我们规定A₀=0，前向差分序列为数组D。也就是说\\(D_j=A_j-A_{j-1}\\)。根据上面说到的性质，我们可以得到以下的关系： 查询：\\(A_i = \\sum_{j=1}^i D_j\\) 修改：\\(A_{L\\to R}+x \\Leftrightarrow D_L+x,D_{R+1}-x\\) 这样的差分序列有一个巨大的优势：修改一个区间就仅需要修改区间的上下界的两个值。所以为了加速区间的修改，我们可以利用这个性质对D数组建立树状数组，就可以方便区间修改了。 综上所述，如果要进行修改和查询，可以写出这样的代码： 12345678910111213141516171819202122232425void add(int p, int x)&#123; while(p &lt;= N) &#123; D[p] += x; p += p&amp;-p; &#125;&#125;void add(int l, int r, int x)&#123; add(l,x); if (r&lt;N) add(r+1,x); // 可以不判断&#125;int ask(int i) // 差分前缀和，即A[i]&#123; int res = 0; while (i) &#123; res += D[i]; i -= i&amp;-i; &#125; return res;&#125; 因为这里的树状数组D是根据原数组A的一阶差分序列而构建的，所以构建时的输入应该是A数组两个元素的差： 12345void build() // 依然是在线算法&#123; for (int i=1;i&lt;=N;++i) add(i,A[i]-A[i-1]);&#125; 这样，更新的过程被大大的简化，依然可以在\\(O(log(n))\\)的复杂度完成区间的更新和单点查询。但是这也导致了这样的树状数组不能快速的查询区间内值的和。 区间修改+区间查询 如果问题模型既有大量的区间修改又有大量的区间查询怎么办？这样的情况似乎即使是上面的那种树状数组也不是很够用。在开始之前我们先考虑上面说的差分数组，显然有： \\(\\sum_{i=1}^nA_i=\\sum_{i=1}^n\\sum_{j=1}^iD_j\\) 也就是说： \\(\\sum_{i=1}^nA_i=\\sum_{i=1}^n (n+1-i)D_i\\) \\(=n\\sum_{i=1}^nD_i-\\sum_{i=1}^n(i-1)D_i\\) 只要知道了\\(\\sum_{i=1}^nD_i\\)和\\(\\sum_{i=1}^n(i-1)D_i\\)，就可以求出A数组的前缀和。而这两个表达式本身都是前缀和。前缀和可以通过维护树状数组方便的求出。所以这次需要分别对D数组和与D数组相关的乘积进行树状数组维护。 因为两个数组都是和D数组相关，可以整到一起一并处理。设乘积的树状数组是sum数组，那代码大概就可以写成下面这样： 12345678910111213141516171819202122232425262728293031323334353637383940414243void add(int p, int x) // 传入A的差分序列&#123; int k = p-1; while (p &lt;= N) &#123; D[p] += x; sum[p] += k*x; p += p&amp;-p; &#125;&#125;void query(int p) // 查询A数组的前缀和&#123; int res = 0, k = p; while (p) &#123; res += k*D[p]-sum[p]; p -= p&amp;-p; &#125; return res;&#125;void ask(int i) // 查询A数组节点&#123; int res = 0; while (i) &#123; res += D[i]; i -= i&amp;-i; &#125; return res;&#125;void add(int l, int r, int x)&#123; add(l,x); add(r+1,x); // 做题时数组开大点&#125;void query(int l, int r)&#123; return query(r)-query(l-1);&#125; 这样的树状数组就既可以满足区间修改的需要，也可以快速的进行区间查询和节点查询了。大多数的问题都可以使用这样的树状数组来解决吧。 对比线段树 最开始的时候就提到了。树状数组思想上继承自线段树，两者极为相似，但是树状数组的空间复杂度比线段树要小，并且实现更加的简单容易。但是作为代价，它的使用范围比线段树是要小的。 树状数组的优劣 树状数组的优势：空间复杂度略低，编程复杂度低，容易扩展到多维情况。 比线段树的劣势：适用范围小，对可以进行的运算也有限制。 等我知道了再完善这一部分 实现的对比 这里为了对线段树和全功能一维树状数组的实现进行对比，先简单的介绍以下线段树的几大基本操作的实现： 操作 线段树实现描述 树状数组实现描述 构造 使用递归，每次递归二分，直到区间[l,r]缩为一个点。 在线构建 单点修改 向下找到包含的节点，并全部修改 使用lowbit找爸爸，修改所有包含。 单点查询 自上而下一直搜索到目标节点，将路径上的节点值求和即可 传统树状数组可直接查询，或求差分序列的前缀和 区间查询 在每一个节点（区间），若完全包含就加上，否则递归不完全的区间。 使用lowbit向前直到完成计算前缀和，之后使用前缀和计算区间和 区间修改 和查询类似，完全包含的区间就直接加上，否则就递归直到找到完全包含。 如果是差分序列的树状数组，就仅需对区间两端进行修改就可以满足。 上述线段树基本操作的实现如下，一般来说用来表示线段树的数组的大小是原数组的四倍。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* 定义线段树节点结构体 */struct node &#123; int l,r,v; // 区间和数值 bool ispoint()&#123;return l==r;&#125;&#125; t[4*N]; // 线段树数组/* 构建线段树： 从根[1~n]开始 */void build(int l, int r, int i)&#123; t[i].l = l; t[i].r = r; if (l==r) return; int m = (l+r)&gt;&gt;1; build(l,m,i&lt;&lt;1); build(m+1,r,(i&lt;&lt;1)^1);&#125;/* 线段树单点修改： A[p]+=k */void add(int i, int p, int k)&#123; t[i].v += k; if (t[i].ispoint()) return; if (p &lt;= t[i&lt;&lt;1].r) add(i&lt;&lt;1,p,k); else if (p &gt;= t[(i&lt;&lt;1)^1].l) add((i&lt;&lt;1)^1,p,k);&#125;/* 线段树区间查询： ΣA[l~r]的值 */int query(int i, int l, int r)&#123; if (t[i].l &gt;= l &amp;&amp; t[i].r &lt;= r) return t[i].v; int res = 0; if (l &lt;= t[i&lt;&lt;1].r) res += query(i&lt;&lt;1,l,r); if (r &gt;= t[(i&lt;&lt;1)^1].l) res += query((i&lt;&lt;1)^1,l,r); return res;&#125;/* 线段树区间修改： A[l~r]+=k */void add(int i, int l, int r, int k)&#123; if (t[i].l &gt;= l &amp;&amp; t[i].r &lt;= r) &#123; t[i].v += k; return; &#125; if (l &lt;= t[i&lt;&lt;1].r) add(i&lt;&lt;1,l,r,k); if (r &gt;= t[(i&lt;&lt;1)^1].l) add((i&lt;&lt;1)^1,l,r,k);&#125;/* 线段树单点查询： A[p]的值 */int ask(int i, int p)&#123; int res = t[i].v; if (t[i].ispoint()) return res; if (p &lt;= t[i&lt;&lt;1].r) res += ask(i&lt;&lt;1,p); else if (p &gt;= t[(i&lt;&lt;1)^1].l) res += ask((i&lt;&lt;1)^1,p); return res;&#125; 这里的实现只是最基础的线段树实现，并没有引入延迟标记之类的优化。如果要使用线段树还应该使用别的板子。 总结 简单的一维树状数组大概就是上面说到的三种。它们的特点简单整理为下表： 类型 简介 树状数组 ask query add 单点修改 传统的树状数组，可以快速求出前缀和区间和 基于A维护C 直接返回A[i] 返回A的前缀和 更新指定节点 区间修改 可以快速的修改区间的值，但不支持快速求出原数组的前缀和 基于A的差分维护D 返回A的差分的前缀和 - 更新区间首尾节点 区间查询 既可以快速修改区间，也可以快速区间查询 基于A的差分维护D，以及一个乘积的sum 返回A的差分的前缀和 根据推导公式返回 更新区间首尾节点 二维树状数组 在和线段树做对比的时候提到了树状数组更容易扩展到多维情况，那这里就简单地提一下多维情况下的树状数组。此时，它的复杂度是\\(O(log^kn)\\)。 练习题 这里列了几个网上看到的出现的比较多的板子题。等我写完了就会把代码放上来的。 洛谷 P3374 题目链接：https://www.luogu.com.cn/problem/P3374 洛谷 P3368 题目链接：https://www.luogu.com.cn/problem/P3368 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960template &lt;class T&gt;class tree_array&#123; vector&lt;T&gt; c, d; static uint lowbit(uint x) &#123;return x &amp; -x;&#125; void add(uint i, T x) &#123; uint ii = i, siz = c.size(); while (ii &lt; siz) &#123; c[ii] += x, d[ii] += x * i; ii += lowbit(ii); &#125; &#125; T sum(uint i) &#123; T ret = 0; uint ii = i; while (ii) &#123; ret += (i + 1) * c[ii] - d[ii]; ii -= lowbit(ii); &#125; return ret; &#125;public: tree_array() = default; explicit tree_array(uint n) : c(n + 1), d(n + 1) &#123;&#125; void resize(uint n) &#123;c.resize(n + 1), d.resize(n + 1);&#125; void add(uint l, uint r, T x) &#123;add(l, x); add(r + 1, -x);&#125; T ask(uint l, uint r) &#123;return sum(r) - sum(l - 1);&#125;&#125;;signed main()&#123; int n, m, x; cin &gt;&gt; n &gt;&gt; m; tree_array&lt;longs&gt; a(n + 1); for (int i = 1; i &lt;= n; ++ i) &#123;cin &gt;&gt; x; a.add(i, i, x);&#125; while (m --) &#123; int op, y, k; cin &gt;&gt; op &gt;&gt; x; if (op == 1) &#123; cin &gt;&gt; y &gt;&gt; k; a.add(x, y, k); &#125; else cout &lt;&lt; a.ask(x, x) &lt;&lt; endl; &#125; return 0;&#125; UPD: 2021-3-26 已验证板子的正确性； 洛谷 P3431 题目链接：https://www.luogu.com.cn/problem/P3431 HDU - 1166 题目链接：http://acm.hdu.edu.cn/showproblem.php?pid=1166 外挂链接：https://vjudge.net/problem/HDU-1166 POJ - 3468 外挂链接：https://vjudge.net/problem/POJ-3468 POJ - 2155 外挂链接：https://vjudge.net/problem/POJ-2155 URAL - 1470 补充练习题 如果有好的练习题可以联系我补在这里~ 参考资料 https://www.cnblogs.com/lyp-Bird/p/10544435.html https://baike.baidu.com/item/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/313739?fr=aladdin https://www.cnblogs.com/xenny/p/9739600.html https://www.zhihu.com/question/54404092 https://zhuanlan.zhihu.com/p/46699931 https://www.cnblogs.com/--lr/p/9345779.html https://blog.csdn.net/bestsort/article/details/80796531 https://bestsort.cn/2019/04/26/195/","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://shiraha.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"数据结构","slug":"数据结构","permalink":"https://shiraha.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"基本的图论算法","slug":"Basic-graph-theory-algorithm","date":"2020-02-19T07:19:46.000Z","updated":"2020-02-19T07:19:46.000Z","comments":true,"path":"2020/Basic-graph-theory-algorithm/","link":"","permalink":"https://shiraha.cn/2020/Basic-graph-theory-algorithm/","excerpt":"","text":"图论是一位同级的计科老哥做的介绍，简单的总结一下他上课提到的这些图论算法以及问题。大概这也就是差不多要准备的模板吧，下面是自己总结的他的一个思路，本文也会根据这个思路来组织内容： 培训内容 - 图论 最小生成树 定义补足 Prim 算法 Kruskal 算法 题型 树形DP LCA /倍增 最短路问题 最短路算法应该是整个图论算法体系中使用的最频繁的一类算法吧，大体就是有三种比较常见的算法，它们有各自的特点，但是一般使用是后两者居多。为了熟悉这三个算法大概我是写了洛谷P3371这个题目，分别使用了这三种方法来写。 Floyd 算法 Dijkstra 算法 SPFA 算法 强连通和双连通 二分图匹配 这一部分的东西看之前的代码渐渐魔怔了 匈牙利算法 说这个之前先提一下二分图的一个性质： König定理： 二分图中，最小覆盖点数 = 最大匹配数。这里的最小点覆盖指的是，对于二分图找到最少的一些点，使二分图所有的边都至少有一个端点在这些点之中。或者说，只要删除包含这些点的边，可以删掉所有边，这个点集就是最小点覆盖。 匈牙利算法是使用寻找增广路的方法来解决二分图最大匹配问题的算法。简单的说就是有一个二分图，假设两侧点集为M和N。然后先尽可能匹配M和N里的点，如果遇到冲突的话就DFS，让原配去寻找其它的可能性（）也就是增广路。找到了，大家Happy*Happy，匹配数喜加一；找不到，再见== 最简单的板子大概就长下面这样。主要是nextMatch也就是DFS和对每一个点发起匹配的maxMatch函数构成，不太要求存图方法，下面用的是邻接矩阵。然后得到结果的同时还会得到一个最大匹配的方案。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int N = 1050; // u &lt;= nconst int M = 1050; // v &lt;= Mint n,m,e,u,v;bool graph[N][M]&#123;0&#125;; bool visit[M]&#123;0&#125;; // v是否被访问int match[M]&#123;0&#125;; // match[v]=u;bool nextMatch(int i) // 其实这是DFS&#123; for(int j=1;j&lt;=m;++j) // 不要从中途开始 if(graph[i][j]&amp;&amp;!visit[j]) &#123; visit[j] = true; if(!match[j]||nextMatch(match[j])) &#123; match[j] = i; return true; &#125; &#125; return false;&#125;inline int maxMatch()&#123; int ans = 0; for(int i=1;i&lt;=n;++i) // 要重置visit &#123; memset(visit,0,sizeof(bool)*(m+1)); if(nextMatch(i)) ++ans; &#125; return ans;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); cin&gt;&gt;n&gt;&gt;m&gt;&gt;e; while(e--) &#123; cin&gt;&gt;u&gt;&gt;v; graph[u][v] = true; &#125; cout&lt;&lt;maxMatch()&lt;&lt;endl; return 0;&#125; 这个板子是基于洛谷P3386来写的。细节方面有两点要注意：一是因为递归链调用累计，所以必须要有visit数组，而且每次还要复位；二就是寻找增广路时，之前扫过的部分不可跳过。 网络流问题 网络流模型 Edmonds-Karp 算法 Dinic 算法 费用流 2-SAT 问题 参考资料 https://zhuanlan.zhihu.com/p/96229700","categories":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"图论算法","slug":"算法/图论算法","permalink":"https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"图论","slug":"图论","permalink":"https://shiraha.cn/tags/%E5%9B%BE%E8%AE%BA/"}]},{"title":"Nowcoder 2020 寒假算法基础训练","slug":"nowcoder-2020-winter-training","date":"2020-02-16T01:55:37.000Z","updated":"2020-02-16T01:55:37.000Z","comments":true,"path":"2020/nowcoder-2020-winter-training/","link":"","permalink":"https://shiraha.cn/2020/nowcoder-2020-winter-training/","excerpt":"","text":"一共六场云比赛，据官方声称大约是cf-div3的难度，然而我做的并不顺畅就是了。首先是它们的题解链接，放在前面备用。 &gt; 第一场：https://ac.nowcoder.com/discuss/364600 &gt; 第二场：https://ac.nowcoder.com/discuss/364961 &gt; 第三场：https://ac.nowcoder.com/discuss/365306 &gt; 第四场：https://ac.nowcoder.com/discuss/365889 &gt; 第五场：https://ac.nowcoder.com/discuss/366644 &gt; 第六场：https://ac.nowcoder.com/discuss/367149 然后对一些题目做一些笔记吧，毕竟自己也确实是菜的真实（） 第四场 所有题目的链接：https://ac.nowcoder.com/acm/contest/3005 官方的题解帖子：https://ac.nowcoder.com/discuss/365889 为什么这场宣称没有难题没有毒瘤题我只A了一个啊噫呜呜噫我好菜啊哭哭== 4589838F557722182419F54B9B98BF93.jpg 不过这一场题目确实，不仅整体相对偏向思维的考察，也非常考察写代码细节注意的程度。像我好多题目对着答案的思路敲也是WA不可避== 这套题补下来还是觉得想法会开拓不少，但是之后遇到类似的题目不知道能不能做出来就是了…… D - 子段异或 题目链接：https://ac.nowcoder.com/acm/contest/3005/D F - 树上博弈 题目链接：https://ac.nowcoder.com/acm/contest/3005/F G - 音乐鉴赏 题目链接：https://ac.nowcoder.com/acm/contest/3005/G 这整个就是一个概率题。看懂之前真的连一个式子都列不出来，更别说怎么写代码求解了== 不过我只看了一眼就放弃了，真不愧是我（）所以在上这个题目的代码之前先进行不那么简单的数学推导： 首先，我们设第\\(i\\)个同学的总分是\\(S\\)，其中包含\\(s\\geq90\\)分的平时分以及\\(r\\leq90\\)分的随机论文得分，随机的得分在总得分中占比\\(p\\)。显然，同学\\(i\\)优秀的概率是\\(P_i(S\\geq90)\\)，这个总分满足等式\\(S = s\\cdot(1-p)+r\\cdot p\\)。 仅仅这样我们也什么都不知道，还需要进行一些变换。首先将总分的等式带入到概率的不等式中，可以得到： \\(P_i:s\\cdot(1-p)+r\\cdot p\\geq90\\) 将不等式的两侧同时减去90，可以得到： \\(P_i:S-90=s\\cdot(1-p)+r\\cdot p-90\\geq0\\) \\((s-90)\\cdot(1-p)+(r-90)\\cdot p\\geq0\\) 又因为\\(r\\)本来就是一个范围是[0,90]的随机数，所以\\(r-90\\)是一个[-90,0]的随机数，和\\(-r\\)是等价的。因此上式可以变成： \\((s-90)\\cdot(1-p)-r\\cdot p\\geq0\\) 整理可得： \\(P_i: \\frac{(s-90)\\cdot(1-p)}{p} \\geq r\\) 又因为\\(r\\)是一个范围是[0,90]的随机数，易得\\(P(r\\leq x)=\\frac{x}{90}\\)，所以上述不等式成立的概率\\(\\frac{(s-90)\\cdot(1-p)}{p} \\geq r\\)等于\\(P(r\\leq \\frac{(s-90)\\cdot(1-p)}{p})=\\frac{(s-90)\\cdot(1-p)}{90p}\\)。至此，我们求出了第\\(i\\)位学生优秀的概率： \\(P_i:\\ \\frac{(s-90)\\cdot(1-p)}{90p}\\) 设班级内一共有\\(n\\)名同学，要求优秀率恰好为10%，也就是说： \\(E = \\sum _{i=1}^n P_i = \\sum _{i=1}^n \\frac{(s_i-90)\\cdot(1-p)}{90p} = 0.1n\\) 解这个方程可得：\\(p = \\frac{\\sum _{i=1}^n (s_i-90)}{9n+\\sum _{i=1}^n (s_i-90)}\\) 但是除此之外，出题人称还可以使用二分的方法求解。这也许是一种数值计算方法，等我弄明白了再在这里补充好了。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;typedef long long longs;typedef long double longd;int n,ss;int in[100010];int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout&lt;&lt;fixed&lt;&lt;setprecision(2); while(cin&gt;&gt;n) &#123; ss = 0; for(int i=0;i&lt;n;++i) &#123; cin&gt;&gt;in[i]; ss += in[i]-90; &#125; cout&lt;&lt;(longd)ss/(9.0l*n+ss)*100.0l&lt;&lt;&#x27;%&#x27;&lt;&lt;endl; &#125; return 0;&#125; 属于这种只要你把它推出来了，写代码并不是很难的题目。但是像我就直接被吓死了== 此外，通过这个题目，我熟练了使用MathJax和LaTeX的技巧 H - 坐火车 题目链接：https://ac.nowcoder.com/acm/contest/3005/H I - 匹配星星 题目链接：https://ac.nowcoder.com/acm/contest/3005/I J - 二维跑步 题目链接：https://ac.nowcoder.com/acm/contest/3005/J 第五场 所有题目的链接：https://ac.nowcoder.com/acm/contest/3006 官方的题解帖子：https://ac.nowcoder.com/discuss/366644 这次的题目里有大量的浮点数……就容易出现各种各样的小麻烦。印象里这里还有严格的卡了IO的题目（指ios::sync_with_stdio不管用）和超级模拟的毒瘤题=== 总而言之这绝对是一套极其麻烦的题目。 B - 牛牛战队的比赛地 题目链接：https://ac.nowcoder.com/acm/contest/3006/B 看起来就知道这是一个极其麻烦的题目。直接求解想必是十分困难的，但是验证一个点距离最远基地的最小值是可以一定时间内完成的——这样就要考虑到二分算法的可能性。此外，答案的取值范围是确定的，因此更应该想到使用二分解题。 题解使用了三分查找的方法，声称这样比二分查找更加的简单。二分查找最值就是一个比较麻烦的事情……大约需要对每一个区间继续二分然后递归……下次知道的话再做一个专题吧。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;iomanip&gt;#include &lt;algorithm&gt;#define vi vertex[i]using namespace std;typedef long long longs;typedef long double longd;struct point&#123;int x,y;&#125;;int n,x,y;point vertex[100050];longd distance(longd xpos) // 这里也用longd就能AC了&#123; longd tmp = 0.0l; longd x2,y2; for(int i=1;i&lt;=n;++i) &#123; y2 = vi.y*vi.y; x2 = (vi.x-xpos)*(vi.x-xpos); tmp = max(tmp,sqrtl(x2+y2)); &#125; return tmp;&#125;longd triple_search(longd left, longd right)&#123; longd midl,midr; for(int i=0;i&lt;=100;++i) // 因为浮点，所以只能通过搜索次数提高精度 &#123; midl = left + (right-left)/3; midr = left + 2*(right-left)/3; if(distance(midl)&gt;distance(midr)) left = midl; else right = midr; &#125; return midl;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); cout&lt;&lt;fixed&lt;&lt;setprecision(4); while(cin&gt;&gt;n) &#123; for(int i=1;i&lt;=n;++i) &#123; cin&gt;&gt;x&gt;&gt;y; vertex[i] = &#123;x,y&#125;; &#125; cout&lt;&lt;distance(triple_search(-10000,10000))&lt;&lt;endl; &#125; return 0;&#125; 这道题目对于二分/三分查找的最大疑惑就是这个最小值和坐标的x值之间构成的函数关系是不是成单调关系或者是严格凹凸函数关系——至少在这个题里并没有明显的这样的关系的存在，可是笔记里也确实记录了这样的内容： 节选自我的笔记 那么单峰函数和使用三分到底有什么关系呢？它比二分的效率要高？不是的，你写一下二分就知道二分会暴毙再极端情况的。因为二分查找对应的是单调函数，而三分查找对应单峰函数极值点的寻找。 因为是单峰函数，所以最大值的获得只需要使用三分查找就可以了。但是三分查找仅对于严格凹/凸函数有效。如果出现可行域中连续的函数导数为0的情况可能会暴毙。 但是，题目的函数条件虽然写的很复杂，不要忘记你的基础数学知识啊： 凹凸序列： 如果一个函数是若干个开口向上的二次函数的最大值，这个函数就是先减后增的凹形序列了，相应地： 如果一个函数是若干个开口向下的二次函数的最小值 这个函数就是先增后减的凸形序列。 因为对于每一个点，距离所求点的距离都是一个凹函数，所以它们最大值构成的函数也是一个凹函数。这样求最小值极值三分法就毫无疑问了。 F - 碎碎念 这题是个DP是真的万万没想到== 没做出来的原因大概就是读题的时候RJ-&gt;AC这个条件根本就没有有效利用。因为一发RJ之后必定AC，所以必不会出现连续RJ，一发RJ后必连AC。这样就规定了一种转移关系：AC由AC和RJ转移来，RJ由AC转移来。可设dp[x][0/1]是x句话时最后一个是AC或者RJ的可能性，即可得到推导公式。 然后是多次询问，这种询问区间大多都是要使用前缀和这种东西进行优化的。所以dp的时候记得加一下就好。询问的时候直接两个前缀和求差就行了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;typedef long long longs;typedef long double longd;const longs MOD = 1000000007ll;int x,q,l,r;int dp[2][100010];int pre[100010];inline void preProcess(int x)&#123; const int AC=1,RJ=0; dp[RJ][0] = 0; dp[AC][0] = 1; pre[0] = 1; for(int i=1;i&lt;=100010;++i) &#123; dp[RJ][i] = (i&gt;=x)?dp[AC][i-x]:0; dp[AC][i] = ((longs)dp[RJ][i-1]+dp[AC][i-1])%MOD; pre[i] = ((longs)dp[AC][i]+dp[RJ][i]+pre[i-1])%MOD; &#125;&#125;int solution(int l,int r)&#123; return (pre[r]-pre[l-1]+MOD)%MOD; &#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); while(cin&gt;&gt;x&gt;&gt;q) &#123; preProcess(x); while(q--) &#123; cin&gt;&gt;l&gt;&gt;r; cout&lt;&lt;solution(l,r)&lt;&lt;endl; &#125; &#125; return 0;&#125; 交题目的时候出现了奇怪的问题，本地测试通过但是上传却连样例都无法通过，后来把Nowcoder的编译器从 clang++ 换成 GNU g++ 就好了，现在也不知道是什么原因== G - 街机争霸 因为是题目数据范围不大，大概可以用一些简单的算法。比较麻烦的就是僵尸会动来动去，不然的话直接BFS就完事了。但是僵尸动的周期是一致的，所以可以再输入的时候预处理僵尸不同时刻所在的位置，然后在这样的基础之上进行BFS，这个题目就可以做出来了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std;typedef long long longs;typedef long double longd;struct coord&#123;int x,y;coord operator+(const coord&amp; rhs);&#125;;static const coord mov[4] = &#123;&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;0,1&#125;&#125;;struct node &#123;coord p;int t;&#125;;const int N = 500+5;const string ohno = &quot;Oh no&quot;;int n,m,p,k;char map[N][N];bool zmbmap[N][N][50];coord inpos,st,ed;string instr;int T;int vis[N][N][20];queue&lt;node&gt; q;bool judge(coord pos,int now)&#123; if(pos.x&lt;=0||pos.y&lt;=0||pos.x&gt;n||pos.y&gt;m)return false; else if(map[pos.x][pos.y]==&#x27;&amp;&#x27;)return false; else if(zmbmap[pos.x][pos.y][now])return false; else return true;&#125;inline int bfs()&#123; int ans = -1; while(!q.empty())q.pop(); vis[st.x][st.y][0] = 0; q.push(&#123;st,0&#125;); node n;coord c; int nt; while(q.size()) &#123; n = q.front(); q.pop(); if(n.p.x==ed.x&amp;&amp;n.p.y==ed.y) &#123; ans = vis[ed.x][ed.y][n.t]; break; &#125; nt = (n.t+1)%T; for(int i=0;i&lt;4;++i) &#123; c = n.p+mov[i]; if(judge(c,nt)&amp;&amp;vis[c.x][c.y][nt]==-1) &#123; vis[c.x][c.y][nt] = vis[n.p.x][n.p.y][n.t]+1; q.push(&#123;c,nt&#125;); &#125; &#125; &#125; return ans;&#125;inline int parseDir(string &amp;s)&#123; switch(s[0]) &#123; case &#x27;R&#x27;:return 3; case &#x27;U&#x27;:return 0; case &#x27;L&#x27;:return 2; case &#x27;D&#x27;:return 1; default:exit(-1);break; &#125;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;p&gt;&gt;k) &#123; memset(zmbmap,0,sizeof(zmbmap)); memset(vis,-1,sizeof(vis)); T = 2 * k - 2; for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=m;++j) &#123; cin&gt;&gt;map[i][j]; if(map[i][j]==&#x27;A&#x27;) ed=&#123;i,j&#125;; else if(map[i][j]==&#x27;L&#x27;) st=&#123;i,j&#125;; &#125; for(int i=1;i&lt;=p;++i) &#123; cin&gt;&gt;inpos.x&gt;&gt;inpos.y; cin&gt;&gt;instr; zmbmap[inpos.x][inpos.y][0] = true; int dir = parseDir(instr); for(int x=1,j=2*k-3;x&lt;k;++x,--j) &#123; inpos = inpos+mov[dir]; zmbmap[inpos.x][inpos.y][x] = zmbmap[inpos.x][inpos.y][j] = true; &#125; &#125; int res = bfs(); if(~res)cout&lt;&lt;res&lt;&lt;endl; else cout&lt;&lt;ohno&lt;&lt;endl; &#125; return 0;&#125;coord coord::operator+(const coord&amp; rhs)&#123; return &#123;x+rhs.x,y+rhs.y&#125;;&#125; 建议写代码还是尽可能的言简意赅，能不要花里胡哨就不要花里胡哨，不然出错就非常的吃亏。之前包装了一堆函数还给我整了一个段错误出来就非常的离谱== 所以说少麻烦点就少麻烦点。现在感觉这似乎也是某种意义上的多层图：固有障碍每层都有，僵尸不同时间在不同的层的不同位置。 第六场 所有题目的链接：https://ac.nowcoder.com/acm/contest/3007 官方的题解帖子：https://ac.nowcoder.com/discuss/367149 总的来说这一次的题目还是比较的常规的——指的不是简单易懂，就是比较的……正常？毕竟比第五场谜之写错要舒服的多，看完了所有题目，只要思路没什么大问题基本写出来就不会有问题。 B - 图 题目链接：https://ac.nowcoder.com/acm/contest/3007/B 看到这样的题目描述很容易就能知道这个图大概是长什么样子：可能有多个连通块，每个连通块都是一个环外面续着几根链（太阳形），看了题解知道这种图叫做基环内向树森林。这样，从一个点出发一定能到一个环。 如果是在学tarjan判环时期说不定我就直接tarjan了找环然后找最长链了，但是这个题目似乎没有那么麻烦，DFS就好了。因为直接DFS会超时所以要使用记忆化搜索。但是问题就是我没想好这个记忆化具体的实现方法== gg 自己写的版本还特别统计了每个入度。大概能想到的用场就是从入度为0的点开始，利用入度大于1的点寻找链和环的交接处吧。虽然看起来题解没有这么做便是了。能想到的退化点大概就是太阳形的图，大量的入点会导致道面好多遍这个图然后T。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;stack&gt;using namespace std;typedef long long longs;typedef long double longd;int n,v[1000010];bool vis[1000010],in[1000010];stack&lt;int&gt; t;int ans = 0,mem[1000010];int cur,c,cnt;int mem_dfs(int x)&#123; if(mem[x]) return mem[x]; else return mem[x] = 1+mem_dfs(v[x]);&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); while(cin&gt;&gt;n) &#123; for(int i=1;i&lt;=n;++i) cin&gt;&gt;v[i]; memset(vis,0,sizeof(bool)*(n+1)); memset(in,0,sizeof(bool)*(n+1)); memset(mem,0,sizeof(int)*(n+1)); for(int i=1;i&lt;=n;++i) &#123; if(!vis[i]) &#123; cur = i; while(!vis[cur]) // 找点 &#123; t.push(cur); vis[cur] = in[cur] = true; cur = v[cur]; &#125; if(in[cur]) // 找到环 &#123; c=v[cur],cnt=1; while(c!=cur) // 求环的大小 &#123; c = v[c]; ++cnt; &#125; do // 存储环的大小 &#123; c = v[c]; mem[c] = cnt; &#125; while (c!=cur); &#125; while(t.size()) &#123; in[t.top()] = false; t.pop(); &#125; &#125; &#125; for(int i=1;i&lt;=n;++i) ans = max(ans,mem_dfs(i)); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 注意细节……这样的代码还能写炸就不太象话了（）所谓记忆化主要还是记录环的大小。一次遍历得到环的大小之后，无论有什么样的链都不会重复走环，速度就快了。 C - 汉诺塔 题目链接：https://ac.nowcoder.com/acm/contest/3007/C 显然必然是要先按照一边进行排序的。之后就变成了在已经按照x排序的数列中寻找y边长尽可能少的若干组单调子序列。这个单调的方向和按照x排序的顺序一致。然后就是离散数学里的比较常见的Dilworth定理。 Dilworth定理： 偏序集的最少反链划分数等于最长链的长度。 这指出了可以通过求出另一个单调方向的最长链长度来求出这个最小划分的组数。 至于这个最长单调序列的经典求法，可以去看一下洛谷P1020。其实这个最长单调序列问题还是挺经典的，又很多可以做的优化。 但是仅仅是这样是不行的，题目还要让我们输出这个划分的具体方式。所以需要开数组记录每个木板的分组组号和每个分组当前在“栈顶”的木板的宽度。将每一块木板放在使用二分找到的最大的比它小的（sort默认升序）木板上就好。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;algorithm&gt;#include &lt;functional&gt;#include &lt;cstring&gt;#define x first.first#define y first.second#define num secondusing namespace std;typedef long long longs;typedef long double longd;typedef pair&lt;pair&lt;int,int&gt;,int&gt; it;it in[100010];int n;int ans[100010]; // 0是组数，1~n记录分组情况int stack[100010]; // 维护最长的下降子序列int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); while(cin&gt;&gt;n) &#123; ans[0] = 0; memset(stack,0,sizeof(int)*(n+1)); for(int i=1;i&lt;=n;++i) &#123; cin&gt;&gt;in[i].x&gt;&gt;in[i].y; in[i].num = i; &#125; sort(in+1,in+1+n); for(int i=1;i&lt;=n;++i) &#123; // 使用STL二分找出第一个小于当前木板宽的组号 int lb = upper_bound(stack+1,stack+ans[0]+1,in[i].y,greater&lt;int&gt;())-stack; stack[lb] = in[i].y; if(lb&gt;ans[0]) ans[0]=lb; ans[in[i].num] = lb; &#125; cout&lt;&lt;ans[0]&lt;&lt;endl; for(int i=1;i&lt;=n;++i) cout&lt;&lt;ans[i]&lt;&lt;&#x27; &#x27;; &#125; return 0;&#125; 其实就是谁都能想到的朴素n²算法的二分优化……我已经什么都不会了（大悲） E - 立方数 题目链接：https://ac.nowcoder.com/acm/contest/3007/E 这是这套题目里一个比较令我上头的题目。很显然答案就在 1~³√n之间，验证起来的话倒也不是那么麻烦。看起来极其的像二分找答案== 但是实在不知道拿什么当作判别二分的标准……遂作罢。想着分治但是这看起来不是可以轻易分治的样子，没有想到一种确实可以加快速度的分治方案== gg。 之后用先提取2然后跳奇数的方法分解因数然后也妥妥T了，转念一想就算是数据的极限情况，有价值尝试的质因数范围也不过1e6，比之前的1e8好多了== 如果用欧拉筛的话1e6的质数也不是事，况且还要多次查询而预处理只需要一次……稳赚不赔啊（）遂尝试欧拉筛选出质数进行分解但是最终谜之WA了，遂作罢。 看了题解，这是题解中题目作者的进一步分析: &gt; 作者：珩月 &gt; 链接：https://ac.nowcoder.com/discuss/367149?type=101&amp;order=0&amp;pos=1&amp;page=1 &gt; 来源：牛客网 &gt; &gt; 先做简单一点的优化，容易发现其实只要枚举106(N(1/3)以内)的质数就好，复杂度O(TN(1/3)/ln(N(1/3))) &gt; 再作进一步的分析，如果我们仅使用N^(1/4)(记为W)以内的质数去试除，那么最后余下的数X仅具有大于W的因子 &gt; 此时X要么是一个完全立方数，要么对答案没有任何贡献，只需要使用二分法来验证X是不是一个完全立方数即可 &gt; 复杂度O(TN(1/4)/ln(N(1/4)))，不卡常数。 其实我一开始没怎么看懂…… 使用⁴√n作为测试的素数范围的话，最大的问题就是⁴√n~³√n这个区间范围内的可能性了。筛之后的数字确实不再包含任何小于³√n的因子，也就是说如果它不是完全立方数且对答案有贡献，设贡献的因子为k，那么这个剩下来的数一定会大于k³·m，其中k,m&gt;³√n。但是若这样的k存在，那么这个剩下的数字会大于(³√n)⁴&gt;n，这必然是不可能的。所以只需要判断剩下来的部分是不是完全立方数就好了，而这部操作是可以使用二分查找的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;typedef long long longs;typedef long double longd;int t;longs n;bool is[1000100]&#123;0&#125;;int prime[100000]&#123;0&#125;; // 1e6内质数大约是7.2w个longs tri[100000],qua[1000000];inline void preProcess() // 欧拉筛 + 预先计算幂&#123; int tmp; for(int i=2;i&lt;=1000010;++i) &#123; if(!is[i]) &#123; prime[++prime[0]]=i; tri[prime[0]] = i*i*i; qua[prime[0]] = tri[prime[0]]*i; &#125; for(int j=1;j&lt;=prime[0]&amp;&amp;(tmp=i*prime[j])&lt;=1000010;++j) &#123; is[tmp]=1; if(i%prime[j]==0) break; &#125; &#125;&#125;inline longs solve(longs n)&#123; if(!(n&amp;1ll)) // 处理因数2 &#123; int cnt = 0; while(!(n&amp;1ll)) &#123; ++cnt; n&gt;&gt;=1; &#125; return (1ll&lt;&lt;(cnt/3))*solve(n); &#125; longs ans = 1; for(int i=1;qua[i]&lt;=n;++i) // i&lt;=prime[0]没有必要 if(n%prime[i]) continue; else // 完全去除这个因数 &#123; while(!(n%tri[i])) &#123; ans *= prime[i]; n /= tri[i]; &#125; while(!(n%prime[i])) n/=prime[i]; &#125; int lb = 1, rb = 1000000; while(lb&lt;=rb) // 可以二分查找 &#123; int mid = lb+rb &gt;&gt; 1; if((longs)mid*mid*mid&lt;n) lb = mid+1; else rb = mid-1; &#125; if((longs)lb*lb*lb==n) ans*=lb; return ans;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); preProcess(); while(cin&gt;&gt;t) while(t--) &#123; cin&gt;&gt;n; cout&lt;&lt;solve(n)&lt;&lt;endl; &#125; return 0;&#125; 现在想想，最开始想到二分但是不能二分的原因是因为无法确定判据：如果是用大于/小于n的话，只会让二分结果更加趋向于³√n，但是实际上很多数字的答案是1，显然这不合理；如果使用除数/余数作为判据，那就比较的麻烦，甚至可能要考虑它们的变化，就不像是二分了…… 也就是说二分最大的障碍是那些比较小的因数，而这可以先行筛去。之后可能的因数在⁴√n~³√n内，因为这个数一定是小于等于n的，所以要不是立方数要不是倍数，就转化的可以二分了…… 妙啊。 简单的说，就是：如果n有大于⁴√n~³√n的因子且有贡献，那么必然会有小于³√n的因子，筛去这部分因子之后剩下的就是（有奉献的）完全立方数或者（无奉献的）质因数乘积。 这么一想，之前写的³√n的时候细节也不怎么注意，常数必然很大，被卡掉也是自然（）而且对于1e18的数据来说两种复杂度差距很大的啊……确实也是根本没有向⁴√n的方向去想吧== 学到了学到了。 I - 导航系统 题目链接：https://ac.nowcoder.com/acm/contest/3007/I 这应该是这次最麻烦的题目。最开始看到n-1条边、看到两点距离、再看到判断最短距离的正误，第一反应是并查集和树上LCA（虽然板子用的并不熟练）。但是仔细一看发现题目并没有指明点之间的关系用来建图，遂作罢。 看了题解才想着：n个节点n-1条边就是一棵树，如果数据合法，那么这棵树就是输入的完全图的最小生成树（草怎么就没想到==）。因为边权是非负数的，可以使用Kruskal算法构建最小生成树再进行验证即可。 如果忘记了以贪心为基本思想的Kruskal算法的话，那自裁，请（无慈悲）我爬了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;typedef long long longs;typedef long double longd;struct edge&#123; int from,to,val; bool operator&lt;(const edge&amp; rhs) const;&#125;;const string yes = &quot;Yes&quot;;const string no = &quot;No&quot;;const int N = 505;int n;int map[N][N];edge elist[N*N];int cur = 0; // 输入的完全图边光标bool fall = false;int dis[N][N]; int ufs[N]; // Kruskal用并查集int head[N]; // 前向星存最小生成树edge fstree[N*2];int nextptr[N*2];int tot;int father(int x)&#123; if(!ufs[x]) return x; else return ufs[x]=father(ufs[x]);&#125;inline int unite(int u,int v)&#123; return ufs[u] = v;&#125;inline void addedge(edge&amp; e)&#123; nextptr[tot] = head[e.from]; head[e.from] = tot; fstree[tot] = e; ++tot; nextptr[tot] = head[e.to]; head[e.to] = tot; fstree[tot] = &#123;e.to,e.from,e.val&#125;; ++tot;&#125;void dfs(int now,int prev,int sp,int leng)&#123; dis[sp][now] = leng; int c = head[now]; while(~c) &#123; edge&amp; ce = fstree[c]; if(ce.to^prev) dfs(ce.to,now,sp,leng+ce.val); c = nextptr[c]; &#125;&#125;inline void init()&#123; fall = false; memset(ufs,0,sizeof(int)*(n+1)); tot = 0; memset(head,-1,sizeof(int)*(n+1)); cur = 0;&#125;int main()&#123; ios::sync_with_stdio(false); cin.tie(nullptr); while(cin&gt;&gt;n) &#123; init(); for(int i=1;i&lt;=n;++i) for(int j=1;j&lt;=n;++j) cin&gt;&gt;map[i][j]; for(int i=1;i&lt;=n;++i) &#123; for(int j=i+1;j&lt;=n;++j) if(map[i][j]!=map[j][i]) // 简单筛查 &#123; cout&lt;&lt;no&lt;&lt;endl; fall = true; break; &#125; else elist[cur++] = &#123;i,j,map[i][j]&#125;; if(fall) break; &#125; if(fall) continue; sort(elist,elist+cur); const int ne = n-1&lt;&lt;1; for(int i=0;i&lt;cur&amp;&amp;tot&lt;ne;++i) // Kruskal找树 &#123; int fu=father(elist[i].from),fv=father(elist[i].to); if(fu!=fv) &#123; unite(fu,fv); addedge(elist[i]); &#125; &#125; for(int i=1;i&lt;=n;++i) dfs(i,0,i,0); // 找i到所有点的距离 for(int i=1;i&lt;=n;++i) &#123; for(int j=i+1;j&lt;=n;++j) if(map[i][j]!=dis[i][j]) // 二度核对 &#123; cout&lt;&lt;no&lt;&lt;endl; fall = true; break; &#125; if(fall) break; &#125; if(fall) continue; cout&lt;&lt;yes&lt;&lt;endl; for(int i=0;i&lt;tot;i+=2) cout&lt;&lt;fstree[i].val&lt;&lt;endl; &#125; return 0;&#125;bool edge::operator&lt;(const edge&amp; rhs) const&#123; return val&lt;rhs.val;&#125; 简单的说一下这个题目的具体实现：首先简单排查双向边的两个方向是否长度相等——因为题目只是保证了自环为0，而且确实需要这么扫一遍来构建题目所说的完全图；建图之后使用并查集跑一边Kruskal找到最小生成树的边存到新图（树）中。之后再以每一个顶点作为树根进行DFS，计算出所有定点对之间的距离并与输入进行核对即可。 主要就是想到这个最小生成树。完全图的点对之间，最短距离的路径一定在最小生成树上。想到这个之后写代码仔细点基本就没什么问题了…… 虽然说流程比较复杂，但是图论题，数据范围1e2，很显然复数算法折腾没毛病…… 不要怕啊。 后记 说是说写代码，但是这几轮真正考察到的算法硬知识都比较少，主要就是思维和……代码能力吧。而且有的题目即使可以想到可能的算法Tag，自己的实现也会是和答案千差万别，就还是缺乏训练，题目做少了的表现吧== 虽然说学习某些高级算法的时候有那样的万能感，实际上不会运用，连基本的题目也会卡住，大概就是现在的状态吧。毕竟高级算法可以看板子，解题能力和代码能力才是真正要训练的东西啊（）害！路漫漫啊== 虽说不太喜欢nowcoder这个网站但是这种感觉也还不错。认真的学习这几套题之后要尝试补一补Codeforces的div2/div3以及AtCoder的ABC/ARC了。用之前学化学的感觉来说，就是之前只是在瞎玩，现在大概来感觉了吧。虽然时间很迟，但是是时候做出努力了（）这方面来说我还是期待nowcoder之后的题的，下次还来== 不说了，一个寒假宅在家里都没碰luogu，名字都绿了，该刷题力（大悲","categories":[{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"https://shiraha.cn/tags/Nowcoder/"}]},{"title":"辗转相除法和有理数取模","slug":"Euclid-and-modulus-of-rational-number","date":"2020-02-12T08:35:57.000Z","updated":"2020-02-12T08:35:57.000Z","comments":true,"path":"2020/Euclid-and-modulus-of-rational-number/","link":"","permalink":"https://shiraha.cn/2020/Euclid-and-modulus-of-rational-number/","excerpt":"","text":"首先简单复习一下辗转相除法（欧几里得算法）和扩展欧几里得算法： 1234567891011121314151617181920212223242526272829// 最大公约数 &amp; 最小公倍数int gcd(int a, int b)&#123; if(a&lt;b) return gcd(b,a); // 确保 a&gt;b else if(!b) return a; else return gcd(b,a%b);&#125;int lcm(int a, int b)&#123; return a/gcd(a,b)*b; // 如果是 a*b/gcd(a,b)，中间结果可能会爆&#125;// 拓展欧几里得： 解不定方程 ax+by=gcd(a,b)void exgcd(int a, int b, int&amp; d, int&amp;x, int&amp; y)&#123; if(a&lt;b) return exgcd(b,a,d,y,x); else if(!b) // 基础情况： 1*a-0*0 = a = gcd(a,0) &#123; d = a; // gcd(a,b) x = 1; // a 的系数 y = 0; // b 的系数 &#125; else &#123; exgcd(b,a%b,d,y,x); y -= x*(a/b); &#125;&#125; 根据写法流派的不同，exgcd的参数d（最大公约数）可以作为返回值返回。 扩展欧几里得 说这个之前先说一下贝祖定理： 贝祖定理：如果a、b是整数，那么一定存在整数x、y使得ax+by=gcd(a,b)。 也就是说，如果ax+by=m有解，那么m一定是gcd(a,b)的若干倍。特别地，如果ax+by=1有解，那么gcd(a,b) = 1。直接的应用就是知道不定方程的情况下，判断这样的等式有没有整数解。 但是这样并不能得到这个不定方程的解，这种时候就需要使用扩展欧几里得算法。 扩展欧几里得算法可以在求得a、b的最大公约数的同时，能找到整数x、y（其中一个很可能是负数），使它们满足贝祖等式 ax+by=gcd(a,b)。如果a是负数，可以把问题转化成 |a|(-x')+by=gcd(a,b)，然后令 x=(-x')。 和欧几里得算法一样，扩展欧几里得也是使用递归求解，有一样的递归边界：确保a&gt;b的前提下，当b = 0的时候，GCD的值是a，此时对于不定方程 a*x + b*y = gcd(a,b) 有显而易见的解(x,y) = (1,0)。 现在我们可以从这个基本情况进行反推，求出一般a和b的可能解(x,y)。假设其中的某一阶段是这样的：已知 b、a%b 和 gcd(b,a%b)=gcd(a,b)=d，已经求解得到了 b*x' + (a%b)*y' = d。接下来要继续反推求出 ax + by = d 的x和y： 显然，a%b = a - (a/b)*b。将这个式子待入到上述状态的不等方程中可以得到： d = b * x' + (a%b) * y' d = b * x' + (a - (a/b) * b) * y' = b * x' + a * y' - (a/b) * b * y' d = a * y' + b * (x' - (a/b) * y') 小声bb：我马上就去学习怎么输入数学公式 综上所述，可以得到：若 b*x' + (a%b)*y' = d，那么解为 x = y'；y = x' - (a/b)*b，即 a*y' + b*(x'-(a/b)*b) = d。递归返回的过程中根据这个更新值就可以。 更新方法：x和y是引用值，每层递归要使用下一层计算出的y作为自己的x，使用下一层计算的x作为自己的y后再进行本层值的处理。所以有了y -= x*(a/b);。 扩展欧几里得算法可以用来计算模反元素(也叫模逆元)，而模反元素在RSA加密算法中有重要的作用。 模逆元 再说这个之前先简单的复习一下同余和模算数的相关知识： 同余： a ≡ b (mod n)，含义是 a, b除以 n的余数相同。它的充要条件是 a-b 可以被 n整除。若有整数 y满足 a ≡ y (mod n)，那么 y ≡ b (mod n)。所以实际上同余方程的一个解指的是一整个同余等价类。 模线性方程组： 形如 ax ≡ b (mod n) 的方程。由上述等价条件可知 ax - b = ny，再进行移项可得 ax - ny = b，正是可以被扩展欧几里得求解的不等方程的形式。先对 a, n 进行 exgcd，若 d不能被 b整除，那么无解；否则将求出的 x, y按照比例放大即可。 模算数： 同余也有四则运算 - 加法： (a + b) % n = ((a%n) + (b%n)) % n - 减法： (a - b) % n = ((a%n) - (b%n) + n) % n - 乘法： ab % n = (a%n)(b%n) % n - 除法： - 同余式： c≠0, ac ≡ bc (mod n) =&gt; a ≡ b (mod n/gcd(c,n)) 特别注意，最后一项不能简单理解为除法。最后一项的特点是都可以整除。 费马小定理： 若p是质数，且a、p互质，那么a^(p-1) mod p = 1。若p是质数，有 a^p ≡ a (mod p)。两式在 p|a（p整除a）时不等价。 那么什么是模逆元？就是上述模线性方程组的 b=1 的特殊情况：当 ax ≡ 1 (mod n) 时，解出的 x 就是 a 关于模 n 的逆。在这种情况下，a 的逆存在的必要条件就是该模线性方程组（或其等价形式 ax - ny = 1）有解。而它有解的必要条件是 1|gcd(a,n)，也就是 a 和 n 互素，gcd(a,n)=1。此时，该方程有唯一解。（唯一解是刘汝佳书上的原话，但是不是这样的） 此时，可以利用模逆元来求模算数的除法。虽然模除法相当于对一个分数有理数取模，意义不明，但是它依然满足同余的性质。若已有 x 使得 bx ≡ 1 (mod n)，又由模乘法可以得到： (a/b) % m = (a/b)*1 % m = (a/b)*bx % m = ax % m，即 (a/b) ≡ ax (mod m)，式中 x 是 b 关于模 m 的逆。 使用扩展欧几里得求模逆元 求解这个逆元就要使用到前面说的扩展欧几里得算法。bx ≡ 1 (mod n) 等价于 bx - ny = 1。若 gcd(b,n)=1，那么可以使用扩展欧几里得求出逆元 x。因为实际上线性不定方程组有无穷多解，这里只求正的最小的逆元。代码如下： 12345678910// 使用扩展欧几里得求 a 关于模 m 的逆元int inverse(int a, int m) &#123; int x,y,d; // 等价： ax - ny = 1 exgcd(a,m,d,x,y); if(1%d) return -1; // gcd(a,m)≠1 时，无解 x *= 1/gcd; // 解不定方程通用：放大倍数 if(x&lt;0) x+=m; // 求出负数时，将它加为正数 return x%m;&#125; 上述代码并没有处理 m 是负数的情况。如果 m 是负数，那么在 exgcd 之后将 m 取绝对值就好了。 使用费马小定理求模逆元 当模数 m 是素数的时候，求模逆元也可以使用费马小定理进行。很多题目在使用模数时都会给一个很大的素数，与任何比它小的正数互质，就可以使用。设这个很大的质数是 p，那么根据费马小定理，有 a^(p-1) ≡ 1 (mod p)，a 是任何比 p 小的正数。那么根据模逆元的定义，显然有 a*a^(p-2) ≡ 1 (mod p)，故 a 关于模 p 的逆元是 a^(p-2)。 1234567891011121314151617181920// 快速幂： 计算 a^n (n&gt;=0)，非取模int fastpow(int a, int n)&#123; if(!n) return a?1:0; int ans = 1; while(n) &#123; if(n&amp;1) ans*=a; a*=a; n&gt;&gt;=1; &#125; return ans;&#125;// 使用费马小定理求 a 关于模 p 的逆元int inverse(int a, int p)&#123; if(a&gt;p||a&lt;=0) return -1; return fastpow(a,p-2)%p; // 返回模值&#125; 特别注意：上述代码中的快速幂，如果要取模，即使结果不超过int范围，考虑到中间结果的可能性，参数和中间变量的类型应当改为long long。 这样的话，就可以很方便的解决一些带模的除法问题了，而不是使用高精度计算了。比如求 x = (a/c) % p，可以简单的转化为 a*c^(-1) % p。又因为费马小定理，1 ≡ c^(p-1) (mod p)，原式可以化为 x = a*c^(p-2) % p。这样就可以完成分数的求模了。 分数取模 首先看定义： 分数取模运算的定义： x = a/b (mod m) &lt;=&gt; xb = a (mod m)，仅当 gcd(b,m)=1 时成立 当上述恒等式成立时，求已知分数的模相当于求解等价的不等方程： xb - my = a。这可以使用扩展欧几里得求解。当 m 是质数的时候，也可以使用费马小定理快速求解。 但是现在有一些题目会给分数取模的整数作为输入数据。这种题目如果是恰好需要计算概率的话，就很容易陷入“将取模后分数转化为分数”的误区中。但是实际上将取模后分数转化为分数并不是分数取模的逆运算——分数的模只是不定方程的一个解，另一个解被舍弃了。然而题目并不会告诉逆被舍弃的解。但是因为分数取模和分数满足同余等式，可以直接使用分数的模当作分数进行计算，只是要注意负数的情况即可。 练习题 一些相关的题目。写了我就放上来（） 洛谷 P2613 题目链接：洛谷 P2613【模板】有理数取余 真正的模板题，直接告诉了要对分数 a/b 取模。但是数据范围着实吓人，不像是可以用一个变量装下的。如果要是打高精度的话风险太大，也不是这个题目的正确解法。因为分数取模最后可以通过逆元转化为模乘法，所以运算依然是线性的。可以修改C快读模板，在C快读模板每读入一位数字时进行取模操作，最后就可以得到待输入数字的关于给定数字的模。然而这里取模对题目是不影响的。 检查一下，发现题目给的19260817是一个素数。这太好了，直接费马小定理就完事了。当然也可以使用扩展欧几里得解不定方程解出。因为实际上是分母和大质数求不定方程，有解仅当它们互质，那么易得无解的情况：分母是0，根本就没有和p互质的余地。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cctype&gt;using namespace std;typedef long long longs;const longs MOD = 19260817LL; // 是素数const int Power = (int)MOD-2;const char No[] = &quot;Angry!&quot;;longs a,b;longs getlongs() // 未处理负数的带模快读&#123; longs ll = 0ll; char ch; ch = getchar(); while(!isdigit(ch) &amp;&amp; ch != EOF) ch = getchar(); while(isdigit(ch)) &#123; ll = (ll&lt;&lt;1)+(ll&lt;&lt;3)+ch-&#x27;0&#x27;; ll %= MOD; // 立即取模 ch = getchar(); &#125; return ll;&#125;int mod(longs a, longs b) // 费马小定理法&#123; int n = Power; longs ans = 1; while(n) &#123; if(n&amp;1) ans = (ans*b)%MOD; b = (b*b)%MOD; n &gt;&gt;= 1; &#125; ans = (ans*a)%MOD; return (int)ans;&#125;int main()&#123; // 要使用C快读，必须关闭C++快读 // ios::sync_with_stdio(false); // cin.tie(nullptr); a = getlongs(); b = getlongs(); if(!b) cout&lt;&lt;No&lt;&lt;endl; else cout&lt;&lt;mod(a,b)&lt;&lt;endl; return 0;&#125; HDU - 4828 题目链接：HDU - 4828 Grids 更多练习题 如果遇到好题目以后会补在这里。如果你们有推荐的题目也欢迎在评论区留言~ 参考资料 《算法竞赛入门经典（第2版）》 - 刘汝佳编著，清华大学出版社 https://www.cnblogs.com/zhanhonhao/p/11329772.html https://www.luogu.com.cn/problemnew/solution/P2613","categories":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"算法/数学","permalink":"https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"数论","slug":"数论","permalink":"https://shiraha.cn/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-02-09T13:18:00.000Z","updated":"2020-02-09T13:18:00.000Z","comments":true,"path":"2020/hello-world/","link":"","permalink":"https://shiraha.cn/2020/hello-world/","excerpt":"","text":"如果只是介绍Hexo客户端的用法就太无聊了，干脆简单的说一下搭建Hexo博客的流程好了。系统自动生成的那些东西的翻译就放在最后一个板块了== 这里只简单的介绍一下在 Windows 10 平台上将 Hexo 博客部署到 Github Pages 上的基本操作，大概就是：准备必须的环境-&gt;在Github上创建仓库-&gt;使用Hexo客户端-&gt;修改博客工程的配置文件-&gt;写作并发表。 仔细看看官方文档，发现它讲的其实挺全面的…… 瞬间就不想写这个了。 准备工作 这一步主要的是准备Hexo运行的基本环境。 安装程序 首先，你得在你的电脑上安装Node.js和Git。文章里的链接可能不是最新版本的，需要最新版本请去官网： Git官网的下载页面： https://git-scm.com/downloads Node.js官网的下载页面： https://nodejs.org/zh-cn/ 特别注意，安装Git的时候，安装向导会出现一个复选框提示是否将Git增加到系统变量（PATH），选择这个。 安装完成之后，右键开始菜单按钮选择 Windows Powershell，输入命令npm和git测试它们是否已经正确安装。如果已经正确安装会出现帮助文字，否则会出错。如果Git已经正确安装但是在控制台中没有找到，可能是因为Git不在系统变量中，这个时候需要手动将Git添加到Path或者使用 git bash 作为终端。 安装Hexo客户端 之后你需要使用Hexo安装Hexo的客户端，执行的命令是： 1$ npm install -g hexo-cli 安装之后，使用npx hexo应该就可以使用hexo了。如果需要之后使用的更方便，还可以将 Hexo 所在的目录下的 node_modules 添加到环境变量，之后即可直接使用hexo使用它。（但是我的电脑似乎并没有做这一步操作） 布置Github 首先，Hexo的Github部署工具只支持SSH方式部署。也就是说在使用前，你需要将你的电脑的SSH公钥存放到Github账户里。你的电脑的SSH公钥的存放位置在你的个人文件夹下的一个叫做.ssh的文件夹下，如果该目录不存在，或者该目录下没有叫做id_rsa和id_rsa.pub的文件存在，则说明公钥不存在，这时需要生成一个公钥。 可以通过在 Git Bash 或者其他任何终端中键入以下命令生成一个公钥： 1$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; 将your_email@youremail.com替换成自己的邮箱，或者任何其他包含一个@的字符串后一路回车采取默认设置，就会在上述位置生成默认SSH密钥对，也就是上面提到的那两个文件。 登录 Github，点击自己的头像进入 Settings 页面，在 SSH and GPG Keys 目录下，选择新建密钥，将上文提到的id_rsa.pub文件里的所有文本信息复制到网页的文本框里，保存即可。这样就将你电脑的SSH公钥增加到你的 Github 账号里了。 创建站点 这一步的主要目的是创建一个Hexo的工程。 初始化 选择主题 创建仓库 配置站点 修改主题 设置部署信息 使用 写作 ……闲的时候会回来补的…… 快速开始（原文翻译） 欢迎使用Hexo！这是系统默认生成的您的第一篇博文。您可以阅读官方文档来获得更多的消息。如果您在使用Hexo的过程中遇到了任何的问题，您可以在检修页面中找到答案，或者您也可以在GitHub上向我发起询问。 创建一篇新的博文 使用模板创建一篇新的博文的md文件，可以通过执行以下命令： 1$ hexo new &quot;My New Post&quot; 这样就创建了一篇叫做 \"My New Post\" 的博文。 更多信息： 使用Hexo写作 - Hexo官方文档 启动服务器 在本机启动服务器，然后在浏览器中预览您的博客，您可以通过执行以下命令： 1$ hexo server 这样您的博客会在https://localhost:4000（默认端口4000）启动，您可以在浏览器中访问它，或在终端Ctrl+C中断服务器。 更多信息： Hexo服务器 - Hexo官方文档 生成静态文件 要将博客发布，需要先生成静态文件，这可以通过执行以下命令： 1$ hexo generate 这将根据您的配置文件生成静态的html文件，以供部署。 更多信息： 构建/生成 - Hexo官方文档 部署到远程站点 要让您的博客可以在互联网中访问，您可以执行以下命令： 1$ hexo deploy 这样将根据您的配置文件，自动将生成的静态文件发布到互联网。 特别注意： 如果您要将博客发布到 Github Pages，您还额外需要先执行以下命令安装 Github 部署工具。 1$ npm install hexo-deployer-git --save 最新版本的 Hexo 客户端已经不再默认包含这个工具。 更多信息： 部署到远端 - Hexo官方文档","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://shiraha.cn/tags/hexo/"}]},{"title":"Arch Linux 操作系统原理实验报告","slug":"Linux-FoDOS-experiment-dian","date":"2019-11-17T11:04:35.000Z","updated":"2019-11-17T11:04:35.000Z","comments":true,"path":"2019/Linux-FoDOS-experiment-dian/","link":"","permalink":"https://shiraha.cn/2019/Linux-FoDOS-experiment-dian/","excerpt":"","text":"原标题：Linux操作系统原理实验 - 实验报告 补档时间：2020-02-12 19:04:35 因为原稿时间久远，相关的图片素材可能已经遗失。 实验一： 安装Arch Linux并配置图形界面 一、实验描述 在虚拟机上安装可以日常使用的Arch Linux，并为之配置图形界面。 二、实验设计 安装前准备： 启动Hyper-V虚拟机、下载Arch引导镜像、创建虚拟机并且从镜像启动 安装Arch Linux： 检测网络、分区并挂载、更改镜像源、使用pacman安装Arch、配置Arch、解挂载并重启 安装图形界面： 登录Arch、安装图形界面软件包 安装常用软件包： 安装yaourt、安装WMwarm-tools 三、实验原理 pacman包管理器 和Ubuntu不一样，Arch Linux使用的包管理程序是pacman。使用pacman安装一个新的包的命令是： 1pacman -S &lt;包名&gt; 和Ubuntu的apt一样，pacman也需要更新它的信息。更新pacman的软件包的数据库可以使用以下命令的任意一条： 123pacman -Syypacman -Syupacman -Sy 除此之外，pacman还有以下的常用命令： 1234567891011# 移除软件包pacman -R &lt;包名&gt;# 移除软件包以及依赖项pacman -Rs &lt;包名&gt;# 查看可用的包Rpacman -Sl | grep &lt;关键词&gt;# 列出已安装的包pacman -Q &lt;包名&gt; UEFI模式 对于一台使用了“快速创建”的虚拟机或者物理机，我们首先需要知道它引导启动的模式。在archiso的终端执行命令efivar -l，如果输出正确的列出了UEFI变量，则是UEFI模式启动。 如果通过UEFI模式，那么需要将分区挂载到/boot/EFI目录，而不是BIOS模式下挂载到/boot目录。 窗口环境的软件包 在配置图形界面过程中安装的众多软件包中，不同的软件包有不同的作用： xorg server： 众多窗口环境的软件包的基础 sddm： 提供了图形化的用户登录界面 xfce4： 常用的Linux桌面环境 plasma： 基于KDE的更加美观的桌面环境 安装以上所有的软件包之后，在用户的登陆页面将出现选项框，可以选择进入不同的桌面环境。 四、实验步骤 安装前准备 因为Windows 10 1903 对旧版的VMware Workstation存在兼容性问题，为了方便，所以本次实验采用基于Windows10自带的Hyper-V的虚拟机。Hyper-V功能默认是关闭的。在控制面板中选择“程序或功能-&gt;添加/删除Windows功能”中选择启动Hyper-V，随后系统将会下载相关的数据并且重新启动，Hyper-V功能将启用。 进入官网或者镜像站下载Arch Linux的镜像，这里给出浙江大学镜像站的下载地址，进入后选择archlinux-2019.10.01-x86_64.iso下载即可。将下载的镜像文件作为新建的Hyper-V虚拟机中虚拟光驱引入，完成虚拟机创建。 搜索栏中输入“Hyper-V管理器”，可以打开它。在右侧状态栏中选择新建，手动配置新虚拟机的信息。这次实验我使用的是第一代（基于BIOS）的虚拟机，你也可以使用第二代（基于UEFI）虚拟机，但是具体操作将会与本实验报告描述内容存在出入。使用刚才下载的光盘镜像文件作为虚拟光驱，创建虚拟机并启动。 安装Arch Linux 启动刚刚新建的虚拟机，虚拟机将会自动加载的光驱并且进入引导界面。选择Boot Arch Linux(x86_64)选项启动，进入archiso的tyy控制台界面。此时已经可以使用一些常用的Linux命令操作了，安装过程本身也是使用Linux命令完成的。在控制台中输入ping baidu.com，可以检测网络状态——如果ping通，则网络连接正常。否则，可能需要退出虚拟机检查Hyper-V的虚拟网卡/交换器的设置，这可以参考Microsoft Docs。 屏幕截图_1_.jpg 使用cfdisk命令打开cfdisk为虚拟机进行分区。在这次实验中，我将硬盘划分为四个区域，并将它们分别挂载为不同的目录： 分区名 大小 文件系统 挂载目录 /dev/sda1 32GB ext4 /mnt /dev/sda2 1G vfat /mnt/boot /dev/sda3 4G .. SWAP分区 /dev/sda4 余下所有空间 ext4 /mnt/home 在cfdisk中，上下方向键对存储块进行选择，左右键对命令选择，回车键开始操作。完成分区操作之后要执行[Write]命令保存分区信息后方可退出。可以使用lsblk命令展示分区的状态。完成分区之后，需要对分区进行挂载。挂载的命令如下： 1234567891011mkfs.ext4 /dev/sda1mkfs.vfat -F32 /dev/sda2mkswap /dev/sda3mkfs.ext4 /dev/sda4mount /dev/sda1 /mntmkdir /mnt/bootmount /dev/sda2 /mnt/bootswapon /dev/sda3mkdir /mnt/homemount /dev/sda4 /mnt/home 这一步完成之后，再在终端中输入命令genfstab -U /mnt &gt;&gt; /mnt/etc/fstab生成文件系统信息。这一步是必要的，因为生成的文件系统信息会被用来在后面的步骤生成启动引导文件。 屏幕截图_2_.jpg Arch的安装是使用pacman安装的，他需要接收一些必要的数据才可以安装。而国内直接连接Arch官网的速度是非常的不理想的，所以需要更换镜像站，使用国内的镜像站下载必要的文件。首先，可以在控制台中输入vi /etc/pacman.d/mirrorlist以使用vim打开pacman的镜像文件，然后在文件开头加入你喜欢的镜像站，比如： 12Server &#x3D; http:&#x2F;&#x2F;mirrors.163.com&#x2F;archlinux&#x2F;$repo&#x2F;os&#x2F;$archServer &#x3D; http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;archlinux&#x2F;$repo&#x2F;os&#x2F;$arch 添加后控制台执行pacman -Syy更新镜像源，就完成了镜像源的替换。 在终端执行pacstrap -i /mnt base base-devel linux linux-firmware命令，使用缺省的默认设置（一路回车）就可以安装Arch了。特别注意的是，因为新版的Arch基本包已经不再包含Linux内核了，所以安装过程中一定要安装linux和linux-firmware两个包。否则之后创建引导的时候会因为找不到系统而安装失败。 屏幕截图_4_.jpg 此时，Arch Linux已经安装到了虚拟机的硬盘中，为了配置刚安装的Arch Linux，我们需要从光盘的终端中切换到安装好的系统的终端中去。实现这件事的命令是arch-chroot /mnt /bin/bash。archiso-tyy执行这个命令之后的行首会发生变化，很容易观察到。在新的系统的终端中，我们可以： + 配置语言区域 使用vi etc/locale.gen打开文件，删除en_US.UTF-8前的#号，保存之后在终端运行locale-gen. 屏幕截图_8_.jpg 配置时区 1ln -sf &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Shanghai &#x2F;etc&#x2F;localtime 安装grub并生成引导文件 123pacman -S grub grub-install --force /dev/sdagrub-mkconfig -o /boot/grub/grub.cfg 安装dhcpcd并配置网络 对于有线网络，因为Base包里已经不包括联网所需的程序，所以需要下载dhcp客户端之后才能启动服务。 12pacman -S dhcpcdsystemctl enable dhcpcd.service 设置主机名 1echo shiohalinux &gt; /etc/hostname 将主机名增加到/etc/hosts 使用vim打开这个文件，将主机名添加到这个文件的后面，大概就像这样 123127.0.0.1 localhost.localdomain localhost::1 localhost.localdomain localhost127.0.1.1 shirohalinux.localdomain shirohalinux 设置root的密码 终端中输入passwd命令后输入两次要创建的密码就可以了。 创建登录用户并给予它sudo权限 终端中输入useradd -m -G wheel -s /bin/bash shiroha就可以创建名为shiroha的用户。这里的命令最重要的是-G：它指定了用户要加入的附加组列表；现在我们将用户加到wheel组中，之后可以在接下来的操作中给予这个组执行sudo命令的权限，可以方便使用。（当然，你也可以在新用户中使用su - root切换到root用户执行sudo命令）使用passwd shiroha命令可以为新用户shiroha创建密码。可以通过修改/etc/sudoers文件为普通用户提权，但是一般使用命令visudo修改。使用该命令打开sudoers之后，删除wheel组前的#就可以了。特别说明：在使用visudo之前，请确保系统中已经安装了vim。 完成了对新系统的配置之后，就可以退出光驱启动而直接从硬盘启动Arch Linux了。先在当前的终端中执行exit退回tyy终端，再使用umount -R /mnt解挂载光驱，并执行reboot命令重启。特别说明：因为Hyper-V的解挂载并不能弹出虚拟光驱，所以不需要执行解挂载的过程，使用shutdown关机之后再虚拟机管理页面弹出光驱，再手动启动虚拟机就可以了。 屏幕截图_14_.jpg 安装图形界面 如果安装Arch Linux成功完成，那么可通过控制台登录到Arch。首先可以使用root登录到Arch，输入用户名root和正确的密码即可。 图形界面是Arch Linux中额外的软件包提供的功能。所以安装图形界面就是安装和这个图形界面相关的软件包就可以了。与这个相关的软件包主要包括xorg,sddm,xfce4,plasma,ifconfig.当然，这一步骤还会包括安装一些使用软件。 安装脚本： 12345678pacman -S xorgpacman -S xtermpacman -S xorg-xinitpacman -S sddmpacman -S xfce4pacman -S xfce4-goodiespacman -S plasmapacman -S kde-applications 所有的软件包都是使用pacman命令安装，特别要注意的是plasma安装前必须要确保xorg已经安装到虚拟机中；此外，因为plasma桌面环境是基于KDE桌面环境的，所以需要安装kde环境常用的软件包。 配置脚本： 12sddm --example-config &gt; /etc/sddm.confsystemctl enable sddm.service 这步主要是配置sddm：首先生成ssdm的配置文件，随后将ssdm服务增加开机启动项。ssdm主要提供了用户登录界面。 屏幕截图_21_.jpg ssdm的登陆只能使用普通用户登录。这意味着如果你在之前的步骤没有增加一个普通用户，那么你需要使用useradd命令为电脑增加一个用户，并使用passwd为其设置密码。 安装常用软件包 需要安装的一些常用软件包，主要是ifconfig,ssh,zsh,git以及wget.安装这些所有的软件包的脚本如下： 12345678910pacman -S net-tools dnsutils inetutils iproute2pacman -Syy opensshsystemctl start sshdps -e | grep sshdsystemctl enable sshd.servicepacman -S zshpacman -S gitchsh -s $(which zsh)sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;pacman -S wget 虽然pacman用作包管理已经极其方便，但是他还是缺少了一些软件包。我们可以通过安装包管理器yaourt来解决pacman软件包不全的问题。安装yaourt可以这么做： - 在/etc/pacman.conf文件末尾处增加镜像源： 12[archlinuxcn] Server=https://mirrors.ustc.edu.cn/archlinuxcn/$arch - 更新镜像源并安装yaourt： 123pacman -Sypacman -S yaourtpacman -S archlinuxcn-keyring - 使用yaourt安装软件包： 比如安装Chrome可以使用命令yaourt google-chrome。 如果使用的虚拟机是VMWare而不是Hyper-V，可以为Arch安装vmware提供的VMwarm-tools。安装过程如下： 12345678910111213141516171819# 通过虚拟机软件挂载VMwarm-tools# 挂载安装程序mount /dev/cdrom /mnt# 将工具解压tar xf /mnt/VMwareTools*.tar.gz -C /home/zhaozhao/Desktopcd /etcmkdir init.dfor i in &#123;0,1,2,3,4,5,6&#125;; do mkdir rc$i.d; done# 找到解压文件存放的位置cd /home/zhaozhao/Desktop/vmware-distrid# 执行安装脚本./vmware-install.pl# 重启计算机reboot 这个程序提供了将Windows文件夹挂载到Linux的功能，可以方便的在虚拟机和物理机的操作系统之间传输数据。如果虚拟机软件支持这个软件包，建议安装一下。但是似乎Hyper-V并不支持这个包。 五、实验结果 安装Linux：重新启动后，虚拟机画面上出现了grub的加载界面，其中的首选项是+Arch Linux。选择该项启动后，进入了Arch Linux的登陆终端而不是archiso的tyy终端，输入设置的用户以及对应的密码可以进入终端，安装完成。 安装图形界面：此步完成后，启动虚拟机，待看到了服务启动的终端输出之后，将会看到sddm提供的用户登陆界面。输入正确的用户密码后会看到plasma桌面环境的加载画面，随后进入plasma桌面环境。 实验二： 编译并安装Linux内核 一、实验描述 在实验一中安装的Arch Linux虚拟机中编译一个从Arch官方网站上下载的内核，并且将这个内核安装到虚拟机中。 二、实验设计 下载、编译、安装 进入官网下载内核、编译内核、安装内核模块、将编译的模块复制到/boot目录 制作初始化内存盘 制作初始化内存盘、复制System.map 更新引导程序 更新grub配置、重启验证结果 三、实验原理 编译内核的menuconfig 编译内核需要一个配置文件，而获得这个配置文件有很多种方法。其中一种方法是通过make menuconfig命令进入一个图形化的配置页面进行对内核的自定义配置，然后生成对应的.config文件。接下来简要的介绍一下键入这个命令后系统的执行的流程： 屏幕截图_30_.jpg 首先，这个过程涉及到了以下的文件： Linux内核根目录下的/scripts文件夹 arch/$ARCH/Kconfig文件、各层目录下的Kconfig文件 Linux内核根目录下的makefile文件、各层目录下的makefile文件 Linux内核根目录下的的.config文件、arm/$ARCH/.config文件 Linux内核根目录下的include/generated/autoconf.h文件 首先系统读取arch/$ARCH/Kconfig文件，使用/scripts下的绘制图形相关的文件生成图形化的config界面。环境变量$ARCH是定义在根目录的makefile文件中的。 arch/$ARCH/configs目录下存储了默认的配置。内核会默认读取根目录下的.config文件作为默认配置。但是为了和内核完全匹配，往往需要对这个文件进行修改。 在图形化的配置界面调整了不同的选项之后，最后保存退出时Linux内核会把新的选项新到.config中。此时将.config重命名为其它文件保存起来（当执行make distclean时系统会把.config文件删除）就可以在需要的时候还原这个配置了。 make命令 当make命令被执行时，它会扫描当前目录下makefile文件找到目标以及其依赖。如果这些依赖自身也是目标，继续为这些依赖扫描Makefile文件并且建立其依赖关系，然后编译它们。一旦主依赖编译之后，然后就编译主目标。如果之后某个源文件发生了修改，再次执行make命令，它将只编译与该源文件相关的目标文件。 make指令的命令参量： &gt;-f：指定“makefile”文件； &gt;-i：忽略命令执行返回的出错信息； &gt;-s：沉默模式，在执行之前不输出相应的命令行信息； &gt;-r：禁止使用build-in规则； &gt;-n：非执行模式，输出所有执行命令，但并不执行； &gt;-t：更新目标文件； &gt;-q：make操作将根据目标文件是否已经更新返回\"0\"或非\"0\"的状态信息； &gt;-p：输出所有宏定义和目标文件描述； &gt;-d：Debug模式，输出有关文件和检测时间的详细信息。 &gt;-C dir：在读取makefile 之前改变到指定的目录dir； &gt;-I dir：当包含其他makefile文件时，利用该选项指定搜索目录； &gt;-h：help文挡，显示所有的make选项； &gt;-w：在处理makefile之前和之后，都显示工作目录。 &gt;-j：指定编译的线程数，线程数越大理论越快。 make install是编译后的安装过程，它从makefile中读取信息，并且将软件包安装到指定位置。可以使用configure生成makefile文件。往往需要sudo权限来向系统写入数据。有的软件包在安装之前可能需要先运行 make check或make test来进行一些测试。 make clean命令在编译前会清除之前编译的可执行文件及配置文件。而make distclean命令则会在编译前删除所有之前的编译生成的文件。使用这两项命令会使得编译过程延长，但是在编译内核的时候可以保证生成的内核树的绝对清洁。 四、实验步骤 安装前准备 在开始之前，我们需要先查看一下虚拟机上的Arch Linux的当前的内核信息。查看内核信息可以通过screenfetch命令。这个软件包不是Arch Linux的基本包中包含的内容，所以再使用之前需要先安装： 1pacman -S screenfetch 安装完成后就可以使用screenfetch命令查看内核信息了。截图保存以与应用新自定义内核后形成对比。 屏幕截图_33_.jpg 首先，可以访问官网选择想要安装的内核版本进行下载。但是由于国内访问官网速度较慢，也可以通过国内的开源镜像站下载，比如清华大学镜像站。选择需要下载的镜像之后使用wget命令下载。Arch的基本包是没有wget的，所以如果之前没有安装wget则需要通过pacman安装。这里我选择了Linux 5.3版本的内核，执行的命令如下： 123wget https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.3.tar.xzxz -d linux-5.3.tar.xztar -xvf linux-5.3.tar 下载完成后，使用xz命令和tar命令解压下载的内核包。解压后使用cd命令进入解压得到的目录下。 屏幕截图_28_.jpg 编译内核 进入目录后就可以开始编译了，编译使用的命令是make。它有很多的模式可以选择，比如make menuconfig命令会进入由Kconfig和scripts构建的图形化的配置页面，完成配置后会生成一个.config文件。这里我使用的是缺省配置： 1zcat /proc/config.gz &gt; .config 复制内核配置文件之后，还需要通过修改得到的config文件的CONFIG_LOCALVERSION的值来修改内核版本，以避免将要编译的内核文件覆盖当前内核文件。 得到了.config文件之后就可以开始编译了。编译的命令是make -j&lt;线程数&gt;。可以根据虚拟机的配置修改这里线程数的值。因为内核的编译需要一段较长的时间，合理的线程数可以增加编译的速度。我使用的是make -j2。 安装内核并验证 完成了内核的编译之后就可以开始安装内核了。安装内核主要包括这些步骤：安装内核模块-&gt;复制内核文件-&gt;制作initramfs镜像-&gt;复制System.map-&gt;生成新的启动引导。执行的命令脚本如下： 安装内核模块： 1sudo make modules_install 这条命令会将编译好的模块安装到主目录/lib/modules下。这样，会使得这些模块独立于虚拟机原有内核的模块。 复制内核文件： 12345# 对于32位(i686)内核：sudo cp -v arch/x86/boot/bzImage /boot/vmlinuz-linux53# 对于64位(x86_64)内核：sudo cp -v arch/x86_64/boot/bzImage /boot/vmlinuz-linux53 将内核编译完成生成的bzImage（较大的压缩的内核映像，使用gzip压缩）文件复制到/boot目录下。 制作initramfs（初始内存盘）镜像： 复制并且修改mkinitcpio（一个创建initramfs的脚本）preset就可以通过官方内核一样的方式生成自定义内核的initramfs镜像。复制之后需要使用vim修改这个文件。 12sudo cp /etc/mkinitcpio.d/linux.preset /etc/mkinitcpio.d/linux53.presetsudo vi /etc/mkinitcpio.d/linux53.preset 打开linux53.preset文件之后，修改部分字段使得它与新的自定义内核所匹配。需要修改的字段如下： 12345# /etc/mkinitcpio.d/linux53.presetALL_kver=&quot;/boot/vmlinuz-linux53&quot;default_image=&quot;/boot/initramfs-linux53.img&quot;fallback_image=&quot;/boot/initramfs-linux53-fallback.img&quot; 修改并保存之后执行sudo mkinitcpio -p linux53就可以使用官方内核生成的方式生成自定义内核的initramfs镜像。 复制System.map 如果虚拟机的/boot挂载到的分区的文件系统是ext4格式。就需要将解压目录下的System.map文件复制到/boot中，并且创建/boot/System.map，将新建的System.map软链接到复制到其中的System.map中。需要执行的命令如下： 123sudo touch /boot/System.mapsudo cp System.map /boot/System.map-MyKernelsudo ln -sf /boot/System.map-Mykernel /boot/System.map 但是由于本次使用的虚拟机的boot分区挂载的分区是vfat文件系统的，无需也不必创建软链接。 更新grub引导的配置信息 使用命令grub-mkconfig -o /boot/grub/grub.cfg可以生成grub默认的配置信息。它会自动地将刚添加的内核增加到启动配置中。在Ubuntu这种系统中，这个命令被包装成了update-grub或其他形式。 屏幕截图_37_.jpg 随后使用reboot命令重新启动虚拟机，使用screenfetch命令查看当前的系统信息，就可以看到系统的内核发生了变化。这样内核的编译和安装就完成了。 五、实验结果 实验前和试验后，对Arch Linux虚拟机使用screenfetch命令获得的内核信息不相同，内核信息变成了安装的内核的版本信息，说明用户的自定义内核已经成功的编译并且安装。 实验三： 为Linux内核增加系统调用 一、实验描述 在实验一的Arch Linux虚拟机的基础上，在Linux内核中增加一个系统调用，并对这个修改生成patch。将这个patch应用到一个Linux内核中，编译并安装这个自定义内核，验证对内核增加的系统调用是否已经成功的应用到操作系统。 二、实验设计 修改内核源码 向内核中增加一个函数、将函数注册为系统调用 生成补丁并重新编译内核 使用diff生成补丁、安装patch补丁、编译并安装内核 测试补丁是否成功patch 编写调用自定义系统调用的源文件、执行源文件观察结果 三、实验原理 patch Patch有两种常用意思： &gt; Patch文件： &gt; &gt; 也就是补丁文件。在Linux社区中，如果某人对某一个版本的Linux源码做出了一定的修改以解决某些问题，并且希望把它分享出去，他就可以为代码生成一个patch文件供社区使用。往往，patch文件的目的是用于修正已知错误或者作为一种调试手段调试代码。一般来说，patch文件可以使用diff指令比较原有代码和修改过的代码生成。 &gt; &gt; Patch指令 &gt; &gt; 是Linux中的一个指令。可以用于将patch文件的修改应用到一个代码中。并且在此基础上可以提供一些实用的功能：比如消除父目录，检测对象代码是否已经安装过此补丁等。关于patch命令的详细使用方法可以使用man命令或者求助Google。 屏幕截图_50_.jpg 本次实验需要生成一个自定义的系统调用的patch文件，并且将这个patch文件应用到内核中。生成patch文件可以使用diff指令： 1diff -Naur kernel/ kernel_new/ &gt; new.patch 指令中，kernel/是修改前的内核源码所在的文件夹，kernel_new/目录是修改过的内核源代码所在的文件夹。这条指令将会比较两个内核的源码的差别并且根据对比结果生成\"new.patch\"文件。 如果要将这个patch文件应用到一个未修改的内核，可以使用patch命令将patch文件中记录的改动应用到内核源码中： 123cp -v new.patch kernel/cd kernelpatch -p1 &lt; new.patch 首先将patch文件放在将要打补丁的源码目录下，再使用patch命令就可以了。由于patch文件中记录了基于原代码所在目录的名字（所在目录的绝对地址），可能和当前打补丁的源码所在目录不匹配。比如当向Linux-5.3.x打Linux-5.3的补丁，就需要使用使用-p1参数忽视文件名目录的第一个分量。 官方网站也提供了Patch包下载。这些Patch包是用于大版本内的小版本更新的。使用时，只需要将对应的Patch文件patch到对应版本的内核源码文件中，编译安装patch后的内核即可。 系统调用 增加最简单的系统调用主要分为增加新函数-&gt;增加新声明-&gt;将新调用增加到系统调用注册表三个步骤。 增加新的系统调用函数：比如可以向内核缓存区打印一条消息。可以使用printk函数实现这个功能。打印到内核缓存区的消息不会直接输出到控制台中，需要使用dmesg -c命令清除所有缓冲区日志并且查看内核缓存区信息。printk函数打印的信息将会这里显示。 增加系统调用的声明：不同的Linux发行版所需要增加声明的头文件地址不同。大体是在内核文件夹下的include/目录下的unistd.h和syscalls.h文件中。对于Arch Linux，需要修改的头文件的目录是include/uapi/asm-generic/unistd.h和include/linux/syscalls.h。可以在这个文件的对应位置增加在系统源文件（一般是sys.c）中增加的系统调用函数的声明。 注册新系统调用：不同的Linux发行版OS的系统调用表所在的位置不同，对于Arch Linux而言，系统调用注册表的位置在arch/x86/entry/syscalls目录下。它包含了32位系统和64位系统的注册表，分别是syscall_32.tbl和syscall_64.tbl。 内核编程相关 dmesg 命令: &gt; &gt; dmesg命令在设备故障诊断中有重要的用途。它可以用于检测硬件连接或断开的信息，可以查看内核缓存区的信息，可以使用Linux管道规定它的输出范围获得需要的数据：比如搜索和特定硬件相关的消息等。关于这个命令的使用可以参考man或者Google。以下只介绍基本的一些使用方法。 &gt; &gt;+ 列出所有检测到的硬件： &gt; &gt; 比如要显示所有被内核检测到的硬盘设备，可以使用grep参量搜索sda关键词。最后执行的命令是：dmesg | grep sda。此外，grep命令参量可以附加-i选项表示忽略搜索字符串的大小写。 &gt; &gt;+ 输出指定行数的日志： &gt; &gt; 可以通过跟随head或者tail命令参量来控制显示的日志范围。比如需要显示前20行日志，可以使用命令dmesg | head -20。 &gt; &gt;+ 清空dmesg缓冲区日志 &gt; &gt; 可以使用命令dmesg -c来清空dmesg的日志。该命令会清空dmesg环形缓冲区中的日志。但是依然可以查看存储在‘/var/log/dmesg’文件中的日志。此时连接任何的设备都会产生dmesg日志输出。 asmlinkage修饰符： &gt; &gt;asmlinkage的定义： &gt; &gt; 位于/usr/include/asm/linkage.h中，定义内容如下： &gt;1&gt;#define asmlinkage CPP_ASMLINKAGE __attribute__((regparm(0))) &gt;__attribute__是关键字，是gcc的C语言扩展，regparm(0)表示不从寄存器传递参数。如果是__attribute__((regparm(3)))，那么调用函数的时候参数不是通过栈传递，而是直接放到寄存器里，被调用函数直接从寄存器取参数。 &gt; &gt;这主要涉及了函数传参的方式是否通过寄存器。asmlinkage表示这些函数通过堆栈而不是通过寄存器传递参数。gcc编译器在汇编过程中调用C语言函数时传递参数有两种方法：一种是通过堆栈，另一种是通过寄存器。缺省时采用寄存器。 &gt; &gt;一般来说，内核中的函数都是通过asmlinkage限定使用堆栈传递参数的。我们向内核源文件中增加的系统调用函数也需要使用asmlinkage修饰。 四、实验步骤 准备工作 将从官网上下载的一个Linux内核源码解压，并将解压得到的文件夹复制一份。一份作为原版源码，对另一份进行修改。这里我使用实验二中使用的Linux内核作为基础。 增加系统调用 进入待修改的内核源码根目录，之后所有的相对路径都建立在内核源代码根目录的基础上。使用vim打开将要增加系统调用的实现的源文件kernel/sys.c。这里我们要增加的是最简单的系统调用，即在内核缓冲区打印消息，所以在它的末尾增加如下函数： 123456asmlinkage void sys_shirohashow(void)&#123; printk(&quot;Shiroha do your best!&quot;); printk(&quot;\\n@Edit by Shiroha on 2019-11-15.&quot;); return 0;&#125; 这样，我们就增加了一个系统调用函数sys_shirohashow的实现。 屏幕截图_51_.jpg 增加完实现之后，我们还需要为这个函数增加声明。增加声明主要需要修改两个文件。首先使用vim打开include/uapi/asm-generic/unistd.h，在这个文件的末尾处增加宏： 12#define __NR_shirohashow 765__SYSCALL(__NR_shirohashow,sys_shirohashow) 这里的765是系统调用的编号。注意不是所有的数字都可以使用，可以在设置这个数字之前前往系统调用注册表（find syscall_64.tbl寻找这个文件并使用vi或者nano查看确认系统调用编号的使用情况），然后使用没有被占用的系统调用编号。 屏幕截图_52_.jpg 增加宏之后，还需要再使用命令vi include/linux/syscalls.h打开syscalls头文件，将函数的声明asmlinkage void sys_shirohashow(void);增加到该头文件中/* kernel/sys.c */的部分中。 注册系统调用 完成了系统调用的声明和实现后，还需要将系统调用注册到注册表中，才可以使得它可以被正确的系统调用编号调用。系统调用注册表文件储存在arch/x86/entry/syscalls目录下。32位系统是syscall_32.tbl，64位系统是syscall_64.tbl。可以根据需要修改对应的注册表。这里以修改64位注册表为例，将在syscall_64.tbl的第435号系统调用后增加以下内容： 1765 common shirohashow sys_shirohashow 保存退出后，对内核的源文件的修改就全部完成了。 生成补丁并patch 完成上述步骤中所有的操作后，就可以生成patch补丁了。可以通过diff命令对比原内核代码和修改后的内核代码得到补丁文件，执行命令： 1diff -Naur ../../linux-5.3/kernel/ kernel/ &gt; new.patch 可以将生成的patch文件应用到原内核源码中，也可以直接编译修改过的内核源码。（本质上，对原内核源码运行patch命令打得到的补丁文件变为修改过后的版本）打补丁的命令是： 123cp -v new.patch ../../linux-5.3/kernel/new.patchcd ../../linux-5.3/kernel/patch -p1 &lt; new.patch 安装patch之后就可以编译安装内核了。为了得到纯净的内核树，推荐编译过程中使用make clean &amp;&amp; make mrproper命令，但是这样的编译速度较慢，耗时较多。 屏幕截图_56_.jpg 编译完成之后，可以采用实验二中的步骤（安装内核模块-&gt;复制内核文件-&gt;制作initramfs镜像-&gt;生成新的启动引导）来安装新的内核。安装完成后，重启虚拟机，打过自定义补丁的内核就安装完成了。 验证系统调用 我们对内核的修改是增加了一条系统调用。这个系统调用会在内核缓存目录中打印一条消息。所以验证该系统调用是否被正确应用，只需要编写一个程序调用该系统调用，并观察该系统调用是否正确执行即可。 屏幕截图_60_.jpg 首先，使用以下命令新建一个C程序源文件并使用vim打开它： 12touch myTest.cvi myTest.c 在新建的源文件中输入以下的编码： 123456789101112#include &lt;stdio.h&gt;#include &lt;sys/reg.h&gt;#include &lt;sys/syscall.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/user.h&gt;#include &lt;sys/types.h&gt;int main()&#123; syscall(765); return 0;&#125; 保存并退出vim之后，使用以下命令编译并执行： 12gcc -o myTest myTest.c./myTest 执行编译生成的二进制文件之后，控制台没有任何输出。这是因为printk函数是向内核缓冲区打印信息而不是控制台。需要使用dmesg -c命令输出内核缓冲区的信息，可以检查printk的输出结果。 五、实验结果 在安装了patch过的内核的Arch Linux虚拟机中执行调用新系统调用的C程序，并且使用dmesg -c命令查看内核缓存区，发现了系统调用使用printk函数打印的字符串。这说明增加的系统调用成功注册，并且随着编译后的内核成功安装到了虚拟机中。 屏幕截图_61_.jpg 2020-3-8 更新： 原本的截图可以去这里下载。 附录 疑问和未解决问题 虚拟机分辨率问题 采用了Microsoft Docs中提到的，在grub配置文件中修改分辨率的方法。只对虚拟机运行时的tyy终端界面有效，而无法改变图形环境的分辨率。 虚拟机没有显卡 使用screenfetch命令查看系统信息的时候发现虚拟机没有显卡。初步判定这是导致无法改变桌面环境的分辨率以及执行OpenGL程序的原因。 patch后内核编译缓慢 使用patch对已经预编译的内核进行打补丁操作之后，使用make编译时，make将所有的文件重新编译。而这种情况下，make应当只重新编译被patch修改过的极少部分文件。 参考链接 ArchLinux 安装/配置/美化 - 米V米 arch里没有update-grub这个命令吗 - 百度知道 Hyper-V虚拟机安装Linux后修改Linux的屏幕分辨率 - CSDN Linux环境下root用户与普通用户切换 - CSDN Windows 10 hyper-v安装manjaro 18.0.4+Xfce4 后调整分辨率 - CSDN 美轮美奂的Arch, 详解Arch虚拟机安装 - 简书 Arch Linux 安装指南（ArchISO 2014.10） - Ubuntu论坛 defconfig、.config、kconfig与makefile和make menuconfig流程 - CSDN make oldconfig和make defconfig有何区别 - 百度知道 Linux 内核编译 - CSDN zimage和bzimage有什么区别 - 博客园 asmlinkage的用法 - CSDN dmesg七种用法 - 博客园 关于asmlinkage - 博客园 汇编语言的主程序与子程序之间的参数传递方式 - CSDN Archlinux官方Wiki - mkinitcpio（简体中文） Dian团队 - 网安组@李勉学长 Installation guide (简体中文) - Arch Wiki","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://shiraha.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux","slug":"操作系统/Linux","permalink":"https://shiraha.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://shiraha.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"实验报告","slug":"实验报告","permalink":"https://shiraha.cn/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"Linux","slug":"Linux","permalink":"https://shiraha.cn/tags/Linux/"},{"name":"Dian","slug":"Dian","permalink":"https://shiraha.cn/tags/Dian/"},{"name":"Arch","slug":"Arch","permalink":"https://shiraha.cn/tags/Arch/"}]}],"categories":[{"name":"Web","slug":"Web","permalink":"https://shiraha.cn/categories/Web/"},{"name":"前端","slug":"Web/前端","permalink":"https://shiraha.cn/categories/Web/%E5%89%8D%E7%AB%AF/"},{"name":"课业","slug":"课业","permalink":"https://shiraha.cn/categories/%E8%AF%BE%E4%B8%9A/"},{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"数学","slug":"算法/数学","permalink":"https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/%E6%95%B0%E5%AD%A6/"},{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/categories/%E9%A2%98%E8%A7%A3/"},{"name":"折腾记录","slug":"折腾记录","permalink":"https://shiraha.cn/categories/%E6%8A%98%E8%85%BE%E8%AE%B0%E5%BD%95/"},{"name":"校队讲义","slug":"校队讲义","permalink":"https://shiraha.cn/categories/%E6%A0%A1%E9%98%9F%E8%AE%B2%E4%B9%89/"},{"name":"操作系统","slug":"操作系统","permalink":"https://shiraha.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Windows","slug":"操作系统/Windows","permalink":"https://shiraha.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Windows/"},{"name":"Linux","slug":"操作系统/Linux","permalink":"https://shiraha.cn/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux/"},{"name":"树上算法","slug":"算法/树上算法","permalink":"https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/%E6%A0%91%E4%B8%8A%E7%AE%97%E6%B3%95/"},{"name":"有趣的东西","slug":"有趣的东西","permalink":"https://shiraha.cn/categories/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%B8%9C%E8%A5%BF/"},{"name":"数据结构","slug":"数据结构","permalink":"https://shiraha.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论算法","slug":"算法/图论算法","permalink":"https://shiraha.cn/categories/%E7%AE%97%E6%B3%95/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"npm","slug":"npm","permalink":"https://shiraha.cn/tags/npm/"},{"name":"Web","slug":"Web","permalink":"https://shiraha.cn/tags/Web/"},{"name":"推导","slug":"推导","permalink":"https://shiraha.cn/tags/%E6%8E%A8%E5%AF%BC/"},{"name":"考研数学","slug":"考研数学","permalink":"https://shiraha.cn/tags/%E8%80%83%E7%A0%94%E6%95%B0%E5%AD%A6/"},{"name":"算法","slug":"算法","permalink":"https://shiraha.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"https://shiraha.cn/tags/ACM/"},{"name":"数论","slug":"数论","permalink":"https://shiraha.cn/tags/%E6%95%B0%E8%AE%BA/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://shiraha.cn/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"name":"FFT","slug":"FFT","permalink":"https://shiraha.cn/tags/FFT/"},{"name":"NTT","slug":"NTT","permalink":"https://shiraha.cn/tags/NTT/"},{"name":"课内作业","slug":"课内作业","permalink":"https://shiraha.cn/tags/%E8%AF%BE%E5%86%85%E4%BD%9C%E4%B8%9A/"},{"name":"实验报告","slug":"实验报告","permalink":"https://shiraha.cn/tags/%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://shiraha.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Wireshark","slug":"Wireshark","permalink":"https://shiraha.cn/tags/Wireshark/"},{"name":"抓包","slug":"抓包","permalink":"https://shiraha.cn/tags/%E6%8A%93%E5%8C%85/"},{"name":"NpCap","slug":"NpCap","permalink":"https://shiraha.cn/tags/NpCap/"},{"name":"nginx","slug":"nginx","permalink":"https://shiraha.cn/tags/nginx/"},{"name":"Linux","slug":"Linux","permalink":"https://shiraha.cn/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://shiraha.cn/tags/Ubuntu/"},{"name":"Codeforces","slug":"Codeforces","permalink":"https://shiraha.cn/tags/Codeforces/"},{"name":"Gym","slug":"Gym","permalink":"https://shiraha.cn/tags/Gym/"},{"name":"持续更新","slug":"持续更新","permalink":"https://shiraha.cn/tags/%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"},{"name":"水","slug":"水","permalink":"https://shiraha.cn/tags/%E6%B0%B4/"},{"name":"Windows 10","slug":"Windows-10","permalink":"https://shiraha.cn/tags/Windows-10/"},{"name":"组合数学","slug":"组合数学","permalink":"https://shiraha.cn/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"hexo","slug":"hexo","permalink":"https://shiraha.cn/tags/hexo/"},{"name":"废话","slug":"废话","permalink":"https://shiraha.cn/tags/%E5%BA%9F%E8%AF%9D/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"https://shiraha.cn/tags/Nowcoder/"},{"name":"题解","slug":"题解","permalink":"https://shiraha.cn/tags/%E9%A2%98%E8%A7%A3/"},{"name":"云服务","slug":"云服务","permalink":"https://shiraha.cn/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/"},{"name":"syzoj","slug":"syzoj","permalink":"https://shiraha.cn/tags/syzoj/"},{"name":"Dian","slug":"Dian","permalink":"https://shiraha.cn/tags/Dian/"},{"name":"React","slug":"React","permalink":"https://shiraha.cn/tags/React/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://shiraha.cn/tags/TypeScript/"},{"name":"Microsoft","slug":"Microsoft","permalink":"https://shiraha.cn/tags/Microsoft/"},{"name":"msys2","slug":"msys2","permalink":"https://shiraha.cn/tags/msys2/"},{"name":"美化","slug":"美化","permalink":"https://shiraha.cn/tags/%E7%BE%8E%E5%8C%96/"},{"name":"软件工程","slug":"软件工程","permalink":"https://shiraha.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"校队","slug":"校队","permalink":"https://shiraha.cn/tags/%E6%A0%A1%E9%98%9F/"},{"name":"UML","slug":"UML","permalink":"https://shiraha.cn/tags/UML/"},{"name":"EOJ","slug":"EOJ","permalink":"https://shiraha.cn/tags/EOJ/"},{"name":"Windows","slug":"Windows","permalink":"https://shiraha.cn/tags/Windows/"},{"name":"操作系统","slug":"操作系统","permalink":"https://shiraha.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"C++","slug":"C","permalink":"https://shiraha.cn/tags/C/"},{"name":"学习笔记","slug":"学习笔记","permalink":"https://shiraha.cn/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Luogu","slug":"Luogu","permalink":"https://shiraha.cn/tags/Luogu/"},{"name":"Java","slug":"Java","permalink":"https://shiraha.cn/tags/Java/"},{"name":"Powershell","slug":"Powershell","permalink":"https://shiraha.cn/tags/Powershell/"},{"name":"个性化","slug":"个性化","permalink":"https://shiraha.cn/tags/%E4%B8%AA%E6%80%A7%E5%8C%96/"},{"name":"数据结构","slug":"数据结构","permalink":"https://shiraha.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图论","slug":"图论","permalink":"https://shiraha.cn/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"Arch","slug":"Arch","permalink":"https://shiraha.cn/tags/Arch/"}]}